{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cert-manager adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing and using those certificates. It can issue certificates from a variety of supported sources, including Let's Encrypt , HashiCorp Vault , and Venafi as well as private PKI. It will ensure certificates are valid and up to date, and attempt to renew certificates at a configured time before expiry. It is loosely based upon the work of kube-lego and has borrowed some wisdom from other similar projects such as kube-cert-manager . This website provides the full technical documentation for the project, and can be used as a reference; if you feel that there's anything missing, please let us know or raise a PR to add it.","title":"\u7b80\u4ecb"},{"location":"cli/","text":"View the --help output from our various CLI tools, including those which run in containers in your cluster. This might help if you need to tweak an option or if you need to check which values are valid!","title":"CLI reference"},{"location":"cli/acmesolver/","text":"HTTP server used to solve ACME challenges. Usage: acmesolver [flags] Flags: --domain string the domain name to verify -h, --help help for acmesolver --key string the challenge key to respond with --listen-port int the port number to listen on for connections (default 8089) --token string the challenge token to verify against","title":"acmesolver CLI reference"},{"location":"cli/cainjector/","text":"cert-manager CA injector is a Kubernetes addon to automate the injection of CA data into webhooks and APIServices from cert-manager certificates. It will ensure that annotated webhooks and API services always have the correct CA data from the referenced certificates, which can then be used to serve API servers and webhook servers. Usage: ca-injector [flags] Flags: --add_dir_header If true, adds the file directory to the header of the log messages --alsologtostderr log to standard error as well as files (no effect when -logtostderr=true) --enable-profiling Enable profiling for cainjector --feature-gates mapStringBool A set of key=value pairs that describe feature gates for alpha/experimental features. Options are: AllAlpha=true|false (ALPHA - default=false) AllBeta=true|false (BETA - default=false) -h, --help help for ca-injector --kubeconfig string Paths to a kubeconfig. Only required if out-of-cluster. --leader-elect If true, cainjector will perform leader election between instances to ensure no more than one instance of cainjector operates at a time (default true) --leader-election-lease-duration duration The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled. (default 1m0s) --leader-election-namespace string Namespace used to perform leader election. Only used if leader election is enabled (default \"kube-system\") --leader-election-renew-deadline duration The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled. (default 40s) --leader-election-retry-period duration The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled. (default 15s) --log-flush-frequency duration Maximum number of seconds between log flushes (default 5s) --log_backtrace_at traceLocation when logging hits line file:N, emit a stack trace (default :0) --log_dir string If non-empty, write log files in this directory (no effect when -logtostderr=true) --log_file string If non-empty, use this log file (no effect when -logtostderr=true) --log_file_max_size uint Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800) --logtostderr log to standard error instead of files (default true) --namespace string If set, this limits the scope of cainjector to a single namespace. If set, cainjector will not update resources with certificates outside of the configured namespace. --one_output If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true) --profiler-address string Address of the Go profiler (pprof) if enabled. This should never be exposed on a public interface. (default \"localhost:6060\") --skip_headers If true, avoid header prefixes in the log messages --skip_log_headers If true, avoid headers when opening log files (no effect when -logtostderr=true) --stderrthreshold severity logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=false) (default 2) -v, --v Level number for the log level verbosity --vmodule moduleSpec comma-separated list of pattern=N settings for file-filtered logging","title":"cainjector CLI reference"},{"location":"cli/cmctl/","text":"cmctl is a CLI tool manage and configure cert-manager resources for Kubernetes Usage: cmctl [command] Available Commands: approve Approve a CertificateRequest check Check cert-manager components convert Convert cert-manager config files between different API versions create Create cert-manager resources deny Deny a CertificateRequest experimental Interact with experimental features help Help about any command inspect Get details on certificate related resources renew Mark a Certificate for manual renewal status Get details on current status of cert-manager resources upgrade Tools that assist in upgrading cert-manager version Print the cert-manager CLI version and the deployed cert-manager version Flags: -h, --help help for cmctl --log-flush-frequency duration Maximum number of seconds between log flushes (default 5s) Use \"cmctl [command] --help\" for more information about a command.","title":"cmctl CLI reference"},{"location":"cli/controller/","text":"cert-manager is a Kubernetes addon to automate the management and issuance of TLS certificates from various issuing sources. It will ensure certificates are valid and up to date periodically, and attempt to renew certificates at an appropriate time before expiry. Usage: cert-manager-controller [flags] Flags: --acme-http01-solver-image string The docker image to use to solve ACME HTTP01 challenges. You most likely will not need to change this parameter unless you are testing a new feature or developing cert-manager. (default \"quay.io/jetstack/cert-manager-acmesolver:canary\") --acme-http01-solver-nameservers strings A list of comma separated dns server endpoints used for ACME HTTP01 check requests. This should be a list containing host and port, for example 8.8.8.8:53,8.8.4.4:53 --acme-http01-solver-resource-limits-cpu string Defines the resource limits CPU size when spawning new ACME HTTP01 challenge solver pods. (default \"100m\") --acme-http01-solver-resource-limits-memory string Defines the resource limits Memory size when spawning new ACME HTTP01 challenge solver pods. (default \"64Mi\") --acme-http01-solver-resource-request-cpu string Defines the resource request CPU size when spawning new ACME HTTP01 challenge solver pods. (default \"10m\") --acme-http01-solver-resource-request-memory string Defines the resource request Memory size when spawning new ACME HTTP01 challenge solver pods. (default \"64Mi\") --add_dir_header If true, adds the file directory to the header of the log messages --alsologtostderr log to standard error as well as files (no effect when -logtostderr=true) --auto-certificate-annotations strings The annotation consumed by the ingress-shim controller to indicate a ingress is requesting a certificate (default [kubernetes.io/tls-acme]) --cluster-issuer-ambient-credentials Whether a cluster-issuer may make use of ambient credentials for issuers. 'Ambient Credentials' are credentials drawn from the environment, metadata services, or local files which are not explicitly configured in the ClusterIssuer API object. When this flag is enabled, the following sources for credentials are also used: AWS - All sources the Go SDK defaults to, notably including any EC2 IAM roles available via instance metadata. (default true) --cluster-resource-namespace string Namespace to store resources owned by cluster scoped resources such as ClusterIssuer in. This must be specified if ClusterIssuers are enabled. (default \"kube-system\") --controllers strings A list of controllers to enable. '--controllers=*' enables all on-by-default controllers, '--controllers=foo' enables just the controller named 'foo', '--controllers=*,-foo' disables the controller named 'foo'. All controllers: issuers, clusterissuers, certificates-metrics, ingress-shim, gateway-shim, orders, challenges, certificaterequests-issuer-acme, certificaterequests-approver, certificaterequests-issuer-ca, certificaterequests-issuer-selfsigned, certificaterequests-issuer-vault, certificaterequests-issuer-venafi, certificates-trigger, certificates-issuing, certificates-key-manager, certificates-request-manager, certificates-readiness, certificates-revision-manager (default [*]) --copied-annotation-prefixes strings Specify which annotations should/shouldn't be copiedfrom Certificate to CertificateRequest and Order, as well as from CertificateSigningRequest to Order, by passing a list of annotation key prefixes.A prefix starting with a dash(-) specifies an annotation that shouldn't be copied. Example: '*,-kubectl.kuberenetes.io/'- all annotationswill be copied apart from the ones where the key is prefixed with 'kubectl.kubernetes.io/'. (default [*,-kubectl.kubernetes.io/,-fluxcd.io/,-argocd.argoproj.io/]) --default-issuer-group string Group of the Issuer to use when the tls is requested but issuer group is not specified on the ingress resource. (default \"cert-manager.io\") --default-issuer-kind string Kind of the Issuer to use when the tls is requested but issuer kind is not specified on the ingress resource. (default \"Issuer\") --default-issuer-name string Name of the Issuer to use when the tls is requested but issuer name is not specified on the ingress resource. --dns01-check-retry-period duration The duration the controller should wait between a propagation check. Despite the name, this flag is used to configure the wait period for both DNS01 and HTTP01 challenge propagation checks. For DNS01 challenges the propagation check verifies that a TXT record with the challenge token has been created. For HTTP01 challenges the propagation check verifies that the challenge token is served at the challenge URL.This should be a valid duration string, for example 180s or 1h (default 10s) --dns01-recursive-nameservers strings A list of comma separated dns server endpoints used for DNS01 check requests. This should be a list containing host and port, for example 8.8.8.8:53,8.8.4.4:53 --dns01-recursive-nameservers-only When true, cert-manager will only ever query the configured DNS resolvers to perform the ACME DNS01 self check. This is useful in DNS constrained environments, where access to authoritative nameservers is restricted. Enabling this option could cause the DNS01 self check to take longer due to caching performed by the recursive nameservers. --enable-certificate-owner-ref Whether to set the certificate resource as an owner of secret where the tls certificate is stored. When this flag is enabled, the secret will be automatically removed when the certificate resource is deleted. --enable-profiling Enable profiling for controller. --feature-gates mapStringBool A set of key=value pairs that describe feature gates for alpha/experimental features. Options are: AdditionalCertificateOutputFormats=true|false (ALPHA - default=false) AllAlpha=true|false (ALPHA - default=false) AllBeta=true|false (BETA - default=false) ExperimentalCertificateSigningRequestControllers=true|false (ALPHA - default=false) ExperimentalGatewayAPISupport=true|false (ALPHA - default=false) LiteralCertificateSubject=true|false (ALPHA - default=false) ServerSideApply=true|false (ALPHA - default=false) StableCertificateRequestName=true|false (ALPHA - default=false) ValidateCAA=true|false (ALPHA - default=false) -h, --help help for cert-manager-controller --issuer-ambient-credentials Whether an issuer may make use of ambient credentials. 'Ambient Credentials' are credentials drawn from the environment, metadata services, or local files which are not explicitly configured in the Issuer API object. When this flag is enabled, the following sources for credentials are also used: AWS - All sources the Go SDK defaults to, notably including any EC2 IAM roles available via instance metadata. --kube-api-burst int the maximum burst queries-per-second of requests sent to the Kubernetes apiserver (default 50) --kube-api-qps float32 indicates the maximum queries-per-second requests to the Kubernetes apiserver (default 20) --kubeconfig string Paths to a kubeconfig. Only required if out-of-cluster. --leader-elect If true, cert-manager will perform leader election between instances to ensure no more than one instance of cert-manager operates at a time (default true) --leader-election-lease-duration duration The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled. (default 1m0s) --leader-election-namespace string Namespace used to perform leader election. Only used if leader election is enabled (default \"kube-system\") --leader-election-renew-deadline duration The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled. (default 40s) --leader-election-retry-period duration The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled. (default 15s) --log-flush-frequency duration Maximum number of seconds between log flushes (default 5s) --log_backtrace_at traceLocation when logging hits line file:N, emit a stack trace (default :0) --log_dir string If non-empty, write log files in this directory (no effect when -logtostderr=true) --log_file string If non-empty, use this log file (no effect when -logtostderr=true) --log_file_max_size uint Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800) --logtostderr log to standard error instead of files (default true) --master string Optional apiserver host address to connect to. If not specified, autoconfiguration will be attempted. --max-concurrent-challenges int The maximum number of challenges that can be scheduled as 'processing' at once. (default 60) --metrics-listen-address string The host and port that the metrics endpoint should listen on. (default \"0.0.0.0:9402\") --namespace string If set, this limits the scope of cert-manager to a single namespace and ClusterIssuers are disabled. If not specified, all namespaces will be watched --one_output If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true) --profiler-address string The host and port that Go profiler should listen on, i.e localhost:6060. Ensure that profiler is not exposed on a public address. Profiler will be served at /debug/pprof. (default \"localhost:6060\") --skip_headers If true, avoid header prefixes in the log messages --skip_log_headers If true, avoid headers when opening log files (no effect when -logtostderr=true) --stderrthreshold severity logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=false) (default 2) -v, --v Level number for the log level verbosity --vmodule moduleSpec comma-separated list of pattern=N settings for file-filtered logging","title":"controller CLI reference"},{"location":"cli/webhook/","text":"Webhook component providing API validation, mutation and conversion functionality for cert-manager (canary) () Usage: webhook [flags] Flags: --add-dir-header If true, adds the file directory to the header of the log messages --alsologtostderr log to standard error as well as files (no effect when -logtostderr=true) --api-server-host string Optional apiserver host address to connect to. If not specified, autoconfiguration will be attempted. --config string Path to a file containing a WebhookConfiguration object used to configure the webhook --dynamic-serving-ca-secret-name string name of the secret used to store the CA that signs serving certificates certificates --dynamic-serving-ca-secret-namespace string namespace of the secret used to store the CA that signs serving certificates --dynamic-serving-dns-names strings DNS names that should be present on certificates generated by the dynamic serving CA --enable-profiling Enable profiling for webhook. --feature-gates mapStringBool A set of key=value pairs that describe feature gates for alpha/experimental features. Options are: AdditionalCertificateOutputFormats=true|false (ALPHA - default=false) AllAlpha=true|false (ALPHA - default=false) AllBeta=true|false (BETA - default=false) ExperimentalCertificateSigningRequestControllers=true|false (ALPHA - default=false) ExperimentalGatewayAPISupport=true|false (ALPHA - default=false) LiteralCertificateSubject=true|false (ALPHA - default=false) ServerSideApply=true|false (ALPHA - default=false) StableCertificateRequestName=true|false (ALPHA - default=false) ValidateCAA=true|false (ALPHA - default=false) --healthz-port int port number to listen on for insecure healthz connections (default 6080) -h, --help help for webhook --kubeconfig string optional path to the kubeconfig used to connect to the apiserver. If not specified, in-cluster-config will be used --log-backtrace-at traceLocation when logging hits line file:N, emit a stack trace (default :0) --log-dir string If non-empty, write log files in this directory (no effect when -logtostderr=true) --log-file string If non-empty, use this log file (no effect when -logtostderr=true) --log-file-max-size uint Defines the maximum size a log file can grow to (no effect when -logtostderr=true). Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800) --logtostderr log to standard error instead of files (default true) --one-output If true, only write logs to their native severity level (vs also writing to each lower severity level; no effect when -logtostderr=true) --profiler-address string Address of the Go profiler (pprof). This should never be exposed on a public interface. If this flag is not set, the profiler is not run. (default \"localhost:6060\") --secure-port int port number to listen on for secure TLS connections (default 6443) --skip-headers If true, avoid header prefixes in the log messages --skip-log-headers If true, avoid headers when opening log files (no effect when -logtostderr=true) --stderrthreshold severity logs at or above this threshold go to stderr when writing to files and stderr (no effect when -logtostderr=true or -alsologtostderr=false) (default 2) --tls-cert-file string path to the file containing the TLS certificate to serve with --tls-cipher-suites strings Comma-separated list of cipher suites for the server. If omitted, the default Go cipher suites will be use. Possible values: TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_RC4_128_SHA --tls-min-version string Minimum TLS version supported. Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13 --tls-private-key-file string path to the file containing the TLS private key to serve with -v, --v Level number for the log level verbosity --vmodule moduleSpec comma-separated list of pattern=N settings for file-filtered logging","title":"webhook CLI reference"},{"location":"concepts/","text":"There are several components and ideas that make up cert-manager. This section describes them on a conceptual level, to aid with understanding how cert-manager does its job. You probably don't want this section if you're just getting started; check out a tutorial instead.","title":"\u4ecb\u7ecd"},{"location":"concepts/acme-orders-challenges/","text":"cert-manager supports requesting certificates from ACME servers, including from Let's Encrypt , with use of the ACME Issuer . These certificates are typically trusted on the public Internet by most computers. To successfully request a certificate, cert-manager must solve ACME Challenges which are completed in order to prove that the client owns the DNS addresses that are being requested. In order to complete these challenges, cert-manager introduces two CustomResource types; Orders and Challenges . Orders \u00b6 Order resources are used by the ACME issuer to manage the lifecycle of an ACME 'order' for a signed TLS certificate. More details on ACME orders and domain validation can be found on the Let's Encrypt website here . An order represents a single certificate request which will be created automatically once a new CertificateRequest resource referencing an ACME issuer has been created. CertificateRequest resources are created automatically by cert-manager once a Certificate resource is created, has its specification changed, or needs renewal. As an end-user, you will never need to manually create an Order resource. Once created, an Order cannot be changed. Instead, a new Order resource must be created. The Order resource encapsulates multiple ACME 'challenges' for that 'order', and as such, will manage one or more Challenge resources. Challenges \u00b6 Challenge resources are used by the ACME issuer to manage the lifecycle of an ACME 'challenge' that must be completed in order to complete an 'authorization' for a single DNS name/identifier. When an Order resource is created, the order controller will create Challenge resources for each DNS name that is being authorized with the ACME server. As an end-user, you will never need to manually create a Challenge resource. Once created, a Challenge cannot be changed. Instead, a new Challenge resource must be created. Challenge Lifecycle \u00b6 After a Challenge resource has been created, it will be initially queued for processing. Processing will not begin until the challenge has been 'scheduled' to start. This scheduling process prevents too many challenges being attempted at once, or multiple challenges for the same DNS name being attempted at once. For more information on how challenges are scheduled, read the challenge scheduling . Once a challenge has been scheduled, it will first be 'synced' with the ACME server in order to determine its current state. If the challenge is already valid, its 'state' will be updated to 'valid', and will also set status.processing = false to 'unschedule' itself. If the challenge is still 'pending', the challenge controller will 'present' the challenge using the configured solver, one of HTTP01 or DNS01. Once the challenge has been 'presented', it will set status.presented = true . Once 'presented', the challenge controller will perform a 'self check' to ensure that the challenge has 'propagated' (i.e. the authoritative DNS servers have been updated to respond correctly, or the changes to the ingress resources have been observed and in-use by the ingress controller). If the self check fails, cert-manager will retry the self check with a fixed 10 second retry interval. Challenges that do not ever complete the self check will continue retrying until the user intervenes by either retrying the Order (by deleting the Order resource) or amending the associated Certificate resource to resolve any configuration errors. Once the self check is passing, the ACME 'authorization' associated with this challenge will be 'accepted'. The final state of the authorization after accepting it will be copied across to the Challenge's status.state field, as well as the 'error reason' if an error occurred whilst the ACME server attempted to validate the challenge. Once a Challenge has entered the valid , invalid , expired or revoked state, it will set status.processing = false to prevent any further processing of the ACME challenge, and to allow another challenge to be scheduled if there is a backlog of challenges to complete. Challenge Scheduling \u00b6 Instead of attempting to process all challenges at once, challenges are 'scheduled' by cert-manager. This scheduler applies a cap on the maximum number of simultaneous challenges as well as disallows two challenges for the same DNS name and solver type ( HTTP01 or DNS01 ) to be completed at once. The maximum number of challenges that can be processed at a time is 60 as of ddff78 .","title":"ACME Orders and Challenges"},{"location":"concepts/acme-orders-challenges/#orders","text":"Order resources are used by the ACME issuer to manage the lifecycle of an ACME 'order' for a signed TLS certificate. More details on ACME orders and domain validation can be found on the Let's Encrypt website here . An order represents a single certificate request which will be created automatically once a new CertificateRequest resource referencing an ACME issuer has been created. CertificateRequest resources are created automatically by cert-manager once a Certificate resource is created, has its specification changed, or needs renewal. As an end-user, you will never need to manually create an Order resource. Once created, an Order cannot be changed. Instead, a new Order resource must be created. The Order resource encapsulates multiple ACME 'challenges' for that 'order', and as such, will manage one or more Challenge resources.","title":"Orders"},{"location":"concepts/acme-orders-challenges/#challenges","text":"Challenge resources are used by the ACME issuer to manage the lifecycle of an ACME 'challenge' that must be completed in order to complete an 'authorization' for a single DNS name/identifier. When an Order resource is created, the order controller will create Challenge resources for each DNS name that is being authorized with the ACME server. As an end-user, you will never need to manually create a Challenge resource. Once created, a Challenge cannot be changed. Instead, a new Challenge resource must be created.","title":"Challenges"},{"location":"concepts/acme-orders-challenges/#challenge-lifecycle","text":"After a Challenge resource has been created, it will be initially queued for processing. Processing will not begin until the challenge has been 'scheduled' to start. This scheduling process prevents too many challenges being attempted at once, or multiple challenges for the same DNS name being attempted at once. For more information on how challenges are scheduled, read the challenge scheduling . Once a challenge has been scheduled, it will first be 'synced' with the ACME server in order to determine its current state. If the challenge is already valid, its 'state' will be updated to 'valid', and will also set status.processing = false to 'unschedule' itself. If the challenge is still 'pending', the challenge controller will 'present' the challenge using the configured solver, one of HTTP01 or DNS01. Once the challenge has been 'presented', it will set status.presented = true . Once 'presented', the challenge controller will perform a 'self check' to ensure that the challenge has 'propagated' (i.e. the authoritative DNS servers have been updated to respond correctly, or the changes to the ingress resources have been observed and in-use by the ingress controller). If the self check fails, cert-manager will retry the self check with a fixed 10 second retry interval. Challenges that do not ever complete the self check will continue retrying until the user intervenes by either retrying the Order (by deleting the Order resource) or amending the associated Certificate resource to resolve any configuration errors. Once the self check is passing, the ACME 'authorization' associated with this challenge will be 'accepted'. The final state of the authorization after accepting it will be copied across to the Challenge's status.state field, as well as the 'error reason' if an error occurred whilst the ACME server attempted to validate the challenge. Once a Challenge has entered the valid , invalid , expired or revoked state, it will set status.processing = false to prevent any further processing of the ACME challenge, and to allow another challenge to be scheduled if there is a backlog of challenges to complete.","title":"Challenge Lifecycle"},{"location":"concepts/acme-orders-challenges/#challenge-scheduling","text":"Instead of attempting to process all challenges at once, challenges are 'scheduled' by cert-manager. This scheduler applies a cap on the maximum number of simultaneous challenges as well as disallows two challenges for the same DNS name and solver type ( HTTP01 or DNS01 ) to be completed at once. The maximum number of challenges that can be processed at a time is 60 as of ddff78 .","title":"Challenge Scheduling"},{"location":"concepts/ca-injector/","text":"cainjector helps to configure the CA certificates for: Mutating Webhooks , Validating Webhooks and API Services In particular, cainjector populates the caBundle field of four API types: ValidatingWebhookConfiguration , MutatingWebhookConfiguration CustomResourceDefinition and APIService . The first three resource types are used to configure how the Kubernetes API server connects to webhooks. This caBundle data is loaded by the Kubernetes API server and used to verify the serving certificates of webhook API servers. APIService is used to represent an Extension API Server . caBundle of APIService can be populated with CA cert that can be used to validate the API server's serving certificate. We will refer to these four API types as injectable resources. An injectable resource MUST have one of these annotations: cert-manager.io/inject-ca-from , cert-manager.io/inject-ca-from-secret , or cert-manager.io/inject-apiserver-ca , depending on the injection source . This is explained in more detail below. cainjector copies CA data from one of three sources : a Kubernetes Secret , a cert-manager Certificate , or from the Kubernetes API server CA certificate (which cainjector itself uses to verify its TLS connection to the Kubernetes API server). If the source is a Kubernetes Secret , that resource MUST also have an cert-manager.io/allow-direct-injection: \"true\" annotation. The three source types are explained in more detail below. Examples \u00b6 Here are examples demonstrating how to use the three cainjector sources . In each case we use ValidatingWebhookConfiguration as the injectable , but you can substitute MutatingWebhookConfiguration or CustomResourceDefinition definition instead. Injecting CA data from a Certificate resource \u00b6 Here is an example of a ValidatingWebhookConfiguration configured with the annotation cert-manager.io/inject-ca-from , which will make cainjector populate the caBundle field using CA data from a cert-manager Certificate . NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example1 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook1 annotations : cert-manager.io/inject-ca-from : example1/webhook1-certificate webhooks : - name : webhook1.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook1 namespace : example1 path : /validate port : 443 sideEffects : None --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : webhook1-certificate namespace : example1 spec : secretName : webhook1-certificate dnsNames : - webhook1.example1 issuerRef : name : selfsigned --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : selfsigned namespace : example1 spec : selfSigned : {} You should find that the caBundle value is now identical to the CA value in the Secret for the Certificate : kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook1 -o yaml | grep caBundle kubectl -n example1 get secret webhook1-certificate -o yaml | grep ca.crt And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server. Injecting CA data from a Secret resource \u00b6 Here is another example of a ValidatingWebhookConfiguration this time configured with the annotation cert-manager.io/inject-ca-from-secret , which will make cainjector populate the caBundle field using CA data from a Kubernetes Secret . NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example2 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook2 annotations : cert-manager.io/inject-ca-from-secret : example2/example-ca webhooks : - name : webhook2.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook2 namespace : example2 path : /validate port : 443 sideEffects : None --- apiVersion : v1 kind : Secret metadata : name : example-ca namespace : example2 annotations : cert-manager.io/allow-direct-injection : \"true\" type : kubernetes.io/tls data : ca.crt : LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5akNDQWQ2Z0F3SUJBZ0lRTkdJZ24yM3BQYVpNbk9MUjJnVmZHakFOQmdrcWhraUc5dzBCQVFzRkFEQVYKTVJNd0VRWURWUVFERXdwRmVHRnRjR3hsSUVOQk1CNFhEVEl3TURreU5ERTFOREEwTVZvWERUSXdNVEl5TXpFMQpOREEwTVZvd0ZURVRNQkVHQTFVRUF4TUtSWGhoYlhCc1pTQkRRVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFECmdnRVBBRENDQVFvQ2dnRUJBS2F3RzVoMzlreHdyNEl0WCtHaDNYVWQrdTVJc2ZlSFdoTTc4TTRQTmZFeXhQMXoKRmNLN1d0MHJFMkwwNUppYmQ4ZjNpb3k5OXNnQ3I4OEw2SWxYZTB0RnkzNysxenJ4TFluR2hDQnZzZjltd0hLbgpIVTEvNERwQjROZkhPbFllNE9tbHVoNE9HdmZINU1EbDh5OWZGMjhXRXVBQ2dwdmpCUWxvRDNlVjJ5UmJvQ2kyCmtSTDJWYTFZL0FQZEpWK21VYkFvZmg0bllmUmNLRTJsSUg0RG5ZdXFPU3JaaituZUQ2M2RTSktxcHQ5K2luN2YKNHljZ2pQYU93MmdyKzhLK291QTlSQTV1VDI3SVNJcUJDcEV6elRqbVBUUWNvUTYxZGF0aDZkc1lsTEU4aWZWUwp4RWZuVEdQKy94M0FXQXR4eU5lanVuZGFXbVNFL3h5OHh0K0FxblVDQXdFQUFhTkNNRUF3RGdZRFZSMFBBUUgvCkJBUURBZ0trTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3SFFZRFZSME9CQllFRkowNkc5eEc2V1VBTHB6T3JYaHAKV2dsTm5qMkFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUI3ZG9CZnBLR3o4VlRQSnc0YXhpdisybzJpMHE1SQpSRzU2UE81WnhKQktZQlRROElHQmFOSm1yeGtmNTJCV0ttUGp4cXlNSGRwWjVBU00zOUJkZVUzRGtEWHp4RkgwCjM5RU12UnhIUERyMGQ4cTFFbndQT0xZY1hzNjJhYjdidE11cTJUMFNNZzRYMkY5VmNKTW5YdjlrNnA0VGZNR3MKVThCQnJhVGhUZm53ejBsWXMyblFjdzNmZjZ1bG1wWlk4K3BTak1aVDNJZHZOMFA4Y2hOdUlmUFRHWDJmSlo2NQpxcUUrelRoU3hIeXFTOTVoczhsd1lRRUhGQlVsalRnMCtQZThXL0hOSXZBOU9TYWw1U3UvdlhydmcxN04xdHVyCk5XcWRyZU5OVm1ubXMvTFJodmthWTBGblRvbFNBRkNXWS9GSDY5ZzRPcThiMHVyK3JVMHZOZFFXCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K tls.key : \"\" tls.crt : \"\" You should find that the caBundle value is now identical to the ca.crt value in the Secret : kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook2 -o yaml | grep caBundle And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server. This Secret based injection mechanism can operate independently of the Certificate based mechanism described earlier. It will work without the cert-manager CRDs installed and it will work if the cert-manager CRDs and associated webhook servers are not yet configured. NOTE: For this reason, cert-manager uses the Secret based injection mechanism to bootstrap its own webhook server. The cert-manager webhook server generates its own private key and self-signed certificate and places them in a Secret when it starts up. Injecting the Kubernetes API Server CA \u00b6 Here is another example of a ValidatingWebhookConfiguration this time configured with the annotation cert-manager.io/inject-apiserver-ca: \"true\" , which will make cainjector populate the caBundle field using the same CA certificate used by the Kubernetes API server. NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example3 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook3 annotations : cert-manager.io/inject-apiserver-ca : \"true\" webhooks : - name : webhook3.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook3 namespace : example3 path : /validate port : 443 sideEffects : None You should find that the caBundle value is now identical to the CA used in your KubeConfig file: kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook3 -o yaml | grep caBundle kubectl config view --minify --raw | grep certificate-authority-data And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server. NOTE: In this case you will have to ensure that your webhook is configured to serve a TLS certificate that has been signed by the Kubernetes cluster CA. The disadvantages of this mechanism are that: you will require access to the private key of the Kubernetes cluster CA and you will need to manually rotate the webhook certificate.","title":"CA Injector"},{"location":"concepts/ca-injector/#examples","text":"Here are examples demonstrating how to use the three cainjector sources . In each case we use ValidatingWebhookConfiguration as the injectable , but you can substitute MutatingWebhookConfiguration or CustomResourceDefinition definition instead.","title":"Examples"},{"location":"concepts/ca-injector/#injecting-ca-data-from-a-certificate-resource","text":"Here is an example of a ValidatingWebhookConfiguration configured with the annotation cert-manager.io/inject-ca-from , which will make cainjector populate the caBundle field using CA data from a cert-manager Certificate . NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example1 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook1 annotations : cert-manager.io/inject-ca-from : example1/webhook1-certificate webhooks : - name : webhook1.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook1 namespace : example1 path : /validate port : 443 sideEffects : None --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : webhook1-certificate namespace : example1 spec : secretName : webhook1-certificate dnsNames : - webhook1.example1 issuerRef : name : selfsigned --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : selfsigned namespace : example1 spec : selfSigned : {} You should find that the caBundle value is now identical to the CA value in the Secret for the Certificate : kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook1 -o yaml | grep caBundle kubectl -n example1 get secret webhook1-certificate -o yaml | grep ca.crt And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server.","title":"Injecting CA data from a Certificate resource"},{"location":"concepts/ca-injector/#injecting-ca-data-from-a-secret-resource","text":"Here is another example of a ValidatingWebhookConfiguration this time configured with the annotation cert-manager.io/inject-ca-from-secret , which will make cainjector populate the caBundle field using CA data from a Kubernetes Secret . NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example2 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook2 annotations : cert-manager.io/inject-ca-from-secret : example2/example-ca webhooks : - name : webhook2.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook2 namespace : example2 path : /validate port : 443 sideEffects : None --- apiVersion : v1 kind : Secret metadata : name : example-ca namespace : example2 annotations : cert-manager.io/allow-direct-injection : \"true\" type : kubernetes.io/tls data : ca.crt : LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5akNDQWQ2Z0F3SUJBZ0lRTkdJZ24yM3BQYVpNbk9MUjJnVmZHakFOQmdrcWhraUc5dzBCQVFzRkFEQVYKTVJNd0VRWURWUVFERXdwRmVHRnRjR3hsSUVOQk1CNFhEVEl3TURreU5ERTFOREEwTVZvWERUSXdNVEl5TXpFMQpOREEwTVZvd0ZURVRNQkVHQTFVRUF4TUtSWGhoYlhCc1pTQkRRVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFECmdnRVBBRENDQVFvQ2dnRUJBS2F3RzVoMzlreHdyNEl0WCtHaDNYVWQrdTVJc2ZlSFdoTTc4TTRQTmZFeXhQMXoKRmNLN1d0MHJFMkwwNUppYmQ4ZjNpb3k5OXNnQ3I4OEw2SWxYZTB0RnkzNysxenJ4TFluR2hDQnZzZjltd0hLbgpIVTEvNERwQjROZkhPbFllNE9tbHVoNE9HdmZINU1EbDh5OWZGMjhXRXVBQ2dwdmpCUWxvRDNlVjJ5UmJvQ2kyCmtSTDJWYTFZL0FQZEpWK21VYkFvZmg0bllmUmNLRTJsSUg0RG5ZdXFPU3JaaituZUQ2M2RTSktxcHQ5K2luN2YKNHljZ2pQYU93MmdyKzhLK291QTlSQTV1VDI3SVNJcUJDcEV6elRqbVBUUWNvUTYxZGF0aDZkc1lsTEU4aWZWUwp4RWZuVEdQKy94M0FXQXR4eU5lanVuZGFXbVNFL3h5OHh0K0FxblVDQXdFQUFhTkNNRUF3RGdZRFZSMFBBUUgvCkJBUURBZ0trTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3SFFZRFZSME9CQllFRkowNkc5eEc2V1VBTHB6T3JYaHAKV2dsTm5qMkFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUI3ZG9CZnBLR3o4VlRQSnc0YXhpdisybzJpMHE1SQpSRzU2UE81WnhKQktZQlRROElHQmFOSm1yeGtmNTJCV0ttUGp4cXlNSGRwWjVBU00zOUJkZVUzRGtEWHp4RkgwCjM5RU12UnhIUERyMGQ4cTFFbndQT0xZY1hzNjJhYjdidE11cTJUMFNNZzRYMkY5VmNKTW5YdjlrNnA0VGZNR3MKVThCQnJhVGhUZm53ejBsWXMyblFjdzNmZjZ1bG1wWlk4K3BTak1aVDNJZHZOMFA4Y2hOdUlmUFRHWDJmSlo2NQpxcUUrelRoU3hIeXFTOTVoczhsd1lRRUhGQlVsalRnMCtQZThXL0hOSXZBOU9TYWw1U3UvdlhydmcxN04xdHVyCk5XcWRyZU5OVm1ubXMvTFJodmthWTBGblRvbFNBRkNXWS9GSDY5ZzRPcThiMHVyK3JVMHZOZFFXCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K tls.key : \"\" tls.crt : \"\" You should find that the caBundle value is now identical to the ca.crt value in the Secret : kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook2 -o yaml | grep caBundle And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server. This Secret based injection mechanism can operate independently of the Certificate based mechanism described earlier. It will work without the cert-manager CRDs installed and it will work if the cert-manager CRDs and associated webhook servers are not yet configured. NOTE: For this reason, cert-manager uses the Secret based injection mechanism to bootstrap its own webhook server. The cert-manager webhook server generates its own private key and self-signed certificate and places them in a Secret when it starts up.","title":"Injecting CA data from a Secret resource"},{"location":"concepts/ca-injector/#injecting-the-kubernetes-api-server-ca","text":"Here is another example of a ValidatingWebhookConfiguration this time configured with the annotation cert-manager.io/inject-apiserver-ca: \"true\" , which will make cainjector populate the caBundle field using the same CA certificate used by the Kubernetes API server. NOTE: This example does not deploy a webhook server, it only deploys a partial webhook configuration, but it should be sufficient to help you understand what cainjector does: apiVersion : v1 kind : Namespace metadata : name : example3 --- apiVersion : admissionregistration.k8s.io/v1 kind : ValidatingWebhookConfiguration metadata : name : webhook3 annotations : cert-manager.io/inject-apiserver-ca : \"true\" webhooks : - name : webhook3.example.com admissionReviewVersions : - v1 clientConfig : service : name : webhook3 namespace : example3 path : /validate port : 443 sideEffects : None You should find that the caBundle value is now identical to the CA used in your KubeConfig file: kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io webhook3 -o yaml | grep caBundle kubectl config view --minify --raw | grep certificate-authority-data And after a short time, the Kubernetes API server will read that new caBundle value and use it to verify a TLS connection to the webhook server. NOTE: In this case you will have to ensure that your webhook is configured to serve a TLS certificate that has been signed by the Kubernetes cluster CA. The disadvantages of this mechanism are that: you will require access to the private key of the Kubernetes cluster CA and you will need to manually rotate the webhook certificate.","title":"Injecting the Kubernetes API Server CA"},{"location":"concepts/certificate/","text":"cert-manager has the concept of Certificates that define a desired X.509 certificate which will be renewed and kept up to date. A Certificate is a namespaced resource that references an Issuer or ClusterIssuer that determine what will be honoring the certificate request. When a Certificate is created, a corresponding CertificateRequest resource is created by cert-manager containing the encoded X.509 certificate request, Issuer reference, and other options based upon the specification of the Certificate resource. Here is one such example of a Certificate resource. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : acme-crt spec : secretName : acme-crt-secret dnsNames : - example.com - foo.example.com issuerRef : name : letsencrypt-prod # We can reference ClusterIssuers by changing the kind here. # The default value is Issuer (i.e. a locally namespaced Issuer) kind : Issuer group : cert-manager.io This Certificate will tell cert-manager to attempt to use the Issuer named letsencrypt-prod to obtain a certificate key pair for the example.com and foo.example.com domains. If successful, the resulting TLS key and certificate will be stored in a secret named acme-crt-secret , with keys of tls.key , and tls.crt respectively. This secret will live in the same namespace as the Certificate resource. When a certificate is issued by an intermediate CA and the Issuer can provide the issued certificate's chain, the contents of tls.crt will be the requested certificate followed by the certificate chain. Additionally, if the Certificate Authority is known, the corresponding CA certificate will be stored in the secret with key ca.crt . For example, with the ACME issuer, the CA is not known and ca.crt will not exist in acme-crt-secret . cert-manager intentionally avoids adding root certificates to tls.crt , because they are useless in a situation where TLS is being done securely. For more information, see RFC 5246 section 7.4.2 which contains the following explanation: Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case. When configuring a client to connect to a TLS server with a serving certificate that is signed by a private CA, you will need to provide the client with the CA certificate in order for it to verify the server. `ca.crt` will likely contain the certificate you need to trust, but __do not mount the same `Secret` as the server__ to access `ca.crt`. This is because: 1. That `Secret` also contains the private key of the server, which should only be accessible to the server. You should use RBAC to ensure that the `Secret` containing the serving certificate and private key are only accessible to Pods that need it. 2. Rotating CA certificates safely relies on being able to have both the old and new CA certificates trusted at the same time. By consuming the CA directly from the source, this isn't possible; you'll be _forced_ to have some down-time in order to rotate certificates. When configuring the client you should independently choose and fetch the CA certificates that you want to trust. Download the CA out of band and store it in a `Secret` or `ConfigMap` separate from the `Secret` containing the server's private key and certificate. This ensures that if the material in the `Secret` containing the server key and certificate is tampered with, the client will fail to connect to the compromised server. The same concept also applies when configuring a server for mutually-authenticated TLS; don't give the server access to Secret containing the client certificate and private key. The dnsNames field specifies a list of Subject Alternative Names to be associated with the certificate. The referenced Issuer must exist in the same namespace as the Certificate . A Certificate can alternatively reference a ClusterIssuer which is non-namespaced and so can be referenced from any namespace. You can read more on how to configure your Certificate resources here . Certificate Lifecycle \u00b6 This diagram shows the lifecycle of a Certificate named cert-1 using an ACME / Let's Encrypt issuer. You don't need to understand all of these steps to use cert-manager; this is more of an explanation of the logic which happens under the hood for those curious about the process.","title":"Certificate"},{"location":"concepts/certificate/#certificate-lifecycle","text":"This diagram shows the lifecycle of a Certificate named cert-1 using an ACME / Let's Encrypt issuer. You don't need to understand all of these steps to use cert-manager; this is more of an explanation of the logic which happens under the hood for those curious about the process.","title":"Certificate Lifecycle"},{"location":"concepts/certificaterequest/","text":"The CertificateRequest is a namespaced resource in cert-manager that is used to request X.509 certificates from an Issuer . The resource contains a base64 encoded string of a PEM encoded certificate request which is sent to the referenced issuer. A successful issuance will return a signed certificate, based on the certificate signing request. CertificateRequests are typically consumed and managed by controllers or other systems and should not be used by humans - unless specifically needed. A simple CertificateRequest looks like the following: apiVersion : cert-manager.io/v1 kind : CertificateRequest metadata : name : my-ca-cr spec : request : LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQzNqQ0NBY1lDQVFBd2daZ3hDekFKQmdOVkJBWVRBbHBhTVE4d0RRWURWUVFJREFaQmNHOXNiRzh4RFRBTApCZ05WQkFjTUJFMXZiMjR4RVRBUEJnTlZCQW9NQ0VwbGRITjBZV05yTVJVd0V3WURWUVFMREF4alpYSjBMVzFoCmJtRm5aWEl4RVRBUEJnTlZCQU1NQ0dwdmMyaDJZVzVzTVN3d0tnWUpLb1pJaHZjTkFRa0JGaDFxYjNOb2RXRXUKZG1GdWJHVmxkWGRsYmtCcVpYUnpkR0ZqYXk1cGJ6Q0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQwpBUW9DZ2dFQkFLd01tTFhuQkNiRStZdTIvMlFtRGsxalRWQ3BvbHU3TlZmQlVFUWl1bDhFMHI2NFBLcDRZQ0c5Cmx2N2kwOHdFMEdJQUgydnJRQmxVd3p6ZW1SUWZ4YmQvYVNybzRHNUFBYTJsY2NMaFpqUlh2NEVMaER0aVg4N3IKaTQ0MWJ2Y01OM0ZPTlRuczJhRkJYcllLWGxpNG4rc0RzTEVuZmpWdXRiV01Zeis3M3ptaGZzclRJUjRzTXo3cQpmSzM2WFM4UkRjNW5oVVcyYU9BZ3lnbFZSOVVXRkxXNjNXYXVhcHg2QUpBR1RoZnJYdVVHZXlZUUVBSENxZmZmCjhyOEt3YTFYK1NwYm9YK1ppSVE0Nk5jQ043OFZnL2dQVHNLZmphZURoNWcyNlk1dEVidHd3MWdRbWlhK0MyRHIKWHpYNU13RzJGNHN0cG5kUnRQckZrU1VnMW1zd0xuc0NBd0VBQWFBQU1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQgpBUUFXR0JuRnhaZ0gzd0N3TG5IQ0xjb0l5RHJrMUVvYkRjN3BJK1VVWEJIS2JBWk9IWEFhaGJ5RFFLL2RuTHN3CjJkZ0J3bmlJR3kxNElwQlNxaDBJUE03eHk5WjI4VW9oR3piN0FVakRJWHlNdmkvYTJyTVhjWjI1d1NVQmxGc28Kd005dE1QU2JwcEVvRERsa3NsOUIwT1BPdkFyQ0NKNnZGaU1UbS9wMUJIUWJSOExNQW53U0lUYVVNSFByRzJVMgpjTjEvRGNMWjZ2enEyeENjYVoxemh2bzBpY1VIUm9UWmV1ZEp6MkxmR0VHM1VOb2ppbXpBNUZHd0RhS3BySWp3ClVkd1JmZWZ1T29MT1dNVnFNbGRBcTlyT24wNHJaT3Jnak1HSE9tTWxleVdPS1AySllhaDNrVDdKU01zTHhYcFYKV0ExQjRsLzFFQkhWeGlKQi9Zby9JQWVsCi0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo= isCA : false usages : - signing - digital signature - server auth # 90 days duration : 2160h issuerRef : name : ca-issuer # We can reference ClusterIssuers by changing the kind here. # The default value is Issuer (i.e. a locally namespaced Issuer) kind : Issuer group : cert-manager.io This CertificateRequest will make cert-manager attempt to request the Issuer ca-issuer in the default issuer group cert-manager.io , return a certificate based upon the certificate signing request. Other groups can be specified inside the issuerRef which will change the targeted issuer to other external, third party issuers you may have installed. The resource also exposes the option for stating the certificate as CA, Key Usages, and requested validity duration. All fields within the spec of the CertificateRequest , as well as any managed cert-manager annotations, are immutable and cannot be modified after creation. A successful issuance of the certificate signing request will cause an update to the resource, setting the status with the signed certificate, the CA of the certificate (if available), and setting the Ready condition to True . Whether issuance of the certificate signing request was successful or not, a retry of the issuance will not happen. It is the responsibility of some other controller to manage the logic and life cycle of CertificateRequests . Conditions \u00b6 CertificateRequests have a set of strongly defined conditions that should be used and relied upon by controllers or services to make decisions on what actions to take next on the resource. Ready \u00b6 Each ready condition consists of the pair Ready - a boolean value, and Reason - a string. The set of values and meanings are as follows: Ready Reason Condition Meaning False Pending The CertificateRequest is currently pending, waiting for some other operation to take place. This could be that the Issuer does not exist yet or the Issuer is in the process of issuing a certificate. False Failed The certificate has failed to be issued - either the returned certificate failed to be decoded or an instance of the referenced issuer used for signing failed. No further action will be taken on the CertificateRequest by it's controller. True Issued A signed certificate has been successfully issued by the referenced Issuer . UserInfo \u00b6 CertificateRequests include a set of UserInfo fields as part of the spec, namely: username , groups , uid , and extra . These values contain the user who created the CertificateRequest . This user will be cert-manager itself in the case that the CertificateRequest was created by a Certificate resource, or instead the user who created the CertificateRequest directly. Warning : These fields are managed by cert-manager and should never be set or modified by anything else. When the CertificateRequest is created, these fields will be overridden, and any request attempting to modify them will be rejected. Approval \u00b6 CertificateRequests can be Approved or Denied . These mutually exclusive conditions gate a CertificateRequest from being signed by its managed signer. A signer should not sign a managed CertificateRequest without an Approved condition A signer will sign a managed CertificateRequest with an Approved condition A signer will never sign a managed CertificateRequest with a Denied condition These conditions are permanent , and cannot be modified or changed once set. NAMESPACE NAME APPROVED DENIED READY ISSUER REQUESTOR AGE istio-system service-mesh-ca-whh5b True True mesh-ca system:serviceaccount:istio-system:istiod 16s istio-system my-app-fj9sa True mesh-ca system:serviceaccount:my-app:my-app 4s Behavior \u00b6 The Approved and Denied conditions are two distinct condition types on the CertificateRequest. These conditions must only have the status of True, and are mutually exclusive (i.e. a CertificateRequest cannot have an Approved and Denied condition simultaneously). This behavior is enforced in the cert-manager validating admission webhook. An \"approver\" is an entity that is responsible for setting the Approved/Denied conditions. It is up to the approver's implementation as to what CertificateRequests are managed by that approver. The Reason field of the Approved/Denied condition should be set to who set the condition. Who can be interpreted however makes sense to the approver implementation. For example, it may include the API group of an approving policy controller, or the client agent of a manual request. The Message field of the Approved/Denied condition should be set to why the condition is set. Again, why can be interpreted however makes sense to the implementation of the approver. For example, the name of the resource that approves this request, the violations which caused the request to be denied, or the team to who manually approved the request. Approver Controller \u00b6 By default, cert-manager will run an internal approval controller which will automatically approve all CertificateRequests that reference any internal issuer type in any namespace: cert-manager.io/Issuer , cert-manager.io/ClusterIssuer . To disable this controller, add the following argument to the cert-manager-controller: --controllers=*,-certificaterequests-approver . This can be achieved with helm by appending: --set extraArgs ={ --controllers = '*\\,-certificaterequests-approver' } Alternatively, in order for the internal approver controller to approve CertificateRequests that reference an external issuer, add the following RBAC to the cert-manager-controller Service Account. Please replace the given resource names with the relevant names: apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cert-manager-controller-approve:my-issuer-example-com # edit rules : - apiGroups : - cert-manager.io resources : - signers verbs : - approve resourceNames : - issuers.my-issuer.example.com/* # edit - clusterissuers.my-issuer.example.com/* # edit --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : cert-manager-controller-approve:my-issuer-example-com # edit roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-controller-approve:my-issuer-example-com # edit subjects : - kind : ServiceAccount name : cert-manager namespace : cert-manager RBAC Syntax \u00b6 When a user or controller attempts to approve or deny a CertificateRequest, the cert-manager webhook will evaluate whether it has sufficient permissions to do so. These permissions are based upon the request itself- specifically the request's IssuerRef: apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"approve\" ] resourceNames : # namesapced signers - \"<signer-resource-name>.<signer-group>/<signer-namespace>.<signer-name>\" # cluster scoped signers - \"<signer-resource-name>.<signer-group>/<signer-name>\" # all signers of this resource name - \"<signer-resource-name>.<signer-group>/*\" An example ClusterRole that would grant the permissions to set the Approve and Denied conditions of CertificateRequests that reference the cluster scoped myissuers external issuer, in the group my-example.io , with the name myapp : apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : my-example-io-my-issuer-myapp-approver rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"approve\" ] resourceNames : [ \"myissuers.my-example.io/myapp\" ] If the approver does not have sufficient permissions defined above to set the Approved or Denied conditions, the request will be rejected by the cert-manager validating admission webhook. The RBAC permissions must be granted at the cluster scope Namespaced signers are represented by a namespaced resource using the syntax of <signer-resource-name>.<signer-group>/<signer-namespace>.<signer-name> Cluster scoped signers are represented using the syntax of <signer-resource-name>.<signer-group>/<signer-name> An approver can be granted approval for all namespaces via <signer-resource-name>.<signer-group>/* The apiGroup must always be cert-manager.io The resource must always be signers The verb must always be approve , which grants the approver the permissions to set both Approved and Denied conditions An example of signing all myissuer signers in all namespaces, and clustermyissuers with the name myapp , in the my-example.io group: resourceNames : [ \"myissuers.my-example.io/*\" , \"clustermyissuers.my-example.io/myapp\" ] An example of signing myissuer with the name myapp in the namespaces foo and bar : resourceNames : [ \"myissuers.my-example.io/foo.myapp\" , \"myissuers.my-example.io/bar.myapp\" ]","title":"CertificateRequest"},{"location":"concepts/certificaterequest/#conditions","text":"CertificateRequests have a set of strongly defined conditions that should be used and relied upon by controllers or services to make decisions on what actions to take next on the resource.","title":"Conditions"},{"location":"concepts/certificaterequest/#ready","text":"Each ready condition consists of the pair Ready - a boolean value, and Reason - a string. The set of values and meanings are as follows: Ready Reason Condition Meaning False Pending The CertificateRequest is currently pending, waiting for some other operation to take place. This could be that the Issuer does not exist yet or the Issuer is in the process of issuing a certificate. False Failed The certificate has failed to be issued - either the returned certificate failed to be decoded or an instance of the referenced issuer used for signing failed. No further action will be taken on the CertificateRequest by it's controller. True Issued A signed certificate has been successfully issued by the referenced Issuer .","title":"Ready"},{"location":"concepts/certificaterequest/#userinfo","text":"CertificateRequests include a set of UserInfo fields as part of the spec, namely: username , groups , uid , and extra . These values contain the user who created the CertificateRequest . This user will be cert-manager itself in the case that the CertificateRequest was created by a Certificate resource, or instead the user who created the CertificateRequest directly. Warning : These fields are managed by cert-manager and should never be set or modified by anything else. When the CertificateRequest is created, these fields will be overridden, and any request attempting to modify them will be rejected.","title":"UserInfo"},{"location":"concepts/certificaterequest/#approval","text":"CertificateRequests can be Approved or Denied . These mutually exclusive conditions gate a CertificateRequest from being signed by its managed signer. A signer should not sign a managed CertificateRequest without an Approved condition A signer will sign a managed CertificateRequest with an Approved condition A signer will never sign a managed CertificateRequest with a Denied condition These conditions are permanent , and cannot be modified or changed once set. NAMESPACE NAME APPROVED DENIED READY ISSUER REQUESTOR AGE istio-system service-mesh-ca-whh5b True True mesh-ca system:serviceaccount:istio-system:istiod 16s istio-system my-app-fj9sa True mesh-ca system:serviceaccount:my-app:my-app 4s","title":"Approval"},{"location":"concepts/certificaterequest/#behavior","text":"The Approved and Denied conditions are two distinct condition types on the CertificateRequest. These conditions must only have the status of True, and are mutually exclusive (i.e. a CertificateRequest cannot have an Approved and Denied condition simultaneously). This behavior is enforced in the cert-manager validating admission webhook. An \"approver\" is an entity that is responsible for setting the Approved/Denied conditions. It is up to the approver's implementation as to what CertificateRequests are managed by that approver. The Reason field of the Approved/Denied condition should be set to who set the condition. Who can be interpreted however makes sense to the approver implementation. For example, it may include the API group of an approving policy controller, or the client agent of a manual request. The Message field of the Approved/Denied condition should be set to why the condition is set. Again, why can be interpreted however makes sense to the implementation of the approver. For example, the name of the resource that approves this request, the violations which caused the request to be denied, or the team to who manually approved the request.","title":"Behavior"},{"location":"concepts/certificaterequest/#approver-controller","text":"By default, cert-manager will run an internal approval controller which will automatically approve all CertificateRequests that reference any internal issuer type in any namespace: cert-manager.io/Issuer , cert-manager.io/ClusterIssuer . To disable this controller, add the following argument to the cert-manager-controller: --controllers=*,-certificaterequests-approver . This can be achieved with helm by appending: --set extraArgs ={ --controllers = '*\\,-certificaterequests-approver' } Alternatively, in order for the internal approver controller to approve CertificateRequests that reference an external issuer, add the following RBAC to the cert-manager-controller Service Account. Please replace the given resource names with the relevant names: apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cert-manager-controller-approve:my-issuer-example-com # edit rules : - apiGroups : - cert-manager.io resources : - signers verbs : - approve resourceNames : - issuers.my-issuer.example.com/* # edit - clusterissuers.my-issuer.example.com/* # edit --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : cert-manager-controller-approve:my-issuer-example-com # edit roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-controller-approve:my-issuer-example-com # edit subjects : - kind : ServiceAccount name : cert-manager namespace : cert-manager","title":"Approver Controller"},{"location":"concepts/certificaterequest/#rbac-syntax","text":"When a user or controller attempts to approve or deny a CertificateRequest, the cert-manager webhook will evaluate whether it has sufficient permissions to do so. These permissions are based upon the request itself- specifically the request's IssuerRef: apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"approve\" ] resourceNames : # namesapced signers - \"<signer-resource-name>.<signer-group>/<signer-namespace>.<signer-name>\" # cluster scoped signers - \"<signer-resource-name>.<signer-group>/<signer-name>\" # all signers of this resource name - \"<signer-resource-name>.<signer-group>/*\" An example ClusterRole that would grant the permissions to set the Approve and Denied conditions of CertificateRequests that reference the cluster scoped myissuers external issuer, in the group my-example.io , with the name myapp : apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : my-example-io-my-issuer-myapp-approver rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"approve\" ] resourceNames : [ \"myissuers.my-example.io/myapp\" ] If the approver does not have sufficient permissions defined above to set the Approved or Denied conditions, the request will be rejected by the cert-manager validating admission webhook. The RBAC permissions must be granted at the cluster scope Namespaced signers are represented by a namespaced resource using the syntax of <signer-resource-name>.<signer-group>/<signer-namespace>.<signer-name> Cluster scoped signers are represented using the syntax of <signer-resource-name>.<signer-group>/<signer-name> An approver can be granted approval for all namespaces via <signer-resource-name>.<signer-group>/* The apiGroup must always be cert-manager.io The resource must always be signers The verb must always be approve , which grants the approver the permissions to set both Approved and Denied conditions An example of signing all myissuer signers in all namespaces, and clustermyissuers with the name myapp , in the my-example.io group: resourceNames : [ \"myissuers.my-example.io/*\" , \"clustermyissuers.my-example.io/myapp\" ] An example of signing myissuer with the name myapp in the namespaces foo and bar : resourceNames : [ \"myissuers.my-example.io/foo.myapp\" , \"myissuers.my-example.io/bar.myapp\" ]","title":"RBAC Syntax"},{"location":"concepts/issuer/","text":"Issuers , and ClusterIssuers , are Kubernetes resources that represent certificate authorities (CAs) that are able to generate signed certificates by honoring certificate signing requests. All cert-manager certificates require a referenced issuer that is in a ready condition to attempt to honor the request. An example of an Issuer type is CA . A simple CA Issuer is as follows: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ca-issuer namespace : mesh-system spec : ca : secretName : ca-key-pair This is a simple Issuer that will sign certificates based on a private key. The certificate stored in the secret ca-key-pair can then be used to trust newly signed certificates by this Issuer in a Public Key Infrastructure (PKI) system. Namespaces \u00b6 An Issuer is a namespaced resource, and it is not possible to issue certificates from an Issuer in a different namespace. This means you will need to create an Issuer in each namespace you wish to obtain Certificates in. If you want to create a single Issuer that can be consumed in multiple namespaces, you should consider creating a ClusterIssuer resource. This is almost identical to the Issuer resource, however is non-namespaced so it can be used to issue Certificates across all namespaces. Supported Issuers \u00b6 cert-manager supports a number of 'in-tree', as well as 'out-of-tree' Issuer types. An exhaustive list of these Issuer types can be found in the cert-manager configuration documentation .","title":"Issuer"},{"location":"concepts/issuer/#namespaces","text":"An Issuer is a namespaced resource, and it is not possible to issue certificates from an Issuer in a different namespace. This means you will need to create an Issuer in each namespace you wish to obtain Certificates in. If you want to create a single Issuer that can be consumed in multiple namespaces, you should consider creating a ClusterIssuer resource. This is almost identical to the Issuer resource, however is non-namespaced so it can be used to issue Certificates across all namespaces.","title":"Namespaces"},{"location":"concepts/issuer/#supported-issuers","text":"cert-manager supports a number of 'in-tree', as well as 'out-of-tree' Issuer types. An exhaustive list of these Issuer types can be found in the cert-manager configuration documentation .","title":"Supported Issuers"},{"location":"concepts/webhook/","text":"cert-manager extends the Kubernetes API using Custom Resource Definitions. It installs a webhook which has three main functions: Validation : Ensures that when cert-manager resources are created or updated, they conform to the rules of the API. This validation is more in depth than for example ensuring resources conform to the OpenAPI schema, but instead contains logic such as not allowing to specify more than one Issuer type per Issuer resource. The validating admission is always called and will respond with a success or failed response. Mutation / Defaulting : Changes the contents of resources during create and update operations, for example to set default values. Conversion : The webhook is also responsible for implementing a conversion over versions in the cert-manager CustomResources ( cert-manager.io ). This means that multiple API versions can be supported simultaneously; from v1alpha2 through to v1 . This makes it possible to rely on a particular version of our configuration schema. \u2139\ufe0f This is known as Dynamic Admission Control. Read more about Dynamic Admission Control in the Kubernetes documentation. Overview \u00b6 The webhook component is deployed as another pod that runs alongside the main cert-manager controller and CA injector components. In order for the API server to communicate with the webhook component, the webhook requires a TLS certificate that the apiserver is configured to trust. The cainjector creates secret/cert-manager-webhook-ca , a self-signed root CA certificate which is used to sign certificates for the webhook pod. Then the webhook can be configured with either paths to a TLS certificate and key signed by the webhook CA, or a reference to the CA Secret for dynamic generation of the certificate and key on webhook startup Known Problems and Solutions \u00b6 Webhook connection problems on GKE private cluster \u00b6 If errors occur around the webhook but the webhook is running then the webhook is most likely not reachable from the API server. In this case, ensure that the API server can communicate with the webhook by following the GKE private cluster explanation . Webhook connection problems on AWS EKS \u00b6 When using a custom CNI (such as Weave or Calico) on EKS, the webhook cannot be reached by cert-manager. This happens because the control plane cannot be configured to run on a custom CNI on EKS, so the CNIs differ between control plane and worker nodes. The solution is to run the webhook in the host network so it can be reached by cert-manager. Webhook connection problems shortly after cert-manager installation \u00b6 When you first install cert-manager, it will take a few seconds before the cert-manager API is usable. This is because the cert-manager API requires the cert-manager webhook server, which takes some time to start up. Here's why: The webhook server performs a leader election at startup which may take a few seconds. The webhook server may take a few seconds to start up and to generate its self-signed CA and serving certificate and to publish those to a Secret. cainjector performs a leader election at start up which can take a few seconds. cainjector , once started, will take a few seconds to update the caBundle in all the webhook configurations. For these reasons, after installing cert-manager and when performing post-installation cert-manager API operations, you will need to check for temporary API configuration errors and retry. You could also add a post-installation check which performs kubectl --dry-run operations on the cert-manager API. Or you could add a post-installation check which automatically retries the Installation Verification steps until they succeed. Other Webhook Problems \u00b6 If you encounter any other problems with the webhook, please refer to the webhook troubleshooting guide .","title":"All About the cert-manager Webhook"},{"location":"concepts/webhook/#overview","text":"The webhook component is deployed as another pod that runs alongside the main cert-manager controller and CA injector components. In order for the API server to communicate with the webhook component, the webhook requires a TLS certificate that the apiserver is configured to trust. The cainjector creates secret/cert-manager-webhook-ca , a self-signed root CA certificate which is used to sign certificates for the webhook pod. Then the webhook can be configured with either paths to a TLS certificate and key signed by the webhook CA, or a reference to the CA Secret for dynamic generation of the certificate and key on webhook startup","title":"Overview"},{"location":"concepts/webhook/#known-problems-and-solutions","text":"","title":"Known Problems and Solutions"},{"location":"concepts/webhook/#webhook-connection-problems-on-gke-private-cluster","text":"If errors occur around the webhook but the webhook is running then the webhook is most likely not reachable from the API server. In this case, ensure that the API server can communicate with the webhook by following the GKE private cluster explanation .","title":"Webhook connection problems on GKE private cluster"},{"location":"concepts/webhook/#webhook-connection-problems-on-aws-eks","text":"When using a custom CNI (such as Weave or Calico) on EKS, the webhook cannot be reached by cert-manager. This happens because the control plane cannot be configured to run on a custom CNI on EKS, so the CNIs differ between control plane and worker nodes. The solution is to run the webhook in the host network so it can be reached by cert-manager.","title":"Webhook connection problems on AWS EKS"},{"location":"concepts/webhook/#webhook-connection-problems-shortly-after-cert-manager-installation","text":"When you first install cert-manager, it will take a few seconds before the cert-manager API is usable. This is because the cert-manager API requires the cert-manager webhook server, which takes some time to start up. Here's why: The webhook server performs a leader election at startup which may take a few seconds. The webhook server may take a few seconds to start up and to generate its self-signed CA and serving certificate and to publish those to a Secret. cainjector performs a leader election at start up which can take a few seconds. cainjector , once started, will take a few seconds to update the caBundle in all the webhook configurations. For these reasons, after installing cert-manager and when performing post-installation cert-manager API operations, you will need to check for temporary API configuration errors and retry. You could also add a post-installation check which performs kubectl --dry-run operations on the cert-manager API. Or you could add a post-installation check which automatically retries the Installation Verification steps until they succeed.","title":"Webhook connection problems shortly after cert-manager installation"},{"location":"concepts/webhook/#other-webhook-problems","text":"If you encounter any other problems with the webhook, please refer to the webhook troubleshooting guide .","title":"Other Webhook Problems"},{"location":"configuration/","text":"The first thing you'll need to configure after you've installed cert-manager is an Issuer or a ClusterIssuer . These are resources that represent certificate authorities (CAs) able to sign certificates in response to certificate signing requests. This section documents how the different issuer types can be configured. You might want to read more about Issuer and ClusterIssuer resources . cert-manager comes with a number of built-in certificate issuers which are denoted by being in the cert-manager.io group. You can also install external issuers in addition to the built-in types. Built-in and external issuers are treated the same and are configured similarly. Cluster Resource Namespace \u00b6 When using ClusterIssuer resource types, ensure you understand the purpose of the Cluster Resource Namespace; this can be a common source of issues for people getting started with cert-manager. The ClusterIssuer resource is cluster scoped. This means that when referencing a secret via the secretName field, secrets will be looked for in the Cluster Resource Namespace . By default, this namespace is cert-manager however it can be changed via a flag on the cert-manager-controller component: --cluster-resource-namespace = my-namespace","title":"\u4ecb\u7ecd"},{"location":"configuration/#cluster-resource-namespace","text":"When using ClusterIssuer resource types, ensure you understand the purpose of the Cluster Resource Namespace; this can be a common source of issues for people getting started with cert-manager. The ClusterIssuer resource is cluster scoped. This means that when referencing a secret via the secretName field, secrets will be looked for in the Cluster Resource Namespace . By default, this namespace is cert-manager however it can be changed via a flag on the cert-manager-controller component: --cluster-resource-namespace = my-namespace","title":"Cluster Resource Namespace"},{"location":"configuration/ca/","text":"\u26a0\ufe0f CA issuers are generally either for trying cert-manager out or else for advanced users with a good idea of how to run a PKI. To be used safely in production, CA issuers introduce complex planning requirements around rotation, trust store distribution and disaster recovery. If you're not planning to run your own PKI, use a different issuer type. The CA issuer represents a Certificate Authority whose certificate and private key are stored inside the cluster as a Kubernetes Secret . Certificates issued by a CA issuer will not be publicly trusted and so are unlikely to be trusted by your applications without further configuration work. Consider the trust-manager project for distributing trust stores. Deployment \u00b6 CA Issuers must be configured with a certificate and private key stored in a Kubernetes secret. You can create this externally if you wish, or you could bootstrap a root certificate using a SelfSigned issuer . Your certificate's secret should reside in the same namespace as the Issuer , or otherwise in the Cluster Resource Namespace in the case of a ClusterIssuer . The Cluster Resource Namespace is defaulted as being the cert-manager namespace, but can be configured using the --cluster-resource-namespace flag on the cert-manager controller. Below is an example of a secret resource that will be used for signing. Take note of the index keys used for each field as these are required in order for cert-manager to find the certificate and key. Also note that, like all secrets, data must be base64 encoded. The command $ cat crt.pem | base64 -w0 should help you on GNU-based systems (Debian, Ubuntu, etc.) and $ cat crt.pem | base64 -b0 on BSD-based systems (most notably macOS). apiVersion : v1 kind : Secret metadata : name : ca-key-pair namespace : sandbox data : tls.crt : LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMrVENDQWVHZ0F3SUJBZ0lKQUtQR3dLRGwvNUhuTUEwR0NTcUdTSWIzRFFFQkN3VUFNQk14RVRBUEJnTlYKQkFNTUNHcHZjMmgyWVc1c01CNFhEVEU1TURneU1qRTJNRFUxT0ZvWERUSTVNRGd4T1RFMk1EVTFPRm93RXpFUgpNQThHQTFVRUF3d0lhbTl6YUhaaGJtd3dnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCCkFRQ3doU0IvcVc2L2tMYjJ6cHUrRUp2RDl3SEZhcStRQS8wSkgvTGxseW83ekFGeCtISHErQ09BYmsrQzhCNHQKL0hVRXNuczVSTDA5Q1orWDRqNnBiSkZkS2R1UHhYdTVaVllua3hZcFVEVTd5ZzdPU0tTWnpUbklaNzIzc01zMApSNmpZbi9Ecmo0eFhNSkVmSFVEcVllU1dsWnIzcWkxRUZhMGM3ZlZEeEgrNHh0WnROTkZPakg3YzZEL3ZXa0lnCldRVXhpd3Vzc2U2S01PV2pEbnYvNFZyamVsMlFnVVlVYkhDeWVaSG1jdGkrSzBMV0Nmby9SZzZQdWx3cmJEa2gKam1PZ1l0MzBwZGhYME9aa0F1a2xmVURIZnA4YmpiQ29JMnRhWUFCQTZBS2pLc08zNUxBRVU3OUNMMW1MVkh1WgpBQ0k1VWppamEzVlBXVkhTd21KUEp5dXhBZ01CQUFHalVEQk9NQjBHQTFVZERnUVdCQlFtbDVkVEFaaXhGS2hqCjkzd3VjUldoYW8vdFFqQWZCZ05WSFNNRUdEQVdnQlFtbDVkVEFaaXhGS2hqOTN3dWNSV2hhby90UWpBTUJnTlYKSFJNRUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCK2tsa1JOSlVLQkxYOHlZa3l1VTJSSGNCdgpHaG1tRGpKSXNPSkhac29ZWGRMbEcxcFpORmpqUGFPTDh2aDQ0Vmw5OFJoRVpCSHNMVDFLTWJwMXN1NkNxajByClVHMWtwUkJlZitJT01UNE1VN3ZSSUNpN1VPbFJMcDFXcDBGOGxhM2hQT2NSYjJ5T2ZGcVhYeVpXWGY0dDBCNDUKdEhpK1pDTkhCOUZ4alNSeWNiR1lWaytUS3B2aEphU1lOTUdKM2R4REthUDcrRHgzWGNLNnNBbklBa2h5SThhagpOVSttdzgvdG1Sa1A0SW4va1hBUitSaTBxVW1Iai92d3ZuazRLbTdaVXkxRllIOERNZVM1TmtzbisvdUhsUnhSClY3RG5uMDM5VFJtZ0tiQXFONzJnS05MbzVjWit5L1lxREFZSFlybjk4U1FUOUpEZ3RJL0svQVRwVzhkWAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== tls.key : LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBc0lVZ2Y2bHV2NUMyOXM2YnZoQ2J3L2NCeFdxdmtBUDlDUi95NVpjcU84d0JjZmh4CjZ2Z2pnRzVQZ3ZBZUxmeDFCTEo3T1VTOVBRbWZsK0krcVd5UlhTbmJqOFY3dVdWV0o1TVdLVkExTzhvT3praWsKbWMwNXlHZTl0N0RMTkVlbzJKL3c2NCtNVnpDUkh4MUE2bUhrbHBXYTk2b3RSQld0SE8zMVE4Ui91TWJXYlRUUgpUb3grM09nLzcxcENJRmtGTVlzTHJMSHVpakRsb3c1Ny8rRmE0M3Bka0lGR0ZHeHdzbm1SNW5MWXZpdEMxZ242ClAwWU9qN3BjSzJ3NUlZNWpvR0xkOUtYWVY5RG1aQUxwSlgxQXgzNmZHNDJ3cUNOcldtQUFRT2dDb3lyRHQrU3cKQkZPL1FpOVppMVI3bVFBaU9WSTRvMnQxVDFsUjBzSmlUeWNyc1FJREFRQUJBb0lCQUNFTkhET3JGdGg1a1RpUApJT3dxa2UvVVhSbUl5MHlNNHFFRndXWXBzcmUxa0FPMkFDWjl4YS96ZDZITnNlanNYMEM4NW9PbmtrTk9mUHBrClcxVS94Y3dLM1ZpRElwSnBIZ09VNzg1V2ZWRXZtU3dZdi9Fb1V3eHFHRVMvcnB5Z1drWU5WSC9XeGZGQlg3clMKc0dmeVltbXJvM09DQXEyLzNVVVFiUjcrT09md3kzSHdUdTBRdW5FSnBFbWU2RXdzdWIwZzhTTGp2cEpjSHZTbQpPQlNKSXJyL1RjcFRITjVPc1h1Vm5FTlVqV3BBUmRQT1NrRFZHbWtCbnkyaVZURElST3NGbmV1RUZ1NitXOWpqCmhlb1hNN2czbkE0NmlLenUzR0YwRWhLOFkzWjRmeE42NERkbWNBWnphaU1vMFJVaktWTFVqbVlQSEUxWWZVK3AKMkNYb3dNRUNnWUVBMTgyaU52UEkwVVlWaUh5blhKclNzd1YrcTlTRStvVi90U2ZSUUNGU2xsV0d3KzYyblRiVwpvNXpoL1RDQW9VTVNSbUFPZ0xKWU1LZUZ1SWdvTEoxN1pvWjN0U1czTlVtMmRpT0lPSHorcTQxQzM5MDRrUzM5CjkrYkFtVmtaSFA5VktLOEMraS9tek5mSkdHZEJadGIweWtTM2t3OUIxTHdnT3o3MDhFeXFSQ2tDZ1lFQTBXWlAKbzF2MThnV2tMK2FnUDFvOE13eDRPZlpTN3dKY3E0Z0xnUWhjYS9pSkttY0x0RFN4cUJHckJ4UVo0WTIyazlzdQpzTFVrNEJobGlVM29iUUJNaUdtMGtITHVBSEFRNmJvdWZBMUJwZjN2VFdHSkhSRjRMeFJsNzc2akw4UXI4VnpxClpURVBtY0R0T0hpYjdwb2I1Z2IzSDhiVGhYeUhmdGZxRW55alhFa0NnWUVBdk9DdDZZclZhTlQrWThjMmRFYk4Kd3dJOExBaUZtdjdkRjZFUjlCODJPWDRCeGR0WTJhRDFtNTNqN2NaVnpzNzFYOE1TN25FcDN1dkFqaElkbDI3KwpZbTJ1dUUyYVhIbDN5VTZ3RzBETFpUcnVIU0Z5TVI4ZithbHRTTXBDd0s1NXluSGpHVFp6dXpYaVBBbWpwRzdmCk1XbVRncE1IK3puc3UrNE9VNFBHUW9FQ2dZQWNqdUdKbS84YzlOd0JsR2lDZTJIK2JGTHhSTURteStHcm16QkcKZHNkMENqOWF3eGI3aXJ3MytjRGpoRUJMWExKcjA5YTRUdHdxbStrdElxenlRTG92V0l0QnNBcjVrRThlTVVBcAp0djBmRUZUVXJ0cXVWaldYNWlaSTNpMFBWS2ZSa1NSK2pJUmVLY3V3aWZKcVJpWkw1dU5KT0NxYzUvRHF3Yk93CnRjTHAwUUtCZ0VwdEw1SU10Sk5EQnBXbllmN0F5QVBhc0RWRE9aTEhNUGRpL2dvNitjSmdpUmtMYWt3eUpjV3IKU25QSG1TbFE0aEluNGMrNW1lbHBDWFdJaklLRCtjcTlxT2xmQmRtaWtYb2RVQ2pqWUJjNnVGQ1QrNWRkMWM4RwpiUkJQOUNtWk9GL0hOcHN0MEgxenhNd1crUHk5Q2VnR3hhZ0ZCekxzVW84N0xWR2h0VFFZCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg== Note: If your issuer represents an intermediate, ensure that tls.crt contains the issuer's full chain in the correct order: issuer -> intermediate(s) -> root . The root (self-signed) CA certificate is optional, but adding it will ensure that the correct CA certificate is stored in the secrets for issued Certificate s under the ca.crt key. If you fail to provide a complete chain, it might not be possible for consumers of issued Certificate s to verify whether they're trusted. Next is to deploy the CA issuer which references this Secret . This is done by referencing the secret name under the ca stanza in the Issuer spec. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ca-issuer namespace : sandbox spec : ca : secretName : ca-key-pair Optionally, you can specify CRL Distribution Points; an array of strings each of which identifies the location of the CRL from which the revocation of this certificate can be checked. ... spec : ca : secretName : ca-key-pair crlDistributionPoints : - \"http://example.com\" Once deployed, you can then check that the issuer has been successfully configured by checking the ready status of the certificate. Replace issuers here with clusterissuers if that is what has been deployed. $ kubectl get issuers ca-issuer -n sandbox -o wide NAME READY STATUS AGE ca-issuer True Signing CA verified 2m Certificates are now ready to be requested by using the CA Issuer named ca-issuer within the sandbox namespace.","title":"CA"},{"location":"configuration/ca/#deployment","text":"CA Issuers must be configured with a certificate and private key stored in a Kubernetes secret. You can create this externally if you wish, or you could bootstrap a root certificate using a SelfSigned issuer . Your certificate's secret should reside in the same namespace as the Issuer , or otherwise in the Cluster Resource Namespace in the case of a ClusterIssuer . The Cluster Resource Namespace is defaulted as being the cert-manager namespace, but can be configured using the --cluster-resource-namespace flag on the cert-manager controller. Below is an example of a secret resource that will be used for signing. Take note of the index keys used for each field as these are required in order for cert-manager to find the certificate and key. Also note that, like all secrets, data must be base64 encoded. The command $ cat crt.pem | base64 -w0 should help you on GNU-based systems (Debian, Ubuntu, etc.) and $ cat crt.pem | base64 -b0 on BSD-based systems (most notably macOS). apiVersion : v1 kind : Secret metadata : name : ca-key-pair namespace : sandbox data : tls.crt : LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMrVENDQWVHZ0F3SUJBZ0lKQUtQR3dLRGwvNUhuTUEwR0NTcUdTSWIzRFFFQkN3VUFNQk14RVRBUEJnTlYKQkFNTUNHcHZjMmgyWVc1c01CNFhEVEU1TURneU1qRTJNRFUxT0ZvWERUSTVNRGd4T1RFMk1EVTFPRm93RXpFUgpNQThHQTFVRUF3d0lhbTl6YUhaaGJtd3dnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUtBb0lCCkFRQ3doU0IvcVc2L2tMYjJ6cHUrRUp2RDl3SEZhcStRQS8wSkgvTGxseW83ekFGeCtISHErQ09BYmsrQzhCNHQKL0hVRXNuczVSTDA5Q1orWDRqNnBiSkZkS2R1UHhYdTVaVllua3hZcFVEVTd5ZzdPU0tTWnpUbklaNzIzc01zMApSNmpZbi9Ecmo0eFhNSkVmSFVEcVllU1dsWnIzcWkxRUZhMGM3ZlZEeEgrNHh0WnROTkZPakg3YzZEL3ZXa0lnCldRVXhpd3Vzc2U2S01PV2pEbnYvNFZyamVsMlFnVVlVYkhDeWVaSG1jdGkrSzBMV0Nmby9SZzZQdWx3cmJEa2gKam1PZ1l0MzBwZGhYME9aa0F1a2xmVURIZnA4YmpiQ29JMnRhWUFCQTZBS2pLc08zNUxBRVU3OUNMMW1MVkh1WgpBQ0k1VWppamEzVlBXVkhTd21KUEp5dXhBZ01CQUFHalVEQk9NQjBHQTFVZERnUVdCQlFtbDVkVEFaaXhGS2hqCjkzd3VjUldoYW8vdFFqQWZCZ05WSFNNRUdEQVdnQlFtbDVkVEFaaXhGS2hqOTN3dWNSV2hhby90UWpBTUJnTlYKSFJNRUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFCK2tsa1JOSlVLQkxYOHlZa3l1VTJSSGNCdgpHaG1tRGpKSXNPSkhac29ZWGRMbEcxcFpORmpqUGFPTDh2aDQ0Vmw5OFJoRVpCSHNMVDFLTWJwMXN1NkNxajByClVHMWtwUkJlZitJT01UNE1VN3ZSSUNpN1VPbFJMcDFXcDBGOGxhM2hQT2NSYjJ5T2ZGcVhYeVpXWGY0dDBCNDUKdEhpK1pDTkhCOUZ4alNSeWNiR1lWaytUS3B2aEphU1lOTUdKM2R4REthUDcrRHgzWGNLNnNBbklBa2h5SThhagpOVSttdzgvdG1Sa1A0SW4va1hBUitSaTBxVW1Iai92d3ZuazRLbTdaVXkxRllIOERNZVM1TmtzbisvdUhsUnhSClY3RG5uMDM5VFJtZ0tiQXFONzJnS05MbzVjWit5L1lxREFZSFlybjk4U1FUOUpEZ3RJL0svQVRwVzhkWAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg== tls.key : LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBc0lVZ2Y2bHV2NUMyOXM2YnZoQ2J3L2NCeFdxdmtBUDlDUi95NVpjcU84d0JjZmh4CjZ2Z2pnRzVQZ3ZBZUxmeDFCTEo3T1VTOVBRbWZsK0krcVd5UlhTbmJqOFY3dVdWV0o1TVdLVkExTzhvT3praWsKbWMwNXlHZTl0N0RMTkVlbzJKL3c2NCtNVnpDUkh4MUE2bUhrbHBXYTk2b3RSQld0SE8zMVE4Ui91TWJXYlRUUgpUb3grM09nLzcxcENJRmtGTVlzTHJMSHVpakRsb3c1Ny8rRmE0M3Bka0lGR0ZHeHdzbm1SNW5MWXZpdEMxZ242ClAwWU9qN3BjSzJ3NUlZNWpvR0xkOUtYWVY5RG1aQUxwSlgxQXgzNmZHNDJ3cUNOcldtQUFRT2dDb3lyRHQrU3cKQkZPL1FpOVppMVI3bVFBaU9WSTRvMnQxVDFsUjBzSmlUeWNyc1FJREFRQUJBb0lCQUNFTkhET3JGdGg1a1RpUApJT3dxa2UvVVhSbUl5MHlNNHFFRndXWXBzcmUxa0FPMkFDWjl4YS96ZDZITnNlanNYMEM4NW9PbmtrTk9mUHBrClcxVS94Y3dLM1ZpRElwSnBIZ09VNzg1V2ZWRXZtU3dZdi9Fb1V3eHFHRVMvcnB5Z1drWU5WSC9XeGZGQlg3clMKc0dmeVltbXJvM09DQXEyLzNVVVFiUjcrT09md3kzSHdUdTBRdW5FSnBFbWU2RXdzdWIwZzhTTGp2cEpjSHZTbQpPQlNKSXJyL1RjcFRITjVPc1h1Vm5FTlVqV3BBUmRQT1NrRFZHbWtCbnkyaVZURElST3NGbmV1RUZ1NitXOWpqCmhlb1hNN2czbkE0NmlLenUzR0YwRWhLOFkzWjRmeE42NERkbWNBWnphaU1vMFJVaktWTFVqbVlQSEUxWWZVK3AKMkNYb3dNRUNnWUVBMTgyaU52UEkwVVlWaUh5blhKclNzd1YrcTlTRStvVi90U2ZSUUNGU2xsV0d3KzYyblRiVwpvNXpoL1RDQW9VTVNSbUFPZ0xKWU1LZUZ1SWdvTEoxN1pvWjN0U1czTlVtMmRpT0lPSHorcTQxQzM5MDRrUzM5CjkrYkFtVmtaSFA5VktLOEMraS9tek5mSkdHZEJadGIweWtTM2t3OUIxTHdnT3o3MDhFeXFSQ2tDZ1lFQTBXWlAKbzF2MThnV2tMK2FnUDFvOE13eDRPZlpTN3dKY3E0Z0xnUWhjYS9pSkttY0x0RFN4cUJHckJ4UVo0WTIyazlzdQpzTFVrNEJobGlVM29iUUJNaUdtMGtITHVBSEFRNmJvdWZBMUJwZjN2VFdHSkhSRjRMeFJsNzc2akw4UXI4VnpxClpURVBtY0R0T0hpYjdwb2I1Z2IzSDhiVGhYeUhmdGZxRW55alhFa0NnWUVBdk9DdDZZclZhTlQrWThjMmRFYk4Kd3dJOExBaUZtdjdkRjZFUjlCODJPWDRCeGR0WTJhRDFtNTNqN2NaVnpzNzFYOE1TN25FcDN1dkFqaElkbDI3KwpZbTJ1dUUyYVhIbDN5VTZ3RzBETFpUcnVIU0Z5TVI4ZithbHRTTXBDd0s1NXluSGpHVFp6dXpYaVBBbWpwRzdmCk1XbVRncE1IK3puc3UrNE9VNFBHUW9FQ2dZQWNqdUdKbS84YzlOd0JsR2lDZTJIK2JGTHhSTURteStHcm16QkcKZHNkMENqOWF3eGI3aXJ3MytjRGpoRUJMWExKcjA5YTRUdHdxbStrdElxenlRTG92V0l0QnNBcjVrRThlTVVBcAp0djBmRUZUVXJ0cXVWaldYNWlaSTNpMFBWS2ZSa1NSK2pJUmVLY3V3aWZKcVJpWkw1dU5KT0NxYzUvRHF3Yk93CnRjTHAwUUtCZ0VwdEw1SU10Sk5EQnBXbllmN0F5QVBhc0RWRE9aTEhNUGRpL2dvNitjSmdpUmtMYWt3eUpjV3IKU25QSG1TbFE0aEluNGMrNW1lbHBDWFdJaklLRCtjcTlxT2xmQmRtaWtYb2RVQ2pqWUJjNnVGQ1QrNWRkMWM4RwpiUkJQOUNtWk9GL0hOcHN0MEgxenhNd1crUHk5Q2VnR3hhZ0ZCekxzVW84N0xWR2h0VFFZCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg== Note: If your issuer represents an intermediate, ensure that tls.crt contains the issuer's full chain in the correct order: issuer -> intermediate(s) -> root . The root (self-signed) CA certificate is optional, but adding it will ensure that the correct CA certificate is stored in the secrets for issued Certificate s under the ca.crt key. If you fail to provide a complete chain, it might not be possible for consumers of issued Certificate s to verify whether they're trusted. Next is to deploy the CA issuer which references this Secret . This is done by referencing the secret name under the ca stanza in the Issuer spec. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ca-issuer namespace : sandbox spec : ca : secretName : ca-key-pair Optionally, you can specify CRL Distribution Points; an array of strings each of which identifies the location of the CRL from which the revocation of this certificate can be checked. ... spec : ca : secretName : ca-key-pair crlDistributionPoints : - \"http://example.com\" Once deployed, you can then check that the issuer has been successfully configured by checking the ready status of the certificate. Replace issuers here with clusterissuers if that is what has been deployed. $ kubectl get issuers ca-issuer -n sandbox -o wide NAME READY STATUS AGE ca-issuer True Signing CA verified 2m Certificates are now ready to be requested by using the CA Issuer named ca-issuer within the sandbox namespace.","title":"Deployment"},{"location":"configuration/external/","text":"cert-manager supports external Issuer types. While external issuers are not implemented in the main cert-manager repository, they are otherwise treated the same as any other issuer. External issuers are typically deployed as a pod which is configured to watch for CertificateRequest resources in the cluster whose issuerRef matches the name of the issuer. External issuers exist outside of the cert-manager.io group. Installation for each issuer may differ; check the documentation for each external issuer for more details on installing, configuring and using it. Known External Issuers \u00b6 If you've created an external issuer which you'd like to share, raise a Pull Request to have it added here! These external issuers are known to support and honor approval . kms-issuer : Requests certificates signed using an AWS KMS asymmetric key. aws-privateca-issuer : Requests certificates from AWS Private Certificate Authority for cloud native/hybrid environments. google-cas-issuer : Used to request certificates signed by private CAs managed by the Google Cloud Certificate Authority Service . origin-ca-issuer : Used to request certificates signed by Cloudflare Origin CA to enable TLS between Cloudflare edge and your Kubernetes workloads. step-issuer : Requests certificates from the Smallstep Certificate Authority server . freeipa-issuer : Requests certificates signed by FreeIPA . ADCS Issuer : Requests certificates signed by Microsoft Active Directory Certificate Service . [NOT MAINTAINED] CFSSL Issuer : Request certificates signed by a CFSSL multirootca instance. ncm-issuer : Requests certificates from the Nokia Netguard Certificate Manager tcs-issuer Requests certificates signed securely using Intel's SGX technology . Building New External Issuers \u00b6 If you're interested in building a new external issuer, check the development documentation .","title":"External"},{"location":"configuration/external/#known-external-issuers","text":"If you've created an external issuer which you'd like to share, raise a Pull Request to have it added here! These external issuers are known to support and honor approval . kms-issuer : Requests certificates signed using an AWS KMS asymmetric key. aws-privateca-issuer : Requests certificates from AWS Private Certificate Authority for cloud native/hybrid environments. google-cas-issuer : Used to request certificates signed by private CAs managed by the Google Cloud Certificate Authority Service . origin-ca-issuer : Used to request certificates signed by Cloudflare Origin CA to enable TLS between Cloudflare edge and your Kubernetes workloads. step-issuer : Requests certificates from the Smallstep Certificate Authority server . freeipa-issuer : Requests certificates signed by FreeIPA . ADCS Issuer : Requests certificates signed by Microsoft Active Directory Certificate Service . [NOT MAINTAINED] CFSSL Issuer : Request certificates signed by a CFSSL multirootca instance. ncm-issuer : Requests certificates from the Nokia Netguard Certificate Manager tcs-issuer Requests certificates signed securely using Intel's SGX technology .","title":"Known External Issuers"},{"location":"configuration/external/#building-new-external-issuers","text":"If you're interested in building a new external issuer, check the development documentation .","title":"Building New External Issuers"},{"location":"configuration/selfsigned/","text":"\u26a0\ufe0f SelfSigned issuers are generally useful for bootstrapping a PKI locally, which is a complex topic for advanced users. To be used safely in production, running a PKI introduces complex planning requirements around rotation, trust store distribution and disaster recovery. If you're not planning to run your own PKI, use a different issuer type. The SelfSigned issuer doesn't represent a certificate authority as such, but instead denotes that certificates will \"sign themselves\" using a given private key. In other words, the private key of the certificate will be used to sign the certificate itself. This Issuer type is useful for bootstrapping a root certificate for a custom PKI (Public Key Infrastructure), or for otherwise creating simple ad-hoc certificates for a quick test. There are important caveats - including security issues - to consider with SelfSigned issuers; in general you'd likely want to use a CA issuer rather than a SelfSigned issuer. That said, SelfSigned issuers are really useful for initially bootstrapping a CA issuer. Note: a CertificateRequest that references a self-signed certificate must also contain the cert-manager.io/private-key-secret-name annotation since the private key corresponding to the CertificateRequest is required to sign the certificate. This annotation is added automatically by the Certificate controller. Deployment \u00b6 Since the SelfSigned issuer has no dependency on any other resource, it is the simplest to configure. Only the SelfSigned stanza is required to be present in the issuer spec, with no other configuration required: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : selfsigned-issuer namespace : sandbox spec : selfSigned : {} apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : selfsigned-cluster-issuer spec : selfSigned : {} Once deployed, you should be able to see immediately that the issuer is ready for signing: $ kubectl get issuers -n sandbox -o wide selfsigned-issuer NAME READY STATUS AGE selfsigned-issuer True 2m $ kubectl get clusterissuers -o wide selfsigned-cluster-issuer NAME READY STATUS AGE selfsigned-cluster-issuer True 3m Bootstrapping CA Issuers \u00b6 One of the ideal use cases for SelfSigned issuers is to bootstrap a custom root certificate for a private PKI, including with the cert-manager CA issuer. The YAML below will create a SelfSigned issuer, issue a root certificate and use that root as a CA issuer: apiVersion : v1 kind : Namespace metadata : name : sandbox --- apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : selfsigned-issuer spec : selfSigned : {} --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : my-selfsigned-ca namespace : sandbox spec : isCA : true commonName : my-selfsigned-ca secretName : root-secret privateKey : algorithm : ECDSA size : 256 issuerRef : name : selfsigned-issuer kind : ClusterIssuer group : cert-manager.io --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : my-ca-issuer namespace : sandbox spec : ca : secretName : root-secret CRL Distribution Points \u00b6 You may also optionally specify CRL Distribution Points as an array of strings, each of which identifies the location of a CRL in which the revocation status of issued certificates can be checked: ... spec : selfSigned : crlDistributionPoints : - \"http://example.com\" Caveats \u00b6 Trust \u00b6 Clients consuming SelfSigned certificates have no way to trust them without already having the certificates beforehand. This becomes hard to manage when the client of the server using the certificate exists in a different namespace. This limitation can be tackled by using trust-manager to distribute the ca.crt to other namespaces. The alternative is to use \"TOFU\" (trust on first use), which has security implications in the event of a man-in-the-middle attack. Certificate Validity \u00b6 One side-effect of a certificate being self-signed is that its Subject DN and its Issuer DN are identical. The X.509 RFC 5280, section 4.1.2.4 requires that: The issuer field MUST contain a non-empty distinguished name (DN). However, self-signed certs don't have a subject DN set by default. Unless you manually set a certificate's Subject DN, the Issuer DN will be empty and the certificate will technically be invalid. Validation of this specific area of the spec is patchy and varies between TLS libraries, but there's always the risk that a library will improve its validation - entirely within spec - in the future and break your app if you're using a certificate with an empty Issuer DN. To avoid this, be sure to set a Subject for SelfSigned certs. This can be done by setting the spec.subject on a cert-manager Certificate object which will be issued by a SelfSigned issuer. Starting in version 1.3, cert-manager will emit a Kubernetes warning event of type BadConfig if it detects that a certificate is being created by a SelfSigned issuer which has an empty Issuer DN.","title":"SelfSigned"},{"location":"configuration/selfsigned/#deployment","text":"Since the SelfSigned issuer has no dependency on any other resource, it is the simplest to configure. Only the SelfSigned stanza is required to be present in the issuer spec, with no other configuration required: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : selfsigned-issuer namespace : sandbox spec : selfSigned : {} apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : selfsigned-cluster-issuer spec : selfSigned : {} Once deployed, you should be able to see immediately that the issuer is ready for signing: $ kubectl get issuers -n sandbox -o wide selfsigned-issuer NAME READY STATUS AGE selfsigned-issuer True 2m $ kubectl get clusterissuers -o wide selfsigned-cluster-issuer NAME READY STATUS AGE selfsigned-cluster-issuer True 3m","title":"Deployment"},{"location":"configuration/selfsigned/#bootstrapping-ca-issuers","text":"One of the ideal use cases for SelfSigned issuers is to bootstrap a custom root certificate for a private PKI, including with the cert-manager CA issuer. The YAML below will create a SelfSigned issuer, issue a root certificate and use that root as a CA issuer: apiVersion : v1 kind : Namespace metadata : name : sandbox --- apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : selfsigned-issuer spec : selfSigned : {} --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : my-selfsigned-ca namespace : sandbox spec : isCA : true commonName : my-selfsigned-ca secretName : root-secret privateKey : algorithm : ECDSA size : 256 issuerRef : name : selfsigned-issuer kind : ClusterIssuer group : cert-manager.io --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : my-ca-issuer namespace : sandbox spec : ca : secretName : root-secret","title":"Bootstrapping CA Issuers"},{"location":"configuration/selfsigned/#crl-distribution-points","text":"You may also optionally specify CRL Distribution Points as an array of strings, each of which identifies the location of a CRL in which the revocation status of issued certificates can be checked: ... spec : selfSigned : crlDistributionPoints : - \"http://example.com\"","title":"CRL Distribution Points"},{"location":"configuration/selfsigned/#caveats","text":"","title":"Caveats"},{"location":"configuration/selfsigned/#trust","text":"Clients consuming SelfSigned certificates have no way to trust them without already having the certificates beforehand. This becomes hard to manage when the client of the server using the certificate exists in a different namespace. This limitation can be tackled by using trust-manager to distribute the ca.crt to other namespaces. The alternative is to use \"TOFU\" (trust on first use), which has security implications in the event of a man-in-the-middle attack.","title":"Trust"},{"location":"configuration/selfsigned/#certificate-validity","text":"One side-effect of a certificate being self-signed is that its Subject DN and its Issuer DN are identical. The X.509 RFC 5280, section 4.1.2.4 requires that: The issuer field MUST contain a non-empty distinguished name (DN). However, self-signed certs don't have a subject DN set by default. Unless you manually set a certificate's Subject DN, the Issuer DN will be empty and the certificate will technically be invalid. Validation of this specific area of the spec is patchy and varies between TLS libraries, but there's always the risk that a library will improve its validation - entirely within spec - in the future and break your app if you're using a certificate with an empty Issuer DN. To avoid this, be sure to set a Subject for SelfSigned certs. This can be done by setting the spec.subject on a cert-manager Certificate object which will be issued by a SelfSigned issuer. Starting in version 1.3, cert-manager will emit a Kubernetes warning event of type BadConfig if it detects that a certificate is being created by a SelfSigned issuer which has an empty Issuer DN.","title":"Certificate Validity"},{"location":"configuration/vault/","text":"The Vault Issuer represents the certificate authority Vault - a multi-purpose secret store that can be used to sign certificates for your Public Key Infrastructure (PKI). Vault is an external project to cert-manager and as such, this guide will assume it has been configured and deployed correctly, ready for signing. You can read more on how to configure Vault as a certificate authority here . This Issuer type is typically used when Vault is already being used within your infrastructure, or you would like to make use of its feature set where the CA issuer alone cannot provide. Deployment \u00b6 All Vault issuers share common configuration for requesting certificates, namely the server, path, and CA bundle: Server is the URL whereby Vault is reachable. Path is the Vault path that will be used for signing. Note that the path must use the sign endpoint. CA bundle denotes an optional field containing a base64 encoded string of the Certificate Authority to trust the Vault connection. This is typically always required when using an https URL. Below is an example of a configuration to connect a Vault server. Warning : This configuration is incomplete as no authentication methods have been added. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded CA Bundle PEM file> auth : ... Authenticating \u00b6 In order to request signing of certificates by Vault, the issuer must be able to properly authenticate against it. cert-manager provides multiple approaches to authenticating to Vault which are detailed below. Authenticating via an AppRole \u00b6 An AppRole is a method of authenticating to Vault through use of its internal role policy system. This authentication method requires that the issuer has possession of the SecretID secret key, the RoleID of the role to assume, and the app role path. Firstly, the secret ID key must be stored within a Kubernetes Secret that resides in the same namespace as the Issuer , or otherwise inside the Cluster Resource Namespace in the case of a ClusterIssuer . apiVersion : v1 kind : Secret type : Opaque metadata : name : cert-manager-vault-approle namespace : sandbox data : secretId : \"MDI...\" Once the Secret has been created, the Issuer is ready to be deployed which references this Secret , as well as the data key of the field that stores the secret ID. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded caBundle PEM file> auth : appRole : path : approle roleId : \"291b9d21-8ff5-...\" secretRef : name : cert-manager-vault-approle key : secretId Authenticating with a Token \u00b6 This method of authentication uses a token string that has been generated from one of the many authentication backends that Vault supports. These tokens have an expiry and so need to be periodically refreshed. You can read more on Vault tokens here . Note : cert-manager does not refresh these token automatically and so another process must be put in place to do this. Firstly, the token is be stored inside a Kubernetes Secret inside the same namespace as the Issuer or otherwise in the Cluster Resource Namespace in the case of using a ClusterIssuer . apiVersion : v1 kind : Secret type : Opaque metadata : name : cert-manager-vault-token namespace : sandbox data : token : \"MjI...\" Once submitted, the Vault issuer is able to be created using token authentication by referencing this Secret along with the key of the field the token data is stored at. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded caBundle PEM file> auth : tokenSecretRef : name : cert-manager-vault-token key : token Authenticating with Kubernetes Service Accounts \u00b6 Vault can be configured so that applications can authenticate using Kubernetes Service Account Tokens . You find documentation on how to configure Vault to authenticate using Service Account Tokens here . For the Vault issuer to use this authentication, cert-manager must get access to the token that is stored in a Kubernetes Secret . Kubernetes Service Account Tokens are already stored in Secret resources however, you must ensure that it is present in the same namespace as the Issuer , or otherwise in the Cluster Resource Namespace in the case of using a ClusterIssuer . Note : In Kubernetes 1.24 onwards, the token secret is no longer created by default for the Service Account. In this case you need to manually create the secret resource. See this guide for more details. This authentication method also expects a role field which is the Vault role that the Service Account is to assume, as well as an optional mountPath field which is the authentication mount path, defaulting to kubernetes . Kubernetes version less than 1.24 \u00b6 The following example will be making use of the Service Account my-service-account . The secret data field key will be token if the Secret has been created by Kubernetes. The Vault role used is my-app-1 , using the default mount path of /v1/auth/kubernetes 1) Create the Service Account: ```shell kubectl create serviceaccount -n sandbox vault-issuer ``` 1) Get the auto-generated Secret name: ```shell kubectl get secret -o json | jq -r '.items[] | select(.metadata.annotations[\"kubernetes.io/service-account.name\"] == \"vault-issuer\") | .metadata.name' ``` 1) Create the Issuer using that Secret name retrieved from the previous step: ```yaml apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: vault-issuer namespace: sandbox spec: vault: path: pki_int/sign/example-dot-com server: https://vault.local caBundle: <base64 encoded caBundle PEM file> auth: kubernetes: role: my-app-1 mountPath: /v1/auth/kubernetes secretRef: name: <auto-generated secret name> key: token ``` Kubernetes version 1.24 and greater \u00b6 This example is almost the same as above but adjusted for the change in Kubernetes 1.24 and above. 1) Create the Service Account: ```shell kubectl create serviceaccount -n sandbox vault-issuer ``` 1) Create the Secret resource for Kubernetes to populate the token value: ```yaml apiVersion: v1 kind: Secret metadata: name: vault-issuer-token annotations: kubernetes.io/service-account.name: \"vault-issuer\" type: kubernetes.io/service-account-token data: {} ``` 1) Create the Issuer resource referencing the Secret resource: ```yaml apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: vault-issuer namespace: sandbox spec: vault: path: pki_int/sign/example-dot-com server: https://vault.local caBundle: <base64 encoded caBundle PEM file> auth: kubernetes: role: my-app-1 mountPath: /v1/auth/kubernetes secretRef: name: vault-issuer-token key: token ``` Verifying the issuer Deployment \u00b6 Once the Vault issuer has been deployed, it will be marked as ready if the configuration is valid. Replace issuers here with clusterissuers if that is what has been deployed. $ kubectl get issuers vault-issuer -n sandbox -o wide NAME READY STATUS AGE vault-issuer True Vault verified 2m Certificates are now ready to be requested by using the Vault issuer named vault-issuer within the sandbox namespace.","title":"Vault"},{"location":"configuration/vault/#deployment","text":"All Vault issuers share common configuration for requesting certificates, namely the server, path, and CA bundle: Server is the URL whereby Vault is reachable. Path is the Vault path that will be used for signing. Note that the path must use the sign endpoint. CA bundle denotes an optional field containing a base64 encoded string of the Certificate Authority to trust the Vault connection. This is typically always required when using an https URL. Below is an example of a configuration to connect a Vault server. Warning : This configuration is incomplete as no authentication methods have been added. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded CA Bundle PEM file> auth : ...","title":"Deployment"},{"location":"configuration/vault/#authenticating","text":"In order to request signing of certificates by Vault, the issuer must be able to properly authenticate against it. cert-manager provides multiple approaches to authenticating to Vault which are detailed below.","title":"Authenticating"},{"location":"configuration/vault/#authenticating-via-an-approle","text":"An AppRole is a method of authenticating to Vault through use of its internal role policy system. This authentication method requires that the issuer has possession of the SecretID secret key, the RoleID of the role to assume, and the app role path. Firstly, the secret ID key must be stored within a Kubernetes Secret that resides in the same namespace as the Issuer , or otherwise inside the Cluster Resource Namespace in the case of a ClusterIssuer . apiVersion : v1 kind : Secret type : Opaque metadata : name : cert-manager-vault-approle namespace : sandbox data : secretId : \"MDI...\" Once the Secret has been created, the Issuer is ready to be deployed which references this Secret , as well as the data key of the field that stores the secret ID. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded caBundle PEM file> auth : appRole : path : approle roleId : \"291b9d21-8ff5-...\" secretRef : name : cert-manager-vault-approle key : secretId","title":"Authenticating via an AppRole"},{"location":"configuration/vault/#authenticating-with-a-token","text":"This method of authentication uses a token string that has been generated from one of the many authentication backends that Vault supports. These tokens have an expiry and so need to be periodically refreshed. You can read more on Vault tokens here . Note : cert-manager does not refresh these token automatically and so another process must be put in place to do this. Firstly, the token is be stored inside a Kubernetes Secret inside the same namespace as the Issuer or otherwise in the Cluster Resource Namespace in the case of using a ClusterIssuer . apiVersion : v1 kind : Secret type : Opaque metadata : name : cert-manager-vault-token namespace : sandbox data : token : \"MjI...\" Once submitted, the Vault issuer is able to be created using token authentication by referencing this Secret along with the key of the field the token data is stored at. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vault-issuer namespace : sandbox spec : vault : path : pki_int/sign/example-dot-com server : https://vault.local caBundle : <base64 encoded caBundle PEM file> auth : tokenSecretRef : name : cert-manager-vault-token key : token","title":"Authenticating with a Token"},{"location":"configuration/vault/#authenticating-with-kubernetes-service-accounts","text":"Vault can be configured so that applications can authenticate using Kubernetes Service Account Tokens . You find documentation on how to configure Vault to authenticate using Service Account Tokens here . For the Vault issuer to use this authentication, cert-manager must get access to the token that is stored in a Kubernetes Secret . Kubernetes Service Account Tokens are already stored in Secret resources however, you must ensure that it is present in the same namespace as the Issuer , or otherwise in the Cluster Resource Namespace in the case of using a ClusterIssuer . Note : In Kubernetes 1.24 onwards, the token secret is no longer created by default for the Service Account. In this case you need to manually create the secret resource. See this guide for more details. This authentication method also expects a role field which is the Vault role that the Service Account is to assume, as well as an optional mountPath field which is the authentication mount path, defaulting to kubernetes .","title":"Authenticating with Kubernetes Service Accounts"},{"location":"configuration/vault/#kubernetes-version-less-than-124","text":"The following example will be making use of the Service Account my-service-account . The secret data field key will be token if the Secret has been created by Kubernetes. The Vault role used is my-app-1 , using the default mount path of /v1/auth/kubernetes 1) Create the Service Account: ```shell kubectl create serviceaccount -n sandbox vault-issuer ``` 1) Get the auto-generated Secret name: ```shell kubectl get secret -o json | jq -r '.items[] | select(.metadata.annotations[\"kubernetes.io/service-account.name\"] == \"vault-issuer\") | .metadata.name' ``` 1) Create the Issuer using that Secret name retrieved from the previous step: ```yaml apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: vault-issuer namespace: sandbox spec: vault: path: pki_int/sign/example-dot-com server: https://vault.local caBundle: <base64 encoded caBundle PEM file> auth: kubernetes: role: my-app-1 mountPath: /v1/auth/kubernetes secretRef: name: <auto-generated secret name> key: token ```","title":"Kubernetes version less than 1.24"},{"location":"configuration/vault/#kubernetes-version-124-and-greater","text":"This example is almost the same as above but adjusted for the change in Kubernetes 1.24 and above. 1) Create the Service Account: ```shell kubectl create serviceaccount -n sandbox vault-issuer ``` 1) Create the Secret resource for Kubernetes to populate the token value: ```yaml apiVersion: v1 kind: Secret metadata: name: vault-issuer-token annotations: kubernetes.io/service-account.name: \"vault-issuer\" type: kubernetes.io/service-account-token data: {} ``` 1) Create the Issuer resource referencing the Secret resource: ```yaml apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: vault-issuer namespace: sandbox spec: vault: path: pki_int/sign/example-dot-com server: https://vault.local caBundle: <base64 encoded caBundle PEM file> auth: kubernetes: role: my-app-1 mountPath: /v1/auth/kubernetes secretRef: name: vault-issuer-token key: token ```","title":"Kubernetes version 1.24 and greater"},{"location":"configuration/vault/#verifying-the-issuer-deployment","text":"Once the Vault issuer has been deployed, it will be marked as ready if the configuration is valid. Replace issuers here with clusterissuers if that is what has been deployed. $ kubectl get issuers vault-issuer -n sandbox -o wide NAME READY STATUS AGE vault-issuer True Vault verified 2m Certificates are now ready to be requested by using the Vault issuer named vault-issuer within the sandbox namespace.","title":"Verifying the issuer Deployment"},{"location":"configuration/venafi/","text":"Introduction \u00b6 The Venafi Issuer types allows you to obtain certificates from Venafi as a Service (VaaS) and Venafi Trust Protection Platform (TPP) instances. You can have multiple different Venafi Issuer types installed within the same cluster, including mixtures of Venafi as a Service and TPP issuer types. This allows you to be flexible with the types of Venafi account you use. Automated certificate renewal and management are provided for Certificates using the Venafi Issuer . A single Venafi Issuer represents a single Venafi 'zone' so you must create one Issuer resource for each zone you want to use. A zone is a single entity that combines the policy that governs certificate issuance with information about how certificates are organized in Venafi to identify the business application and establish ownership. You can configure your Issuer resource to either issue certificates only within a single namespace, or cluster-wide (using a ClusterIssuer resource). For more information on the distinction between Issuer and ClusterIssuer resources, read the Namespaces section. Creating a Venafi as a Service Issuer \u00b6 If you haven't already done so, create your Venafi as a Service account on this page and copy the API key from your user preferences. Then you may want to create a custom CA Account and Issuing Template or choose instead to use defaults that are automatically created for testing (\"Built-in CA\" and \"Default\", respectively). Lastly you'll need to create an Application for establishing ownership of all the certificates requested by your cert-manager Issuer, and assign to it the Issuing Template. Make a note of the Application name and API alias of the Issuing Template because together they comprise the 'zone' you will need for your Issuer configuration. In order to set up a Venafi as a Service Issuer , you must first create a Kubernetes Secret resource containing your Venafi as a Service API credentials: $ kubectl create secret generic \\ vaas-secret \\ --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' \\ --from-literal = apikey = 'YOUR_VAAS_API_KEY_HERE' Note : If you are configuring your issuer as a ClusterIssuer resource in order to serve Certificates across your whole cluster, you must set the --namespace parameter to cert-manager , which is the default Cluster Resource Namespace . The Cluster Resource Namespace can be configured through the --cluster-resource-namespace flag on the cert-manager controller component. This API key will be used by cert-manager to interact with Venafi as a Service on your behalf. Once the API key Secret has been created, you can create your Issuer or ClusterIssuer resource. If you are creating a ClusterIssuer resource, you must change the kind field to ClusterIssuer and remove the metadata.namespace field. Save the below content after making your amendments to a file named vaas-issuer.yaml . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vaas-issuer namespace : <NAMESPACE YOU WANT TO ISSUE CERTIFICATES IN> spec : venafi : zone : \"My Application \\ My CIT\" # Set this to <Application Name>\\<Issuing Template Alias> cloud : apiTokenSecretRef : name : vaas-secret key : apikey You can then create the Issuer using kubectl create . $ kubectl create -f vaas-issuer.yaml Verify the Issuer has been initialized correctly using kubectl describe . $ kubectl get issuer vaas-issuer --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' -o wide NAME READY STATUS AGE vaas-issuer True Venafi issuer started 2m You are now ready to issue certificates using the newly provisioned Venafi Issuer and Venafi as a Service. Read the Issuing Certificates document for more information on how to create Certificate resources. Creating a Venafi Trust Protection Platform Issuer \u00b6 The Venafi Trust Protection Platform integration allows you to obtain certificates from a properly configured Venafi TPP instance. The setup is similar to the Venafi as a Service configuration above, however some of the connection parameters are slightly different. Note : You must allow \"User Provided CSRs\" as part of your TPP policy, as this is the only type supported by cert-manager at this time. More specifically, the valid configurations of the \"CSR handling\" are: \"User Provided CSRs\" selected and unlocked, \"User Provided CSRs\" selected and locked, \"Service Generated CSRs\" selected and unlocked. When using \"Service Generated CSRs\" selected and unlocked, the default CSR configuration present in your policy folder will override the configuration of your Certificate resource. The subject DN, key algorithm, and key size will be overridden by the values set in the policy folder. With \"Service Generated CSRs\" selected and locked, the certificate issuance will systematically fail with the following message: 400 PKCS#10 data will not be processed. Policy \"\\VED\\Policy\\foo\" is locked to a Server Generated CSR. In order to set up a Venafi Trust Protection Platform Issuer , you must first create a Kubernetes Secret resource containing your Venafi TPP API credentials. Access Token Authentication \u00b6 Set up token authentication . NOTE: Do not select \"Refresh Token Enabled\" and set a long \"Token Validity (days)\". Create a new user with sufficient privileges to manage and revoke certificates in a particular policy folder (zone). E.g. k8s-xyz-automation Create a new application integration Create an application integration with name and ID cert-manager . Set the \"API Access Settings\" to Certificates: Read,Manage,Revoke . \"Edit Access\" to the new application integration, and allow it to be used by the user you created earlier. Generate an access token vcert getcred \\ --username k8s-xyz-automation \\ --password somepassword \\ -u https://tpp.example.com/vedsdk \\ --client-id cert-manager \\ --scope \"certificate:manage,revoke\" This will print an access-token to stdout . E.g. vCert: 2020/10/07 16:34:27 Getting credentials access_token: I69n.............y1VjNJT3o9U0Wko19g== access_token_expires: 2021-01-05T15:34:30Z Save the access-token to a Secret in the Kubernetes cluster $ kubectl create secret generic \\ tpp-secret \\ --namespace = <NAMESPACE OF YOUR ISSUER RESOURCE> \\ --from-literal = access-token = 'YOUR_TPP_ACCESS_TOKEN' Username / Password Authentication \u00b6 \u26a0\ufe0f When you supply a Venafi TPP username and password, cert-manager uses an older authentication method which is called \"API Keys\", which has been deprecated since Venafi TPP 19.2 . Beginning in Venafi TPP 22.2 , \"API Keys\" are disabled by default. You will need to contact Venafi customer support for a special license key which will allow you to re-enable the \"API Keys\" feature, so that you can continue to use username and password authentication with cert-manager. In Venafi TPP 22.3 , the \"API Keys\" feature will be permanently removed, and you will need to use access-token authentication instead. \ud83d\udcd6 Read Deprecated functionality from Venafi Platform and Functionality Scheduled for Deprecation for more information. $ kubectl create secret generic \\ tpp-secret \\ --namespace = <NAMESPACE OF YOUR ISSUER RESOURCE> \\ --from-literal = username = 'YOUR_TPP_USERNAME_HERE' \\ --from-literal = password = 'YOUR_TPP_PASSWORD_HERE' Note: If you are configuring your issuer as a ClusterIssuer resource in order to issue Certificates across your whole cluster, you must set the --namespace parameter to cert-manager , which is the default Cluster Resource Namespace . The Cluster Resource Namespace can be configured through the --cluster-resource-namespace flag on the cert-manager controller component. These credentials will be used by cert-manager to interact with your Venafi TPP instance. Username attribute must be adhere to the <identity provider>:<username> format. For example: local:admin . Once the Secret containing credentials has been created, you can create your Issuer or ClusterIssuer resource. If you are creating a ClusterIssuer resource, you must change the kind field to ClusterIssuer and remove the metadata.namespace field. Save the below content after making your amendments to a file named tpp-issuer.yaml . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : tpp-issuer namespace : <NAMESPACE YOU WANT TO ISSUE CERTIFICATES IN> spec : venafi : zone : \\VED\\Policy\\devops\\cert-manager # Set this to the Venafi policy folder you want to use tpp : url : https://tpp.venafi.example/vedsdk # Change this to the URL of your TPP instance caBundle : <base64 encoded string of caBundle PEM file, or empty to use system root CAs> credentialsRef : name : tpp-secret You can then create the Issuer using kubectl create -f . $ kubectl create -f tpp-issuer.yaml Verify the Issuer has been initialized correctly using kubectl describe . $ kubectl describe issuer tpp-issuer --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' You are now ready to issue certificates using the newly provisioned Venafi Issuer and Trust Protection Platform. Read the Issuing Certificates document for more information on how to create Certificate resources. Issuer specific annotations \u00b6 Custom Fields \u00b6 Starting v0.14 you can pass custom fields to Venafi (TPP version v19.2 and higher) using the venafi.cert-manager.io/custom-fields annotation on Certificate resources. The value is a JSON encoded array of custom field objects having a name and value key. For example: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-certificate annotations : venafi.cert-manager.io/custom-fields : |- [ {\"name\": \"field-name\", \"value\": \"vield value\"}, {\"name\": \"field-name-2\", \"value\": \"vield value 2\"} ] ...","title":"Venafi"},{"location":"configuration/venafi/#introduction","text":"The Venafi Issuer types allows you to obtain certificates from Venafi as a Service (VaaS) and Venafi Trust Protection Platform (TPP) instances. You can have multiple different Venafi Issuer types installed within the same cluster, including mixtures of Venafi as a Service and TPP issuer types. This allows you to be flexible with the types of Venafi account you use. Automated certificate renewal and management are provided for Certificates using the Venafi Issuer . A single Venafi Issuer represents a single Venafi 'zone' so you must create one Issuer resource for each zone you want to use. A zone is a single entity that combines the policy that governs certificate issuance with information about how certificates are organized in Venafi to identify the business application and establish ownership. You can configure your Issuer resource to either issue certificates only within a single namespace, or cluster-wide (using a ClusterIssuer resource). For more information on the distinction between Issuer and ClusterIssuer resources, read the Namespaces section.","title":"Introduction"},{"location":"configuration/venafi/#creating-a-venafi-as-a-service-issuer","text":"If you haven't already done so, create your Venafi as a Service account on this page and copy the API key from your user preferences. Then you may want to create a custom CA Account and Issuing Template or choose instead to use defaults that are automatically created for testing (\"Built-in CA\" and \"Default\", respectively). Lastly you'll need to create an Application for establishing ownership of all the certificates requested by your cert-manager Issuer, and assign to it the Issuing Template. Make a note of the Application name and API alias of the Issuing Template because together they comprise the 'zone' you will need for your Issuer configuration. In order to set up a Venafi as a Service Issuer , you must first create a Kubernetes Secret resource containing your Venafi as a Service API credentials: $ kubectl create secret generic \\ vaas-secret \\ --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' \\ --from-literal = apikey = 'YOUR_VAAS_API_KEY_HERE' Note : If you are configuring your issuer as a ClusterIssuer resource in order to serve Certificates across your whole cluster, you must set the --namespace parameter to cert-manager , which is the default Cluster Resource Namespace . The Cluster Resource Namespace can be configured through the --cluster-resource-namespace flag on the cert-manager controller component. This API key will be used by cert-manager to interact with Venafi as a Service on your behalf. Once the API key Secret has been created, you can create your Issuer or ClusterIssuer resource. If you are creating a ClusterIssuer resource, you must change the kind field to ClusterIssuer and remove the metadata.namespace field. Save the below content after making your amendments to a file named vaas-issuer.yaml . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : vaas-issuer namespace : <NAMESPACE YOU WANT TO ISSUE CERTIFICATES IN> spec : venafi : zone : \"My Application \\ My CIT\" # Set this to <Application Name>\\<Issuing Template Alias> cloud : apiTokenSecretRef : name : vaas-secret key : apikey You can then create the Issuer using kubectl create . $ kubectl create -f vaas-issuer.yaml Verify the Issuer has been initialized correctly using kubectl describe . $ kubectl get issuer vaas-issuer --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' -o wide NAME READY STATUS AGE vaas-issuer True Venafi issuer started 2m You are now ready to issue certificates using the newly provisioned Venafi Issuer and Venafi as a Service. Read the Issuing Certificates document for more information on how to create Certificate resources.","title":"Creating a Venafi as a Service Issuer"},{"location":"configuration/venafi/#creating-a-venafi-trust-protection-platform-issuer","text":"The Venafi Trust Protection Platform integration allows you to obtain certificates from a properly configured Venafi TPP instance. The setup is similar to the Venafi as a Service configuration above, however some of the connection parameters are slightly different. Note : You must allow \"User Provided CSRs\" as part of your TPP policy, as this is the only type supported by cert-manager at this time. More specifically, the valid configurations of the \"CSR handling\" are: \"User Provided CSRs\" selected and unlocked, \"User Provided CSRs\" selected and locked, \"Service Generated CSRs\" selected and unlocked. When using \"Service Generated CSRs\" selected and unlocked, the default CSR configuration present in your policy folder will override the configuration of your Certificate resource. The subject DN, key algorithm, and key size will be overridden by the values set in the policy folder. With \"Service Generated CSRs\" selected and locked, the certificate issuance will systematically fail with the following message: 400 PKCS#10 data will not be processed. Policy \"\\VED\\Policy\\foo\" is locked to a Server Generated CSR. In order to set up a Venafi Trust Protection Platform Issuer , you must first create a Kubernetes Secret resource containing your Venafi TPP API credentials.","title":"Creating a Venafi Trust Protection Platform Issuer"},{"location":"configuration/venafi/#access-token-authentication","text":"Set up token authentication . NOTE: Do not select \"Refresh Token Enabled\" and set a long \"Token Validity (days)\". Create a new user with sufficient privileges to manage and revoke certificates in a particular policy folder (zone). E.g. k8s-xyz-automation Create a new application integration Create an application integration with name and ID cert-manager . Set the \"API Access Settings\" to Certificates: Read,Manage,Revoke . \"Edit Access\" to the new application integration, and allow it to be used by the user you created earlier. Generate an access token vcert getcred \\ --username k8s-xyz-automation \\ --password somepassword \\ -u https://tpp.example.com/vedsdk \\ --client-id cert-manager \\ --scope \"certificate:manage,revoke\" This will print an access-token to stdout . E.g. vCert: 2020/10/07 16:34:27 Getting credentials access_token: I69n.............y1VjNJT3o9U0Wko19g== access_token_expires: 2021-01-05T15:34:30Z Save the access-token to a Secret in the Kubernetes cluster $ kubectl create secret generic \\ tpp-secret \\ --namespace = <NAMESPACE OF YOUR ISSUER RESOURCE> \\ --from-literal = access-token = 'YOUR_TPP_ACCESS_TOKEN'","title":"Access Token Authentication"},{"location":"configuration/venafi/#username-password-authentication","text":"\u26a0\ufe0f When you supply a Venafi TPP username and password, cert-manager uses an older authentication method which is called \"API Keys\", which has been deprecated since Venafi TPP 19.2 . Beginning in Venafi TPP 22.2 , \"API Keys\" are disabled by default. You will need to contact Venafi customer support for a special license key which will allow you to re-enable the \"API Keys\" feature, so that you can continue to use username and password authentication with cert-manager. In Venafi TPP 22.3 , the \"API Keys\" feature will be permanently removed, and you will need to use access-token authentication instead. \ud83d\udcd6 Read Deprecated functionality from Venafi Platform and Functionality Scheduled for Deprecation for more information. $ kubectl create secret generic \\ tpp-secret \\ --namespace = <NAMESPACE OF YOUR ISSUER RESOURCE> \\ --from-literal = username = 'YOUR_TPP_USERNAME_HERE' \\ --from-literal = password = 'YOUR_TPP_PASSWORD_HERE' Note: If you are configuring your issuer as a ClusterIssuer resource in order to issue Certificates across your whole cluster, you must set the --namespace parameter to cert-manager , which is the default Cluster Resource Namespace . The Cluster Resource Namespace can be configured through the --cluster-resource-namespace flag on the cert-manager controller component. These credentials will be used by cert-manager to interact with your Venafi TPP instance. Username attribute must be adhere to the <identity provider>:<username> format. For example: local:admin . Once the Secret containing credentials has been created, you can create your Issuer or ClusterIssuer resource. If you are creating a ClusterIssuer resource, you must change the kind field to ClusterIssuer and remove the metadata.namespace field. Save the below content after making your amendments to a file named tpp-issuer.yaml . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : tpp-issuer namespace : <NAMESPACE YOU WANT TO ISSUE CERTIFICATES IN> spec : venafi : zone : \\VED\\Policy\\devops\\cert-manager # Set this to the Venafi policy folder you want to use tpp : url : https://tpp.venafi.example/vedsdk # Change this to the URL of your TPP instance caBundle : <base64 encoded string of caBundle PEM file, or empty to use system root CAs> credentialsRef : name : tpp-secret You can then create the Issuer using kubectl create -f . $ kubectl create -f tpp-issuer.yaml Verify the Issuer has been initialized correctly using kubectl describe . $ kubectl describe issuer tpp-issuer --namespace = 'NAMESPACE OF YOUR ISSUER RESOURCE' You are now ready to issue certificates using the newly provisioned Venafi Issuer and Trust Protection Platform. Read the Issuing Certificates document for more information on how to create Certificate resources.","title":"Username / Password Authentication"},{"location":"configuration/venafi/#issuer-specific-annotations","text":"","title":"Issuer specific annotations"},{"location":"configuration/venafi/#custom-fields","text":"Starting v0.14 you can pass custom fields to Venafi (TPP version v19.2 and higher) using the venafi.cert-manager.io/custom-fields annotation on Certificate resources. The value is a JSON encoded array of custom field objects having a name and value key. For example: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-certificate annotations : venafi.cert-manager.io/custom-fields : |- [ {\"name\": \"field-name\", \"value\": \"vield value\"}, {\"name\": \"field-name-2\", \"value\": \"vield value 2\"} ] ...","title":"Custom Fields"},{"location":"configuration/acme/","text":"The ACME Issuer type represents a single account registered with the Automated Certificate Management Environment (ACME) Certificate Authority server. When you create a new ACME Issuer , cert-manager will generate a private key which is used to identify you with the ACME server. Certificates issued by public ACME servers are typically trusted by client's computers by default. This means that, for example, visiting a website that is backed by an ACME certificate issued for that URL, will be trusted by default by most client's web browsers. ACME certificates are typically free. Solving Challenges \u00b6 In order for the ACME CA server to verify that a client owns the domain, or domains, a certificate is being requested for, the client must complete \"challenges\". This is to ensure clients are unable to request certificates for domains they do not own and as a result, fraudulently impersonate another's site. As detailed in the RFC8555 , cert-manager offers two challenge validations - HTTP01 and DNS01 challenges. HTTP01 challenges are completed by presenting a computed key, that should be present at a HTTP URL endpoint and is routable over the internet. This URL will use the domain name requested for the certificate. Once the ACME server is able to get this key from this URL over the internet, the ACME server can validate you are the owner of this domain. When a HTTP01 challenge is created, cert-manager will automatically configure your cluster ingress to route traffic for this URL to a small web server that presents this key. DNS01 challenges are completed by providing a computed key that is present at a DNS TXT record. Once this TXT record has been propagated across the internet, the ACME server can successfully retrieve this key via a DNS lookup and can validate that the client owns the domain for the requested certificate. With the correct permissions, cert-manager will automatically present this TXT record for your given DNS provider. Configuration \u00b6 Creating a Basic ACME Issuer \u00b6 All ACME Issuers follow a similar configuration structure - a clients email , a server URL, a privateKeySecretRef , and one or more solvers . Below is an example of a simple ACME issuer: apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : # You must replace this email address with your own. # Let's Encrypt will use this to contact you about expiring # certificates, and issues related to your account. email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : # Secret resource that will be used to store the account's private key. name : example-issuer-account-key # Add a single challenge solver, HTTP01 using nginx solvers : - http01 : ingress : class : nginx Solvers come in the form of dns01 and http01 stanzas. For more information on how to configure these solver types, visit their respective documentation - DNS01 , HTTP01 . External Account Bindings \u00b6 cert-manager supports using External Account Bindings with your ACME account. External Account Bindings are used to associate your ACME account with an external account such as a CA custom database. This is typically not needed for most cert-manager users unless you know it is explicitly needed. External Account Bindings require two fields on an ACME Issuer which represents your ACME account. These fields are: keyID - the key ID or account ID of which your external account binding is indexed by the external account manager keySecretRef - the name and key of a secret containing a base 64 encoded URL string of your external account symmetric MAC key Note: In most cases, the MAC key must be encoded in base64URL . The following command will base64-encode a key and convert it to base64URL : $ echo 'my-secret-key' | base64 -w0 | sed -e 's/+/-/g' -e 's/\\//_/g' -e 's/=//g' You can then create the Secret resource with: $ kubectl create secret generic eab-secret --from-literal \\ secret ={ base64 encoded secret key } An example of an ACME issuer with an External Account Binding is as follows. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : my-acme-server-with-eab spec : acme : email : user@example.com server : https://my-acme-server-with-eab.com/directory externalAccountBinding : keyID : my-keyID-1 keySecretRef : name : eab-secret key : secret privateKeySecretRef : name : example-issuer-account-key solvers : - http01 : ingress : class : nginx Note: cert-manager versions pre- v1.3.0 also required users to specify the MAC algorithm for EAB by setting Issuer.spec.acme.externalAccountBinding.keyAlgorithm field. This field is now deprecated because the upstream Go x/crypto library hardcodes the algorithm to HS256 . (See related discussion upstream CL#41430 ). Reusing an ACME Account \u00b6 You may want to reuse a single ACME account across multiple clusters. This might especially be useful when using EAB. If the disableAccountKeyGeneration field is set, cert-manager will not create a new ACME account and use the existing key specified in privateKeySecretRef . Note that the Issuer / ClusterIssuer will not be ready and will continue to retry until the Secret is provided. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : my-acme-server-with-existing-acme-account spec : acme : email : user@example.com disableAccountKeyGeneration : true privateKeySecretRef : name : example-issuer-account-key Adding Multiple Solver Types \u00b6 You may want to use different types of challenge solver configurations for different ingress controllers, for example if you want to issue wildcard certificates using DNS01 alongside other certificates that are validated using HTTP01 . The solvers stanza has an optional selector field, that can be used to specify which Certificates , and further, what DNS names on those Certificates should be used to solve challenges. There are three selector types that can be used to form the requirements that a Certificate must meet in order to be selected for a solver - matchLabels , dnsNames and dnsZones . You can have any number of these three selectors on a single solver. Match Labels \u00b6 The matchLabel selector requires that all Certificates match all of the labels that are defined in the string map list of that stanza. For example, the following Issuer will only match on Certificates that have the labels \"user-cloudflare-solver\": \"true\" and \"email\": \"user@example.com\" . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : matchLabels : \"use-cloudflare-solver\" : \"true\" \"email\" : \"user@example.com\" DNS Names \u00b6 The dnsNames selector is a list of exact DNS names that should be mapped to a solver. This means that Certificates containing any of these DNS names will be selected. If a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. The following example will solve challenges of Certificates with DNS names example.com and *.example.com for these domains. Note: dnsNames take an exact match and do not resolve wildcards, meaning the following Issuer will not solve for DNS names such as foo.example.com . Use the dnsZones selector type to match all subdomains within a zone. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsNames : - 'example.com' - '*.example.com' DNS Zones \u00b6 The dnsZones stanza defines a list of DNS zones that can be solved by this solver. If a DNS name is an exact match, or a subdomain of any of the specified dnsZones , this solver will be used, unless a more specific dnsNames match is configured. This means that sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com . If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. In the following example, this solver will resolve challenges for the domain example.com , as well as all of its subdomains *.example.com . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsZones : - 'example.com' All Together \u00b6 Each solver is able to have any number of the three selector types defined. In the following example, the DNS01 solver for CloudFlare will be used to solve challenges for domains for Certificates that contain the DNS names a.example.com and b.example.com . The DNS01 solver for Google CloudDNS will be used to solve challenges for Certificates whose DNS names match zone test.example.com and all of its subdomains (e.g. foo.test.example.com ). For all other challenges, the HTTP01 solver will be used only if the Certificate also contains the label \"use-http01-solver\": \"true\" . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - http01 : ingress : class : nginx selector : matchLabels : \"use-http01-solver\" : \"true\" - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsNames : - 'a.example.com' - 'b.example.com' - dns01 : cloudDNS : project : my-project-id hostedZoneName : 'test-example.com' serviceAccountSecretRef : key : sa name : gcp-sa-secret selector : dnsZones : - 'test.example.com' # This should be the DNS name of the zone Each individual selector block can contain more than one selector type for example: solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : matchLabels : 'email' : 'user@example.com' 'solver' : 'cloudflare' dnsZones : - 'test.example.com' - 'example.dev' In this case the DNS01 solver for Cloudflare will only be used to solve a challenge for a DNS name if the Certificate has a label from matchLabels and the DNS name matches a zone from dnsZones . Alternative Certificate Chains \u00b6 {/* This empty link preserves old links to #alternative-certificate-chain\", which matched the old title of this section */} It's possible to choose alternative certificate chains when fetching a certificate from an ACME server. This allows issuers to gracefully roll people over to a new root certificate during a transition period; the most famous example was the Let's Encrypt \"ISRG Root\" changeover . This functionality is not exclusive to Let's Encrypt; if your ACME server supports signing by multiple CAs you can use preferredChain with the value of the Common Name of the chain you want in the Issuer part of the certificate. If the common name matches a difference chain, the server can choose to use and return that new chain. If the preferredChain does not match a certificate the server will return whatever it considers to be its default certificate. By way of an example, below is how a user would have requested an alternative chain before the (now completed) \"ISRG Root\" changeover, but note that since this change has already happened there's no need for this with Let's Encrypt any more: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"ISRG Root X1\"","title":"ACME"},{"location":"configuration/acme/#solving-challenges","text":"In order for the ACME CA server to verify that a client owns the domain, or domains, a certificate is being requested for, the client must complete \"challenges\". This is to ensure clients are unable to request certificates for domains they do not own and as a result, fraudulently impersonate another's site. As detailed in the RFC8555 , cert-manager offers two challenge validations - HTTP01 and DNS01 challenges. HTTP01 challenges are completed by presenting a computed key, that should be present at a HTTP URL endpoint and is routable over the internet. This URL will use the domain name requested for the certificate. Once the ACME server is able to get this key from this URL over the internet, the ACME server can validate you are the owner of this domain. When a HTTP01 challenge is created, cert-manager will automatically configure your cluster ingress to route traffic for this URL to a small web server that presents this key. DNS01 challenges are completed by providing a computed key that is present at a DNS TXT record. Once this TXT record has been propagated across the internet, the ACME server can successfully retrieve this key via a DNS lookup and can validate that the client owns the domain for the requested certificate. With the correct permissions, cert-manager will automatically present this TXT record for your given DNS provider.","title":"Solving Challenges"},{"location":"configuration/acme/#configuration","text":"","title":"Configuration"},{"location":"configuration/acme/#creating-a-basic-acme-issuer","text":"All ACME Issuers follow a similar configuration structure - a clients email , a server URL, a privateKeySecretRef , and one or more solvers . Below is an example of a simple ACME issuer: apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : # You must replace this email address with your own. # Let's Encrypt will use this to contact you about expiring # certificates, and issues related to your account. email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : # Secret resource that will be used to store the account's private key. name : example-issuer-account-key # Add a single challenge solver, HTTP01 using nginx solvers : - http01 : ingress : class : nginx Solvers come in the form of dns01 and http01 stanzas. For more information on how to configure these solver types, visit their respective documentation - DNS01 , HTTP01 .","title":"Creating a Basic ACME Issuer"},{"location":"configuration/acme/#external-account-bindings","text":"cert-manager supports using External Account Bindings with your ACME account. External Account Bindings are used to associate your ACME account with an external account such as a CA custom database. This is typically not needed for most cert-manager users unless you know it is explicitly needed. External Account Bindings require two fields on an ACME Issuer which represents your ACME account. These fields are: keyID - the key ID or account ID of which your external account binding is indexed by the external account manager keySecretRef - the name and key of a secret containing a base 64 encoded URL string of your external account symmetric MAC key Note: In most cases, the MAC key must be encoded in base64URL . The following command will base64-encode a key and convert it to base64URL : $ echo 'my-secret-key' | base64 -w0 | sed -e 's/+/-/g' -e 's/\\//_/g' -e 's/=//g' You can then create the Secret resource with: $ kubectl create secret generic eab-secret --from-literal \\ secret ={ base64 encoded secret key } An example of an ACME issuer with an External Account Binding is as follows. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : my-acme-server-with-eab spec : acme : email : user@example.com server : https://my-acme-server-with-eab.com/directory externalAccountBinding : keyID : my-keyID-1 keySecretRef : name : eab-secret key : secret privateKeySecretRef : name : example-issuer-account-key solvers : - http01 : ingress : class : nginx Note: cert-manager versions pre- v1.3.0 also required users to specify the MAC algorithm for EAB by setting Issuer.spec.acme.externalAccountBinding.keyAlgorithm field. This field is now deprecated because the upstream Go x/crypto library hardcodes the algorithm to HS256 . (See related discussion upstream CL#41430 ).","title":"External Account Bindings"},{"location":"configuration/acme/#reusing-an-acme-account","text":"You may want to reuse a single ACME account across multiple clusters. This might especially be useful when using EAB. If the disableAccountKeyGeneration field is set, cert-manager will not create a new ACME account and use the existing key specified in privateKeySecretRef . Note that the Issuer / ClusterIssuer will not be ready and will continue to retry until the Secret is provided. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : my-acme-server-with-existing-acme-account spec : acme : email : user@example.com disableAccountKeyGeneration : true privateKeySecretRef : name : example-issuer-account-key","title":"Reusing an ACME Account"},{"location":"configuration/acme/#adding-multiple-solver-types","text":"You may want to use different types of challenge solver configurations for different ingress controllers, for example if you want to issue wildcard certificates using DNS01 alongside other certificates that are validated using HTTP01 . The solvers stanza has an optional selector field, that can be used to specify which Certificates , and further, what DNS names on those Certificates should be used to solve challenges. There are three selector types that can be used to form the requirements that a Certificate must meet in order to be selected for a solver - matchLabels , dnsNames and dnsZones . You can have any number of these three selectors on a single solver.","title":"Adding Multiple Solver Types"},{"location":"configuration/acme/#match-labels","text":"The matchLabel selector requires that all Certificates match all of the labels that are defined in the string map list of that stanza. For example, the following Issuer will only match on Certificates that have the labels \"user-cloudflare-solver\": \"true\" and \"email\": \"user@example.com\" . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : matchLabels : \"use-cloudflare-solver\" : \"true\" \"email\" : \"user@example.com\"","title":"Match Labels"},{"location":"configuration/acme/#dns-names","text":"The dnsNames selector is a list of exact DNS names that should be mapped to a solver. This means that Certificates containing any of these DNS names will be selected. If a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. The following example will solve challenges of Certificates with DNS names example.com and *.example.com for these domains. Note: dnsNames take an exact match and do not resolve wildcards, meaning the following Issuer will not solve for DNS names such as foo.example.com . Use the dnsZones selector type to match all subdomains within a zone. apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsNames : - 'example.com' - '*.example.com'","title":"DNS Names"},{"location":"configuration/acme/#dns-zones","text":"The dnsZones stanza defines a list of DNS zones that can be solved by this solver. If a DNS name is an exact match, or a subdomain of any of the specified dnsZones , this solver will be used, unless a more specific dnsNames match is configured. This means that sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com . If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. In the following example, this solver will resolve challenges for the domain example.com , as well as all of its subdomains *.example.com . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsZones : - 'example.com'","title":"DNS Zones"},{"location":"configuration/acme/#all-together","text":"Each solver is able to have any number of the three selector types defined. In the following example, the DNS01 solver for CloudFlare will be used to solve challenges for domains for Certificates that contain the DNS names a.example.com and b.example.com . The DNS01 solver for Google CloudDNS will be used to solve challenges for Certificates whose DNS names match zone test.example.com and all of its subdomains (e.g. foo.test.example.com ). For all other challenges, the HTTP01 solver will be used only if the Certificate also contains the label \"use-http01-solver\": \"true\" . apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : ... solvers : - http01 : ingress : class : nginx selector : matchLabels : \"use-http01-solver\" : \"true\" - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : dnsNames : - 'a.example.com' - 'b.example.com' - dns01 : cloudDNS : project : my-project-id hostedZoneName : 'test-example.com' serviceAccountSecretRef : key : sa name : gcp-sa-secret selector : dnsZones : - 'test.example.com' # This should be the DNS name of the zone Each individual selector block can contain more than one selector type for example: solvers : - dns01 : cloudflare : email : user@example.com apiKeySecretRef : name : cloudflare-apikey-secret key : apikey selector : matchLabels : 'email' : 'user@example.com' 'solver' : 'cloudflare' dnsZones : - 'test.example.com' - 'example.dev' In this case the DNS01 solver for Cloudflare will only be used to solve a challenge for a DNS name if the Certificate has a label from matchLabels and the DNS name matches a zone from dnsZones .","title":"All Together"},{"location":"configuration/acme/#alternative-certificate-chains","text":"{/* This empty link preserves old links to #alternative-certificate-chain\", which matched the old title of this section */} It's possible to choose alternative certificate chains when fetching a certificate from an ACME server. This allows issuers to gracefully roll people over to a new root certificate during a transition period; the most famous example was the Let's Encrypt \"ISRG Root\" changeover . This functionality is not exclusive to Let's Encrypt; if your ACME server supports signing by multiple CAs you can use preferredChain with the value of the Common Name of the chain you want in the Issuer part of the certificate. If the common name matches a difference chain, the server can choose to use and return that new chain. If the preferredChain does not match a certificate the server will return whatever it considers to be its default certificate. By way of an example, below is how a user would have requested an alternative chain before the (now completed) \"ISRG Root\" changeover, but note that since this change has already happened there's no need for this with Let's Encrypt any more: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"ISRG Root X1\"","title":"Alternative Certificate Chains"},{"location":"configuration/acme/dns01/","text":"Configuring DNS01 Challenge Provider \u00b6 This page contains details on the different options available on the Issuer resource's DNS01 challenge solver configuration. For more information on configuring ACME Issuers and their API format, read the ACME Issuers documentation. DNS01 provider configuration must be specified on the Issuer resource, similar to the examples in the setting up documentation. You can read about how the DNS01 challenge type works on the Let's Encrypt challenge types page . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key solvers : - dns01 : cloudDNS : project : my-project serviceAccountSecretRef : name : prod-clouddns-svc-acct-secret key : service-account.json Each issuer can specify multiple different DNS01 challenge providers, and it is also possible to have multiple instances of the same DNS provider on a single Issuer (e.g. two CloudDNS accounts could be set, each with their own name). For more information on utilizing multiple solver types on a single Issuer , read the multiple-solver-types section. Setting Nameservers for DNS01 Self Check \u00b6 cert-manager will check the correct DNS records exist before attempting a DNS01 challenge. By default cert-manager will use the recursive nameservers taken from /etc/resolv.conf to query for the authoritative nameservers, which it will then query directly to verify the DNS records exist. If this is not desired (for example with multiple authoritative nameservers or split-horizon DNS), the cert-manager controller exposes two flags that allows you alter this behavior: --dns01-recursive-nameservers Comma separated string with host and port of the recursive nameservers cert-manager should query. --dns01-recursive-nameservers-only Forces cert-manager to only use the recursive nameservers for verification. Enabling this option could cause the DNS01 self check to take longer due to caching performed by the recursive nameservers. Example usage: --dns01-recursive-nameservers-only --dns01-recursive-nameservers = 8 .8.8.8:53,1.1.1.1:53 If you're using the cert-manager helm chart, you can set recursive nameservers through .Values.extraArgs or at the command at helm install/upgrade time with --set : --set 'extraArgs={--dns01-recursive-nameservers-only,--dns01-recursive-nameservers=8.8.8.8:53\\,1.1.1.1:53}' Delegated Domains for DNS01 \u00b6 By default, cert-manager will not follow CNAME records pointing to subdomains. If granting cert-manager access to the root DNS zone is not desired, then the _acme-challenge.example.com subdomain can instead be delegated to some other, less privileged domain ( less-privileged.example.org ). This could be achieved in the following way. Say, one has two zones: example.com less-privileged.example.org Create a CNAME record pointing to this less privileged domain: _acme-challenge.example.com IN CNAME _acme-challenge.less-privileged.example.org. Grant cert-manager rights to update less privileged less-privileged.example.org zone Provide configuration/credentials for updating this less privileged zone and add an additional field into the relevant dns01 solver. Note that selector field is still working for the original example.com , while credentials are provided for less-privileged.example.org apiVersion : cert-manager.io/v1 kind : Issuer metadata : ... spec : acme : ... solvers : - selector : dnsZones : - 'example.com' dns01 : # Valid values are None and Follow cnameStrategy : Follow route53 : region : eu-central-1 accessKeyID : <Access ID for less-privileged.example.org here> hostedZoneID : <Zone ID for less-privileged.example.org here> secretAccessKeySecretRef : ... If you have a multitude of (sub)domains requiring separate certificates, it is possible to share an aliased less-privileged domain. To achieve it one should create a CNAME record for each (sub)domain like this: _acme-challenge.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.www.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.foo.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.bar.example.com IN CNAME _acme-challenge.less-privileged.example.org. With this configuration cert-manager will follow CNAME records recursively in order to determine which DNS zone to update during DNS01 challenges. Supported DNS01 providers \u00b6 A number of different DNS providers are supported for the ACME Issuer . Below is a listing of available providers, their .yaml configurations, along with additional Kubernetes and provider specific notes regarding their usage. ACMEDNS Akamai AzureDNS CloudFlare Google Route53 DigitalOcean RFC2136 Webhook \u00b6 cert-manager also supports out of tree DNS providers using an external webhook. Links to these supported providers along with their documentation are below: AliDNS-Webhook cert-manager-alidns-webhook cert-manager-webhook-civo cert-manager-webhook-dnspod cert-manager-webhook-dnsimple cert-manager-webhook-gandi cert-manager-webhook-infomaniak cert-manager-webhook-inwx cert-manager-webhook-linode cert-manager-webhook-oci (Oracle Cloud Infrastructure) cert-manager-webhook-scaleway cert-manager-webhook-selectel cert-manager-webhook-softlayer cert-manager-webhook-ibmcis cert-manager-webhook-loopia cert-manager-webhook-arvan bizflycloud-certmanager-dns-webhook cert-manager-webhook-hetzner cert-manager-webhook-yandex-cloud cert-manager-webhook-netcup You can find more information on how to configure webhook providers here . To create a new unsupported DNS provider, follow the development documentation here .","title":"DNS01"},{"location":"configuration/acme/dns01/#configuring-dns01-challenge-provider","text":"This page contains details on the different options available on the Issuer resource's DNS01 challenge solver configuration. For more information on configuring ACME Issuers and their API format, read the ACME Issuers documentation. DNS01 provider configuration must be specified on the Issuer resource, similar to the examples in the setting up documentation. You can read about how the DNS01 challenge type works on the Let's Encrypt challenge types page . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key solvers : - dns01 : cloudDNS : project : my-project serviceAccountSecretRef : name : prod-clouddns-svc-acct-secret key : service-account.json Each issuer can specify multiple different DNS01 challenge providers, and it is also possible to have multiple instances of the same DNS provider on a single Issuer (e.g. two CloudDNS accounts could be set, each with their own name). For more information on utilizing multiple solver types on a single Issuer , read the multiple-solver-types section.","title":"Configuring DNS01 Challenge Provider"},{"location":"configuration/acme/dns01/#setting-nameservers-for-dns01-self-check","text":"cert-manager will check the correct DNS records exist before attempting a DNS01 challenge. By default cert-manager will use the recursive nameservers taken from /etc/resolv.conf to query for the authoritative nameservers, which it will then query directly to verify the DNS records exist. If this is not desired (for example with multiple authoritative nameservers or split-horizon DNS), the cert-manager controller exposes two flags that allows you alter this behavior: --dns01-recursive-nameservers Comma separated string with host and port of the recursive nameservers cert-manager should query. --dns01-recursive-nameservers-only Forces cert-manager to only use the recursive nameservers for verification. Enabling this option could cause the DNS01 self check to take longer due to caching performed by the recursive nameservers. Example usage: --dns01-recursive-nameservers-only --dns01-recursive-nameservers = 8 .8.8.8:53,1.1.1.1:53 If you're using the cert-manager helm chart, you can set recursive nameservers through .Values.extraArgs or at the command at helm install/upgrade time with --set : --set 'extraArgs={--dns01-recursive-nameservers-only,--dns01-recursive-nameservers=8.8.8.8:53\\,1.1.1.1:53}'","title":"Setting Nameservers for DNS01 Self Check"},{"location":"configuration/acme/dns01/#delegated-domains-for-dns01","text":"By default, cert-manager will not follow CNAME records pointing to subdomains. If granting cert-manager access to the root DNS zone is not desired, then the _acme-challenge.example.com subdomain can instead be delegated to some other, less privileged domain ( less-privileged.example.org ). This could be achieved in the following way. Say, one has two zones: example.com less-privileged.example.org Create a CNAME record pointing to this less privileged domain: _acme-challenge.example.com IN CNAME _acme-challenge.less-privileged.example.org. Grant cert-manager rights to update less privileged less-privileged.example.org zone Provide configuration/credentials for updating this less privileged zone and add an additional field into the relevant dns01 solver. Note that selector field is still working for the original example.com , while credentials are provided for less-privileged.example.org apiVersion : cert-manager.io/v1 kind : Issuer metadata : ... spec : acme : ... solvers : - selector : dnsZones : - 'example.com' dns01 : # Valid values are None and Follow cnameStrategy : Follow route53 : region : eu-central-1 accessKeyID : <Access ID for less-privileged.example.org here> hostedZoneID : <Zone ID for less-privileged.example.org here> secretAccessKeySecretRef : ... If you have a multitude of (sub)domains requiring separate certificates, it is possible to share an aliased less-privileged domain. To achieve it one should create a CNAME record for each (sub)domain like this: _acme-challenge.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.www.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.foo.example.com IN CNAME _acme-challenge.less-privileged.example.org. _acme-challenge.bar.example.com IN CNAME _acme-challenge.less-privileged.example.org. With this configuration cert-manager will follow CNAME records recursively in order to determine which DNS zone to update during DNS01 challenges.","title":"Delegated Domains for DNS01"},{"location":"configuration/acme/dns01/#supported-dns01-providers","text":"A number of different DNS providers are supported for the ACME Issuer . Below is a listing of available providers, their .yaml configurations, along with additional Kubernetes and provider specific notes regarding their usage. ACMEDNS Akamai AzureDNS CloudFlare Google Route53 DigitalOcean RFC2136","title":"Supported DNS01 providers"},{"location":"configuration/acme/dns01/#webhook","text":"cert-manager also supports out of tree DNS providers using an external webhook. Links to these supported providers along with their documentation are below: AliDNS-Webhook cert-manager-alidns-webhook cert-manager-webhook-civo cert-manager-webhook-dnspod cert-manager-webhook-dnsimple cert-manager-webhook-gandi cert-manager-webhook-infomaniak cert-manager-webhook-inwx cert-manager-webhook-linode cert-manager-webhook-oci (Oracle Cloud Infrastructure) cert-manager-webhook-scaleway cert-manager-webhook-selectel cert-manager-webhook-softlayer cert-manager-webhook-ibmcis cert-manager-webhook-loopia cert-manager-webhook-arvan bizflycloud-certmanager-dns-webhook cert-manager-webhook-hetzner cert-manager-webhook-yandex-cloud cert-manager-webhook-netcup You can find more information on how to configure webhook providers here . To create a new unsupported DNS provider, follow the development documentation here .","title":"Webhook"},{"location":"configuration/acme/dns01/acme-dns/","text":"apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : solvers : - dns01 : acmeDNS : host : https://acme.example.com accountSecretRef : name : acme-dns key : acmedns.json In general, clients to ACMEDNS perform registration on the users behalf and inform them of the CNAME entries they must create. This is not possible in cert-manager, it is a non-interactive system. Registration must be carried out beforehand and the resulting credentials JSON uploaded to the cluster as a Secret . In this example, we use curl and the API endpoints directly. Information about setting up and configuring ACMEDNS is available on the ACMEDNS project page . First, register with the ACMEDNS server, in this example, there is one running at auth.example.com . The command: curl -X POST http://auth.example.com/register will return a JSON with credentials for your registration: { \"username\" : \"eabcdb41-d89f-4580-826f-3e62e9755ef2\" , \"password\" : \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" , \"fulldomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\" , \"subdomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\" , \"allowfrom\" : [] } It is strongly recommended to restrict the update endpoint to the IP range of your pods. This is done at registration time as follows: curl -X POST http://auth.example.com/register \\ -H \"Content-Type: application/json\" \\ --data '{\"allowfrom\": [\"10.244.0.0/16\"]}' Make sure to update the allowfrom field to match your cluster configuration. The JSON will now look like: { \"username\" : \"eabcdb41-d89f-4580-826f-3e62e9755ef2\" , \"password\" : \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" , \"fulldomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\" , \"subdomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\" , \"allowfrom\" : [ \"10.244.0.0/16\" ] } Save this JSON to a file with the key as your domain. You can specify multiple domains with the same credentials if you like. In our example, the returned credentials can be used to verify ownership of example.com and and example.org . { \"example.com\" : { \"username\" : \"eabcdb41-d89f-4580-826f-3e62e9755ef2\" , \"password\" : \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" , \"fulldomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\" , \"subdomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\" , \"allowfrom\" : [ \"10.244.0.0/16\" ] }, \"example.org\" : { \"username\" : \"eabcdb41-d89f-4580-826f-3e62e9755ef2\" , \"password\" : \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" , \"fulldomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\" , \"subdomain\" : \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\" , \"allowfrom\" : [ \"10.244.0.0/16\" ] } } Next, update your primary DNS server with the CNAME record that will tell the verifier how to locate the challenge TXT record. This is obtained from the fulldomain field in the registration: _acme-challenge.example.com CNAME d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com _acme-challenge.example.org CNAME d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com The \"name\" of the record always has the _acme-challenge subdomain, and the \"value\" of the record matches exactly the fulldomain field from registration. At verification time, the domain name d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com will be a TXT record that is set to your validation token. When the verifier queries _acme-challenge.example.com , it will be directed to the correct location by this CNAME record. This proves that you control example.com Create a secret from the credentials JSON that was saved in step 2, this secret is referenced in the accountSecretRef field of your DNS01 issuer settings. When creating an Issuer both this Issuer and Secret must be in the same namespace. However for a ClusterIssuer (which does not have a namespace) the Secret must be placed in the same namespace as where the cert-manager pod is running in (in the default setup cert-manager ). kubectl create secret generic acme-dns --from-file acmedns.json Limitation of the acme-dns server \u00b6 The acme-dns server has a known limitation : when a set of credentials is used with more than 2 domains, cert-manager will fail solving the DNS01 challenges. Imagining that you have configured the ACMEDNS issuer with a single set of credentials, and that the \"subdomain\" of this set of credentials is d420c923-bbd7-4056-ab64-c3ca54c9b3cf : kind : Secret metadata : name : auth-example-com stringData : acmedns.json : | { \"example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] }, } --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : my-acme-dns spec : acme : solvers : - dns01 : acmeDNS : accountSecretRef : name : auth-example-com key : acmedns.json host : auth.example.com and imagine that you want to create a Certificate with three subdomains: kind : Certificate spec : issuerRef : name : issuer-1 dnsNames : - \"example.com\" - \"*.example.com\" - \"foo.example.com\" cert-manager will only be able to solve 2 challenges out of 3 in a non deterministic way. This limitation comes from a \"feature\" mentioned this acme-dns issue . One workaround is to issue one set of acme-dns credentials for each domain that we want to be challenged, keeping in mind that each acme-dns \"subdomain\" can only accept at most 2 challenged domains. For example, the above secret would become: kind : Secret metadata : name : auth-example-com stringData : acmedns.json : | { \"example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] }, \"foo.example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] } With this setup, we have: example.com and *.example.com are registered in the acme-dns \"subdomain\" d420c923-bbd7-4056-ab64-c3ca54c9b3cf . foo.example.com is registered in the acme-dns \"subdomain\" d420c923-bbd7-4056-ab64-c3ca54c9b3cf . Another workaround is to use --max-concurrent-challenges 2 when running the cert-manager-controller . With this setting, acme-dns will only have 2 TXT records in its database at any time, which mitigates the issue.","title":"ACMEDNS"},{"location":"configuration/acme/dns01/acme-dns/#limitation-of-the-acme-dns-server","text":"The acme-dns server has a known limitation : when a set of credentials is used with more than 2 domains, cert-manager will fail solving the DNS01 challenges. Imagining that you have configured the ACMEDNS issuer with a single set of credentials, and that the \"subdomain\" of this set of credentials is d420c923-bbd7-4056-ab64-c3ca54c9b3cf : kind : Secret metadata : name : auth-example-com stringData : acmedns.json : | { \"example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] }, } --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : my-acme-dns spec : acme : solvers : - dns01 : acmeDNS : accountSecretRef : name : auth-example-com key : acmedns.json host : auth.example.com and imagine that you want to create a Certificate with three subdomains: kind : Certificate spec : issuerRef : name : issuer-1 dnsNames : - \"example.com\" - \"*.example.com\" - \"foo.example.com\" cert-manager will only be able to solve 2 challenges out of 3 in a non deterministic way. This limitation comes from a \"feature\" mentioned this acme-dns issue . One workaround is to issue one set of acme-dns credentials for each domain that we want to be challenged, keeping in mind that each acme-dns \"subdomain\" can only accept at most 2 challenged domains. For example, the above secret would become: kind : Secret metadata : name : auth-example-com stringData : acmedns.json : | { \"example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] }, \"foo.example.com\": { \"username\": \"eabcdb41-d89f-4580-826f-3e62e9755ef2\", \"password\": \"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\", \"fulldomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.com\", \"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"allowfrom\": [\"10.244.0.0/16\"] } With this setup, we have: example.com and *.example.com are registered in the acme-dns \"subdomain\" d420c923-bbd7-4056-ab64-c3ca54c9b3cf . foo.example.com is registered in the acme-dns \"subdomain\" d420c923-bbd7-4056-ab64-c3ca54c9b3cf . Another workaround is to use --max-concurrent-challenges 2 when running the cert-manager-controller . With this setting, acme-dns will only have 2 TXT records in its database at any time, which mitigates the issue.","title":"Limitation of the acme-dns server"},{"location":"configuration/acme/dns01/akamai/","text":"Edge DNS \u00b6 Use Edge DNS to solve DNS01 ACME challenges by creating a Secret using Akamai API credentials and an Issuer that references the Secret and sets the solver type. Create a Secret \u00b6 The Secret should look like the following for the Issuer to reference. Replace use_akamai_client_secret , use_akamai_access_token and use_akamai_client_token with the respective Akamai API credential values. apiVersion : v1 kind : Secret metadata : name : akamai-secret type : Opaque stringData : clientSecret : use_akamai_client_secret accessToken : use_akamai_access_token clientToken : use_akamai_client_token Create an Issuer \u00b6 To set Edge DNS for challenge tokens, cert-manager uses an Issuer that references the above Secret and other attributes such as the solver type. The Issuer should look like the following. Replace use_akamai_host with the Akamai API credential host value. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-akamai-dns spec : acme : server : https://acme-v02.api.letsencrypt.org/directory email : contact@me.com privateKeySecretRef : name : letsencrypt-akamai-issuer-account-key solvers : - dns01 : akamai : serviceConsumerDomain : use_akamai_host clientTokenSecretRef : name : akamai-secret key : clientToken clientSecretSecretRef : name : akamai-secret key : clientSecret accessTokenSecretRef : name : akamai-secret key : accessToken Create a Certificate \u00b6 The Certificate should look like the following and reference the Akamai Edge DNS Issuer above. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-zone spec : secretName : akamai-crt-secret dnsNames : - '*.example.zone' issuerRef : name : letsencrypt-akamai-dns kind : Issuer Note: cert-manager will wait for challenge tokens to propagate across the Edge DNS network. Follow the certificate status with a command such as the following. kubectl describe certificate example-zone Troubleshooting \u00b6 Follow the cert-manager events to identify any issues with a command such as the following. cmctl status certificate example-zone","title":"Akamai"},{"location":"configuration/acme/dns01/akamai/#edge-dns","text":"Use Edge DNS to solve DNS01 ACME challenges by creating a Secret using Akamai API credentials and an Issuer that references the Secret and sets the solver type.","title":"Edge DNS"},{"location":"configuration/acme/dns01/akamai/#create-a-secret","text":"The Secret should look like the following for the Issuer to reference. Replace use_akamai_client_secret , use_akamai_access_token and use_akamai_client_token with the respective Akamai API credential values. apiVersion : v1 kind : Secret metadata : name : akamai-secret type : Opaque stringData : clientSecret : use_akamai_client_secret accessToken : use_akamai_access_token clientToken : use_akamai_client_token","title":"Create a Secret"},{"location":"configuration/acme/dns01/akamai/#create-an-issuer","text":"To set Edge DNS for challenge tokens, cert-manager uses an Issuer that references the above Secret and other attributes such as the solver type. The Issuer should look like the following. Replace use_akamai_host with the Akamai API credential host value. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-akamai-dns spec : acme : server : https://acme-v02.api.letsencrypt.org/directory email : contact@me.com privateKeySecretRef : name : letsencrypt-akamai-issuer-account-key solvers : - dns01 : akamai : serviceConsumerDomain : use_akamai_host clientTokenSecretRef : name : akamai-secret key : clientToken clientSecretSecretRef : name : akamai-secret key : clientSecret accessTokenSecretRef : name : akamai-secret key : accessToken","title":"Create an Issuer"},{"location":"configuration/acme/dns01/akamai/#create-a-certificate","text":"The Certificate should look like the following and reference the Akamai Edge DNS Issuer above. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-zone spec : secretName : akamai-crt-secret dnsNames : - '*.example.zone' issuerRef : name : letsencrypt-akamai-dns kind : Issuer Note: cert-manager will wait for challenge tokens to propagate across the Edge DNS network. Follow the certificate status with a command such as the following. kubectl describe certificate example-zone","title":"Create a Certificate"},{"location":"configuration/acme/dns01/akamai/#troubleshooting","text":"Follow the cert-manager events to identify any issues with a command such as the following. cmctl status certificate example-zone","title":"Troubleshooting"},{"location":"configuration/acme/dns01/azuredns/","text":"To configure the AzureDNS DNS01 Challenge in a Kubernetes cluster there are 3 ways available: Managed Identity Using AAD Pod Identities Managed Identity Using AKS Kubelet Identity Service Principal Managed Identity Using AAD Pod Identities \u00b6 AAD Pod Identities allows assigning a Managed Identity to a pod. This removes the need for adding explicit credentials into the cluster to create the required DNS records. Note: When using Pod identity, even though assigning multiple identities to a single pod is allowed, currently cert-manager does not support this as it is not able to identify which identity to use. Firstly an identity should be created that has access to contribute to the DNS Zone. Example creation using azure-cli and jq : # Choose a unique Identity name and existing resource group to create identity in. IDENTITY = $( az identity create --name $IDENTITY_NAME --resource-group $IDENTITY_GROUP --output json ) # Gets principalId to use for role assignment PRINCIPAL_ID = $( echo $IDENTITY | jq -r '.principalId' ) # Used for identity binding CLIENT_ID = $( echo $IDENTITY | jq -r '.clientId' ) RESOURCE_ID = $( echo $IDENTITY | jq -r '.id' ) # Get existing DNS Zone Id ZONE_ID = $( az network dns zone show --name $ZONE_NAME --resource-group $ZONE_GROUP --query \"id\" -o tsv ) # Create role assignment az role assignment create --role \"DNS Zone Contributor\" --assignee $PRINCIPAL_ID --scope $ZONE_ID Example creation using Terraform variable resource_group_name {} variable location {} variable dns_zone_id {} # Creates Identity resource \"azurerm_user_assigned_identity\" \"dns_identity\" { name = \"cert-manager-dns01\" resource_group_name = var.resource_group_name location = var.location } # Creates Role Assignment resource \"azurerm_role_assignment\" \"dns_contributor\" { scope = var.dns_zone_id role_definition_name = \"DNS Zone Contributor\" principal_id = azurerm_user_assigned_identity.dns_identity.principal_id } # Client Id Used for identity binding output \"identity_client_id\" { value = azurerm_user_assigned_identity.dns_identity.client_id } # Resource Id Used for identity binding output \"identity_resource_id\" { value = azurerm_user_assigned_identity.dns_identity.id } Next we need to ensure we have installed AAD Pod Identity using their walk-through. This will install the CRDs and deployment required to assign the identity. Now we can create the identity resource and binding using the below manifest as an example: apiVersion : \"aadpodidentity.k8s.io/v1\" kind : AzureIdentity metadata : annotations : # recommended to use namespaced identites https://azure.github.io/aad-pod-identity/docs/configure/match_pods_in_namespace/ aadpodidentity.k8s.io/Behavior : namespaced name : certman-identity namespace : cert-manager # change to your preferred namespace spec : type : 0 # MSI resourceID : <Identity_Id> # Resource Id From Previous step clientID : <Client_Id> # Client Id from previous step --- apiVersion : \"aadpodidentity.k8s.io/v1\" kind : AzureIdentityBinding metadata : name : certman-id-binding namespace : cert-manager # change to your preferred namespace spec : azureIdentity : certman-identity selector : certman-label # This is the label that needs to be set on cert-manager pods Next we need to ensure the cert-manager pod has a relevant label to use the pod identity binding. This can be done by editing the deployment and adding the below into the .spec.template.metadata.labels field spec : template : metadata : labels : aadpodidbinding : certman-label # must match selector in AzureIdentityBinding Or by using the helm values podLabels podLabels : aadpodidbinding : certman-label Lastly when we create the certificate issuer we only need to specify the hostedZoneName , resourceGroupName and subscriptionID fields for the DNS zone. Example below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : subscriptionID : AZURE_SUBSCRIPTION_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud This authentication mechanism is what cert-manager considers 'ambient credentials'. Use of ambient credentials is disabled by default for cert-manager Issuer s. This to ensure unprivileged users who have permission to create issuers cannot issue certificates using any credentials cert-manager incidentally has access to. To enable this authentication mechanism for Issuer s, you will need to set --issuer-ambient-credentials flag on cert-manager controller to true. (There is a corresponding --cluster-issuer-ambient-credentials flag which is set to true by default). If you are using this authentication mechanism and ambient credentials are not enabled, you will see this error: error instantiating azuredns challenge solver: ClientID is not set but neither --cluster-issuer-ambient-credentials nor --issuer-ambient-credentials are set. These are necessary to enable Azure Managed Identities. Managed Identity Using AKS Kubelet Identity \u00b6 When creating an AKS cluster in Azure there is the option to use a managed identity that is assigned to the kubelet. This identity is assigned to the underlying node pool in the AKS cluster and can then be used by the cert-manager pods to authenticate to Azure Active Directory. There are some caveats with this approach, these mainly being: Any permissions granted to this identity will also be accessible to all containers running inside the Kubernetes cluster. Using AKS extensions like Kube Dashboard , Virtual Node , or HTTP Application Routing (see full list here ) will create additional identities that are assigned to your node pools. If your node pools have more than one identity assigned, you will need to specify either clientID or resourceID to select the correct one. To set this up, firstly you will need to retrieve the identity that the kubelet is using by querying the AKS cluster. This can then be used to create the appropriate permissions in the DNS zone. Example commands using azure-cli : # Get AKS Kubelet Identity PRINCIPAL_ID = $( az aks show -n $CLUSTERNAME -g $CLUSTER_GROUP --query \"identityProfile.kubeletidentity.objectId\" -o tsv ) # Get existing DNS Zone Id ZONE_ID = $( az network dns zone show --name $ZONE_NAME --resource-group $ZONE_GROUP --query \"id\" -o tsv ) # Create role assignment az role assignment create --role \"DNS Zone Contributor\" --assignee $PRINCIPAL_ID --scope $ZONE_ID Example terraform: variable dns_zone_id {} # Creating the AKS cluster, abbreviated. resource \"azurerm_kubernetes_cluster\" \"cluster\" { ... # Creates Identity associated to kubelet identity { type = \"SystemAssigned\" } ... } resource \"azurerm_role_assignment\" \"dns_contributor\" { scope = var.dns_zone_id role_definition_name = \"DNS Zone Contributor\" principal_id = azurerm_kubernetes_cluster.cluster.kubelet_identity[0].object_id skip_service_principal_aad_check = true # Allows skipping propagation of identity to ensure assignment succeeds. } Then when creating the cert-manager issuer we need to specify the hostedZoneName , resourceGroupName and subscriptionID fields for the DNS Zone. We also need to specify managedIdentity.clientID or managedIdentity.resourceID if multiple managed identities are assigned to the node pools. The value for managedIdentity.clientID can be fetched by running this command: az aks show -n $CLUSTERNAME -g $CLUSTER_GROUP --query \"identityProfile.kubeletidentity.clientId\" -o tsv Example below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : subscriptionID : AZURE_SUBSCRIPTION_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud # optional, only required if node pools have more than 1 managed identity assigned managedIdentity : # client id of the node pool managed identity (can not be set at the same time as resourceID) clientID : YOUR_MANAGED_IDENTITY_CLIENT_ID # resource id of the managed identity (can not be set at the same time as clientID) # resourceID: YOUR_MANAGED_IDENTITY_RESOURCE_ID Service Principal \u00b6 Configuring the AzureDNS DNS01 Challenge for a Kubernetes cluster requires creating a service principal in Azure. To create the service principal you can use the following script (requires azure-cli and jq ): # Choose a name for the service principal that contacts azure DNS to present # the challenge. $ AZURE_CERT_MANAGER_NEW_SP_NAME = NEW_SERVICE_PRINCIPAL_NAME # This is the name of the resource group that you have your dns zone in. $ AZURE_DNS_ZONE_RESOURCE_GROUP = AZURE_DNS_ZONE_RESOURCE_GROUP # The DNS zone name. It should be something like domain.com or sub.domain.com. $ AZURE_DNS_ZONE = AZURE_DNS_ZONE $ DNS_SP = $( az ad sp create-for-rbac --name $AZURE_CERT_MANAGER_NEW_SP_NAME --output json ) $ AZURE_CERT_MANAGER_SP_APP_ID = $( echo $DNS_SP | jq -r '.appId' ) $ AZURE_CERT_MANAGER_SP_PASSWORD = $( echo $DNS_SP | jq -r '.password' ) $ AZURE_TENANT_ID = $( echo $DNS_SP | jq -r '.tenant' ) $ AZURE_SUBSCRIPTION_ID = $( az account show --output json | jq -r '.id' ) For security purposes, it is appropriate to utilize RBAC to ensure that you properly maintain access control to your resources in Azure. The service principal that is generated by this tutorial has fine-grained access to ONLY the DNS Zone in the specific resource group specified. It requires this permission so that it can read/write the _acme_challenge TXT records to the zone. Lower the Permissions of the service principal. $ az role assignment delete --assignee $AZURE_CERT_MANAGER_SP_APP_ID --role Contributor Give Access to DNS Zone. $ DNS_ID = $( az network dns zone show --name $AZURE_DNS_ZONE --resource-group $AZURE_DNS_ZONE_RESOURCE_GROUP --query \"id\" --output tsv ) $ az role assignment create --assignee $AZURE_CERT_MANAGER_SP_APP_ID --role \"DNS Zone Contributor\" --scope $DNS_ID Check Permissions. As the result of the following command, we would like to see just one object in the permissions array with \"DNS Zone Contributor\" role. $ az role assignment list --all --assignee $AZURE_CERT_MANAGER_SP_APP_ID A secret containing service principal password should be created on Kubernetes to facilitate presenting the challenge to Azure DNS. You can create the secret with the following command: $ kubectl create secret generic azuredns-config --from-literal = client-secret = $AZURE_CERT_MANAGER_SP_PASSWORD Get the variables for configuring the issuer. $ echo \"AZURE_CERT_MANAGER_SP_APP_ID: $AZURE_CERT_MANAGER_SP_APP_ID \" $ echo \"AZURE_CERT_MANAGER_SP_PASSWORD: $AZURE_CERT_MANAGER_SP_PASSWORD \" $ echo \"AZURE_SUBSCRIPTION_ID: $AZURE_SUBSCRIPTION_ID \" $ echo \"AZURE_TENANT_ID: $AZURE_TENANT_ID \" $ echo \"AZURE_DNS_ZONE: $AZURE_DNS_ZONE \" $ echo \"AZURE_DNS_ZONE_RESOURCE_GROUP: $AZURE_DNS_ZONE_RESOURCE_GROUP \" To configure the issuer, substitute the capital cased variables with the values from the previous script. You can get the subscription id from the Azure portal. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : clientID : AZURE_CERT_MANAGER_SP_APP_ID clientSecretSecretRef : # The following is the secret we created in Kubernetes. Issuer will use this to present challenge to Azure DNS. name : azuredns-config key : client-secret subscriptionID : AZURE_SUBSCRIPTION_ID tenantID : AZURE_TENANT_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud","title":"AzureDNS"},{"location":"configuration/acme/dns01/azuredns/#managed-identity-using-aad-pod-identities","text":"AAD Pod Identities allows assigning a Managed Identity to a pod. This removes the need for adding explicit credentials into the cluster to create the required DNS records. Note: When using Pod identity, even though assigning multiple identities to a single pod is allowed, currently cert-manager does not support this as it is not able to identify which identity to use. Firstly an identity should be created that has access to contribute to the DNS Zone. Example creation using azure-cli and jq : # Choose a unique Identity name and existing resource group to create identity in. IDENTITY = $( az identity create --name $IDENTITY_NAME --resource-group $IDENTITY_GROUP --output json ) # Gets principalId to use for role assignment PRINCIPAL_ID = $( echo $IDENTITY | jq -r '.principalId' ) # Used for identity binding CLIENT_ID = $( echo $IDENTITY | jq -r '.clientId' ) RESOURCE_ID = $( echo $IDENTITY | jq -r '.id' ) # Get existing DNS Zone Id ZONE_ID = $( az network dns zone show --name $ZONE_NAME --resource-group $ZONE_GROUP --query \"id\" -o tsv ) # Create role assignment az role assignment create --role \"DNS Zone Contributor\" --assignee $PRINCIPAL_ID --scope $ZONE_ID Example creation using Terraform variable resource_group_name {} variable location {} variable dns_zone_id {} # Creates Identity resource \"azurerm_user_assigned_identity\" \"dns_identity\" { name = \"cert-manager-dns01\" resource_group_name = var.resource_group_name location = var.location } # Creates Role Assignment resource \"azurerm_role_assignment\" \"dns_contributor\" { scope = var.dns_zone_id role_definition_name = \"DNS Zone Contributor\" principal_id = azurerm_user_assigned_identity.dns_identity.principal_id } # Client Id Used for identity binding output \"identity_client_id\" { value = azurerm_user_assigned_identity.dns_identity.client_id } # Resource Id Used for identity binding output \"identity_resource_id\" { value = azurerm_user_assigned_identity.dns_identity.id } Next we need to ensure we have installed AAD Pod Identity using their walk-through. This will install the CRDs and deployment required to assign the identity. Now we can create the identity resource and binding using the below manifest as an example: apiVersion : \"aadpodidentity.k8s.io/v1\" kind : AzureIdentity metadata : annotations : # recommended to use namespaced identites https://azure.github.io/aad-pod-identity/docs/configure/match_pods_in_namespace/ aadpodidentity.k8s.io/Behavior : namespaced name : certman-identity namespace : cert-manager # change to your preferred namespace spec : type : 0 # MSI resourceID : <Identity_Id> # Resource Id From Previous step clientID : <Client_Id> # Client Id from previous step --- apiVersion : \"aadpodidentity.k8s.io/v1\" kind : AzureIdentityBinding metadata : name : certman-id-binding namespace : cert-manager # change to your preferred namespace spec : azureIdentity : certman-identity selector : certman-label # This is the label that needs to be set on cert-manager pods Next we need to ensure the cert-manager pod has a relevant label to use the pod identity binding. This can be done by editing the deployment and adding the below into the .spec.template.metadata.labels field spec : template : metadata : labels : aadpodidbinding : certman-label # must match selector in AzureIdentityBinding Or by using the helm values podLabels podLabels : aadpodidbinding : certman-label Lastly when we create the certificate issuer we only need to specify the hostedZoneName , resourceGroupName and subscriptionID fields for the DNS zone. Example below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : subscriptionID : AZURE_SUBSCRIPTION_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud This authentication mechanism is what cert-manager considers 'ambient credentials'. Use of ambient credentials is disabled by default for cert-manager Issuer s. This to ensure unprivileged users who have permission to create issuers cannot issue certificates using any credentials cert-manager incidentally has access to. To enable this authentication mechanism for Issuer s, you will need to set --issuer-ambient-credentials flag on cert-manager controller to true. (There is a corresponding --cluster-issuer-ambient-credentials flag which is set to true by default). If you are using this authentication mechanism and ambient credentials are not enabled, you will see this error: error instantiating azuredns challenge solver: ClientID is not set but neither --cluster-issuer-ambient-credentials nor --issuer-ambient-credentials are set. These are necessary to enable Azure Managed Identities.","title":"Managed Identity Using AAD Pod Identities"},{"location":"configuration/acme/dns01/azuredns/#managed-identity-using-aks-kubelet-identity","text":"When creating an AKS cluster in Azure there is the option to use a managed identity that is assigned to the kubelet. This identity is assigned to the underlying node pool in the AKS cluster and can then be used by the cert-manager pods to authenticate to Azure Active Directory. There are some caveats with this approach, these mainly being: Any permissions granted to this identity will also be accessible to all containers running inside the Kubernetes cluster. Using AKS extensions like Kube Dashboard , Virtual Node , or HTTP Application Routing (see full list here ) will create additional identities that are assigned to your node pools. If your node pools have more than one identity assigned, you will need to specify either clientID or resourceID to select the correct one. To set this up, firstly you will need to retrieve the identity that the kubelet is using by querying the AKS cluster. This can then be used to create the appropriate permissions in the DNS zone. Example commands using azure-cli : # Get AKS Kubelet Identity PRINCIPAL_ID = $( az aks show -n $CLUSTERNAME -g $CLUSTER_GROUP --query \"identityProfile.kubeletidentity.objectId\" -o tsv ) # Get existing DNS Zone Id ZONE_ID = $( az network dns zone show --name $ZONE_NAME --resource-group $ZONE_GROUP --query \"id\" -o tsv ) # Create role assignment az role assignment create --role \"DNS Zone Contributor\" --assignee $PRINCIPAL_ID --scope $ZONE_ID Example terraform: variable dns_zone_id {} # Creating the AKS cluster, abbreviated. resource \"azurerm_kubernetes_cluster\" \"cluster\" { ... # Creates Identity associated to kubelet identity { type = \"SystemAssigned\" } ... } resource \"azurerm_role_assignment\" \"dns_contributor\" { scope = var.dns_zone_id role_definition_name = \"DNS Zone Contributor\" principal_id = azurerm_kubernetes_cluster.cluster.kubelet_identity[0].object_id skip_service_principal_aad_check = true # Allows skipping propagation of identity to ensure assignment succeeds. } Then when creating the cert-manager issuer we need to specify the hostedZoneName , resourceGroupName and subscriptionID fields for the DNS Zone. We also need to specify managedIdentity.clientID or managedIdentity.resourceID if multiple managed identities are assigned to the node pools. The value for managedIdentity.clientID can be fetched by running this command: az aks show -n $CLUSTERNAME -g $CLUSTER_GROUP --query \"identityProfile.kubeletidentity.clientId\" -o tsv Example below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : subscriptionID : AZURE_SUBSCRIPTION_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud # optional, only required if node pools have more than 1 managed identity assigned managedIdentity : # client id of the node pool managed identity (can not be set at the same time as resourceID) clientID : YOUR_MANAGED_IDENTITY_CLIENT_ID # resource id of the managed identity (can not be set at the same time as clientID) # resourceID: YOUR_MANAGED_IDENTITY_RESOURCE_ID","title":"Managed Identity Using AKS Kubelet Identity"},{"location":"configuration/acme/dns01/azuredns/#service-principal","text":"Configuring the AzureDNS DNS01 Challenge for a Kubernetes cluster requires creating a service principal in Azure. To create the service principal you can use the following script (requires azure-cli and jq ): # Choose a name for the service principal that contacts azure DNS to present # the challenge. $ AZURE_CERT_MANAGER_NEW_SP_NAME = NEW_SERVICE_PRINCIPAL_NAME # This is the name of the resource group that you have your dns zone in. $ AZURE_DNS_ZONE_RESOURCE_GROUP = AZURE_DNS_ZONE_RESOURCE_GROUP # The DNS zone name. It should be something like domain.com or sub.domain.com. $ AZURE_DNS_ZONE = AZURE_DNS_ZONE $ DNS_SP = $( az ad sp create-for-rbac --name $AZURE_CERT_MANAGER_NEW_SP_NAME --output json ) $ AZURE_CERT_MANAGER_SP_APP_ID = $( echo $DNS_SP | jq -r '.appId' ) $ AZURE_CERT_MANAGER_SP_PASSWORD = $( echo $DNS_SP | jq -r '.password' ) $ AZURE_TENANT_ID = $( echo $DNS_SP | jq -r '.tenant' ) $ AZURE_SUBSCRIPTION_ID = $( az account show --output json | jq -r '.id' ) For security purposes, it is appropriate to utilize RBAC to ensure that you properly maintain access control to your resources in Azure. The service principal that is generated by this tutorial has fine-grained access to ONLY the DNS Zone in the specific resource group specified. It requires this permission so that it can read/write the _acme_challenge TXT records to the zone. Lower the Permissions of the service principal. $ az role assignment delete --assignee $AZURE_CERT_MANAGER_SP_APP_ID --role Contributor Give Access to DNS Zone. $ DNS_ID = $( az network dns zone show --name $AZURE_DNS_ZONE --resource-group $AZURE_DNS_ZONE_RESOURCE_GROUP --query \"id\" --output tsv ) $ az role assignment create --assignee $AZURE_CERT_MANAGER_SP_APP_ID --role \"DNS Zone Contributor\" --scope $DNS_ID Check Permissions. As the result of the following command, we would like to see just one object in the permissions array with \"DNS Zone Contributor\" role. $ az role assignment list --all --assignee $AZURE_CERT_MANAGER_SP_APP_ID A secret containing service principal password should be created on Kubernetes to facilitate presenting the challenge to Azure DNS. You can create the secret with the following command: $ kubectl create secret generic azuredns-config --from-literal = client-secret = $AZURE_CERT_MANAGER_SP_PASSWORD Get the variables for configuring the issuer. $ echo \"AZURE_CERT_MANAGER_SP_APP_ID: $AZURE_CERT_MANAGER_SP_APP_ID \" $ echo \"AZURE_CERT_MANAGER_SP_PASSWORD: $AZURE_CERT_MANAGER_SP_PASSWORD \" $ echo \"AZURE_SUBSCRIPTION_ID: $AZURE_SUBSCRIPTION_ID \" $ echo \"AZURE_TENANT_ID: $AZURE_TENANT_ID \" $ echo \"AZURE_DNS_ZONE: $AZURE_DNS_ZONE \" $ echo \"AZURE_DNS_ZONE_RESOURCE_GROUP: $AZURE_DNS_ZONE_RESOURCE_GROUP \" To configure the issuer, substitute the capital cased variables with the values from the previous script. You can get the subscription id from the Azure portal. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : azureDNS : clientID : AZURE_CERT_MANAGER_SP_APP_ID clientSecretSecretRef : # The following is the secret we created in Kubernetes. Issuer will use this to present challenge to Azure DNS. name : azuredns-config key : client-secret subscriptionID : AZURE_SUBSCRIPTION_ID tenantID : AZURE_TENANT_ID resourceGroupName : AZURE_DNS_ZONE_RESOURCE_GROUP hostedZoneName : AZURE_DNS_ZONE # Azure Cloud Environment, default to AzurePublicCloud environment : AzurePublicCloud","title":"Service Principal"},{"location":"configuration/acme/dns01/cloudflare/","text":"To use Cloudflare, you may use one of two types of tokens. API Tokens allow application-scoped keys bound to specific zones and permissions, while API Keys are globally-scoped keys that carry the same permissions as your account. API Tokens are recommended for higher security, since they have more restrictive permissions and are more easily revocable. API Tokens \u00b6 Tokens can be created at User Profile > API Tokens > API Tokens . The following settings are recommended: Permissions: Zone - DNS - Edit Zone - Zone - Read Zone Resources: Include - All Zones To create a new Issuer , first make a Kubernetes secret containing your new API token: apiVersion : v1 kind : Secret metadata : name : cloudflare-api-token-secret type : Opaque stringData : api-token : <API Token> Then in your Issuer manifest: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudflare : apiTokenSecretRef : name : cloudflare-api-token-secret key : api-token API Keys \u00b6 API keys can be retrieved at User Profile > API Tokens > API Keys > Global API Key > View . To create a new Issuer , first make a Kubernetes secret containing your API key: apiVersion : v1 kind : Secret metadata : name : cloudflare-api-key-secret type : Opaque stringData : api-key : <API Key> Then in your Issuer manifest: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key Troubleshooting \u00b6 Actor com.cloudflare.api.token.xxxx requires permission com.cloudflare.api.account.zone.list to list zones \u00b6 If you get the error that your token does not have the correct permission to list zones there can be 2 causes. 1. The token lacks the Zone - Zone - Read permission 2. cert-manager identified the wrong zone name for the domain due to DNS issues. In the case of the 2 nd issue you will see an error like below: Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 6s cert-manager Challenge scheduled for processing Warning PresentError 3s (x2 over 3s) cert-manager Error presenting challenge: Cloudflare API Error for GET \"/zones?name=<TLD>\" Error: 0: Actor 'com.cloudflare.api.token.xxxx' requires permission 'com.cloudflare.api.account.zone.list' to list zones In this case we recommend changing your DNS01 self-check nameservers . Cloudflare API error for POST \"/zones/<id>/dns_records generic error \u00b6 You might be hitting this as Cloudflare blocks the use of the API to update DNS records for the following TLDs: .cf , .ga , .gq , .ml and .tk . This is discussed in the Cloudflare Community . We recommend using an alternative DNS provider when using these TLDs.","title":"Cloudflare"},{"location":"configuration/acme/dns01/cloudflare/#api-tokens","text":"Tokens can be created at User Profile > API Tokens > API Tokens . The following settings are recommended: Permissions: Zone - DNS - Edit Zone - Zone - Read Zone Resources: Include - All Zones To create a new Issuer , first make a Kubernetes secret containing your new API token: apiVersion : v1 kind : Secret metadata : name : cloudflare-api-token-secret type : Opaque stringData : api-token : <API Token> Then in your Issuer manifest: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudflare : apiTokenSecretRef : name : cloudflare-api-token-secret key : api-token","title":"API Tokens"},{"location":"configuration/acme/dns01/cloudflare/#api-keys","text":"API keys can be retrieved at User Profile > API Tokens > API Keys > Global API Key > View . To create a new Issuer , first make a Kubernetes secret containing your API key: apiVersion : v1 kind : Secret metadata : name : cloudflare-api-key-secret type : Opaque stringData : api-key : <API Key> Then in your Issuer manifest: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key","title":"API Keys"},{"location":"configuration/acme/dns01/cloudflare/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"configuration/acme/dns01/cloudflare/#actor-comcloudflareapitokenxxxx-requires-permission-comcloudflareapiaccountzonelist-to-list-zones","text":"If you get the error that your token does not have the correct permission to list zones there can be 2 causes. 1. The token lacks the Zone - Zone - Read permission 2. cert-manager identified the wrong zone name for the domain due to DNS issues. In the case of the 2 nd issue you will see an error like below: Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 6s cert-manager Challenge scheduled for processing Warning PresentError 3s (x2 over 3s) cert-manager Error presenting challenge: Cloudflare API Error for GET \"/zones?name=<TLD>\" Error: 0: Actor 'com.cloudflare.api.token.xxxx' requires permission 'com.cloudflare.api.account.zone.list' to list zones In this case we recommend changing your DNS01 self-check nameservers .","title":"Actor com.cloudflare.api.token.xxxx requires permission com.cloudflare.api.account.zone.list to list zones"},{"location":"configuration/acme/dns01/cloudflare/#cloudflare-api-error-for-post-zonesiddns_records-generic-error","text":"You might be hitting this as Cloudflare blocks the use of the API to update DNS records for the following TLDs: .cf , .ga , .gq , .ml and .tk . This is discussed in the Cloudflare Community . We recommend using an alternative DNS provider when using these TLDs.","title":"Cloudflare API error for POST \"/zones/&lt;id&gt;/dns_records generic error"},{"location":"configuration/acme/dns01/digitalocean/","text":"This provider uses a Kubernetes Secret resource to work. In the following example, the Secret will have to be named digitalocean-dns and have a sub-key access-token with the token in it. For example: apiVersion : v1 kind : Secret metadata : name : digitalocean-dns data : # insert your DO access token here access-token : \"base64 encoded access-token here\" ``` The access token must have write access. To create a Personal Access Token, see [DigitalOcean documentation](https://docs.digitalocean.com/reference/api/create-personal-access-token/). Handy direct link : https://cloud.digitalocean.com/account/api/tokens/new To encode your access token into base64, you can use the following ``` bash echo -n 'your-access-token' | base64 apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : digitalocean : tokenSecretRef : name : digitalocean-dns key : access-token","title":"DigitalOcean"},{"location":"configuration/acme/dns01/google/","text":"This guide explains how to set up an Issuer , or ClusterIssuer , to use Google CloudDNS to solve DNS01 ACME challenges. It's advised you read the DNS01 Challenge Provider page first for a more general understanding of how cert-manager handles DNS01 challenges. This guide assumes that your cluster is hosted on Google Cloud Platform (GCP) and that you already have a domain set up with CloudDNS. You'll need to be using a Public DNS Zone , so that the ACME challenge checker is able to access the DNS records that cert-manager will create. Set up a Service Account \u00b6 cert-manager needs to be able to add records to CloudDNS in order to solve the DNS01 challenge. To enable this, a GCP service account must be created with the dns.admin role. Note: For this guide the gcloud command will be used to set up the service account. Ensure that gcloud is using the correct project and zone before entering the commands. These steps could also be completed using the Cloud Console. PROJECT_ID = myproject-id gcloud iam service-accounts create dns01-solver --display-name \"dns01-solver\" In the command above, replace myproject-id with the ID of your project. gcloud projects add-iam-policy-binding $PROJECT_ID \\ --member serviceAccount:dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com \\ --role roles/dns.admin Note : The use of the dns.admin role in this example role is for convenience. If you want to ensure cert-manager runs under a least privilege service account, you will need to create a custom role with the following permissions: dns.resourceRecordSets.* dns.changes.* dns.managedZones.list Use Static Credentials \u00b6 Follow the instructions in the following sections to deploy cert-manager using static credentials for the service account you created. You should rotate these credentials periodically. Create a Service Account Secret \u00b6 To access this service account, cert-manager uses a key stored in a Kubernetes Secret . First, create a key for the service account and download it as a JSON file, then create a Secret from this file. Keep the key file safe and do not share it, as it could be used to gain access access to your cloud resources. The key file can be deleted once it has been used to generate the Secret . If you did not create the service account dns01-solver before, you need to create it first. gcloud iam service-accounts create dns01-solver Replace instances of $PROJECT_ID with the ID of your project. gcloud iam service-accounts keys create key.json \\ --iam-account dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com kubectl create secret generic clouddns-dns01-solver-svc-acct \\ --from-file = key.json Note: If you have already added the Secret but get an error: ...due to error processing: error getting clouddns service account: secret \"XXX\" not found , the Secret may be in the wrong namespace. If you're configuring a ClusterIssuer , move the Secret to the Cluster Resource Namespace which is cert-manager by default. If you're configuring an Issuer , the Secret should be stored in the same namespace as the Issuer resource. Create an Issuer That Uses CloudDNS \u00b6 Next, create an Issuer (or ClusterIssuer ) with a cloudDNS provider. An example Issuer manifest can be seen below with annotations. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudDNS : # The ID of the GCP project project : $PROJECT_ID # This is the secret used to access the service account serviceAccountSecretRef : name : clouddns-dns01-solver-svc-acct key : key.json For more information about Issuers and ClusterIssuers , see Configuration . Once an Issuer (or ClusterIssuer ) has been created successfully, a Certificate can then be added to verify that everything works. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : # The issuer created previously name : example-issuer dnsNames : - example.com - www.example.com For more details about Certificates , see Usage . GKE Workload Identity \u00b6 If you are deploying cert-manager into a Google Container Engine (GKE) cluster with workload identity enabled, you can leverage workload identity to avoid creating and managing static service account credentials. The workload identity how-to provides more detail on how workload identity functions, but briefly workload identity allows you to link a Google service accounts (GSA) to Kubernetes service accounts (KSA). This GSA/KSA linking is two-way, i.e., you must establish the link in GCP and Kubernetes. Once configured, workload identity allows Kubernetes pods running under a KSA to access the GCP APIs with the permissions of the linked GSA. The workload identity how-to also provides detailed instructions on how to enable workload identity in your GKE cluster. The instructions in the following sections assume you are deploying cert-manager to a GKE cluster with workload identity already enabled. Link KSA to GSA in GCP \u00b6 The cert-manager component that needs to modify DNS records is the pod created as part of the cert-manager deployment. The standard methods for deploying cert-manager to Kubernetes create the cert-manager deployment in the cert-manager namespace and its pod spec specifies it runs under the cert-manager service account. To link the GSA you created above to the cert-manager KSA in the cert-manager namespace in your GKE cluster, run the following command. gcloud iam service-accounts add-iam-policy-binding \\ --role roles/iam.workloadIdentityUser \\ --member \"serviceAccount: $PROJECT_ID .svc.id.goog[cert-manager/cert-manager]\" \\ dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com If your cert-manager pods are running under a different service account, replace goog[cert-manager/cert-manager] with goog[NAMESPACE/SERVICE_ACCOUNT] , where NAMESPACE is the namespace of the service account and SERVICE_ACCOUNT is the name of the service account. Link KSA to GSA in Kubernetes \u00b6 After deploying cert-manager, add the proper workload identity annotation to the cert-manager service account. kubectl annotate serviceaccount --namespace = cert-manager cert-manager \\ \"iam.gke.io/gcp-service-account=dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com\" Again, if your cert-manager pods are running under a different service account, replace --namespace=cert-manager cert-manager with --namespace=NAMESPACE SERVICE_ACCOUNT , where NAMESPACE is the namespace of the service account and SERVICE_ACCOUNT is the name of the service account. If you are deploying cert-manager using its helm chart, you can use the serviceAccount.annotations configuration parameter to add the above workload identity annotation to the cert-manager KSA. Create an Issuer That Uses CloudDNS \u00b6 Next, create an Issuer (or ClusterIssuer ) with a clouddns provider. An example Issuer manifest can be seen below with annotations. Note that the issuer does not include a serviceAccountSecretRef property. Excluding this instructs cert-manager to use the default credentials provided by GKE workload identity. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudDNS : # The ID of the GCP project project : $PROJECT_ID For more information about Issuers and ClusterIssuers , see Configuration . Once an Issuer (or ClusterIssuer ) has been created successfully, a Certificate can then be added to verify that everything works. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : # The issuer created previously name : example-issuer dnsNames : - example.com - www.example.com For more details about Certificates , see Usage .","title":"Google CloudDNS"},{"location":"configuration/acme/dns01/google/#set-up-a-service-account","text":"cert-manager needs to be able to add records to CloudDNS in order to solve the DNS01 challenge. To enable this, a GCP service account must be created with the dns.admin role. Note: For this guide the gcloud command will be used to set up the service account. Ensure that gcloud is using the correct project and zone before entering the commands. These steps could also be completed using the Cloud Console. PROJECT_ID = myproject-id gcloud iam service-accounts create dns01-solver --display-name \"dns01-solver\" In the command above, replace myproject-id with the ID of your project. gcloud projects add-iam-policy-binding $PROJECT_ID \\ --member serviceAccount:dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com \\ --role roles/dns.admin Note : The use of the dns.admin role in this example role is for convenience. If you want to ensure cert-manager runs under a least privilege service account, you will need to create a custom role with the following permissions: dns.resourceRecordSets.* dns.changes.* dns.managedZones.list","title":"Set up a Service Account"},{"location":"configuration/acme/dns01/google/#use-static-credentials","text":"Follow the instructions in the following sections to deploy cert-manager using static credentials for the service account you created. You should rotate these credentials periodically.","title":"Use Static Credentials"},{"location":"configuration/acme/dns01/google/#create-a-service-account-secret","text":"To access this service account, cert-manager uses a key stored in a Kubernetes Secret . First, create a key for the service account and download it as a JSON file, then create a Secret from this file. Keep the key file safe and do not share it, as it could be used to gain access access to your cloud resources. The key file can be deleted once it has been used to generate the Secret . If you did not create the service account dns01-solver before, you need to create it first. gcloud iam service-accounts create dns01-solver Replace instances of $PROJECT_ID with the ID of your project. gcloud iam service-accounts keys create key.json \\ --iam-account dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com kubectl create secret generic clouddns-dns01-solver-svc-acct \\ --from-file = key.json Note: If you have already added the Secret but get an error: ...due to error processing: error getting clouddns service account: secret \"XXX\" not found , the Secret may be in the wrong namespace. If you're configuring a ClusterIssuer , move the Secret to the Cluster Resource Namespace which is cert-manager by default. If you're configuring an Issuer , the Secret should be stored in the same namespace as the Issuer resource.","title":"Create a Service Account Secret"},{"location":"configuration/acme/dns01/google/#create-an-issuer-that-uses-clouddns","text":"Next, create an Issuer (or ClusterIssuer ) with a cloudDNS provider. An example Issuer manifest can be seen below with annotations. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudDNS : # The ID of the GCP project project : $PROJECT_ID # This is the secret used to access the service account serviceAccountSecretRef : name : clouddns-dns01-solver-svc-acct key : key.json For more information about Issuers and ClusterIssuers , see Configuration . Once an Issuer (or ClusterIssuer ) has been created successfully, a Certificate can then be added to verify that everything works. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : # The issuer created previously name : example-issuer dnsNames : - example.com - www.example.com For more details about Certificates , see Usage .","title":"Create an Issuer That Uses CloudDNS"},{"location":"configuration/acme/dns01/google/#gke-workload-identity","text":"If you are deploying cert-manager into a Google Container Engine (GKE) cluster with workload identity enabled, you can leverage workload identity to avoid creating and managing static service account credentials. The workload identity how-to provides more detail on how workload identity functions, but briefly workload identity allows you to link a Google service accounts (GSA) to Kubernetes service accounts (KSA). This GSA/KSA linking is two-way, i.e., you must establish the link in GCP and Kubernetes. Once configured, workload identity allows Kubernetes pods running under a KSA to access the GCP APIs with the permissions of the linked GSA. The workload identity how-to also provides detailed instructions on how to enable workload identity in your GKE cluster. The instructions in the following sections assume you are deploying cert-manager to a GKE cluster with workload identity already enabled.","title":"GKE Workload Identity"},{"location":"configuration/acme/dns01/google/#link-ksa-to-gsa-in-gcp","text":"The cert-manager component that needs to modify DNS records is the pod created as part of the cert-manager deployment. The standard methods for deploying cert-manager to Kubernetes create the cert-manager deployment in the cert-manager namespace and its pod spec specifies it runs under the cert-manager service account. To link the GSA you created above to the cert-manager KSA in the cert-manager namespace in your GKE cluster, run the following command. gcloud iam service-accounts add-iam-policy-binding \\ --role roles/iam.workloadIdentityUser \\ --member \"serviceAccount: $PROJECT_ID .svc.id.goog[cert-manager/cert-manager]\" \\ dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com If your cert-manager pods are running under a different service account, replace goog[cert-manager/cert-manager] with goog[NAMESPACE/SERVICE_ACCOUNT] , where NAMESPACE is the namespace of the service account and SERVICE_ACCOUNT is the name of the service account.","title":"Link KSA to GSA in GCP"},{"location":"configuration/acme/dns01/google/#link-ksa-to-gsa-in-kubernetes","text":"After deploying cert-manager, add the proper workload identity annotation to the cert-manager service account. kubectl annotate serviceaccount --namespace = cert-manager cert-manager \\ \"iam.gke.io/gcp-service-account=dns01-solver@ $PROJECT_ID .iam.gserviceaccount.com\" Again, if your cert-manager pods are running under a different service account, replace --namespace=cert-manager cert-manager with --namespace=NAMESPACE SERVICE_ACCOUNT , where NAMESPACE is the namespace of the service account and SERVICE_ACCOUNT is the name of the service account. If you are deploying cert-manager using its helm chart, you can use the serviceAccount.annotations configuration parameter to add the above workload identity annotation to the cert-manager KSA.","title":"Link KSA to GSA in Kubernetes"},{"location":"configuration/acme/dns01/google/#create-an-issuer-that-uses-clouddns_1","text":"Next, create an Issuer (or ClusterIssuer ) with a clouddns provider. An example Issuer manifest can be seen below with annotations. Note that the issuer does not include a serviceAccountSecretRef property. Excluding this instructs cert-manager to use the default credentials provided by GKE workload identity. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : cloudDNS : # The ID of the GCP project project : $PROJECT_ID For more information about Issuers and ClusterIssuers , see Configuration . Once an Issuer (or ClusterIssuer ) has been created successfully, a Certificate can then be added to verify that everything works. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : # The issuer created previously name : example-issuer dnsNames : - example.com - www.example.com For more details about Certificates , see Usage .","title":"Create an Issuer That Uses CloudDNS"},{"location":"configuration/acme/dns01/rfc2136/","text":"The goal of this document is to provide a configuration overview of the various facilities required to deploy cert-manager against a RFC2136 compliant DNS server such as BIND named . This capability is also commonly known as \u201cdynamic DNS\u201d. Unlike the peer of other cert-manager DNS integrations, named is a bit of a \u201cSwiss Army Knife\u201d of domain name servers. Over the years, it has been highly optimized to provide maximal vertical scalability for a single node, as well as horizontal scalability with service provider interfaces. This flexibility makes it impossible to go into every possible named deployment that a user may run in to though. Instead, this document will try to make sure your server is ready to accept requests from cert-manager using command line tools, then get on to the making the two work together. Transaction Signatures \u21d2 TSIG \u00b6 Dynamic DNS updates are essentially server queries which otherwise might return resource records (RRs). Since DNS servers are commonly exposed to the public internet, being able to push an unauthenticated update to any server that responds to queries would be immediately untenable. In the eyes of the named architects, the generic solution to this problem space was twofold. The first is to require manual enablement of updates at a zone level, such as example.com . In a naive network, there is no requirement that zone updates have any security to them, and clients can be configured such that they can provide updates without any authentication. An example of where this is useful is for machines booting using DHCP, in this case the machines know about themselves and the DNS server can be configured to accept updates when they come from the address being configured. This clearly has limitations in situations such as cert-manager and the DNS01 challenge. In this environment, a TXT RR must be created after coordination with the ACME server. After negotiating with the ACME server, a the TXT RR that is published on the domain validates that the domain is legitimately engaged with the process of creating a certificate for it. In the bigger picture of DNS, this means that an arbitrary actor (cert-manager, in this case) must be able to add one of these KV mappings to the domain and delete it after the certificate has been issued. cert-manager does not have a convenient physical characteristic such as a DHCP allocation to validate it's requests. For cases like this, we need to be able to sign a request that is being sent to the DNS server. We do that through TSIGs, or Transaction SIGnatures. Configuration Step 1 - Set up your DNS server for secure dynamic updates \u00b6 There are many excellent tutorials on the net that walk through preparing a basic named server for dynamic updates: https://www.cyberciti.biz/faq/unix-linux-bind-named-configuring-tsig/ https://tomthorp.me/blog/using-tsig-enable-secure-zone-transfers-between-bind-9x-servers More complex name deployments will not use text files, but rather may use LDAP or SQL for a database for resource records. An additional wrinkle is metadata configuration, such as for zone metadata like enabling dynamic updates or access control lists (ACLs) for a zone. There are too many configurations to go into here, but you should be able to find the documentation to do so. Whatever your deployment is, the goal at this stage has nothing to do with cert-manager and everything to do with a tool called nsupdate generating updates signed with TSIG. Once this is out of the way, you can attack the cert-manager configuration with far greater confidence. Using nsupdate \u00b6 Most paths to configuring BIND named will go through using dnssec-keygen . This command-line tool generates a named private key that is used for signing TSIG requests. When a request is signed, both the signature and the name of the private key are attached to the request in an unencrypted form. In this manner, when the request is received, the name of the private key can be used to by the recipient to find the private key itself, build a new signature with it, and compare the two for acceptance. Since there are dozens of ways to have your named server misconfigured, we\u2019ll use nsupdate to test that the server behaves as expected before we get there. https://debian-administration.org/article/591/Using_the_dynamic_DNS_editor_nsupdate is a solid breakdown of how to use the tool. To get started, we\u2019ll simply run nsupdate -k <keyID> where keyID is the value returned from dnssec-keygen . This will read the key from disk and provide a command prompt to issue commands. In general, we want to write a simple TXT RR and make sure we can delete it. $ nsupdate -k <keyID> update add www1.example.com 60 txt testing send \u2026 test here with ` nslookup ` update delete www1.example.com txt send \u2026 test here with ` nslookup ` Any failures to write, read or delete the record will mean that cert-manager will not be able to do so either, no matter how well it is configured. Configuration Step 2 - Set up cert-manager \u00b6 Now we get to the fun stuff, seeing everything work. Remember that we need to set up the ACME DNS01 issuer and challenge mechanism as well as the rfc2136 provider. Since the documentation covers the other parts sufficiently, let\u2019s focus on the provider here. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : rfc2136 : nameserver : <address of authoritative nameserver configured above> tsigKeyName : <key name used in `dnssec-keygen`, use something semantically meaningful in both environments> tsigAlgorithm : HMACSHA512 // should be matched to the algo you chose in `dnssec-keygen` tsigSecretSecretRef : name : <the name of the k8s secret holding the TSIG key.. not the key itself!> key : <name of the key *inside* the secret> For example: rfc2136 : nameserver : 1.2.3.4:53 tsigKeyName : example-com-secret tsigAlgorithm : HMACSHA512 tsigSecretSecretRef : name : tsig-secret key : tsig-secret-key For this example configuration, we\u2019ll need the following two commands. The first, on your named server generates the key. Note how example-com-secret is both in the tsigKeyName above and the dnssec-keygen command that follows. $ dnssec-keygen -r /dev/urandom -a HMAC-SHA512 -b 512 -n HOST example-com-secret Also note how the tsigAlgorithm is provided in both the configuration and the keygen command. They are listed at https://github.com/miekg/dns/blob/v1.0.12/tsig.go#L18-L23 . The second bit of configuration you need on the Kubernetes side is to create a secret. Pulling the secret key string from the <key>.private file generated above, use the secret in the placeholder below: $ kubectl -n cert-manager create secret generic tsig-secret --from-literal = tsig-secret-key = <somesecret> Note how the tsig-secret and tsig-secret-key match the configuration in the tsigSecretSecretRef above. Rate Limits \u00b6 The rfc2136 provider waits until all nameservers to in your domain's SOA RR respond with the same result before it contacts Let's Encrypt to complete the challenge process. This is because the challenge server contacts a non-authoritative DNS server that does a recursive query (a query for records it does not maintain locally). If the servers in the SOA do not contain the correct values, it's likely that the non-authoritative server will have bad information as well, causing the request to go against rate limits and eventually locking the process out. This process is in place to protect users from server misconfiguration creating a more subtle lockout that persists after the server configuration has been repaired. As documented elsewhere, it is prudent to fully debug configurations using the ACME staging servers before using the production servers. The staging servers have less aggressive rate limits, but the certificates they issue are not signed with a root certificate trusted by browsers. What\u2019s next? \u00b6 This configuration so far will actually do nothing. You still have to request a certificate as described here . Once a certificate is requested, the provider will begin processing the request. Troubleshooting \u00b6 Be sure that you have fully tested the DNS server updates using nsupdate first. Ideally, this is done from a pod in the same namespace as the rfc2136 provider to ensure there are no firewall issues. The logs for the cert-manager pod are your friend. Additional logs can be generated by adding the --v=5 argument to the container launch. The TSIG key is encoded with base64 , but the Kubernetes API server also expects that key literals will be decoded before they are stored. In some cases, a key must be double-encoded. (If you've tested using nsupdate , it's pretty easy to spot when you are running into this.) Pay attention to the refresh time of the zone you are working with. For zones with low traffic, it will not make a significant difference to reduce the refresh time down to about five minutes while getting initial certificates. Once the process is working, the beauty of cert-manager is it doesn't matter if a renewal takes hours due to refresh times, it's all automated! Compared to the other providers that often use REST APIs to modify DNS RRs, this provider can take a little longer. You can watch kubectl certificate yourcert to get a display of what's going on. It's not uncommon for the process to take five minutes in total.","title":"RFC-2136"},{"location":"configuration/acme/dns01/rfc2136/#transaction-signatures-tsig","text":"Dynamic DNS updates are essentially server queries which otherwise might return resource records (RRs). Since DNS servers are commonly exposed to the public internet, being able to push an unauthenticated update to any server that responds to queries would be immediately untenable. In the eyes of the named architects, the generic solution to this problem space was twofold. The first is to require manual enablement of updates at a zone level, such as example.com . In a naive network, there is no requirement that zone updates have any security to them, and clients can be configured such that they can provide updates without any authentication. An example of where this is useful is for machines booting using DHCP, in this case the machines know about themselves and the DNS server can be configured to accept updates when they come from the address being configured. This clearly has limitations in situations such as cert-manager and the DNS01 challenge. In this environment, a TXT RR must be created after coordination with the ACME server. After negotiating with the ACME server, a the TXT RR that is published on the domain validates that the domain is legitimately engaged with the process of creating a certificate for it. In the bigger picture of DNS, this means that an arbitrary actor (cert-manager, in this case) must be able to add one of these KV mappings to the domain and delete it after the certificate has been issued. cert-manager does not have a convenient physical characteristic such as a DHCP allocation to validate it's requests. For cases like this, we need to be able to sign a request that is being sent to the DNS server. We do that through TSIGs, or Transaction SIGnatures.","title":"Transaction Signatures \u21d2 TSIG"},{"location":"configuration/acme/dns01/rfc2136/#configuration-step-1-set-up-your-dns-server-for-secure-dynamic-updates","text":"There are many excellent tutorials on the net that walk through preparing a basic named server for dynamic updates: https://www.cyberciti.biz/faq/unix-linux-bind-named-configuring-tsig/ https://tomthorp.me/blog/using-tsig-enable-secure-zone-transfers-between-bind-9x-servers More complex name deployments will not use text files, but rather may use LDAP or SQL for a database for resource records. An additional wrinkle is metadata configuration, such as for zone metadata like enabling dynamic updates or access control lists (ACLs) for a zone. There are too many configurations to go into here, but you should be able to find the documentation to do so. Whatever your deployment is, the goal at this stage has nothing to do with cert-manager and everything to do with a tool called nsupdate generating updates signed with TSIG. Once this is out of the way, you can attack the cert-manager configuration with far greater confidence.","title":"Configuration Step 1 - Set up your DNS server for secure dynamic updates"},{"location":"configuration/acme/dns01/rfc2136/#using-nsupdate","text":"Most paths to configuring BIND named will go through using dnssec-keygen . This command-line tool generates a named private key that is used for signing TSIG requests. When a request is signed, both the signature and the name of the private key are attached to the request in an unencrypted form. In this manner, when the request is received, the name of the private key can be used to by the recipient to find the private key itself, build a new signature with it, and compare the two for acceptance. Since there are dozens of ways to have your named server misconfigured, we\u2019ll use nsupdate to test that the server behaves as expected before we get there. https://debian-administration.org/article/591/Using_the_dynamic_DNS_editor_nsupdate is a solid breakdown of how to use the tool. To get started, we\u2019ll simply run nsupdate -k <keyID> where keyID is the value returned from dnssec-keygen . This will read the key from disk and provide a command prompt to issue commands. In general, we want to write a simple TXT RR and make sure we can delete it. $ nsupdate -k <keyID> update add www1.example.com 60 txt testing send \u2026 test here with ` nslookup ` update delete www1.example.com txt send \u2026 test here with ` nslookup ` Any failures to write, read or delete the record will mean that cert-manager will not be able to do so either, no matter how well it is configured.","title":"Using nsupdate"},{"location":"configuration/acme/dns01/rfc2136/#configuration-step-2-set-up-cert-manager","text":"Now we get to the fun stuff, seeing everything work. Remember that we need to set up the ACME DNS01 issuer and challenge mechanism as well as the rfc2136 provider. Since the documentation covers the other parts sufficiently, let\u2019s focus on the provider here. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : rfc2136 : nameserver : <address of authoritative nameserver configured above> tsigKeyName : <key name used in `dnssec-keygen`, use something semantically meaningful in both environments> tsigAlgorithm : HMACSHA512 // should be matched to the algo you chose in `dnssec-keygen` tsigSecretSecretRef : name : <the name of the k8s secret holding the TSIG key.. not the key itself!> key : <name of the key *inside* the secret> For example: rfc2136 : nameserver : 1.2.3.4:53 tsigKeyName : example-com-secret tsigAlgorithm : HMACSHA512 tsigSecretSecretRef : name : tsig-secret key : tsig-secret-key For this example configuration, we\u2019ll need the following two commands. The first, on your named server generates the key. Note how example-com-secret is both in the tsigKeyName above and the dnssec-keygen command that follows. $ dnssec-keygen -r /dev/urandom -a HMAC-SHA512 -b 512 -n HOST example-com-secret Also note how the tsigAlgorithm is provided in both the configuration and the keygen command. They are listed at https://github.com/miekg/dns/blob/v1.0.12/tsig.go#L18-L23 . The second bit of configuration you need on the Kubernetes side is to create a secret. Pulling the secret key string from the <key>.private file generated above, use the secret in the placeholder below: $ kubectl -n cert-manager create secret generic tsig-secret --from-literal = tsig-secret-key = <somesecret> Note how the tsig-secret and tsig-secret-key match the configuration in the tsigSecretSecretRef above.","title":"Configuration Step 2 - Set up cert-manager"},{"location":"configuration/acme/dns01/rfc2136/#rate-limits","text":"The rfc2136 provider waits until all nameservers to in your domain's SOA RR respond with the same result before it contacts Let's Encrypt to complete the challenge process. This is because the challenge server contacts a non-authoritative DNS server that does a recursive query (a query for records it does not maintain locally). If the servers in the SOA do not contain the correct values, it's likely that the non-authoritative server will have bad information as well, causing the request to go against rate limits and eventually locking the process out. This process is in place to protect users from server misconfiguration creating a more subtle lockout that persists after the server configuration has been repaired. As documented elsewhere, it is prudent to fully debug configurations using the ACME staging servers before using the production servers. The staging servers have less aggressive rate limits, but the certificates they issue are not signed with a root certificate trusted by browsers.","title":"Rate Limits"},{"location":"configuration/acme/dns01/rfc2136/#whats-next","text":"This configuration so far will actually do nothing. You still have to request a certificate as described here . Once a certificate is requested, the provider will begin processing the request.","title":"What\u2019s next?"},{"location":"configuration/acme/dns01/rfc2136/#troubleshooting","text":"Be sure that you have fully tested the DNS server updates using nsupdate first. Ideally, this is done from a pod in the same namespace as the rfc2136 provider to ensure there are no firewall issues. The logs for the cert-manager pod are your friend. Additional logs can be generated by adding the --v=5 argument to the container launch. The TSIG key is encoded with base64 , but the Kubernetes API server also expects that key literals will be decoded before they are stored. In some cases, a key must be double-encoded. (If you've tested using nsupdate , it's pretty easy to spot when you are running into this.) Pay attention to the refresh time of the zone you are working with. For zones with low traffic, it will not make a significant difference to reduce the refresh time down to about five minutes while getting initial certificates. Once the process is working, the beauty of cert-manager is it doesn't matter if a renewal takes hours due to refresh times, it's all automated! Compared to the other providers that often use REST APIs to modify DNS RRs, this provider can take a little longer. You can watch kubectl certificate yourcert to get a display of what's going on. It's not uncommon for the process to take five minutes in total.","title":"Troubleshooting"},{"location":"configuration/acme/dns01/route53/","text":"This guide explains how to set up an Issuer , or ClusterIssuer , to use Amazon Route53 to solve DNS01 ACME challenges. It's advised you read the DNS01 Challenge Provider page first for a more general understanding of how cert-manager handles DNS01 challenges. Note: This guide assumes that your cluster is hosted on Amazon Web Services (AWS) and that you already have a hosted zone in Route53. Set up an IAM Role \u00b6 cert-manager needs to be able to add records to Route53 in order to solve the DNS01 challenge. To enable this, create a IAM policy with the following permissions: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"route53:GetChange\" , \"Resource\" : \"arn:aws:route53:::change/*\" }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ChangeResourceRecordSets\" , \"route53:ListResourceRecordSets\" ], \"Resource\" : \"arn:aws:route53:::hostedzone/*\" }, { \"Effect\" : \"Allow\" , \"Action\" : \"route53:ListHostedZonesByName\" , \"Resource\" : \"*\" } ] } Note: The route53:ListHostedZonesByName statement can be removed if you specify the (optional) hostedZoneID . You can further tighten the policy by limiting the hosted zone that cert-manager has access to (e.g. arn:aws:route53:::hostedzone/DIKER8JEXAMPLE ). Credentials \u00b6 You have two options for the set up - either create a user or a role and attach that policy from above. Using a role is considered best practice because you do not have to store permanent credentials in a secret. cert-manager supports two ways of specifying credentials: explicit by providing a accessKeyID and secretAccessKey or implicit (using metadata service or environment variables or credentials file . cert-manager also supports specifying a role to enable cross-account access and/or limit the access of cert-manager. Integration with kiam and kube2iam should work out of the box. Cross Account Access \u00b6 Example: Account Y manages Route53 DNS Zones. Now you want cert-manager running in Account X (or many other accounts) to be able to manage records in Route53 zones hosted in Account Y. First, create a role with the permissions policy above (let's call the role dns-manager ) in Account Y, and attach a trust relationship like the one below. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"arn:aws:iam::XXXXXXXXXXX:role/cert-manager\" }, \"Action\" : \"sts:AssumeRole\" } ] } Bear in mind, that you won't be able to define this policy until cert-manager role on account Y is created. If you are setting this up using a configuration language, you may want to define principal as: \"Principal\" : { \"AWS\" : \"XXXXXXXXXXX\" } And restrict it, in a future step, after all the roles are created. This allows the role cert-manager in Account X to assume the dns-manager role in Account Y to manage the Route53 DNS zones in Account Y. For more information visit the official documentation . Second, create the cert-manager role in Account X; this will be used as a credentials source for the cert-manager pods running in Account X. Attach to the role the following permissions policy: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Resource\" : \"arn:aws:iam::YYYYYYYYYYYY:role/dns-manager\" , \"Action\" : \"sts:AssumeRole\" } ] } And the following trust relationship (Add AWS Service s as needed): { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"Service\" : \"ec2.amazonaws.com\" }, \"Action\" : \"sts:AssumeRole\" } ] } Creating an Issuer (or ClusterIssuer ) \u00b6 Here is an example configuration for a ClusterIssuer : apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-prod spec : acme : ... solvers : # example: cross-account zone management for example.com # this solver uses ambient credentials (i.e. inferred from the environment or EC2 Metadata Service) # to assume a role in a different account - selector : dnsZones : - \"example.com\" dns01 : route53 : region : us-east-1 hostedZoneID : DIKER8JEXAMPLE # optional, see policy above role : arn:aws:iam::YYYYYYYYYYYY:role/dns-manager # this solver handles example.org challenges # and uses explicit credentials - selector : dnsZones : - \"example.org\" dns01 : route53 : region : eu-central-1 accessKeyID : AKIAIOSFODNN7EXAMPLE secretAccessKeySecretRef : name : prod-route53-credentials-secret key : secret-access-key # you can also assume a role with these credentials role : arn:aws:iam::YYYYYYYYYYYY:role/dns-manager Note that, as mentioned above, the pod is using arn:aws:iam::XXXXXXXXXXX:role/cert-manager as a credentials source in Account X, but the ClusterIssuer ultimately assumes the arn:aws:iam::YYYYYYYYYYYY:role/dns-manager role to actually make changes in Route53 zones located in Account Y. EKS IAM Role for Service Accounts (IRSA) \u00b6 While kiam / kube2iam work directly with cert-manager, some special attention is needed for using the IAM Roles for Service Accounts feature available on EKS. OIDC provider \u00b6 First follow the AWS documentation Enabling IAM roles for service accounts on your cluster to ensure that the OIDC provider for the EKS cluster is enabled. The OIDC information is needed to create the trust relationship for the cert-manager role below. IAM role trust policy \u00b6 The cert-manager role needs the following trust relationship attached to the role in order to use the IRSA method. Replace the following: <aws-account-id> with the AWS account ID of the EKS cluster. <aws-region> with the region where the EKS cluster is located. <eks-hash> with the hash in the EKS API URL; this will be a random 32 character hex string (example: 45DABD88EEE3A227AF0FA468BE4EF0B5 ) <namespace> with the namespace where cert-manager is running. <service-account-name> with the name of the ServiceAccount object created by cert-manager. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"sts:AssumeRoleWithWebIdentity\" , \"Principal\" : { \"Federated\" : \"arn:aws:iam::<aws-account-id>:oidc-provider/oidc.eks.<aws-region>.amazonaws.com/id/<eks-hash>\" }, \"Condition\" : { \"StringEquals\" : { \"oidc.eks.<aws-region>.amazonaws.com/id/<eks-hash>:sub\" : \"system:serviceaccount:<namespace>:<service-account-name>\" } } } ] } Note: If you're following the Cross Account example above, this trust policy is attached to the cert-manager role in Account X with ARN arn:aws:iam::XXXXXXXXXXX:role/cert-manager . The permissions policy is the same as above. Service annotation \u00b6 Annotate the ServiceAccount created by cert-manager: apiVersion : v1 kind : ServiceAccount metadata : annotations : eks.amazonaws.com/role-arn : arn:aws:iam::XXXXXXXXXXX:role/cert-manager You will also need to modify the cert-manager Deployment with the correct file system permissions, so the ServiceAccount token can be read. spec : template : spec : securityContext : fsGroup : 1001 The cert-manager Helm chart provides a variable for injecting annotations into cert-manager's ServiceAccount and Deployment object like so: serviceAccount : annotations : eks.amazonaws.com/role-arn : arn:aws:iam::XXXXXXXXXXX:role/cert-manager securityContext : fsGroup : 1001 Note: If you're following the Cross Account example above, modify the ClusterIssuer in the same way as above with the role from Account Y.","title":"Route53"},{"location":"configuration/acme/dns01/route53/#set-up-an-iam-role","text":"cert-manager needs to be able to add records to Route53 in order to solve the DNS01 challenge. To enable this, create a IAM policy with the following permissions: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"route53:GetChange\" , \"Resource\" : \"arn:aws:route53:::change/*\" }, { \"Effect\" : \"Allow\" , \"Action\" : [ \"route53:ChangeResourceRecordSets\" , \"route53:ListResourceRecordSets\" ], \"Resource\" : \"arn:aws:route53:::hostedzone/*\" }, { \"Effect\" : \"Allow\" , \"Action\" : \"route53:ListHostedZonesByName\" , \"Resource\" : \"*\" } ] } Note: The route53:ListHostedZonesByName statement can be removed if you specify the (optional) hostedZoneID . You can further tighten the policy by limiting the hosted zone that cert-manager has access to (e.g. arn:aws:route53:::hostedzone/DIKER8JEXAMPLE ).","title":"Set up an IAM Role"},{"location":"configuration/acme/dns01/route53/#credentials","text":"You have two options for the set up - either create a user or a role and attach that policy from above. Using a role is considered best practice because you do not have to store permanent credentials in a secret. cert-manager supports two ways of specifying credentials: explicit by providing a accessKeyID and secretAccessKey or implicit (using metadata service or environment variables or credentials file . cert-manager also supports specifying a role to enable cross-account access and/or limit the access of cert-manager. Integration with kiam and kube2iam should work out of the box.","title":"Credentials"},{"location":"configuration/acme/dns01/route53/#cross-account-access","text":"Example: Account Y manages Route53 DNS Zones. Now you want cert-manager running in Account X (or many other accounts) to be able to manage records in Route53 zones hosted in Account Y. First, create a role with the permissions policy above (let's call the role dns-manager ) in Account Y, and attach a trust relationship like the one below. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"arn:aws:iam::XXXXXXXXXXX:role/cert-manager\" }, \"Action\" : \"sts:AssumeRole\" } ] } Bear in mind, that you won't be able to define this policy until cert-manager role on account Y is created. If you are setting this up using a configuration language, you may want to define principal as: \"Principal\" : { \"AWS\" : \"XXXXXXXXXXX\" } And restrict it, in a future step, after all the roles are created. This allows the role cert-manager in Account X to assume the dns-manager role in Account Y to manage the Route53 DNS zones in Account Y. For more information visit the official documentation . Second, create the cert-manager role in Account X; this will be used as a credentials source for the cert-manager pods running in Account X. Attach to the role the following permissions policy: { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Resource\" : \"arn:aws:iam::YYYYYYYYYYYY:role/dns-manager\" , \"Action\" : \"sts:AssumeRole\" } ] } And the following trust relationship (Add AWS Service s as needed): { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"Service\" : \"ec2.amazonaws.com\" }, \"Action\" : \"sts:AssumeRole\" } ] }","title":"Cross Account Access"},{"location":"configuration/acme/dns01/route53/#creating-an-issuer-or-clusterissuer","text":"Here is an example configuration for a ClusterIssuer : apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : name : letsencrypt-prod spec : acme : ... solvers : # example: cross-account zone management for example.com # this solver uses ambient credentials (i.e. inferred from the environment or EC2 Metadata Service) # to assume a role in a different account - selector : dnsZones : - \"example.com\" dns01 : route53 : region : us-east-1 hostedZoneID : DIKER8JEXAMPLE # optional, see policy above role : arn:aws:iam::YYYYYYYYYYYY:role/dns-manager # this solver handles example.org challenges # and uses explicit credentials - selector : dnsZones : - \"example.org\" dns01 : route53 : region : eu-central-1 accessKeyID : AKIAIOSFODNN7EXAMPLE secretAccessKeySecretRef : name : prod-route53-credentials-secret key : secret-access-key # you can also assume a role with these credentials role : arn:aws:iam::YYYYYYYYYYYY:role/dns-manager Note that, as mentioned above, the pod is using arn:aws:iam::XXXXXXXXXXX:role/cert-manager as a credentials source in Account X, but the ClusterIssuer ultimately assumes the arn:aws:iam::YYYYYYYYYYYY:role/dns-manager role to actually make changes in Route53 zones located in Account Y.","title":"Creating an Issuer (or ClusterIssuer)"},{"location":"configuration/acme/dns01/route53/#eks-iam-role-for-service-accounts-irsa","text":"While kiam / kube2iam work directly with cert-manager, some special attention is needed for using the IAM Roles for Service Accounts feature available on EKS.","title":"EKS IAM Role for Service Accounts (IRSA)"},{"location":"configuration/acme/dns01/route53/#oidc-provider","text":"First follow the AWS documentation Enabling IAM roles for service accounts on your cluster to ensure that the OIDC provider for the EKS cluster is enabled. The OIDC information is needed to create the trust relationship for the cert-manager role below.","title":"OIDC provider"},{"location":"configuration/acme/dns01/route53/#iam-role-trust-policy","text":"The cert-manager role needs the following trust relationship attached to the role in order to use the IRSA method. Replace the following: <aws-account-id> with the AWS account ID of the EKS cluster. <aws-region> with the region where the EKS cluster is located. <eks-hash> with the hash in the EKS API URL; this will be a random 32 character hex string (example: 45DABD88EEE3A227AF0FA468BE4EF0B5 ) <namespace> with the namespace where cert-manager is running. <service-account-name> with the name of the ServiceAccount object created by cert-manager. { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"sts:AssumeRoleWithWebIdentity\" , \"Principal\" : { \"Federated\" : \"arn:aws:iam::<aws-account-id>:oidc-provider/oidc.eks.<aws-region>.amazonaws.com/id/<eks-hash>\" }, \"Condition\" : { \"StringEquals\" : { \"oidc.eks.<aws-region>.amazonaws.com/id/<eks-hash>:sub\" : \"system:serviceaccount:<namespace>:<service-account-name>\" } } } ] } Note: If you're following the Cross Account example above, this trust policy is attached to the cert-manager role in Account X with ARN arn:aws:iam::XXXXXXXXXXX:role/cert-manager . The permissions policy is the same as above.","title":"IAM role trust policy"},{"location":"configuration/acme/dns01/route53/#service-annotation","text":"Annotate the ServiceAccount created by cert-manager: apiVersion : v1 kind : ServiceAccount metadata : annotations : eks.amazonaws.com/role-arn : arn:aws:iam::XXXXXXXXXXX:role/cert-manager You will also need to modify the cert-manager Deployment with the correct file system permissions, so the ServiceAccount token can be read. spec : template : spec : securityContext : fsGroup : 1001 The cert-manager Helm chart provides a variable for injecting annotations into cert-manager's ServiceAccount and Deployment object like so: serviceAccount : annotations : eks.amazonaws.com/role-arn : arn:aws:iam::XXXXXXXXXXX:role/cert-manager securityContext : fsGroup : 1001 Note: If you're following the Cross Account example above, modify the ClusterIssuer in the same way as above with the role from Account Y.","title":"Service annotation"},{"location":"configuration/acme/dns01/webhook/","text":"The webhook Issuer is a generic ACME solver. The actual work is done by an external service. Look at the respective documentation of dns-providers . View more webhook solvers at https://github.com/topics/cert-manager-webhook . Here is an example of how webhook providers are to be configured. All DNS01 providers will contain their own specific configuration however all require a groupName and solverName field. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : ... solvers : - dns01 : webhook : groupName : $WEBHOOK_GROUP_NAME solverName : $WEBHOOK_SOLVER_NAME config : ... <webhook-specific-configuration>","title":"Webhook"},{"location":"configuration/acme/http01/","text":"\ud83d\udccc This page focuses on solving ACME HTTP-01 challenges. If you are looking for how to automatically create Certificate resources by annotating Ingress or Gateway resources, see [Securing Ingress Resources](../../../usage/ingress.md) and [Securing Gateway Resources](../../../usage/gateway.md). cert-manager uses your existing Ingress or Gateway configuration in order to solve HTTP01 challenges. Configuring the HTTP01 Ingress solver \u00b6 This page contains details on the different options available on the Issuer resource's HTTP01 challenge solver configuration. For more information on configuring ACME issuers and their API format, read the ACME Issuers documentation. You can read about how the HTTP01 challenge type works on the Let's Encrypt challenge types page . Here is an example of a simple HTTP01 ACME issuer with more options for configuration below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key solvers : - http01 : ingress : class : nginx Options \u00b6 The HTTP01 Issuer supports a number of additional options. For full details on the range of options available, read the reference documentation . class \u00b6 If the class field is specified, cert-manager will create new Ingress resources in order to route traffic to the acmesolver pods, which are responsible for responding to ACME challenge validation requests. If this field is not specified, and name is also not specified, cert-manager will default to create new Ingress resources but will not set the ingress class on these resources, meaning all ingress controllers installed in your cluster will serve traffic for the challenge solver, potentially incurring additional cost. name \u00b6 If the name field is specified, cert-manager will edit the named ingress resource in order to solve HTTP01 challenges. This is useful for compatibility with ingress controllers such as ingress-gce , which utilize a unique IP address for each Ingress resource created. This mode should be avoided when using ingress controllers that expose a single IP for all ingress resources, as it can create compatibility problems with certain ingress-controller specific annotations. `serviceType` In rare cases it might be not possible/desired to use NodePort as type for the HTTP01 challenge response service, e.g. because of Kubernetes limit restrictions. To define which Kubernetes service type to use during challenge response specify the following HTTP01 configuration: http01 : ingress : # Valid values are ClusterIP and NodePort serviceType : ClusterIP By default, type NodePort will be used when you don't set HTTP01 or when you set serviceType to an empty string. Normally there's no need to change this. podTemplate \u00b6 You may wish to change or add to the labels and annotations of solver pods. These can be configured under the metadata field under podTemplate . Similarly, you can set the nodeSelector , tolerations and affinity of solver pods by configuring under the spec field of the podTemplate . No other spec fields can be edited. An example of how you could configure the template is as so: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ... spec : acme : server : ... privateKeySecretRef : name : ... solvers : - http01 : ingress : podTemplate : metadata : labels : foo : \"bar\" env : \"prod\" spec : nodeSelector : bar : baz The added labels and annotations will merge on top of the cert-manager defaults, overriding entries with the same key. No other fields of the podTemplate exist. ingressTemplate \u00b6 It is possible to add labels and annotations to the solver ingress resources. It can be really useful when you are managing several Ingress Controllers across your cluster and you want to make sure that the right one will pick up and expose the solver (for the upcoming challenge to resolve). These can be configured under the metadata field under ingressTemplate : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ... spec : acme : server : ... privateKeySecretRef : name : ... solvers : - http01 : ingress : ingressTemplate : metadata : labels : foo : \"bar\" annotations : \"nginx.ingress.kubernetes.io/whitelist-source-range\" : \"0.0.0.0/0,::/0\" \"nginx.org/mergeable-ingress-type\" : \"minion\" \"traefik.ingress.kubernetes.io/frontend-entry-points\" : \"http\" The added labels and annotations will merge on top of the cert-manager defaults, overriding entries with the same key. No other fields of the ingress can be edited. Configuring the HTTP-01 Gateway API solver \u00b6 FEATURE STATE : cert-manager 1.5 [alpha] The Gateway and HTTPRoute resources are part of the Gateway API , a set of CRDs that you install on your Kubernetes cluster that provide various improvements over the Ingress API. \ud83d\udccc This feature requires the installation of the [Gateway API bundle](https://gateway-api.sigs.k8s.io/guides/#installing-a-gateway-controller) and passing a feature flag to the cert-manager controller. To install v1.5.1 Gateway API bundle (Gateway CRDs and webhook), run the following command: kubectl apply -f \"https://github.com/kubernetes-sigs/gateway-api/releases/download/v0.5.1/standard-install.yaml\" To enable the feature in cert-manager, turn on the `GatewayAPI` feature gate: - If you are using Helm: helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager \\ --set \"extraArgs={--feature-gates=ExperimentalGatewayAPISupport=true}\" - If you are using the raw cert-manager manifests, add the following flag to the cert-manager controller Deployment: args : - --feature-gates=ExperimentalGatewayAPISupport=true The Gateway API CRDs should either be installed before cert-manager starts or the cert-manager Deployment should be restarted after installing the Gateway API CRDs. This is important because some of the cert-manager components only perform the Gateway API check on startup. You can restart cert-manager with the following command: kubectl rollout restart deployment cert-manager -n cert-manager \ud83d\udea7 cert-manager 1.8+ is tested with v1alpha2 Kubernetes Gateway API. It should also work with v1beta1 because of resource conversion, but has not been tested with it. The Gateway API HTTPRoute HTTP-01 solver creates a temporary HTTPRoute using the given labels. These labels must match a Gateway that contains a listener on port 80. Here is an example of a HTTP-01 ACME Issuer using the Gateway API: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt namespace : default spec : acme : solvers : - http01 : gatewayHTTPRoute : parentRefs : - name : traefik namespace : traefik kind : Gateway The Issuer relies on an existing Gateway present on the cluster. cert-manager does not edit Gateway resources. For example, the following Gateway will allow the Issuer to solve the challenge: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : traefik namespace : traefik spec : gatewayClassName : traefik listeners : - name : http protocol : HTTP port : 80 allowedRoutes : namespaces : from : All In the above example, the Gateway has been specifically created for the purpose of solving HTTP-01 challenges, but you can also choose to re-use your existing Gateway, as long as it has a listener on port 80. The labels on your Issuer may reference a Gateway that is on a separate namespace, as long as the Gateway's port 80 listener is configured with from: All . Note that the Certificate will still be created on the same namespace as the Issuer, which means that you won't be able to reference this Secret in the above-mentioned Gateway. When the above Issuer is presented with a Certificate, cert-manager creates the temporary HTTPRoute. For example, with the following Certificate: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-tls namespace : default spec : issuerRef : name : letsencrypt dnsNames : - example.net You will see an HTTPRoute appear: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : HTTPRoute metadata : name : cm-acme-http-solver-gdhvg namespace : default spec : parentRefs : - name : traefik namespace : traefik kind : Gateway hostnames : - example.net rules : - forwardTo : - port : 8089 serviceName : cm-acme-http-solver-gdhvg weight : 1 matches : - path : type : Exact value : /.well-known/acme-challenge/YadC4gaAzqEPU1Yea0D2MrzvNRWiBCtUizCtpiRQZqI After the Certificate is issued, the HTTPRoute is deleted. `labels` These labels are copied into the temporary HTTPRoute created by cert-manager for solving the HTTP-01 challenge. These labels must match one of the Gateway resources on your cluster. The matched Gateway have a listener on port 80. Note that when the labels do not match any Gateway on your cluster, cert-manager will create the temporary HTTPRoute challenge and nothing will happen. `serviceType` This field has the same meaning as the http01.ingress.serviceType . Setting Nameservers for HTTP-01 solver propagation checks \u00b6 cert-manager will perform reachability tests before attempting a HTT01 challenge. By default cert-manager will use the recursive nameservers taken from /etc/resolv.conf to query the challenge URL. If this is not desired (for example with split-horizon DNS), the cert-manager controller exposes a flag that allows you alter this behavior: --acme-http01-solver-nameservers Comma separated string with host and port of the recursive nameservers cert-manager should query. Example usage: --acme-http01-solver-nameservers = \"8.8.8.8:53,1.1.1.1:53\" If you're using the cert-manager helm chart, you can set recursive nameservers through .Values.extraArgs or at the command at helm install/upgrade time with --set : --set 'extraArgs={--acme-http01-solver-nameservers=8.8.8.8:53\\,1.1.1.1:53}'","title":"HTTP01"},{"location":"configuration/acme/http01/#configuring-the-http01-ingress-solver","text":"This page contains details on the different options available on the Issuer resource's HTTP01 challenge solver configuration. For more information on configuring ACME issuers and their API format, read the ACME Issuers documentation. You can read about how the HTTP01 challenge type works on the Let's Encrypt challenge types page . Here is an example of a simple HTTP01 ACME issuer with more options for configuration below: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : example-issuer spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key solvers : - http01 : ingress : class : nginx","title":"Configuring the HTTP01 Ingress solver"},{"location":"configuration/acme/http01/#options","text":"The HTTP01 Issuer supports a number of additional options. For full details on the range of options available, read the reference documentation .","title":"Options"},{"location":"configuration/acme/http01/#class","text":"If the class field is specified, cert-manager will create new Ingress resources in order to route traffic to the acmesolver pods, which are responsible for responding to ACME challenge validation requests. If this field is not specified, and name is also not specified, cert-manager will default to create new Ingress resources but will not set the ingress class on these resources, meaning all ingress controllers installed in your cluster will serve traffic for the challenge solver, potentially incurring additional cost.","title":"class"},{"location":"configuration/acme/http01/#name","text":"If the name field is specified, cert-manager will edit the named ingress resource in order to solve HTTP01 challenges. This is useful for compatibility with ingress controllers such as ingress-gce , which utilize a unique IP address for each Ingress resource created. This mode should be avoided when using ingress controllers that expose a single IP for all ingress resources, as it can create compatibility problems with certain ingress-controller specific annotations.","title":"name"},{"location":"configuration/acme/http01/#podtemplate","text":"You may wish to change or add to the labels and annotations of solver pods. These can be configured under the metadata field under podTemplate . Similarly, you can set the nodeSelector , tolerations and affinity of solver pods by configuring under the spec field of the podTemplate . No other spec fields can be edited. An example of how you could configure the template is as so: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ... spec : acme : server : ... privateKeySecretRef : name : ... solvers : - http01 : ingress : podTemplate : metadata : labels : foo : \"bar\" env : \"prod\" spec : nodeSelector : bar : baz The added labels and annotations will merge on top of the cert-manager defaults, overriding entries with the same key. No other fields of the podTemplate exist.","title":"podTemplate"},{"location":"configuration/acme/http01/#ingresstemplate","text":"It is possible to add labels and annotations to the solver ingress resources. It can be really useful when you are managing several Ingress Controllers across your cluster and you want to make sure that the right one will pick up and expose the solver (for the upcoming challenge to resolve). These can be configured under the metadata field under ingressTemplate : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : ... spec : acme : server : ... privateKeySecretRef : name : ... solvers : - http01 : ingress : ingressTemplate : metadata : labels : foo : \"bar\" annotations : \"nginx.ingress.kubernetes.io/whitelist-source-range\" : \"0.0.0.0/0,::/0\" \"nginx.org/mergeable-ingress-type\" : \"minion\" \"traefik.ingress.kubernetes.io/frontend-entry-points\" : \"http\" The added labels and annotations will merge on top of the cert-manager defaults, overriding entries with the same key. No other fields of the ingress can be edited.","title":"ingressTemplate"},{"location":"configuration/acme/http01/#configuring-the-http-01-gateway-api-solver","text":"FEATURE STATE : cert-manager 1.5 [alpha] The Gateway and HTTPRoute resources are part of the Gateway API , a set of CRDs that you install on your Kubernetes cluster that provide various improvements over the Ingress API. \ud83d\udccc This feature requires the installation of the [Gateway API bundle](https://gateway-api.sigs.k8s.io/guides/#installing-a-gateway-controller) and passing a feature flag to the cert-manager controller. To install v1.5.1 Gateway API bundle (Gateway CRDs and webhook), run the following command: kubectl apply -f \"https://github.com/kubernetes-sigs/gateway-api/releases/download/v0.5.1/standard-install.yaml\" To enable the feature in cert-manager, turn on the `GatewayAPI` feature gate: - If you are using Helm: helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager \\ --set \"extraArgs={--feature-gates=ExperimentalGatewayAPISupport=true}\" - If you are using the raw cert-manager manifests, add the following flag to the cert-manager controller Deployment: args : - --feature-gates=ExperimentalGatewayAPISupport=true The Gateway API CRDs should either be installed before cert-manager starts or the cert-manager Deployment should be restarted after installing the Gateway API CRDs. This is important because some of the cert-manager components only perform the Gateway API check on startup. You can restart cert-manager with the following command: kubectl rollout restart deployment cert-manager -n cert-manager \ud83d\udea7 cert-manager 1.8+ is tested with v1alpha2 Kubernetes Gateway API. It should also work with v1beta1 because of resource conversion, but has not been tested with it. The Gateway API HTTPRoute HTTP-01 solver creates a temporary HTTPRoute using the given labels. These labels must match a Gateway that contains a listener on port 80. Here is an example of a HTTP-01 ACME Issuer using the Gateway API: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt namespace : default spec : acme : solvers : - http01 : gatewayHTTPRoute : parentRefs : - name : traefik namespace : traefik kind : Gateway The Issuer relies on an existing Gateway present on the cluster. cert-manager does not edit Gateway resources. For example, the following Gateway will allow the Issuer to solve the challenge: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : traefik namespace : traefik spec : gatewayClassName : traefik listeners : - name : http protocol : HTTP port : 80 allowedRoutes : namespaces : from : All In the above example, the Gateway has been specifically created for the purpose of solving HTTP-01 challenges, but you can also choose to re-use your existing Gateway, as long as it has a listener on port 80. The labels on your Issuer may reference a Gateway that is on a separate namespace, as long as the Gateway's port 80 listener is configured with from: All . Note that the Certificate will still be created on the same namespace as the Issuer, which means that you won't be able to reference this Secret in the above-mentioned Gateway. When the above Issuer is presented with a Certificate, cert-manager creates the temporary HTTPRoute. For example, with the following Certificate: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-tls namespace : default spec : issuerRef : name : letsencrypt dnsNames : - example.net You will see an HTTPRoute appear: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : HTTPRoute metadata : name : cm-acme-http-solver-gdhvg namespace : default spec : parentRefs : - name : traefik namespace : traefik kind : Gateway hostnames : - example.net rules : - forwardTo : - port : 8089 serviceName : cm-acme-http-solver-gdhvg weight : 1 matches : - path : type : Exact value : /.well-known/acme-challenge/YadC4gaAzqEPU1Yea0D2MrzvNRWiBCtUizCtpiRQZqI After the Certificate is issued, the HTTPRoute is deleted.","title":"Configuring the HTTP-01 Gateway API solver"},{"location":"configuration/acme/http01/#setting-nameservers-for-http-01-solver-propagation-checks","text":"cert-manager will perform reachability tests before attempting a HTT01 challenge. By default cert-manager will use the recursive nameservers taken from /etc/resolv.conf to query the challenge URL. If this is not desired (for example with split-horizon DNS), the cert-manager controller exposes a flag that allows you alter this behavior: --acme-http01-solver-nameservers Comma separated string with host and port of the recursive nameservers cert-manager should query. Example usage: --acme-http01-solver-nameservers = \"8.8.8.8:53,1.1.1.1:53\" If you're using the cert-manager helm chart, you can set recursive nameservers through .Values.extraArgs or at the command at helm install/upgrade time with --set : --set 'extraArgs={--acme-http01-solver-nameservers=8.8.8.8:53\\,1.1.1.1:53}'","title":"Setting Nameservers for HTTP-01 solver propagation checks"},{"location":"configuration/acme/http01/externalloadbalancer/","text":"When you are using an external load balancer provided by any host, you can face several configuration issues to get it work with cert-manager. This documentation is intended to help configure the HTTP-01 challenge type for instances behind external load balancer. NAT Loopback / Hairpin \u00b6 The first configuration point is NAT loopback. You can face check issues due to Load Balancer preventing instances behind it to access its external interface. Some Network Load Balancer have this kind of limitation for several reasons. It can be configured through iptables rerouting configuration known as NAT loopback . To check if you are facing this problem : Check that the endpoint of the challenge is accessible to the public : curl <endpoint> Check that the challenge endpoint is NOT accessible from inside behind the Load Balancer: use SSH to open a session on a node places behind the LB; then launch the same command than before : curl <endpoint> The HTTP-01 challenge's endpoint can be found in the logs when the pre-check fails. If it does not appear in the logs, you can check the challenge URL by kubectl command. <endpoint> is the URL used to test the HTTP-01 from the certificate Issuer . For Let's Encrypt for example, the URL is formed like <domain>/.well-known/acme-challenge/<hash> Load Balancer HTTP endpoints \u00b6 If you are using a Load Balancer (outside a managed Kubernetes service), you should be able to configure the Load Balancer protocol as HTTP, HTTPS, TCP, UDP. Several Load Balancer now offer free TLS certificates with Let's Encrypt. When using HTTP(s) protocols for your Load Balancer, it can intercept the challenge URL to replace the response's verification hash with their hash. In this case, cert-manager will fail did not get expected response when querying endpoint, expected 'xxxx' but got: yyyy (truncated) . This kind of error can be thrown for multiple reasons. This case shows a correctly formatted response, but not the expected one. The solution is to configure the Load Balancer with TCP protocol so that the HTTP request will not be intercepted by the host.","title":"External Load Balancer"},{"location":"configuration/acme/http01/externalloadbalancer/#nat-loopback-hairpin","text":"The first configuration point is NAT loopback. You can face check issues due to Load Balancer preventing instances behind it to access its external interface. Some Network Load Balancer have this kind of limitation for several reasons. It can be configured through iptables rerouting configuration known as NAT loopback . To check if you are facing this problem : Check that the endpoint of the challenge is accessible to the public : curl <endpoint> Check that the challenge endpoint is NOT accessible from inside behind the Load Balancer: use SSH to open a session on a node places behind the LB; then launch the same command than before : curl <endpoint> The HTTP-01 challenge's endpoint can be found in the logs when the pre-check fails. If it does not appear in the logs, you can check the challenge URL by kubectl command. <endpoint> is the URL used to test the HTTP-01 from the certificate Issuer . For Let's Encrypt for example, the URL is formed like <domain>/.well-known/acme-challenge/<hash>","title":"NAT Loopback / Hairpin"},{"location":"configuration/acme/http01/externalloadbalancer/#load-balancer-http-endpoints","text":"If you are using a Load Balancer (outside a managed Kubernetes service), you should be able to configure the Load Balancer protocol as HTTP, HTTPS, TCP, UDP. Several Load Balancer now offer free TLS certificates with Let's Encrypt. When using HTTP(s) protocols for your Load Balancer, it can intercept the challenge URL to replace the response's verification hash with their hash. In this case, cert-manager will fail did not get expected response when querying endpoint, expected 'xxxx' but got: yyyy (truncated) . This kind of error can be thrown for multiple reasons. This case shows a correctly formatted response, but not the expected one. The solution is to configure the Load Balancer with TCP protocol so that the HTTP request will not be intercepted by the host.","title":"Load Balancer HTTP endpoints"},{"location":"contributing/","text":"Great to See You! \u00b6 Whether you're a previous contributor or a first timer looking to get involved, we love it when the community comes together to improve the project! In this \"contributing\" section we document processes we follow as a project, and include some details on how to build, test and run cert-manager for development purposes. Meetings \u00b6 All cert-manager meetings are open for everyone to join! To get invites you can subscribe to our mailing list . We have 2 regular repeating meetings: daily stand-up meetings on Google Meet at 10:30 London time every weekday bi-weekly developer meetings on Google Meet at 17:00 London time (for dates, check calendar invites or meeting notes ) Slack \u00b6 We have two cert-manager channels on Kubernetes Slack which we use to chat: cert-manager : for all users of cert-manager; use this one for any usage related questions cert-manager-dev : for collaboration between cert-manager contributors and maintainers; please only use this for code related questions Google Season of Docs 2022 \u00b6 The cert-manager team are participating in Google Season of Docs 2022 ! Check out our 2022 Project Proposals if you want to get involved!","title":"Introduction"},{"location":"contributing/#great-to-see-you","text":"Whether you're a previous contributor or a first timer looking to get involved, we love it when the community comes together to improve the project! In this \"contributing\" section we document processes we follow as a project, and include some details on how to build, test and run cert-manager for development purposes.","title":"Great to See You!"},{"location":"contributing/#meetings","text":"All cert-manager meetings are open for everyone to join! To get invites you can subscribe to our mailing list . We have 2 regular repeating meetings: daily stand-up meetings on Google Meet at 10:30 London time every weekday bi-weekly developer meetings on Google Meet at 17:00 London time (for dates, check calendar invites or meeting notes )","title":"Meetings"},{"location":"contributing/#slack","text":"We have two cert-manager channels on Kubernetes Slack which we use to chat: cert-manager : for all users of cert-manager; use this one for any usage related questions cert-manager-dev : for collaboration between cert-manager contributors and maintainers; please only use this for code related questions","title":"Slack"},{"location":"contributing/#google-season-of-docs-2022","text":"The cert-manager team are participating in Google Season of Docs 2022 ! Check out our 2022 Project Proposals if you want to get involved!","title":"Google Season of Docs 2022"},{"location":"contributing/building/","text":"cert-manager is built and tested using make , with a focus on using the standard Go tooling where possible and keeping system dependencies to a minimum. The cert-manager build system can provision most of its dependencies - including Go - automatically if required. cert-manager's build system fully supports developers who use Linux amd64 , macOS amd64 and macOS arm64 . Other operating systems and architectures may work, but are largely untested. Prerequisites \u00b6 There are very few other requirements needed for developing cert-manager, and crucially the build system should tell you with a friendly error message if there's anything missing. If you think an error message which relates to a missing dependency is unhelpful, we consider that a bug and we'd appreciate if you raised an issue to tell us about it! You should install the following tools before you start developing cert-manager: git curl GNU make , v3.82 or newer GNU Coreutils (usually already installed on Linux, available via homebrew for macOS) jq (available in Linux package managers and in homebrew ) docker (or podman , see Container Engines below) Go (optional; see Go Versions below) Getting Started \u00b6 The vast majority of commands which you're likely to need to use are documented via make help . That's probably the first place to start if you're developing cert-manager. We'll also provide an overview on this page of some of the key targets and things to bear in mind. Go Versions \u00b6 cert-manager defaults to using whatever version of Go you've installed locally on your system. If you want to use your system Go, that's totally fine. Alternatively, make can provision and \"vendor\" Go specifically for cert-manager, helping to ensure you use the same version that's used in CI and to make it easier to get started developing. To start using a vendored Go, run: make vendor-go . You only need to run vendor-go once and it'll be \"sticky\", being used for all future make invocations in your local checkout. To return to using your system version of go, run: make unvendor-go . To check which version of Go is currently being used, run: make which-go , which prints the version number of Go and the path to the Go binary. # Use a vendored version of go $ make vendor-go cd _bin/tools/ && ln -f -s ../downloaded/tools/_go-1.XY.Z-linux-amd64/goroot . cd _bin/tools/ && ln -f -s ../downloaded/tools/_go-1.XY.Z-linux-amd64/goroot/bin/go . # A path to go inside the cert-manager directory indicates that a vendored Go is being used $ make which-go go version go1.XY.Z linux/amd64 go binary used for above version information: /home/user/workspace/cert-manager/_bin/tools/go # Go back to the system Go $ make unvendor-go rm -rf _bin/tools/go _bin/tools/goroot # The binary is now \"go\" which should be found in $PATH $ make which-go go version go1.AB.C linux/amd64 go binary used for above version information: go Parallelism \u00b6 The cert-manager Makefile is designed to be highly parallel wherever possible. Any build and test commands should be able to be executed in parallel using standard Make functionality. One important caveat is that that Go will default to detecting the number of cores available on the system and spinning up as many threads as it can. If you're using Make functionality to run multiple builds in parallel, this number of threads can be excessive and actually lead to slower builds. It's possible to limit the number of threads Go uses we'd generally recommend doing so when using Make parallelism. The best values to use will depend on your system, but we've had success using around half of the available number of cores for Make and limiting Go to between 2 and 4 threads per core. For example, using an 8-core machine: # Run 4 make targets in parallel, and limit each `go build` to 2 threads. make GOMAXPROCS = 2 -j4 release-artifacts Testing \u00b6 cert-manager's build pipeline and CI infrastructure uses the same Makefile that you use when developing locally, so there should be no divergence between what the tests run and what you run. That means you should be able to be pretty confident that any changes you make won't break when tested in CI. Running Local Changes in a Cluster \u00b6 It's common that you might want to run a local Kubernetes cluster with your locally-changed copy of cert-manager in it, for manual testing. There are make targets to help with this; see Developing with Kind for more information. Unit and Integration Tests \u00b6 First of all: If you want to test using go test , feel free! For unit tests (which we define as any test outside of the test/ directory), go test will work on a fresh checkout. Integration tests may require some external tools to be set up first, so to run the integration tests inside test/ you might need to run: make setup-integration-tests Helper targets are also available which use gotestsum for prettier output. It's also possible to configure these targets to run specific tests: # Run all unit and integration tests make test # Run only unit tests make unit-test # Run only integration tests make integration-test # Run all tests in pkg make WHAT = ./pkg/... test # Run unit and integration tests exactly as run in CI # (NB: usually not needed - this is mostly for JUnit test output for dashboards) make test-ci End-to-End Testing \u00b6 cert-manager's end-to-end tests are a little more involved and have dedicated documentation describing their use. Other Checks \u00b6 We run a variety of other tools on every Pull Request to check things like formatting, import ordering and licensing. These checks can all be run locally: make ci-presubmit NB: One of these checks currently requires Python 3 to be installed, which is a unique requirement in the code base. We'd like to remove that requirement in the future. Updating CRDs and Code Generation \u00b6 Changes to cert-manager's CRDs require some code generation to be done, which will be checked on every pull request. If you make changes to cert-manager CRDs, you'll need to run some commands locally before raising your PR. This is documented in our CRDs section. Building \u00b6 cert-manager produces many artifacts for a lot of different OS / architecture combinations, including: Container images Client binaries ( cmctl and kubectl_cert-manager ) Manifests (Helm charts, static YAML) All of these artifacts can be built locally using make. Containers \u00b6 cert-manager's most important artifacts are the containers which actually run cert-manager in a cluster. We default to using docker for this, but aim to support docker-compatible CLI tools such as podman , too. See Container Engines for more info. There are several targets for building different cert-manager containers locally. These will all default to using docker : # Build everything for every architecture make all-containers # Build just the controller containers on every architecture make cert-manager-controller-linux # As above, but for the webhook, cainjector, acmesolver and cmctl containers make cert-manager-webhook-linux make cert-manager-cainjector-linux make cert-manager-acmesolver-linux make cert-manager-ctl-linux Container Engines \u00b6 NB: This section doesn't apply to end-to-end tests, which might not work outside of Docker at the time of writing. See the end-to-end documentation for more information. It's possible to use an alternative container engine to build cert-manager containers. This has been successfully tested using podman . Configure an alternative container engine by setting the CTR variable: # Build everything for every architecture, using podman make CTR = podman all-containers Client Binaries \u00b6 Both cmctl and kubectl_cert-manager can be built locally for a release. These binaries are built for Linux, macOS and Windows across several architectures. # Build all cmctl binaries for all platforms, then for linux only, then for macOS only, then for Windows only make cmctl make cmctl-linux make cmctl-darwin make cmctl-windows # As above but for kubectl_cert-manager make kubectl_cert-manager make kubectl_cert-manager-linux make kubectl_cert-manager-darwin make kubectl_cert-manager-windows Manifests \u00b6 We use \"manifests\" as a catch-all term for non-binary artifacts which we build as part of a release including static installation YAML and our Helm chart. Everything can be built using make: make helm-chart make static-manifests Everything \u00b6 Sometimes it's useful to build absolutely everything locally, to be sure that a change didn't break some obscure architecture and to build confidence when raising a PR. It's not easy to build a complete release locally since a full release includes signatures which depend on KMS keys being configured. Most users probably don't need that, though, and for this use case there's a make target which will build everything except the signed artifacts: make GOMAXPROCS = 2 -j4 release-artifacts","title":"Building cert-manager"},{"location":"contributing/building/#prerequisites","text":"There are very few other requirements needed for developing cert-manager, and crucially the build system should tell you with a friendly error message if there's anything missing. If you think an error message which relates to a missing dependency is unhelpful, we consider that a bug and we'd appreciate if you raised an issue to tell us about it! You should install the following tools before you start developing cert-manager: git curl GNU make , v3.82 or newer GNU Coreutils (usually already installed on Linux, available via homebrew for macOS) jq (available in Linux package managers and in homebrew ) docker (or podman , see Container Engines below) Go (optional; see Go Versions below)","title":"Prerequisites"},{"location":"contributing/building/#getting-started","text":"The vast majority of commands which you're likely to need to use are documented via make help . That's probably the first place to start if you're developing cert-manager. We'll also provide an overview on this page of some of the key targets and things to bear in mind.","title":"Getting Started"},{"location":"contributing/building/#go-versions","text":"cert-manager defaults to using whatever version of Go you've installed locally on your system. If you want to use your system Go, that's totally fine. Alternatively, make can provision and \"vendor\" Go specifically for cert-manager, helping to ensure you use the same version that's used in CI and to make it easier to get started developing. To start using a vendored Go, run: make vendor-go . You only need to run vendor-go once and it'll be \"sticky\", being used for all future make invocations in your local checkout. To return to using your system version of go, run: make unvendor-go . To check which version of Go is currently being used, run: make which-go , which prints the version number of Go and the path to the Go binary. # Use a vendored version of go $ make vendor-go cd _bin/tools/ && ln -f -s ../downloaded/tools/_go-1.XY.Z-linux-amd64/goroot . cd _bin/tools/ && ln -f -s ../downloaded/tools/_go-1.XY.Z-linux-amd64/goroot/bin/go . # A path to go inside the cert-manager directory indicates that a vendored Go is being used $ make which-go go version go1.XY.Z linux/amd64 go binary used for above version information: /home/user/workspace/cert-manager/_bin/tools/go # Go back to the system Go $ make unvendor-go rm -rf _bin/tools/go _bin/tools/goroot # The binary is now \"go\" which should be found in $PATH $ make which-go go version go1.AB.C linux/amd64 go binary used for above version information: go","title":"Go Versions"},{"location":"contributing/building/#parallelism","text":"The cert-manager Makefile is designed to be highly parallel wherever possible. Any build and test commands should be able to be executed in parallel using standard Make functionality. One important caveat is that that Go will default to detecting the number of cores available on the system and spinning up as many threads as it can. If you're using Make functionality to run multiple builds in parallel, this number of threads can be excessive and actually lead to slower builds. It's possible to limit the number of threads Go uses we'd generally recommend doing so when using Make parallelism. The best values to use will depend on your system, but we've had success using around half of the available number of cores for Make and limiting Go to between 2 and 4 threads per core. For example, using an 8-core machine: # Run 4 make targets in parallel, and limit each `go build` to 2 threads. make GOMAXPROCS = 2 -j4 release-artifacts","title":"Parallelism"},{"location":"contributing/building/#testing","text":"cert-manager's build pipeline and CI infrastructure uses the same Makefile that you use when developing locally, so there should be no divergence between what the tests run and what you run. That means you should be able to be pretty confident that any changes you make won't break when tested in CI.","title":"Testing"},{"location":"contributing/building/#running-local-changes-in-a-cluster","text":"It's common that you might want to run a local Kubernetes cluster with your locally-changed copy of cert-manager in it, for manual testing. There are make targets to help with this; see Developing with Kind for more information.","title":"Running Local Changes in a Cluster"},{"location":"contributing/building/#unit-and-integration-tests","text":"First of all: If you want to test using go test , feel free! For unit tests (which we define as any test outside of the test/ directory), go test will work on a fresh checkout. Integration tests may require some external tools to be set up first, so to run the integration tests inside test/ you might need to run: make setup-integration-tests Helper targets are also available which use gotestsum for prettier output. It's also possible to configure these targets to run specific tests: # Run all unit and integration tests make test # Run only unit tests make unit-test # Run only integration tests make integration-test # Run all tests in pkg make WHAT = ./pkg/... test # Run unit and integration tests exactly as run in CI # (NB: usually not needed - this is mostly for JUnit test output for dashboards) make test-ci","title":"Unit and Integration Tests"},{"location":"contributing/building/#end-to-end-testing","text":"cert-manager's end-to-end tests are a little more involved and have dedicated documentation describing their use.","title":"End-to-End Testing"},{"location":"contributing/building/#other-checks","text":"We run a variety of other tools on every Pull Request to check things like formatting, import ordering and licensing. These checks can all be run locally: make ci-presubmit NB: One of these checks currently requires Python 3 to be installed, which is a unique requirement in the code base. We'd like to remove that requirement in the future.","title":"Other Checks"},{"location":"contributing/building/#updating-crds-and-code-generation","text":"Changes to cert-manager's CRDs require some code generation to be done, which will be checked on every pull request. If you make changes to cert-manager CRDs, you'll need to run some commands locally before raising your PR. This is documented in our CRDs section.","title":"Updating CRDs and Code Generation"},{"location":"contributing/building/#building","text":"cert-manager produces many artifacts for a lot of different OS / architecture combinations, including: Container images Client binaries ( cmctl and kubectl_cert-manager ) Manifests (Helm charts, static YAML) All of these artifacts can be built locally using make.","title":"Building"},{"location":"contributing/building/#containers","text":"cert-manager's most important artifacts are the containers which actually run cert-manager in a cluster. We default to using docker for this, but aim to support docker-compatible CLI tools such as podman , too. See Container Engines for more info. There are several targets for building different cert-manager containers locally. These will all default to using docker : # Build everything for every architecture make all-containers # Build just the controller containers on every architecture make cert-manager-controller-linux # As above, but for the webhook, cainjector, acmesolver and cmctl containers make cert-manager-webhook-linux make cert-manager-cainjector-linux make cert-manager-acmesolver-linux make cert-manager-ctl-linux","title":"Containers"},{"location":"contributing/building/#container-engines","text":"NB: This section doesn't apply to end-to-end tests, which might not work outside of Docker at the time of writing. See the end-to-end documentation for more information. It's possible to use an alternative container engine to build cert-manager containers. This has been successfully tested using podman . Configure an alternative container engine by setting the CTR variable: # Build everything for every architecture, using podman make CTR = podman all-containers","title":"Container Engines"},{"location":"contributing/building/#client-binaries","text":"Both cmctl and kubectl_cert-manager can be built locally for a release. These binaries are built for Linux, macOS and Windows across several architectures. # Build all cmctl binaries for all platforms, then for linux only, then for macOS only, then for Windows only make cmctl make cmctl-linux make cmctl-darwin make cmctl-windows # As above but for kubectl_cert-manager make kubectl_cert-manager make kubectl_cert-manager-linux make kubectl_cert-manager-darwin make kubectl_cert-manager-windows","title":"Client Binaries"},{"location":"contributing/building/#manifests","text":"We use \"manifests\" as a catch-all term for non-binary artifacts which we build as part of a release including static installation YAML and our Helm chart. Everything can be built using make: make helm-chart make static-manifests","title":"Manifests"},{"location":"contributing/building/#everything","text":"Sometimes it's useful to build absolutely everything locally, to be sure that a change didn't break some obscure architecture and to build confidence when raising a PR. It's not easy to build a complete release locally since a full release includes signatures which depend on KMS keys being configured. Most users probably don't need that, though, and for this use case there's a make target which will build everything except the signed artifacts: make GOMAXPROCS = 2 -j4 release-artifacts","title":"Everything"},{"location":"contributing/coding-conventions/","text":"cert-manager, like most Go projects, delegates almost all stylistic choices to gofmt , with goimports on top for organizing imports. Broadly speaking, if you set your editor to run goimports when you save a file, your code will be stylistically correct. cert-manager generally also follows the Kubernetes coding conventions and the Google Go code review comments . Organizing Imports \u00b6 Imports should be organized into 3 blocks, with each block separated by two newlines: import ( \"stdlib\" \"external\" \"internal\" ) An example might be the following, taken from pkg/acme/accounts/client.go : import ( \"crypto/rsa\" \"crypto/tls\" \"net\" \"net/http\" \"time\" acmeapi \"golang.org/x/crypto/acme\" acmecl \"github.com/cert-manager/cert-manager/pkg/acme/client\" acmeutil \"github.com/cert-manager/cert-manager/pkg/acme/util\" cmacme \"github.com/cert-manager/cert-manager/pkg/apis/acme/v1\" \"github.com/cert-manager/cert-manager/pkg/metrics\" \"github.com/cert-manager/cert-manager/pkg/util\" ) Once this manual split of standard library, external and internal imports has been made, it will be enforced automatically by goimports when executed in the future. UK vs. US spelling \u00b6 For the sake of consistency, cert-manager uses en-US spelling for the documentation in https://cert-manager.io as well as within the cert-manager codebase. A comprehensive list of en-GB \u2192 en-US word substitution is available on Ubuntu's WordSubstitution page.","title":"Coding Conventions"},{"location":"contributing/coding-conventions/#organizing-imports","text":"Imports should be organized into 3 blocks, with each block separated by two newlines: import ( \"stdlib\" \"external\" \"internal\" ) An example might be the following, taken from pkg/acme/accounts/client.go : import ( \"crypto/rsa\" \"crypto/tls\" \"net\" \"net/http\" \"time\" acmeapi \"golang.org/x/crypto/acme\" acmecl \"github.com/cert-manager/cert-manager/pkg/acme/client\" acmeutil \"github.com/cert-manager/cert-manager/pkg/acme/util\" cmacme \"github.com/cert-manager/cert-manager/pkg/apis/acme/v1\" \"github.com/cert-manager/cert-manager/pkg/metrics\" \"github.com/cert-manager/cert-manager/pkg/util\" ) Once this manual split of standard library, external and internal imports has been made, it will be enforced automatically by goimports when executed in the future.","title":"Organizing Imports"},{"location":"contributing/coding-conventions/#uk-vs-us-spelling","text":"For the sake of consistency, cert-manager uses en-US spelling for the documentation in https://cert-manager.io as well as within the cert-manager codebase. A comprehensive list of en-GB \u2192 en-US word substitution is available on Ubuntu's WordSubstitution page.","title":"UK vs. US spelling"},{"location":"contributing/contributing-flow/","text":"All of cert-manager's development is done via GitHub which contains code, issues and pull requests. All code for the documentation and cert-manager.io can be found at the cert-manager/website repo . Any issues towards the documentation should also be filed there. GitHub bot \u00b6 We use Prow on all our repositories. If you've ever looked at a Kubernetes repo, you will probably already have met Prow. Prow will be able to help you in GitHub using its commands. You can find then all on the command help page . Prow will also run all tests and assign certain labels on PRs. Bugs \u00b6 All bugs should be tracked as issues inside the GitHub repository. Issues should then be attached with the kind/bug tag. To do this add /kind bug to your issue description. This may then be assigned a priority and milestone to be addressed in a future release. The more logs and information you can give about what and how the bug has been discovered, the faster it can be resolved. Critical bug fixes are typically also cherry picked to the current minor stable releases. Note: If you are simply looking for troubleshooting then you should post your question to the community cert-manager slack channel . Many more people read this channel than GitHub issues, it's likely your problem will be solved quicker by using Slack. Please also check that the bug has not already been filed by searching for key terms in the issue search bar. (Re)opening and closing issues \u00b6 Prow can assist you to reopen or close issues you file, you can trigger it using /reopen or /close in a GitHub Issue comment. Features \u00b6 Feature requests should be created as GitHub issues. They should contain clear motivation for the feature you wish to see as well as some possible solutions for how it can be implemented. Issues should then be tagged with kind/feature . To do this add /kind feature to your issue description. Note: It is often a good idea to bring your feature request up on the community cert-manager slack channel to discuss whether the feature request has already been made or is aligned with the project's priorities. Creating Pull Requests \u00b6 Changes to the cert-manager code base is done via pull requests . Each pull request should ideally have a corresponding issue attached that is to be fixed by this pull request. It is valid for multiple pull requests to resolve a single issue in the interest of keeping code changes self contained and simpler to review. Once created, a team member will assign themselves for review and enable testing. To make sure the changes get merged, keep an eye out for reviews which can have multiple cycles. If the pull request is a critical bug fix then this will probably also be cherry picked to the current stable version of cert-manager as a patch release. To let people know that your PR is still a work in progress, we usually add a WIP: prefix to the title of the PR. Prow will then automatically set the label do-not-merge/work-in-progress . Cherry Picking \u00b6 If the pull request contains a critical bug fix then this should be cherry picked in to the current stable cert-manager branch and released as a patch release . To trigger the cherry-pick process, add a comment to the GitHub PR. For example: /cherry-pick release-x.y The jetstack-bot will then create a new branch and a PR against the release branch, which should be reviewed, approved and merged using the process described above. DCO signoff \u00b6 All commits in the PR should be signed off, more info on how to do this is at the DCO Sign Off page. Exceptions can only be made for small documentation fixes. Project Management \u00b6 Most of cert-manager's project management is done on GitHub, with the help of Prow. When will something be released? \u00b6 Our team works using GitHub milestones . When a milestone is set on an Issue it is generally an indication of when we plan to address this. Prow will apply milestones on merged PRs, this will tell you in which version that PR will land. The milestone page will also have an indicated due date when we will release. This might have some delay. We brief our users/contributors about this in our bi-weekly community meeting, for an up to date status report we recommend joining these. Labels \u00b6 We make a heavy use of GitHub labels for PRs and Issues. The ones on PRs are mostly managed by Prow and code reviewers. In issues we always aim to add 3 types: area, priority and kind. These are set using Prow using /area , /kind and /priority . Sometimes /triage is also added which helps us when following up Issues. Area indicates the code area which is/will need changing Kind indicates if it is a bug or a feature but also can be documentation or cleanup (general maintenance) Priority is the priority it has for the cert-manager team, PRs are still very welcome for those! Assignees meaning in PRs and issues \u00b6 Sometimes, you might see someone commenting with the /assign prow command : /assign @meyskens Here is the meaning that we give to the GitHub assignees: On issues, it means that the assignee is working on it. On PRs, we use it as a way to know who should be taking a look at the PR at any time: When the author is assigned, it means the PR needs work to be done aka \"changes requested\"; When nobody is assigned, it means this PR needs review; When someone different from the author is assigned, it means this person is reviewing this PR. Triage Party! \u00b6 Every few weeks we will plan a Triage Party meeting, where we use the (Triage Party)[ https://triage.build-infra.jetstack.net/ ] tool to go recent/old issues to prioritise them so we can address them in a timely matter. These meetings are open to everyone and invites will be sent out using our mailing list (warning: despite the word party these meetings are sometimes boring).","title":"Contributing Flow"},{"location":"contributing/contributing-flow/#github-bot","text":"We use Prow on all our repositories. If you've ever looked at a Kubernetes repo, you will probably already have met Prow. Prow will be able to help you in GitHub using its commands. You can find then all on the command help page . Prow will also run all tests and assign certain labels on PRs.","title":"GitHub bot"},{"location":"contributing/contributing-flow/#bugs","text":"All bugs should be tracked as issues inside the GitHub repository. Issues should then be attached with the kind/bug tag. To do this add /kind bug to your issue description. This may then be assigned a priority and milestone to be addressed in a future release. The more logs and information you can give about what and how the bug has been discovered, the faster it can be resolved. Critical bug fixes are typically also cherry picked to the current minor stable releases. Note: If you are simply looking for troubleshooting then you should post your question to the community cert-manager slack channel . Many more people read this channel than GitHub issues, it's likely your problem will be solved quicker by using Slack. Please also check that the bug has not already been filed by searching for key terms in the issue search bar.","title":"Bugs"},{"location":"contributing/contributing-flow/#reopening-and-closing-issues","text":"Prow can assist you to reopen or close issues you file, you can trigger it using /reopen or /close in a GitHub Issue comment.","title":"(Re)opening and closing issues"},{"location":"contributing/contributing-flow/#features","text":"Feature requests should be created as GitHub issues. They should contain clear motivation for the feature you wish to see as well as some possible solutions for how it can be implemented. Issues should then be tagged with kind/feature . To do this add /kind feature to your issue description. Note: It is often a good idea to bring your feature request up on the community cert-manager slack channel to discuss whether the feature request has already been made or is aligned with the project's priorities.","title":"Features"},{"location":"contributing/contributing-flow/#creating-pull-requests","text":"Changes to the cert-manager code base is done via pull requests . Each pull request should ideally have a corresponding issue attached that is to be fixed by this pull request. It is valid for multiple pull requests to resolve a single issue in the interest of keeping code changes self contained and simpler to review. Once created, a team member will assign themselves for review and enable testing. To make sure the changes get merged, keep an eye out for reviews which can have multiple cycles. If the pull request is a critical bug fix then this will probably also be cherry picked to the current stable version of cert-manager as a patch release. To let people know that your PR is still a work in progress, we usually add a WIP: prefix to the title of the PR. Prow will then automatically set the label do-not-merge/work-in-progress .","title":"Creating Pull Requests"},{"location":"contributing/contributing-flow/#cherry-picking","text":"If the pull request contains a critical bug fix then this should be cherry picked in to the current stable cert-manager branch and released as a patch release . To trigger the cherry-pick process, add a comment to the GitHub PR. For example: /cherry-pick release-x.y The jetstack-bot will then create a new branch and a PR against the release branch, which should be reviewed, approved and merged using the process described above.","title":"Cherry Picking"},{"location":"contributing/contributing-flow/#dco-signoff","text":"All commits in the PR should be signed off, more info on how to do this is at the DCO Sign Off page. Exceptions can only be made for small documentation fixes.","title":"DCO signoff"},{"location":"contributing/contributing-flow/#project-management","text":"Most of cert-manager's project management is done on GitHub, with the help of Prow.","title":"Project Management"},{"location":"contributing/contributing-flow/#when-will-something-be-released","text":"Our team works using GitHub milestones . When a milestone is set on an Issue it is generally an indication of when we plan to address this. Prow will apply milestones on merged PRs, this will tell you in which version that PR will land. The milestone page will also have an indicated due date when we will release. This might have some delay. We brief our users/contributors about this in our bi-weekly community meeting, for an up to date status report we recommend joining these.","title":"When will something be released?"},{"location":"contributing/contributing-flow/#labels","text":"We make a heavy use of GitHub labels for PRs and Issues. The ones on PRs are mostly managed by Prow and code reviewers. In issues we always aim to add 3 types: area, priority and kind. These are set using Prow using /area , /kind and /priority . Sometimes /triage is also added which helps us when following up Issues. Area indicates the code area which is/will need changing Kind indicates if it is a bug or a feature but also can be documentation or cleanup (general maintenance) Priority is the priority it has for the cert-manager team, PRs are still very welcome for those!","title":"Labels"},{"location":"contributing/contributing-flow/#assignees-meaning-in-prs-and-issues","text":"Sometimes, you might see someone commenting with the /assign prow command : /assign @meyskens Here is the meaning that we give to the GitHub assignees: On issues, it means that the assignee is working on it. On PRs, we use it as a way to know who should be taking a look at the PR at any time: When the author is assigned, it means the PR needs work to be done aka \"changes requested\"; When nobody is assigned, it means this PR needs review; When someone different from the author is assigned, it means this person is reviewing this PR.","title":"Assignees meaning in PRs and issues"},{"location":"contributing/contributing-flow/#triage-party","text":"Every few weeks we will plan a Triage Party meeting, where we use the (Triage Party)[ https://triage.build-infra.jetstack.net/ ] tool to go recent/old issues to prioritise them so we can address them in a timely matter. These meetings are open to everyone and invites will be sent out using our mailing list (warning: despite the word party these meetings are sometimes boring).","title":"Triage Party!"},{"location":"contributing/crds/","text":"cert-manager uses Kubernetes Custom Resources to define the resources which users interact with when using cert-manager, such as Certificate s and Issuer s. When changes are made to the CRDs in code, there are a couple of extra steps which are required. Generating CRD Updates \u00b6 We use controller-gen to update our CRDs, and k8s-code-generator for code generation. Verifying and updating CRDs and generated code can be done entirely through make. There are two steps; one will update CRDs and one will update generated code: # Check that CRDs and codegen are up to date make verify-crds verify-codegen # Update CRDs based on code make update-crds # Update generated code based on CRD defintions in code make update-codegen Versions \u00b6 cert-manager currently has a single v1 API version for public use. cert-manager API types are defined in pkg/apis/certmanager . ACME related resources are in pkg/apis/acme . Code Comments \u00b6 Code comments on API type fields are converted into documentation on this website as well as appearing in the output of kubectl explain . That means that go doc -style comments on API fields should be written to be user-facing and not developer-facing. For this reason it's also fine to break from usual Go standards regarding code comments when editing these fields. Internal API Versions \u00b6 cert-manager also has an internal API version which lives under internal/apis . The internal version is only used for validation and conversion and controllers should not generally use it; it's not intended to be user-friendly or stable and can change. However all new fields also have to be added here for the conversion logic to work. For details on conversion and versions, see the official Kubernetes docs for CRD versioning . Kubebuilder \u00b6 While cert-manager doesn't fully use Kubebuilder, CRDs can make use of special Kubebuilder flags such as validation flags . Making Changes to APIs \u00b6 Please see our API compatibility promise for details on which types of changes to APIs are acceptable. Generally, the gist is that new fields can be added but that existing fields cannot be removed. This also means that when a field is added to a version of the API, it's permanent and its name cannot be changed. Because of this, we try to be cautious when adding new fields. The same principles apply to constants and enumerated types .","title":"CRDs"},{"location":"contributing/crds/#generating-crd-updates","text":"We use controller-gen to update our CRDs, and k8s-code-generator for code generation. Verifying and updating CRDs and generated code can be done entirely through make. There are two steps; one will update CRDs and one will update generated code: # Check that CRDs and codegen are up to date make verify-crds verify-codegen # Update CRDs based on code make update-crds # Update generated code based on CRD defintions in code make update-codegen","title":"Generating CRD Updates"},{"location":"contributing/crds/#versions","text":"cert-manager currently has a single v1 API version for public use. cert-manager API types are defined in pkg/apis/certmanager . ACME related resources are in pkg/apis/acme .","title":"Versions"},{"location":"contributing/crds/#code-comments","text":"Code comments on API type fields are converted into documentation on this website as well as appearing in the output of kubectl explain . That means that go doc -style comments on API fields should be written to be user-facing and not developer-facing. For this reason it's also fine to break from usual Go standards regarding code comments when editing these fields.","title":"Code Comments"},{"location":"contributing/crds/#internal-api-versions","text":"cert-manager also has an internal API version which lives under internal/apis . The internal version is only used for validation and conversion and controllers should not generally use it; it's not intended to be user-friendly or stable and can change. However all new fields also have to be added here for the conversion logic to work. For details on conversion and versions, see the official Kubernetes docs for CRD versioning .","title":"Internal API Versions"},{"location":"contributing/crds/#kubebuilder","text":"While cert-manager doesn't fully use Kubebuilder, CRDs can make use of special Kubebuilder flags such as validation flags .","title":"Kubebuilder"},{"location":"contributing/crds/#making-changes-to-apis","text":"Please see our API compatibility promise for details on which types of changes to APIs are acceptable. Generally, the gist is that new fields can be added but that existing fields cannot be removed. This also means that when a field is added to a version of the API, it's permanent and its name cannot be changed. Because of this, we try to be cautious when adding new fields. The same principles apply to constants and enumerated types .","title":"Making Changes to APIs"},{"location":"contributing/dns-providers/","text":"Creating DNS Providers \u00b6 Due to the large number of requests to support DNS providers to resolve DNS challenges, it became impractical and infeasible to maintain and test all DNS providers in the main cert-manager repository. For this reason, it was decided that new DNS providers should be supported out-of-tree by way of external webhooks. To implement an external DNS provider webhook, it is recommended to base your implementation on the cert-manager webhook-example . There's further information available in the configuration section: ACME DNS01 via webhook Configuring an ACME issuer with external webhook If you're struggling with creating a new DNS webhook, reach out on Slack !","title":"DNS Providers"},{"location":"contributing/dns-providers/#creating-dns-providers","text":"Due to the large number of requests to support DNS providers to resolve DNS challenges, it became impractical and infeasible to maintain and test all DNS providers in the main cert-manager repository. For this reason, it was decided that new DNS providers should be supported out-of-tree by way of external webhooks. To implement an external DNS provider webhook, it is recommended to base your implementation on the cert-manager webhook-example . There's further information available in the configuration section: ACME DNS01 via webhook Configuring an ACME issuer with external webhook If you're struggling with creating a new DNS webhook, reach out on Slack !","title":"Creating DNS Providers"},{"location":"contributing/e2e/","text":"cert-manager has an extensive end-to-end (e2e) test suite that verifies functionality against a real Kubernetes cluster. The full end-to-end test suite can take a long time to complete and is run against every pull request made to the cert-manager project. Unless you've made huge changes to the cert-manager codebase --- or to the end-to-end tests themselves --- you probably don't need to run the tests locally. If you do want to run the tests, though, this document explains how. The status of each commit on the master branch is reported on [`testgrid.k8s.io`](https://testgrid.k8s.io/jetstack-cert-manager-master). Join the [`cert-manager-dev-alerts`](https://groups.google.com/g/cert-manager-dev-alerts) Google group to receive email notifications when tests fail. Requirements \u00b6 There are no special requirements for the end-to-end tests. All dependencies can be provisioned automatically through the make build system. Set up End-to-End Tests \u00b6 Create a Cluster \u00b6 You can create a kind cluster using Make: # Create a cluster using whatever K8s version is default, named \"kind\" make e2e-setup-kind # Create a cluster using K8s 1 .23 named \"keith\" make K8S_VERSION=1.23 KIND_CLUSTER_NAME=keith e2e-setup-kind IMPORTANT: the kind cluster will be set up using a specific service CIDR range to enable certain functionality in end-to-end tests. This CIDR range is not currently configurable. Once complete, the cluster is available via kubectl as you'd expect. Install Test Dependencies \u00b6 There are various dependencies which the end-to-end tests require, all of which can also be installed via Make: make e2e-setup If you only need to update or reinstall one of these dependencies in your test cluster, you can instead install named components explicitly to save some time. The most common use case for this is to reinstall cert-manager itself , say if you've made a change locally and want to test that change in a cluster: # Most important: reinstall cert-manager, including rebuilding changed containers locally make e2e-setup-certmanager # An example of reinstalling something else ; reinstall bind make e2e-setup-bind # More generally, see make/e2e-setup.mk for different targets! Run End-to-End Tests \u00b6 As with setup, running tests is available through make. In fact, you can just run make e2e directly and avoid having to set anything up manually! # Set up a cluster using the defaults if one ' s not already present, and then run the end-to-end tests make e2e # Set up a K8s 1 .23 cluster and then run tests make K8S_VERSION=1.23 e2e # Run tests exactly as they ' re run in CI ; usually not needed make e2e-ci If you don't want to run every test you can focus on specific tests using GINKGO_FOCUS syntax, as described in the Ginkgo documentation : make GINKGO_FOCUS=\".*my test description\" e2e Cluster IP Details \u00b6 As mentioned above, the end-to-end tests expect that certain components are deployed in a specific way and even at specific IP addresses. By way of illustration, the following cluster components are deployed with specific IPs: Component / Make Target Used in IP DNS A Record e2e-setup-bind DNS-01 tests 10.0.0.16 e2e-setup-ingressnginx HTTP-01 Ingress tests 10.0.0.15 *.ingress-nginx.db.http01.example.com e2e-setup-projectcontour HTTP-01 GatewayAPI tests 10.0.0.14 *.gateway.db.http01.example.com If you don't set these components up correctly, you might see that the ACME HTTP01 (and other) end-to-end tests fail. End-to-End Test Structure \u00b6 The end-to-end tests consist of 2 main parts: issuer specific tests and the conformance suite. Both parts use Ginkgo to run their tests under the hood. Conformance Suite \u00b6 RBAC \u00b6 This suite tests all RBAC permissions granted to cert-manager on the cluster to check that it is able to operate correctly. Certificates \u00b6 This suite tests certificate functionality against all issuers. Feature Sets \u00b6 Some issuers don't support certain features, such as for example issuing Ed25519 certificates or adding an email address to the X.509 SAN extension. Each test specifies a used feature using s.checkFeatures(feature) , which is then checked against the issuer's UnsupportedFeatures list. Tests which use a feature unsupported by an issuer are skipped for that issuer. Cloud Provider Tests \u00b6 The master branch of cert-manager can also be tested against different cloud providers. Currently, tests for EKS are present which run as a periodic job once every two days. Extending The Cloud Provider Tests \u00b6 The infrastructure used to run the e2e tests on cloud providers is present in the cert-manager/test-infra repository. More cloud providers can be added by creating infrastructure for them using Terraform . Apart from that, tests for the existing infrastructure can be customized by editing their respective prow jobs present in the Jetstack testing repository repository. Values like the cert-manager version or the cloud provider version are present as variables in Terraform so their values can be changed when using terraform apply in the prow jobs, for example, for the EKS prow job the cert-manager version being tested can be changed using terraform apply -var=\"cert_manager_version=v1.3.3\" -auto-approve To see a list of all configurable variables present for a particular infrastructure you can see the variables.tf file for that cloud provider's infrastructure . Please note that the cloud provider tests run the e2e tests present in the master branch of cert-manager on a predefined version of cert-manager (can be changed in the prow job). Currently, they do not test code in a PR, but we have an issue tracking that request.","title":"Running End-to-End Tests"},{"location":"contributing/e2e/#requirements","text":"There are no special requirements for the end-to-end tests. All dependencies can be provisioned automatically through the make build system.","title":"Requirements"},{"location":"contributing/e2e/#set-up-end-to-end-tests","text":"","title":"Set up End-to-End Tests"},{"location":"contributing/e2e/#create-a-cluster","text":"You can create a kind cluster using Make: # Create a cluster using whatever K8s version is default, named \"kind\" make e2e-setup-kind # Create a cluster using K8s 1 .23 named \"keith\" make K8S_VERSION=1.23 KIND_CLUSTER_NAME=keith e2e-setup-kind IMPORTANT: the kind cluster will be set up using a specific service CIDR range to enable certain functionality in end-to-end tests. This CIDR range is not currently configurable. Once complete, the cluster is available via kubectl as you'd expect.","title":"Create a Cluster"},{"location":"contributing/e2e/#install-test-dependencies","text":"There are various dependencies which the end-to-end tests require, all of which can also be installed via Make: make e2e-setup If you only need to update or reinstall one of these dependencies in your test cluster, you can instead install named components explicitly to save some time. The most common use case for this is to reinstall cert-manager itself , say if you've made a change locally and want to test that change in a cluster: # Most important: reinstall cert-manager, including rebuilding changed containers locally make e2e-setup-certmanager # An example of reinstalling something else ; reinstall bind make e2e-setup-bind # More generally, see make/e2e-setup.mk for different targets!","title":"Install Test Dependencies"},{"location":"contributing/e2e/#run-end-to-end-tests","text":"As with setup, running tests is available through make. In fact, you can just run make e2e directly and avoid having to set anything up manually! # Set up a cluster using the defaults if one ' s not already present, and then run the end-to-end tests make e2e # Set up a K8s 1 .23 cluster and then run tests make K8S_VERSION=1.23 e2e # Run tests exactly as they ' re run in CI ; usually not needed make e2e-ci If you don't want to run every test you can focus on specific tests using GINKGO_FOCUS syntax, as described in the Ginkgo documentation : make GINKGO_FOCUS=\".*my test description\" e2e","title":"Run End-to-End Tests"},{"location":"contributing/e2e/#cluster-ip-details","text":"As mentioned above, the end-to-end tests expect that certain components are deployed in a specific way and even at specific IP addresses. By way of illustration, the following cluster components are deployed with specific IPs: Component / Make Target Used in IP DNS A Record e2e-setup-bind DNS-01 tests 10.0.0.16 e2e-setup-ingressnginx HTTP-01 Ingress tests 10.0.0.15 *.ingress-nginx.db.http01.example.com e2e-setup-projectcontour HTTP-01 GatewayAPI tests 10.0.0.14 *.gateway.db.http01.example.com If you don't set these components up correctly, you might see that the ACME HTTP01 (and other) end-to-end tests fail.","title":"Cluster IP Details"},{"location":"contributing/e2e/#end-to-end-test-structure","text":"The end-to-end tests consist of 2 main parts: issuer specific tests and the conformance suite. Both parts use Ginkgo to run their tests under the hood.","title":"End-to-End Test Structure"},{"location":"contributing/e2e/#conformance-suite","text":"","title":"Conformance Suite"},{"location":"contributing/e2e/#rbac","text":"This suite tests all RBAC permissions granted to cert-manager on the cluster to check that it is able to operate correctly.","title":"RBAC"},{"location":"contributing/e2e/#certificates","text":"This suite tests certificate functionality against all issuers.","title":"Certificates"},{"location":"contributing/e2e/#feature-sets","text":"Some issuers don't support certain features, such as for example issuing Ed25519 certificates or adding an email address to the X.509 SAN extension. Each test specifies a used feature using s.checkFeatures(feature) , which is then checked against the issuer's UnsupportedFeatures list. Tests which use a feature unsupported by an issuer are skipped for that issuer.","title":"Feature Sets"},{"location":"contributing/e2e/#cloud-provider-tests","text":"The master branch of cert-manager can also be tested against different cloud providers. Currently, tests for EKS are present which run as a periodic job once every two days.","title":"Cloud Provider Tests"},{"location":"contributing/e2e/#extending-the-cloud-provider-tests","text":"The infrastructure used to run the e2e tests on cloud providers is present in the cert-manager/test-infra repository. More cloud providers can be added by creating infrastructure for them using Terraform . Apart from that, tests for the existing infrastructure can be customized by editing their respective prow jobs present in the Jetstack testing repository repository. Values like the cert-manager version or the cloud provider version are present as variables in Terraform so their values can be changed when using terraform apply in the prow jobs, for example, for the EKS prow job the cert-manager version being tested can be changed using terraform apply -var=\"cert_manager_version=v1.3.3\" -auto-approve To see a list of all configurable variables present for a particular infrastructure you can see the variables.tf file for that cloud provider's infrastructure . Please note that the cloud provider tests run the e2e tests present in the master branch of cert-manager on a predefined version of cert-manager (can be changed in the prow job). Currently, they do not test code in a PR, but we have an issue tracking that request.","title":"Extending The Cloud Provider Tests"},{"location":"contributing/external-issuers/","text":"cert-manager offers a number of core issuer types that represent various certificate authorities. Since the number of potential issuers is larger than what could reasonably be supported in the main cert-manager repository, cert-manager also supports out-of-tree external issuers, and treats them the same as in-tree issuer types. This document is for people looking to create external issuers. For more information on how to install and configure external issuer types, read the configuration documentation . General Overview \u00b6 An issuer represents a certificate authority that signs incoming certificate requests. In cert-manager, the CertificateRequest resource represents a single request for a signed certificate, containing the raw certificate request PEM data as well as other information relating to the desired certificate. In cert-manager, each issuer type has its own controller that watches these CertificateRequest resources and checks to see if a given CertificateRequest is configured to use the issuer. This is done via the issuerRef stanza on the CertificateRequest which contains an issuer name , kind and group . group denotes an API group such as cert-manager.io (which is responsible for all core issuer types). kind denotes the \"kind\" resource type of the issuer - usually Issuer or ClusterIssuer . name denotes the name of the issuer resource of the specified kind. An example might be my-ca-issuer . When an issuer controller observes a new CertificateRequest which refers to it, it then ensures that the corresponding issuer resource exists in Kubernetes. It then uses the information inside the issuer resource to attempt to create a signed certificate, based upon the information inside the certificate request. Sample External Issuer \u00b6 If you want to create an External Issuer, the best place to start is likely to be the Sample External Issuer . The Sample External Issuer is maintained by the cert-manager team, and its README file has step-by-step instructions on how to write an external issuer using Kubebuilder and controller-runtime. Approval \u00b6 Before signing a certificate, Issuers must also ensure that the CertificateRequest is Approved . If the CertificateRequest is not Approved , the issuer must not process it. Issuers are not responsible for approving CertificateRequests and should refuse to proceed if they find a certificate that is not approved. Supporting Legacy cert-manager Releases \u00b6 Certificate approval was added to cert-manager in v1.3 . In order to support older versions of cert-manager, external issuers may choose to sign CertificateRequests that will never have an approval condition set, but this should be feature-gated and disabled by default. If you're creating a new External Issuer today, we'd strongly recommend that you do not support such old versions of cert-manager. Conditions \u00b6 Once a signed certificate has been gathered by the issuer controller, it updates the status of the CertificateRequest resource with the signed certificate. It is then important to update the condition status of that resource to a ready state, as this is what is used to signal to higher order controllers - such as the Certificate controller - that the resource is ready to be consumed. Conversely, if the CertificateRequest fails, it is as important to mark the resource as such, as this will also be used as a signal to higher order controllers. Valid condition states are listed under concepts . Implementation \u00b6 It is recommended that you make use of the kubebuilder project in order to implement your external issuer controller. This makes it very simple to generate CustomResourceDefinitions and gives you a lot of controller functionality out of the box. If you have further questions on how to implement an external issuer controller, it is best to reach out on slack or to join a community calls .","title":"Implementing External Issuers"},{"location":"contributing/external-issuers/#general-overview","text":"An issuer represents a certificate authority that signs incoming certificate requests. In cert-manager, the CertificateRequest resource represents a single request for a signed certificate, containing the raw certificate request PEM data as well as other information relating to the desired certificate. In cert-manager, each issuer type has its own controller that watches these CertificateRequest resources and checks to see if a given CertificateRequest is configured to use the issuer. This is done via the issuerRef stanza on the CertificateRequest which contains an issuer name , kind and group . group denotes an API group such as cert-manager.io (which is responsible for all core issuer types). kind denotes the \"kind\" resource type of the issuer - usually Issuer or ClusterIssuer . name denotes the name of the issuer resource of the specified kind. An example might be my-ca-issuer . When an issuer controller observes a new CertificateRequest which refers to it, it then ensures that the corresponding issuer resource exists in Kubernetes. It then uses the information inside the issuer resource to attempt to create a signed certificate, based upon the information inside the certificate request.","title":"General Overview"},{"location":"contributing/external-issuers/#sample-external-issuer","text":"If you want to create an External Issuer, the best place to start is likely to be the Sample External Issuer . The Sample External Issuer is maintained by the cert-manager team, and its README file has step-by-step instructions on how to write an external issuer using Kubebuilder and controller-runtime.","title":"Sample External Issuer"},{"location":"contributing/external-issuers/#approval","text":"Before signing a certificate, Issuers must also ensure that the CertificateRequest is Approved . If the CertificateRequest is not Approved , the issuer must not process it. Issuers are not responsible for approving CertificateRequests and should refuse to proceed if they find a certificate that is not approved.","title":"Approval"},{"location":"contributing/external-issuers/#supporting-legacy-cert-manager-releases","text":"Certificate approval was added to cert-manager in v1.3 . In order to support older versions of cert-manager, external issuers may choose to sign CertificateRequests that will never have an approval condition set, but this should be feature-gated and disabled by default. If you're creating a new External Issuer today, we'd strongly recommend that you do not support such old versions of cert-manager.","title":"Supporting Legacy cert-manager Releases"},{"location":"contributing/external-issuers/#conditions","text":"Once a signed certificate has been gathered by the issuer controller, it updates the status of the CertificateRequest resource with the signed certificate. It is then important to update the condition status of that resource to a ready state, as this is what is used to signal to higher order controllers - such as the Certificate controller - that the resource is ready to be consumed. Conversely, if the CertificateRequest fails, it is as important to mark the resource as such, as this will also be used as a signal to higher order controllers. Valid condition states are listed under concepts .","title":"Conditions"},{"location":"contributing/external-issuers/#implementation","text":"It is recommended that you make use of the kubebuilder project in order to implement your external issuer controller. This makes it very simple to generate CustomResourceDefinitions and gives you a lot of controller functionality out of the box. If you have further questions on how to implement an external issuer controller, it is best to reach out on slack or to join a community calls .","title":"Implementation"},{"location":"contributing/importing/","text":"cert-manager is written in Go, and uses Go modules. You can import it as a Go module, and in some cases that's fine or even encouraged, but as a rule we generally recommend against importing cert-manager. Generally speaking, except for the cases listed below under When You Might Import cert-manager , code in the cert-manager repository is not covered under any Go module compatibility guarantee. We can and will make breaking changes, even in publicly exported Go code and even in a minor or patch release of cert-manager. We have made breaking changes like this in the past. Note that this doesn't affect running cert-manager. Our commitment on compatibility is to not break the runtime functionality of cert-manager, and we take that seriously. If you're certain that you do need to import cert-manager as a module, see Module Import Paths below for a note on how to do that. When You Might Import cert-manager \u00b6 You might need to import cert-manager if you're writing Go code which: uses cert-manager custom resources, so you want to import something under pkg/apis implements an external DNS solver webhook, as in the webhook-example implements an external issuer, as in the sample-external-issuer If you think you really need to import other parts of the code, please do reach out and talk to us so we're aware of this need! We'll always try to avoid breakage where we can. Module Import Paths \u00b6 The original cert-manager repository was created on GitHub as https://github.com/jetstack/cert-manager , and was later migrated to https://github.com/cert-manager/cert-manager . This means the Go module import path you need depends on the version of cert-manager you're trying to use. For cert-manager 1.8 and later, use the new path: github.com/cert-manager/cert-manager For cert-manager 1.7 and earlier, including all point releases, use the old path: github.com/jetstack/cert-manager","title":"Importing cert-manager in Go"},{"location":"contributing/importing/#when-you-might-import-cert-manager","text":"You might need to import cert-manager if you're writing Go code which: uses cert-manager custom resources, so you want to import something under pkg/apis implements an external DNS solver webhook, as in the webhook-example implements an external issuer, as in the sample-external-issuer If you think you really need to import other parts of the code, please do reach out and talk to us so we're aware of this need! We'll always try to avoid breakage where we can.","title":"When You Might Import cert-manager"},{"location":"contributing/importing/#module-import-paths","text":"The original cert-manager repository was created on GitHub as https://github.com/jetstack/cert-manager , and was later migrated to https://github.com/cert-manager/cert-manager . This means the Go module import path you need depends on the version of cert-manager you're trying to use. For cert-manager 1.8 and later, use the new path: github.com/cert-manager/cert-manager For cert-manager 1.7 and earlier, including all point releases, use the old path: github.com/jetstack/cert-manager","title":"Module Import Paths"},{"location":"contributing/kind/","text":"Kind allows you to provision Kubernetes clusters locally using nested Docker containers, with no requirement for virtual machines. These clusters are quick to create and destroy, and are useful for simple testing for development. cert-manager also uses kind clusters in its end-to-end tests . Using Kind Locally \u00b6 You should be able to make use of cert-manager's end-to-end test setup logic to create a local Kind cluster for development. As such, if you want a local cluster you might want to follow some of the details in the end-to-end test documentation . If, though, you just want to get a cluster up and running with your local changes to cert-manager running inside kind , try the following: make e2e-setup-kind e2e-setup-certmanager Or, if you need a specific version of Kubernetes: make K8S_VERSION=1.xx e2e-setup-kind e2e-setup-certmanager That should leave you with a working cluster which you can interact with using kubectl !","title":"Developing with Kind"},{"location":"contributing/kind/#using-kind-locally","text":"You should be able to make use of cert-manager's end-to-end test setup logic to create a local Kind cluster for development. As such, if you want a local cluster you might want to follow some of the details in the end-to-end test documentation . If, though, you just want to get a cluster up and running with your local changes to cert-manager running inside kind , try the following: make e2e-setup-kind e2e-setup-certmanager Or, if you need a specific version of Kubernetes: make K8S_VERSION=1.xx e2e-setup-kind e2e-setup-certmanager That should leave you with a working cluster which you can interact with using kubectl !","title":"Using Kind Locally"},{"location":"contributing/policy/","text":"We love to receive both feature requests and PRs which add to and improve cert-manager; the community is at the heart of what we do! If you're thinking of adding a feature, we recommend you read this doc to maximize the chances of your contribution getting the attention it deserves and hopefully to get it merged quickly! We recommend creating an issue first for it to be discussed with the cert-manager maintainers. Another possibility is bringing it up in a community meeting for an open discussion on the implementation. Feature Sizing: Getting Your Change Accepted \u00b6 We evaluate new features and PRs based on their size and their significance; either they're small or large. Smaller Features \u00b6 Many contributions are small. That usually - but not always - means that implementing them won't require many lines of code to be added or changed, and in any case they should be easy for maintainers to review. A PR being small is a good thing; if you can down-scope your feature to make it smaller, we won't complain! If you believe your feature is small, please feel free to just raise a PR and optionally also post a link to your PR in the cert-manager-dev slack channel . Usually a sufficiently small PR can be merged without too much ceremony. If we think it's actually a larger piece of work, we'll let you know. Larger Features \u00b6 If you're not sure whether your PR is small, or if you know it's bigger, you'll want to speak to us first before raising a PR. This will help to ensure that your PR is something we're likely to merge to avoid wasting your time. It'll also make it easier for us to do the design process. Design Documents \u00b6 Larger feature development should normally start with a design discussion. To get that started, you would raise a PR with a design document against cert-manager/cert-manager/design . This allows us to discuss the proposed functionality before starting the work to implement it and serves as a way to document the decisions and reasoning behind them. Ideally, a good design document should allow for faster and more consistent feature development and implementation process by providing a single place where all potential concerns and questions are answered. We have a design template that outlines the structure of the document. (This is a simplified version of Kubernetes enhancements KEP template ). Do reach out if you need help with the design. Part of the process of discussing a design document may also include a video call with you included! That helps us to plan how a feature should be implemented and approached. It'll be pretty informal and casual; we just want to make sure we're all on the same page. This call might be part of a biweekly meeting. Making Progress with Larger Features \u00b6 Larger features with a design document are much more likely to be accepted, and in turn we're much more likely to commit a single named cert-manager maintainer to the effort to help the PR to be successful. That maintainer might not be able to answer all your questions, but they should certainly be able to point you in the right direction. To get in touch to discuss a feature, please reach out on the cert-manager-dev slack channel , or join a cert-manager public meeting to talk about your proposal. If you have an open PR with a design document (or have some questions about how to proceed with a design), you should absolutely feel free to add the PR with your design or a link to the relevant GitHub issue to the meeting notes for our next biweekly meeting and join in so we're sure to discuss it and so you can contribute to the discussion! Large Feature Lifecycle \u00b6 Informally ask about the feature in slack or a public meeting Create a PR with a lightweight design document using the design template , for discussion Design doc PR gets reviewed - possibly includes meeting or discussion in a biweekly meeting Implement your feature, helped and reviewed by a named cert-manager maintainer Feature Requests We'll Likely Reject \u00b6 In some cases, people will request features which we've previously rejected or which for some reason we have to reject. It's nothing personal; sometimes we have to make tough choices and especially when it comes to security and maintainability we have to reject certain proposals. If your feature request is listed below, there's a high chance we'll have to reject it. That said, if you think we've made a mistake and that we should reconsider, we're open to chatting - consider joining our biweekly meetings to discuss it with us! Vendoring Kubernetes related APIs outside of the k8s.io/ namespace \u00b6 Vendoring project APIs that also vendor k8s.io/apimachinery , such as OpenShift, Contour, or Velero, is not recommend because the Kubernetes dependency is likely to conflict with cert-manager's instance. It could also cause a conflict with different Kubernetes client versions being used. If this is needed it is suggested to use a \"dynamic client\" that converts the objects into internal structures copied into the cert-manager codebase. Additional configuration options for the Helm chart \u00b6 cert-manager's Helm chart is intended to allow to create a standard, best practices cert-manager installation with basic configuration options, such as being able to provide flags to cert-manager components, label resources etc. We do not aim to include every possible configuration option for resources that the chart creates to avoid maintenance burden and because we do not have automated testing for all chart configuration options. Therefore we are likely to not accept PRs that add advanced or niche configuration options to Helm charts- we recommend that users who require that configuration use another mechanism such as Helm's post-install hooks . Helm + CRDs \u00b6 Helm suggests that CRDs be included in a crds/ subdirectory of a chart, with the crd-install annotation included. This has the unfortunate side effect that CRDs are not upgraded if changed in a later release. CRDs being upgraded without being removed and re-installed is essential for cert-manager to move forward. This was previously discussed in the Helm community . cert-manager works around this limitation by shipping CRDs in the templates. Helm Subchart capabilities \u00b6 cert-manager now has the capability to be installed as a subchart . But you need to be careful when adding it to your umbrella chart. This is because the cert-manager installation creates cluster scoped resources like admission webhooks and custom resource definitions. cert-manager should be seen as part of your cluster and should be treated as such for being installed. An apt comparison to other Kubernetes components would be a LoadBalancer controller or a PV provisioner. It is your responsibility to ensure that cert-manager is only installed once in your cluster. This can be managed via the condition parameter of the dependency in your Chart.yaml , which allows users to disable the installation of a subchart. The condition parameter must be added when using cert-manager as a subchart to allow users to disable your dependency. apiVersion : v2 name : example_chart description : A Helm chart with cert-manager as subchart type : application version : 0.1.0 appVersion : \"0.1.0\" dependencies : - name : cert-manager version : v1.8.0 repository : https://charts.jetstack.io alias : cert-manager condition : cert-manager.enabled Secret injection or copying \u00b6 cert-manager deals with very sensitive information (all TLS certificates for your services) and has cluster-level access to secret resources. As such, when designing features we need to consider all of the ways these secrets might be abused to escalate privilege. Secret data is meant to be securely stored in Secret resources and have narrow scoped access privileges for unauthorized users. Because of this, we won't usually add any functionality that allows this data to be copied/injected into any resource other than a Kubernetes Secret . cainjector \u00b6 The cainjector component is a special exception to this rule as it deals in non-sensitive information (CAs, not cert/key pairs). This component is able to inject the ca.crt file into predefined fields on ValidatingWebhookConfiguration , MutatingWebhookConfiguration , and CustomResourceDefinition resources from Certificate resources. These 3 components are already scoped only for privileged users, and will already give you cluster scoped access to resources. If you\u2019re designing a resource that needs a CA Certificate or TLS key pair it is strongly recommended to use a reference to a secret instead of embedding it in a resource. Cross namespace resources \u00b6 Namespace boundaries in Kubernetes provide a barrier for access scopes. Apps or users can be limited to only access resources in a certain namespace. cert-manager is a controller that operates on cluster wide resources however, and while it may seem interesting to allow access to copy or write certificate data from one namespace to the other, this can cause a bypass of the namespace security model for all users, which is usually not intended and can be a major a security issue. We don't support this behavior; if you believe you need it, and it's intended for your use case then there are other Kubernetes controllers that can do this, although we'd suggest extreme caution. Sign certificates using the Kubernetes CA \u00b6 Kubernetes has a Certificate Signing Requests API, and a kubectl certificates command which allows you to approve certificate signing requests and have them signed by the certificate authority (CA) of the Kubernetes cluster. This CA is generally used for your nodes. This API and CLI have occasionally been misused to sign certificates for use by pods outside of the control plane; we believe this is a mistake. For the security of the Kubernetes cluster it's important to limit access to the Kubernetes certificate authority; such certificates increase the attack surface for the Kubernetes API server since this CA signs certificates for authorization against the API server. If cert-manager used this cert, it could allow any user with permission to create cert-manager resources to elevate privileges by signing certificates which are trusted for API access. See our FAQ for more details on this. Integrations with third party infrastructure providers \u00b6 We try to not include in core cert-manager new functionality that involves calling third party APIs that we don't have infrastructure to test (or that the maintainers don't have the skills to work with). Instead we try to build interfaces such as external DNS webhook solver that can be implemented to use cert-manager with a particular third party implementation. We believe that this is a more sustainable approach as that way folks who have knowledge and skills to work with particular infrastructure can own a project that interacts with it and it lets us avoid merging potentially untested code to core cert-manager. An example of a PR that might be rejected would be adding a new external DNS solver kind, see https://github.com/cert-manager/cert-manager/pull/1088","title":"Feature Policy"},{"location":"contributing/policy/#feature-sizing-getting-your-change-accepted","text":"We evaluate new features and PRs based on their size and their significance; either they're small or large.","title":"Feature Sizing: Getting Your Change Accepted"},{"location":"contributing/policy/#smaller-features","text":"Many contributions are small. That usually - but not always - means that implementing them won't require many lines of code to be added or changed, and in any case they should be easy for maintainers to review. A PR being small is a good thing; if you can down-scope your feature to make it smaller, we won't complain! If you believe your feature is small, please feel free to just raise a PR and optionally also post a link to your PR in the cert-manager-dev slack channel . Usually a sufficiently small PR can be merged without too much ceremony. If we think it's actually a larger piece of work, we'll let you know.","title":"Smaller Features"},{"location":"contributing/policy/#larger-features","text":"If you're not sure whether your PR is small, or if you know it's bigger, you'll want to speak to us first before raising a PR. This will help to ensure that your PR is something we're likely to merge to avoid wasting your time. It'll also make it easier for us to do the design process.","title":"Larger Features"},{"location":"contributing/policy/#design-documents","text":"Larger feature development should normally start with a design discussion. To get that started, you would raise a PR with a design document against cert-manager/cert-manager/design . This allows us to discuss the proposed functionality before starting the work to implement it and serves as a way to document the decisions and reasoning behind them. Ideally, a good design document should allow for faster and more consistent feature development and implementation process by providing a single place where all potential concerns and questions are answered. We have a design template that outlines the structure of the document. (This is a simplified version of Kubernetes enhancements KEP template ). Do reach out if you need help with the design. Part of the process of discussing a design document may also include a video call with you included! That helps us to plan how a feature should be implemented and approached. It'll be pretty informal and casual; we just want to make sure we're all on the same page. This call might be part of a biweekly meeting.","title":"Design Documents"},{"location":"contributing/policy/#making-progress-with-larger-features","text":"Larger features with a design document are much more likely to be accepted, and in turn we're much more likely to commit a single named cert-manager maintainer to the effort to help the PR to be successful. That maintainer might not be able to answer all your questions, but they should certainly be able to point you in the right direction. To get in touch to discuss a feature, please reach out on the cert-manager-dev slack channel , or join a cert-manager public meeting to talk about your proposal. If you have an open PR with a design document (or have some questions about how to proceed with a design), you should absolutely feel free to add the PR with your design or a link to the relevant GitHub issue to the meeting notes for our next biweekly meeting and join in so we're sure to discuss it and so you can contribute to the discussion!","title":"Making Progress with Larger Features"},{"location":"contributing/policy/#large-feature-lifecycle","text":"Informally ask about the feature in slack or a public meeting Create a PR with a lightweight design document using the design template , for discussion Design doc PR gets reviewed - possibly includes meeting or discussion in a biweekly meeting Implement your feature, helped and reviewed by a named cert-manager maintainer","title":"Large Feature Lifecycle"},{"location":"contributing/policy/#feature-requests-well-likely-reject","text":"In some cases, people will request features which we've previously rejected or which for some reason we have to reject. It's nothing personal; sometimes we have to make tough choices and especially when it comes to security and maintainability we have to reject certain proposals. If your feature request is listed below, there's a high chance we'll have to reject it. That said, if you think we've made a mistake and that we should reconsider, we're open to chatting - consider joining our biweekly meetings to discuss it with us!","title":"Feature Requests We'll Likely Reject"},{"location":"contributing/policy/#vendoring-kubernetes-related-apis-outside-of-the-k8sio-namespace","text":"Vendoring project APIs that also vendor k8s.io/apimachinery , such as OpenShift, Contour, or Velero, is not recommend because the Kubernetes dependency is likely to conflict with cert-manager's instance. It could also cause a conflict with different Kubernetes client versions being used. If this is needed it is suggested to use a \"dynamic client\" that converts the objects into internal structures copied into the cert-manager codebase.","title":"Vendoring Kubernetes related APIs outside of the k8s.io/ namespace"},{"location":"contributing/policy/#additional-configuration-options-for-the-helm-chart","text":"cert-manager's Helm chart is intended to allow to create a standard, best practices cert-manager installation with basic configuration options, such as being able to provide flags to cert-manager components, label resources etc. We do not aim to include every possible configuration option for resources that the chart creates to avoid maintenance burden and because we do not have automated testing for all chart configuration options. Therefore we are likely to not accept PRs that add advanced or niche configuration options to Helm charts- we recommend that users who require that configuration use another mechanism such as Helm's post-install hooks .","title":"Additional configuration options for the Helm chart"},{"location":"contributing/policy/#helm-crds","text":"Helm suggests that CRDs be included in a crds/ subdirectory of a chart, with the crd-install annotation included. This has the unfortunate side effect that CRDs are not upgraded if changed in a later release. CRDs being upgraded without being removed and re-installed is essential for cert-manager to move forward. This was previously discussed in the Helm community . cert-manager works around this limitation by shipping CRDs in the templates.","title":"Helm + CRDs"},{"location":"contributing/policy/#helm-subchart-capabilities","text":"cert-manager now has the capability to be installed as a subchart . But you need to be careful when adding it to your umbrella chart. This is because the cert-manager installation creates cluster scoped resources like admission webhooks and custom resource definitions. cert-manager should be seen as part of your cluster and should be treated as such for being installed. An apt comparison to other Kubernetes components would be a LoadBalancer controller or a PV provisioner. It is your responsibility to ensure that cert-manager is only installed once in your cluster. This can be managed via the condition parameter of the dependency in your Chart.yaml , which allows users to disable the installation of a subchart. The condition parameter must be added when using cert-manager as a subchart to allow users to disable your dependency. apiVersion : v2 name : example_chart description : A Helm chart with cert-manager as subchart type : application version : 0.1.0 appVersion : \"0.1.0\" dependencies : - name : cert-manager version : v1.8.0 repository : https://charts.jetstack.io alias : cert-manager condition : cert-manager.enabled","title":"Helm Subchart capabilities"},{"location":"contributing/policy/#secret-injection-or-copying","text":"cert-manager deals with very sensitive information (all TLS certificates for your services) and has cluster-level access to secret resources. As such, when designing features we need to consider all of the ways these secrets might be abused to escalate privilege. Secret data is meant to be securely stored in Secret resources and have narrow scoped access privileges for unauthorized users. Because of this, we won't usually add any functionality that allows this data to be copied/injected into any resource other than a Kubernetes Secret .","title":"Secret injection or copying"},{"location":"contributing/policy/#cainjector","text":"The cainjector component is a special exception to this rule as it deals in non-sensitive information (CAs, not cert/key pairs). This component is able to inject the ca.crt file into predefined fields on ValidatingWebhookConfiguration , MutatingWebhookConfiguration , and CustomResourceDefinition resources from Certificate resources. These 3 components are already scoped only for privileged users, and will already give you cluster scoped access to resources. If you\u2019re designing a resource that needs a CA Certificate or TLS key pair it is strongly recommended to use a reference to a secret instead of embedding it in a resource.","title":"cainjector"},{"location":"contributing/policy/#cross-namespace-resources","text":"Namespace boundaries in Kubernetes provide a barrier for access scopes. Apps or users can be limited to only access resources in a certain namespace. cert-manager is a controller that operates on cluster wide resources however, and while it may seem interesting to allow access to copy or write certificate data from one namespace to the other, this can cause a bypass of the namespace security model for all users, which is usually not intended and can be a major a security issue. We don't support this behavior; if you believe you need it, and it's intended for your use case then there are other Kubernetes controllers that can do this, although we'd suggest extreme caution.","title":"Cross namespace resources"},{"location":"contributing/policy/#sign-certificates-using-the-kubernetes-ca","text":"Kubernetes has a Certificate Signing Requests API, and a kubectl certificates command which allows you to approve certificate signing requests and have them signed by the certificate authority (CA) of the Kubernetes cluster. This CA is generally used for your nodes. This API and CLI have occasionally been misused to sign certificates for use by pods outside of the control plane; we believe this is a mistake. For the security of the Kubernetes cluster it's important to limit access to the Kubernetes certificate authority; such certificates increase the attack surface for the Kubernetes API server since this CA signs certificates for authorization against the API server. If cert-manager used this cert, it could allow any user with permission to create cert-manager resources to elevate privileges by signing certificates which are trusted for API access. See our FAQ for more details on this.","title":"Sign certificates using the Kubernetes CA"},{"location":"contributing/policy/#integrations-with-third-party-infrastructure-providers","text":"We try to not include in core cert-manager new functionality that involves calling third party APIs that we don't have infrastructure to test (or that the maintainers don't have the skills to work with). Instead we try to build interfaces such as external DNS webhook solver that can be implemented to use cert-manager with a particular third party implementation. We believe that this is a more sustainable approach as that way folks who have knowledge and skills to work with particular infrastructure can own a project that interacts with it and it lets us avoid merging potentially untested code to core cert-manager. An example of a PR that might be rejected would be adding a new external DNS solver kind, see https://github.com/cert-manager/cert-manager/pull/1088","title":"Integrations with third party infrastructure providers"},{"location":"contributing/release-process/","text":"This document aims to outline the process that should be followed for cutting a new release of cert-manager. If you would like to know more about current releases and the timeline for future releases, take a look at the Supported Releases page. Prerequisites \u00b6 \u26d4\ufe0f Do not proceed with the release process if you do not meet all of the following conditions: The relevant testgrid dashboard should not be failing for the release you're trying to perform. The release process takes about 40 minutes . You must have time to complete all the steps. You currently need to be at Jetstack to get the required GitHub and GCP permissions. (we'd like contributors outside Jetstack to be able to get access; if that's of interest to you, please let us know). You need to have the GitHub admin permission on the cert-manager project. To check that you have the admin role, run: brew install gh gh auth login gh api /repos/cert-manager/cert-manager/collaborators/ $( gh api /user | jq -r .login ) /permission | jq .permission If your permission is admin , then you are good to go. To request the admin permission on the cert-manager project, open a PR with a link to here. You need to be added as an \"Editor\" to the GCP project cert-manager-release . To check if you do have access, try opening the Cloud Build page . To get the \"Editor\" permission on the GCP project, open a PR with your name added to the maintainers list in cert_manager_release.tf --- a/cert_manager_release.tf +++ b/cert_manager_release.tf @@ -17,6 +17,7 @@ locals { var.personal_email[\"...\"], var.personal_email[\"...\"], var.personal_email[\"...\"], + var.personal_email[\"mael-valais\"], ]) } You may use the following PR description: Title: Access to the cert-manager-release GCP project Hi. As stated in \"Prerequisites\" on the [ release-process ][ 1 ] page, I need access to the [ cert-manager-release ][ 2 ] project on GCP in order to perform the release process. Thanks! [ 1 ]: https://cert-manager.io/docs/contributing/release-process/#prerequisites [ 2 ]: https://console.cloud.google.com/?project=cert-manager-release This guide applies for versions of cert-manager released using make , which should be every version from cert-manager 1.8 and later. If you need to release a version of cert-manager 1.7 or earlier see older releases . First, ensure that you have all the tools required to perform a cert-manager release: Install the release-notes CLI: go install k8s.io/release/cmd/release-notes@v0.13.0 Install our cmrel CLI: go install github.com/cert-manager/release/cmd/cmrel@latest Clone the cert-manager/release repo: # Don't clone it from inside the cert-manager repo folder. git clone https://github.com/cert-manager/release cd release Install the gcloud CLI. Login to gcloud : gcloud auth application-default login Make sure gcloud points to the cert-manager-release project: gcloud config set project cert-manager-release export CLOUDSDK_CORE_PROJECT = cert-manager-release # this is used by cmrel Get a GitHub access token here with no scope ticked. It is used only by the release-notes CLI to avoid API rate limiting since it will go through all the PRs one by one. Minor releases \u00b6 A minor release is a backwards-compatible 'feature' release. It can contain new features and bug fixes. Release schedule \u00b6 We aim to cut a new minor release once per month. The rough goals for each release are outlined as part of a GitHub milestone. We cut a release even if some of these goals are missed, in order to keep up release velocity. Process for releasing a version \u00b6 \ud83d\udd30 Please click on the **Edit this page** button on the top-right corner of this page if a step is missing or if it is outdated. Make sure to note which type of release you are doing. That will be helpful in the next steps. Type of release Example of git tag initial alpha release v1.3.0-alpha.0 subsequent alpha release v1.3.0-alpha.1 initial beta release v1.3.0-beta.0 subsequent beta release v1.3.0-beta.1 final release v1.3.0 (optional) patch pre-release 1 v1.3.1-beta.0 patch release (or \"point release\") v1.3.1 (final release only) Make sure that a PR with the new upgrade document is ready to be merged on cert-manager/website . See for example, see upgrading-1.0-1.1 . Update the release branch: (initial alpha, subsequent alpha and initial beta) The release branch should already exist (it was created at the end of the last final release). Update the release branch with the latest commits from the master branch, as follows: # Must be run from the cert-manager repo folder. git fetch --all git branch --force release-1.0 origin/release-1.0 git checkout release-1.0 git merge --ff-only origin/master # don't run for a point release! (subsequent beta, patch release and final release) : do nothing since things have been merged using /cherry-pick release-1.0 . Note about the code freeze: The first beta starts a new \"code freeze\" period that lasts until the final release. Just before the code freeze, we fast-forward everything from master into the release branch. During the code freeze, we continue merging PRs into master as usual. We don't fast-forward master into the release branch for the second (and subsequent) beta, and only /cherry-pick release-1.0 the fixes that should be part of the subsequent beta. We don't fast-forward for patch releases and final releases; instead, we prepare these releases using the /cherry-pick release-1.0 command. Push the new or updated release branch and create the tag: Check that the origin remote is correct. To do that, run the following command and make sure it returns the upstream https://github.com/cert-manager/cert-manager.git : # Must be run from the cert-manager repo folder. git remote -v | grep origin Push the release branch: # Must be run from the cert-manager repo folder. git push --set-upstream origin release-1.0 GitHub permissions : git push will only work if you have the admin GitHub permission on the cert-manager repo to create or push to the branch, see prerequisites . If you do not have this permission, you will have to open a PR to merge master into the release branch), and wait for the PR checks to become green. Create the tag for the new release locally and push it upstream: git tag -m \"v1.8.0-beta.0\" v1.8.0-beta.0 # be sure to push the named tag explicitly; you don't want to push any other local tags! git push origin v1.8.0-beta.0 Generate and edit the release notes: Use the following two tables to understand how to fill in the four environment variables needed for the next step. These four environment variables are documented on the README for the Kubernetes release-notes tool. Variable Description START_REV * The git tag of the \"previous\"* release END_REV Name of your release branch (inclusive) BRANCH Name of your release branch RELEASE_VERSION The git tag Examples for each release type (e.g., initial alpha release): Variable Example 1 Example 2 Example 2 Example 3 Example 4 initial alpha subsequent alpha beta release final release patch release v1.3.0-alpha.0 v1.3.0-alpha.1 v1.3.0-beta.0 v1.3.0 v1.3.1 START_TAG * v1.2.0 v1.3.0-alpha.0 v1.3.0-alpha.1 v1.2.0 ** v1.3.0 END_REV release-1.3 release-1.3 release-1.3 release-1.3 release-1.3 BRANCH release-1.3 release-1.3 release-1.3 release-1.3 release-1.3 RELEASE_VERSION v1.3.0-alpha.0 v1.3.0-alpha.1 v1.3.0-beta.0 v1.3.0 v1.3.1 *The git tag of the \"previous\" release ( START_TAG ) depends on which type of release you count on doing. Look at the above examples to understand a bit more what those are. **Do not use a patch here (e.g., no v1.2.3 ). It must be v1.2.0 : you must use the latest tag that belongs to the release branch you are releasing on; in the above example, the release branch is release-1.3 , and the latest tag on that branch is v1.2.0 . After finding out the value for each of the 4 environment variables, set the variables in your shell (for example, following the example 1): export RELEASE_VERSION = \"v1.3.0-alpha.0\" export BRANCH = \"release-1.3\" export START_TAG = \"v1.2.0\" export END_REV = \"release-1.3\" Generate release-notes.md at the root of your cert-manager repo folder with the following command: # Must be run from the cert-manager folder. export GITHUB_TOKEN = *your-token* git fetch origin $BRANCH : $BRANCH export START_SHA = \" $( git rev-list --reverse --ancestry-path $( git merge-base $START_TAG $BRANCH ) .. $BRANCH | head -1 ) \" release-notes --debug --repo-path cert-manager \\ --org cert-manager --repo cert-manager \\ --required-author \"jetstack-bot\" \\ --output release-notes.md The GitHub token does not need any scope . The token is required only to avoid rate-limits imposed on anonymous API users. Sanity check the notes: Make sure the notes contain details of all the features and bug fixes that you expect to be in the release. Add additional blurb, notable items and characterize change log. You can see the commits that will go into this release by using the GitHub compare . For example, while releasing v1.0.0 , you want to compare it with the latest pre-released version v1.0.0-beta.1 : https://github.com/cert-manager/cert-manager/compare/v1.0.0-beta.1...master (final release only) Check the release notes include all changes since the last final release. Run cmrel makestage : In this example we stage a release using the v1.8.0-beta.0 git ref: # Must be run from the \"cert-manager/release\" repo folder. cmrel makestage --ref = $RELEASE_VERSION This step takes ~5 minutes. It will build all container images and create all the manifest files, sign Helm charts and upload everything to a storage bucket on Google Cloud. These artifacts will then be published and released in the next steps. While the build is running, send a first Slack message to #cert-manager-dev : Releasing 1.2.0-alpha.2 \ud83e\uddf5 \ud83d\udd30 Please have a quick look at the build log as it might contain some unredacted data that we forgot to redact. We try to make sure the sensitive data is properly redacted but sometimes we forget to update this. Send a second Slack message in reply to this first message with the Cloud Build job link that cmrel displayed in \"View logs at\". For example, the message would look like: Follow the cmrel stage build: https://console.cloud.google.com/cloud-build/builds/7641734d-fc3c-42e7-9e4c-85bfc4d1d547?project=1021342095237 Run cmrel publish : Do a cmrel publish dry-run to ensure that all the staged resources are valid. Run the following command: # Must be run from the \"cert-manager/release\" repo folder. cmrel publish --release-name \" $RELEASE_VERSION \" You can view the progress by clicking the Google Cloud Build URL in the output of this command. While the build is running, send a third Slack message in reply to the first message: Follow the cmrel publish dry-run build: https://console.cloud.google.com/cloud-build/builds16f6f875-0a23-4fff-b24d-3de0af207463?project=1021342095237 Now publish the release artifacts for real. The following command will publish the artifacts to GitHub, Quay.io and to our helm chart repository : # Must be run from the \"cert-manager/release\" repo folder. cmrel publish --nomock --release-name \" $RELEASE_VERSION \" \u23f0 Upon completion there will be: A draft release of cert-manager on GitHub A pull request containing the new Helm chart While the build is running, send a fourth Slack message in reply to the first message: Follow the cmrel publish build: https://console.cloud.google.com/cloud-build/builds/b6fef12b-2e81-4486-9f1f-d00592351789?project=1021342095237 Publish the GitHub release: Visit the draft GitHub release and paste in the release notes that you generated earlier. You will need to manually edit the content to match the style of earlier releases. In particular, remember to remove package-related changes. (initial alpha, subsequent alpha and beta only) Tick the box \"This is a pre-release\". Click \"Publish\" to make the GitHub release live. This will create a Git tag automatically. Merge the pull request containing the Helm chart: The Helm charts for cert-manager are served using Cloudflare pages and the Helm chart files and metadata are stored in the Jetstack charts repository . The cmrel publish --nomock step (above) will have created a PR in this repository which you now have to review and merge, as follows: 1. [Visit the pull request](https://github.com/jetstack/jetstack-charts/pulls) 2. Review the changes 3. Fix any failing checks 4. Merge the PR 5. Check that the [cert-manager Helm chart is visible on ArtifactHUB](https://artifacthub.io/packages/helm/cert-manager/cert-manager). (final release only) Add the new final release to the supported-releases page. Open a PR for a Homebrew formula update for cmctl . Assuming you have brew installed, you can use the brew bump-formula-pr command to do this. You'll need the new tag name and the commit hash of that tag. See brew bump-formula-pr --help for up to date details, but the command will be of the form: brew bump-formula-pr --dry-run --tag v0.10.0 --revision da3265115bfd8be5780801cc6105fa857ef71965 cmctl Replacing the tag and revision with the new ones. This will take time for the Homebrew team to review. Once the pull reqeust against https://github.com/homebrew/homebrew-core has been opened, continue with further release steps. Post a Slack message as an answer to the first message. Toggle the check box \"Also send to #cert-manager-dev \" so that the message is well visible. Also cross-post the message on #cert-manager . https://github.com/cert-manager/cert-manager/releases/tag/v1.0.0 \ud83c\udf89 (final release only) Show the release to the world: Send an email to cert-manager-dev@googlegroups.com with the release label ( examples ). Send a tweet ( example ) and make sure @JetstackHQ retweets it. Proceed to the post-release steps: (initial alpha only) Create a PR on cert-manager/release , add the new release to our list of periodic ProwJobs. Use this PR as an example. (initial alpha only) Run cmrel generate-prow --branch='*' -o file with the new version from the previous step and open a PR to cert-manager/testing adding the generated prow configs. Use this PR as an example. (initial alpha only) If needed, open a PR to cert-manager/website in order to: Update the section \"How we determine supported Kubernetes versions\" on the supported-releases page. (final release only) Create a PR on cert-manager/release , removing the now unsupported release version (2 versions back) in this file: prowspecs/specs.go This will remove the periodic ProwJob for this version as it is no longer needed. (final release only) Run cmrel generate-prow --branch='*' -o file with the new version from the previous step and open a PR to cert-manager/testing adding the generated prow configs. (final release only) Open a PR to cert-manager/website in order to: Update the section \"Supported releases\" in the supported-releases page. Update the section \"Supported releases\" in the supported-releases page. Update the section \"How we determine supported Kubernetes versions\" on the supported-releases page. In the table, set \"n/a\" for the line where \"next periodic\" is since these tests will be disabled until we do our first alpha. (final release only) Open a PR to jetstack/testing and change Prow's config. To do this, take inspiration from Maartje's PR example . (final release only) Push a new release branch to cert-manager/cert-manager . If the final release is v1.0.0 , then push the new branch release-1.1 : # Must be run from the cert-manager repo folder. git checkout -b release-1.1 v1.0.0 git push origin release-1.1 (final release only) Open a PR to cert-manager/website with updates to the website configuration. To do this, take inspiration from Maartje's PR example . Ensure that any installation commands in cert-manager/website install the latest version. This should be done after every release, including patch releases as we want to encourage users to always install the latest patch. Future: check that our Algolia search indexing is up-to-date for the website - i.e. that the new version of the docs is being indexed correctly. This is listed here as it's a step we should be checking after a release of a major version but at the time of writing we don't know how to do it! Open a PR against the Krew index such as this one , bumping the versions of our kubectl plugins. Create a new OLM package and publish to OperatorHub cert-manager can be installed using Operator Lifecycle Manager (OLM) so we need to create OLM packages for each cert-manager version and publish them to both operatorhub.io and the equivalent package index for RedHat OpenShift. Follow the cert-manager OLM release process and, once published, verify that the cert-manager OLM installation instructions still work. Older Releases \u00b6 The above guide only applies for versions of cert-manager from v1.8 onwards. Older versions were built using Bazel and this difference in build process is reflected in the release process. cert-manager 1.6 and 1.7 \u00b6 Follow this older version of the release process on GitHub, rather than the guide on this website. The most notable difference is you'll call cmrel stage rather than cmrel makestage . You should be fine to use the latest version of cmrel to do the release. cert-manager 1.5 and earlier \u00b6 If you're releasing version 1.5 or earlier you must also be sure to install a different version of cmrel . In the step where you install cmrel , you'll want to run the following instead: go install github.com/cert-manager/release/cmd/cmrel@cert-manager-pre-1.6 This will ensure that the version of cmrel you're using is compatible with the version of cert-manager you're releasing. In addition, when you check out the cert-manager/release repository you should be sure to check out the cert-manager-pre-1.6 tag in that repo: git checkout cert-manager-pre-1.6 Other than the different cert-manager/release tag and cmrel version, you can follow the same older release documentation as is used for 1.6 and 1.7 - just remember to change the version of cmrel you install! One or more \"patch pre-releases\" may be created to allow voluntary community testing of a bug fix or security fix before the fix is made generally available. The suffix -beta must be used for patch pre-releases. \u21a9","title":"Release Process"},{"location":"contributing/release-process/#prerequisites","text":"\u26d4\ufe0f Do not proceed with the release process if you do not meet all of the following conditions: The relevant testgrid dashboard should not be failing for the release you're trying to perform. The release process takes about 40 minutes . You must have time to complete all the steps. You currently need to be at Jetstack to get the required GitHub and GCP permissions. (we'd like contributors outside Jetstack to be able to get access; if that's of interest to you, please let us know). You need to have the GitHub admin permission on the cert-manager project. To check that you have the admin role, run: brew install gh gh auth login gh api /repos/cert-manager/cert-manager/collaborators/ $( gh api /user | jq -r .login ) /permission | jq .permission If your permission is admin , then you are good to go. To request the admin permission on the cert-manager project, open a PR with a link to here. You need to be added as an \"Editor\" to the GCP project cert-manager-release . To check if you do have access, try opening the Cloud Build page . To get the \"Editor\" permission on the GCP project, open a PR with your name added to the maintainers list in cert_manager_release.tf --- a/cert_manager_release.tf +++ b/cert_manager_release.tf @@ -17,6 +17,7 @@ locals { var.personal_email[\"...\"], var.personal_email[\"...\"], var.personal_email[\"...\"], + var.personal_email[\"mael-valais\"], ]) } You may use the following PR description: Title: Access to the cert-manager-release GCP project Hi. As stated in \"Prerequisites\" on the [ release-process ][ 1 ] page, I need access to the [ cert-manager-release ][ 2 ] project on GCP in order to perform the release process. Thanks! [ 1 ]: https://cert-manager.io/docs/contributing/release-process/#prerequisites [ 2 ]: https://console.cloud.google.com/?project=cert-manager-release This guide applies for versions of cert-manager released using make , which should be every version from cert-manager 1.8 and later. If you need to release a version of cert-manager 1.7 or earlier see older releases . First, ensure that you have all the tools required to perform a cert-manager release: Install the release-notes CLI: go install k8s.io/release/cmd/release-notes@v0.13.0 Install our cmrel CLI: go install github.com/cert-manager/release/cmd/cmrel@latest Clone the cert-manager/release repo: # Don't clone it from inside the cert-manager repo folder. git clone https://github.com/cert-manager/release cd release Install the gcloud CLI. Login to gcloud : gcloud auth application-default login Make sure gcloud points to the cert-manager-release project: gcloud config set project cert-manager-release export CLOUDSDK_CORE_PROJECT = cert-manager-release # this is used by cmrel Get a GitHub access token here with no scope ticked. It is used only by the release-notes CLI to avoid API rate limiting since it will go through all the PRs one by one.","title":"Prerequisites"},{"location":"contributing/release-process/#minor-releases","text":"A minor release is a backwards-compatible 'feature' release. It can contain new features and bug fixes.","title":"Minor releases"},{"location":"contributing/release-process/#release-schedule","text":"We aim to cut a new minor release once per month. The rough goals for each release are outlined as part of a GitHub milestone. We cut a release even if some of these goals are missed, in order to keep up release velocity.","title":"Release schedule"},{"location":"contributing/release-process/#process-for-releasing-a-version","text":"\ud83d\udd30 Please click on the **Edit this page** button on the top-right corner of this page if a step is missing or if it is outdated. Make sure to note which type of release you are doing. That will be helpful in the next steps. Type of release Example of git tag initial alpha release v1.3.0-alpha.0 subsequent alpha release v1.3.0-alpha.1 initial beta release v1.3.0-beta.0 subsequent beta release v1.3.0-beta.1 final release v1.3.0 (optional) patch pre-release 1 v1.3.1-beta.0 patch release (or \"point release\") v1.3.1 (final release only) Make sure that a PR with the new upgrade document is ready to be merged on cert-manager/website . See for example, see upgrading-1.0-1.1 . Update the release branch: (initial alpha, subsequent alpha and initial beta) The release branch should already exist (it was created at the end of the last final release). Update the release branch with the latest commits from the master branch, as follows: # Must be run from the cert-manager repo folder. git fetch --all git branch --force release-1.0 origin/release-1.0 git checkout release-1.0 git merge --ff-only origin/master # don't run for a point release! (subsequent beta, patch release and final release) : do nothing since things have been merged using /cherry-pick release-1.0 . Note about the code freeze: The first beta starts a new \"code freeze\" period that lasts until the final release. Just before the code freeze, we fast-forward everything from master into the release branch. During the code freeze, we continue merging PRs into master as usual. We don't fast-forward master into the release branch for the second (and subsequent) beta, and only /cherry-pick release-1.0 the fixes that should be part of the subsequent beta. We don't fast-forward for patch releases and final releases; instead, we prepare these releases using the /cherry-pick release-1.0 command. Push the new or updated release branch and create the tag: Check that the origin remote is correct. To do that, run the following command and make sure it returns the upstream https://github.com/cert-manager/cert-manager.git : # Must be run from the cert-manager repo folder. git remote -v | grep origin Push the release branch: # Must be run from the cert-manager repo folder. git push --set-upstream origin release-1.0 GitHub permissions : git push will only work if you have the admin GitHub permission on the cert-manager repo to create or push to the branch, see prerequisites . If you do not have this permission, you will have to open a PR to merge master into the release branch), and wait for the PR checks to become green. Create the tag for the new release locally and push it upstream: git tag -m \"v1.8.0-beta.0\" v1.8.0-beta.0 # be sure to push the named tag explicitly; you don't want to push any other local tags! git push origin v1.8.0-beta.0 Generate and edit the release notes: Use the following two tables to understand how to fill in the four environment variables needed for the next step. These four environment variables are documented on the README for the Kubernetes release-notes tool. Variable Description START_REV * The git tag of the \"previous\"* release END_REV Name of your release branch (inclusive) BRANCH Name of your release branch RELEASE_VERSION The git tag Examples for each release type (e.g., initial alpha release): Variable Example 1 Example 2 Example 2 Example 3 Example 4 initial alpha subsequent alpha beta release final release patch release v1.3.0-alpha.0 v1.3.0-alpha.1 v1.3.0-beta.0 v1.3.0 v1.3.1 START_TAG * v1.2.0 v1.3.0-alpha.0 v1.3.0-alpha.1 v1.2.0 ** v1.3.0 END_REV release-1.3 release-1.3 release-1.3 release-1.3 release-1.3 BRANCH release-1.3 release-1.3 release-1.3 release-1.3 release-1.3 RELEASE_VERSION v1.3.0-alpha.0 v1.3.0-alpha.1 v1.3.0-beta.0 v1.3.0 v1.3.1 *The git tag of the \"previous\" release ( START_TAG ) depends on which type of release you count on doing. Look at the above examples to understand a bit more what those are. **Do not use a patch here (e.g., no v1.2.3 ). It must be v1.2.0 : you must use the latest tag that belongs to the release branch you are releasing on; in the above example, the release branch is release-1.3 , and the latest tag on that branch is v1.2.0 . After finding out the value for each of the 4 environment variables, set the variables in your shell (for example, following the example 1): export RELEASE_VERSION = \"v1.3.0-alpha.0\" export BRANCH = \"release-1.3\" export START_TAG = \"v1.2.0\" export END_REV = \"release-1.3\" Generate release-notes.md at the root of your cert-manager repo folder with the following command: # Must be run from the cert-manager folder. export GITHUB_TOKEN = *your-token* git fetch origin $BRANCH : $BRANCH export START_SHA = \" $( git rev-list --reverse --ancestry-path $( git merge-base $START_TAG $BRANCH ) .. $BRANCH | head -1 ) \" release-notes --debug --repo-path cert-manager \\ --org cert-manager --repo cert-manager \\ --required-author \"jetstack-bot\" \\ --output release-notes.md The GitHub token does not need any scope . The token is required only to avoid rate-limits imposed on anonymous API users. Sanity check the notes: Make sure the notes contain details of all the features and bug fixes that you expect to be in the release. Add additional blurb, notable items and characterize change log. You can see the commits that will go into this release by using the GitHub compare . For example, while releasing v1.0.0 , you want to compare it with the latest pre-released version v1.0.0-beta.1 : https://github.com/cert-manager/cert-manager/compare/v1.0.0-beta.1...master (final release only) Check the release notes include all changes since the last final release. Run cmrel makestage : In this example we stage a release using the v1.8.0-beta.0 git ref: # Must be run from the \"cert-manager/release\" repo folder. cmrel makestage --ref = $RELEASE_VERSION This step takes ~5 minutes. It will build all container images and create all the manifest files, sign Helm charts and upload everything to a storage bucket on Google Cloud. These artifacts will then be published and released in the next steps. While the build is running, send a first Slack message to #cert-manager-dev : Releasing 1.2.0-alpha.2 \ud83e\uddf5 \ud83d\udd30 Please have a quick look at the build log as it might contain some unredacted data that we forgot to redact. We try to make sure the sensitive data is properly redacted but sometimes we forget to update this. Send a second Slack message in reply to this first message with the Cloud Build job link that cmrel displayed in \"View logs at\". For example, the message would look like: Follow the cmrel stage build: https://console.cloud.google.com/cloud-build/builds/7641734d-fc3c-42e7-9e4c-85bfc4d1d547?project=1021342095237 Run cmrel publish : Do a cmrel publish dry-run to ensure that all the staged resources are valid. Run the following command: # Must be run from the \"cert-manager/release\" repo folder. cmrel publish --release-name \" $RELEASE_VERSION \" You can view the progress by clicking the Google Cloud Build URL in the output of this command. While the build is running, send a third Slack message in reply to the first message: Follow the cmrel publish dry-run build: https://console.cloud.google.com/cloud-build/builds16f6f875-0a23-4fff-b24d-3de0af207463?project=1021342095237 Now publish the release artifacts for real. The following command will publish the artifacts to GitHub, Quay.io and to our helm chart repository : # Must be run from the \"cert-manager/release\" repo folder. cmrel publish --nomock --release-name \" $RELEASE_VERSION \" \u23f0 Upon completion there will be: A draft release of cert-manager on GitHub A pull request containing the new Helm chart While the build is running, send a fourth Slack message in reply to the first message: Follow the cmrel publish build: https://console.cloud.google.com/cloud-build/builds/b6fef12b-2e81-4486-9f1f-d00592351789?project=1021342095237 Publish the GitHub release: Visit the draft GitHub release and paste in the release notes that you generated earlier. You will need to manually edit the content to match the style of earlier releases. In particular, remember to remove package-related changes. (initial alpha, subsequent alpha and beta only) Tick the box \"This is a pre-release\". Click \"Publish\" to make the GitHub release live. This will create a Git tag automatically. Merge the pull request containing the Helm chart: The Helm charts for cert-manager are served using Cloudflare pages and the Helm chart files and metadata are stored in the Jetstack charts repository . The cmrel publish --nomock step (above) will have created a PR in this repository which you now have to review and merge, as follows: 1. [Visit the pull request](https://github.com/jetstack/jetstack-charts/pulls) 2. Review the changes 3. Fix any failing checks 4. Merge the PR 5. Check that the [cert-manager Helm chart is visible on ArtifactHUB](https://artifacthub.io/packages/helm/cert-manager/cert-manager). (final release only) Add the new final release to the supported-releases page. Open a PR for a Homebrew formula update for cmctl . Assuming you have brew installed, you can use the brew bump-formula-pr command to do this. You'll need the new tag name and the commit hash of that tag. See brew bump-formula-pr --help for up to date details, but the command will be of the form: brew bump-formula-pr --dry-run --tag v0.10.0 --revision da3265115bfd8be5780801cc6105fa857ef71965 cmctl Replacing the tag and revision with the new ones. This will take time for the Homebrew team to review. Once the pull reqeust against https://github.com/homebrew/homebrew-core has been opened, continue with further release steps. Post a Slack message as an answer to the first message. Toggle the check box \"Also send to #cert-manager-dev \" so that the message is well visible. Also cross-post the message on #cert-manager . https://github.com/cert-manager/cert-manager/releases/tag/v1.0.0 \ud83c\udf89 (final release only) Show the release to the world: Send an email to cert-manager-dev@googlegroups.com with the release label ( examples ). Send a tweet ( example ) and make sure @JetstackHQ retweets it. Proceed to the post-release steps: (initial alpha only) Create a PR on cert-manager/release , add the new release to our list of periodic ProwJobs. Use this PR as an example. (initial alpha only) Run cmrel generate-prow --branch='*' -o file with the new version from the previous step and open a PR to cert-manager/testing adding the generated prow configs. Use this PR as an example. (initial alpha only) If needed, open a PR to cert-manager/website in order to: Update the section \"How we determine supported Kubernetes versions\" on the supported-releases page. (final release only) Create a PR on cert-manager/release , removing the now unsupported release version (2 versions back) in this file: prowspecs/specs.go This will remove the periodic ProwJob for this version as it is no longer needed. (final release only) Run cmrel generate-prow --branch='*' -o file with the new version from the previous step and open a PR to cert-manager/testing adding the generated prow configs. (final release only) Open a PR to cert-manager/website in order to: Update the section \"Supported releases\" in the supported-releases page. Update the section \"Supported releases\" in the supported-releases page. Update the section \"How we determine supported Kubernetes versions\" on the supported-releases page. In the table, set \"n/a\" for the line where \"next periodic\" is since these tests will be disabled until we do our first alpha. (final release only) Open a PR to jetstack/testing and change Prow's config. To do this, take inspiration from Maartje's PR example . (final release only) Push a new release branch to cert-manager/cert-manager . If the final release is v1.0.0 , then push the new branch release-1.1 : # Must be run from the cert-manager repo folder. git checkout -b release-1.1 v1.0.0 git push origin release-1.1 (final release only) Open a PR to cert-manager/website with updates to the website configuration. To do this, take inspiration from Maartje's PR example . Ensure that any installation commands in cert-manager/website install the latest version. This should be done after every release, including patch releases as we want to encourage users to always install the latest patch. Future: check that our Algolia search indexing is up-to-date for the website - i.e. that the new version of the docs is being indexed correctly. This is listed here as it's a step we should be checking after a release of a major version but at the time of writing we don't know how to do it! Open a PR against the Krew index such as this one , bumping the versions of our kubectl plugins. Create a new OLM package and publish to OperatorHub cert-manager can be installed using Operator Lifecycle Manager (OLM) so we need to create OLM packages for each cert-manager version and publish them to both operatorhub.io and the equivalent package index for RedHat OpenShift. Follow the cert-manager OLM release process and, once published, verify that the cert-manager OLM installation instructions still work.","title":"Process for releasing a version"},{"location":"contributing/release-process/#older-releases","text":"The above guide only applies for versions of cert-manager from v1.8 onwards. Older versions were built using Bazel and this difference in build process is reflected in the release process.","title":"Older Releases"},{"location":"contributing/release-process/#cert-manager-16-and-17","text":"Follow this older version of the release process on GitHub, rather than the guide on this website. The most notable difference is you'll call cmrel stage rather than cmrel makestage . You should be fine to use the latest version of cmrel to do the release.","title":"cert-manager 1.6 and 1.7"},{"location":"contributing/release-process/#cert-manager-15-and-earlier","text":"If you're releasing version 1.5 or earlier you must also be sure to install a different version of cmrel . In the step where you install cmrel , you'll want to run the following instead: go install github.com/cert-manager/release/cmd/cmrel@cert-manager-pre-1.6 This will ensure that the version of cmrel you're using is compatible with the version of cert-manager you're releasing. In addition, when you check out the cert-manager/release repository you should be sure to check out the cert-manager-pre-1.6 tag in that repo: git checkout cert-manager-pre-1.6 Other than the different cert-manager/release tag and cmrel version, you can follow the same older release documentation as is used for 1.6 and 1.7 - just remember to change the version of cmrel you install! One or more \"patch pre-releases\" may be created to allow voluntary community testing of a bug fix or security fix before the fix is made generally available. The suffix -beta must be used for patch pre-releases. \u21a9","title":"cert-manager 1.5 and earlier"},{"location":"contributing/security/","text":"Security is the number one priority for cert-manager. If you think you've found a vulnerability in any cert-manager project, please follow the vulnerability reporting process documented in the main cert-manager repository. The reporting process is the same for all repositories under the cert-manager organization. The process is documented in one place to ensure a single source of truth and a single list of security contacts .","title":"Reporting Security Issues"},{"location":"contributing/sign-off/","text":"All contributors to the project retain copyright to their work, but must only submit work which they have the rights to submit. We require all contributors to acknowledge that they have the rights to the code they're contributing by signing their commits in git using a \"DCO Sign Off\". Note that this is different to \"commit signing\" using something like PGP or gitsign ! Any copyright notices in a cert-manager repo should specify the authors as \"The cert-manager Authors\". To sign your work, pass the --signoff option to git commit or git rebase : # Sign off a commit as you're making it git commit --signoff -m \"my commit\" # Add a signoff to the last commit you made git commit --amend --signoff # Rebase your branch against master and sign off every commit in your branch git rebase --signoff master This will add a line similar to the following at the end of your commit: Signed-off-by: Joe Bloggs <joe@example.com> By signing off a commit you're stating that you certify the following: Developer Certificate of Origin Version 1.1 Copyright (C) 2004, 2006 The Linux Foundation and its contributors. 1 Letterman Drive Suite D4700 San Francisco, CA, 94129 Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Developer's Certificate of Origin 1.1 By making a contribution to this project, I certify that: (a) The contribution was created in whole or in part by me and I have the right to submit it under the open source license indicated in the file; or (b) The contribution is based upon previous work that, to the best of my knowledge, is covered under an appropriate open source license and I have the right under that license to submit that work with modifications, whether created in whole or in part by me, under the same open source license (unless I am permitted to submit under a different license), as indicated in the file; or (c) The contribution was provided directly to me by some other person who certified (a), (b) or (c) and I have not modified it. (d) I understand and agree that this project and the contribution are public and that a record of the contribution (including all personal information I submit with it, including my sign-off) is maintained indefinitely and may be redistributed consistent with this project or the open source license(s) involved. That statement is taken from https://developercertificate.org/ .","title":"DCO Sign Off"},{"location":"contributing/signing-keys/","text":"This page describes the bootstrapping process for a key, including how to do it and why a bootstrapping process is required. What do we Serve? \u00b6 To facilitate verification of signatures, we serve public key information from the cert-manager website directly. It's important to serve the keys from a different location to where the artifacts are hosted; if the keys were hosted at the same location as the artifacts, an attacker able to change the artifacts would be able to also change the keys! We serve several key types under static/public-keys : cert-manager-pgp-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.asc : ASCII-armored PGP public key, used for verifying signatures on helm charts via helm verify (after being converted to a keyring) cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg : Old style GPG keyring, needed by the --keyring parameter to helm verify . See Keyring below. cert-manager-pubkey-2021-09-20.pem : The raw, PEM-encoded public key used for signing. Cannot be used with GPG (and therefore helm), but should be used for other verification types. Background / Architecture \u00b6 Code signing for cert-manager artifacts is done entirely using cloud KMS keys, to ensure that nobody can get access to the private keys in plain-text; all signing operations using the key are therefore done through cloud APIs and are logged. Currently, all keys are on Google KMS, since the rest of cert-manager's release infrastructure is also in GCP. The key - and the role bindings which allow access to it - are specified in terraform in a closed source Jetstack repo. Why Bootstrap? \u00b6 While the private key is not retrievable for a KMS key, the public key is and must be retrieved so that end-users can verify signatures made by the key. In GCP, retrieving the public key is itself an API call which returns the raw key in a PEM encoded format. That PEM-encoded public key works for some cases (e.g. verifying container signature made using cosign ) but it's not sufficient for Helm chart verification, since Helm chart signing (sadly) requires the use of PGP. Bootstrapping a PGP Identity \u00b6 It's possible to use a shim to use GCP KMS as a PGP key which enables us to avoid having two separate signing keys, but PGP public identities are slightly more complicated than plain public keys; they also contain a name, creation time, comment and email address to identify the signer. This public \"identity\" must itself be signed by the private key (to prove that the information in the identity is legitimate). This bootstrapping can be done using the cert-manager release tool, cmrel : # note that the key name might not exactly match this in the future $ cmrel bootstrap-pgp --key \"projects/cert-manager-release/locations/europe-west1/keyRings/cert-manager-release/cryptoKeys/cert-manager-release-signing-key/cryptoKeyVersions/1\" This will trigger a cloud build job which will output both the armored PGP identity and the raw PEM public key; the values can be copied from the job output. GPG Keyring \u00b6 As an additional UX feature, we can also generate a GPG keyring from the PGP identity, since the keyring is what's required by the Helm CLI to actually validate a chart: # Example of verifying a chart. $ helm verify --keyring cert_manager_keyring_1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg /path/to/chart.tgz Signed by: cert-manager Maintainers <cert-manager-maintainers@googlegroups.com> Using Key With Fingerprint: 1020.... Chart Hash Verified: sha256:bb86... The keyring can be generated using this script .","title":"Signing Keys"},{"location":"contributing/signing-keys/#what-do-we-serve","text":"To facilitate verification of signatures, we serve public key information from the cert-manager website directly. It's important to serve the keys from a different location to where the artifacts are hosted; if the keys were hosted at the same location as the artifacts, an attacker able to change the artifacts would be able to also change the keys! We serve several key types under static/public-keys : cert-manager-pgp-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.asc : ASCII-armored PGP public key, used for verifying signatures on helm charts via helm verify (after being converted to a keyring) cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg : Old style GPG keyring, needed by the --keyring parameter to helm verify . See Keyring below. cert-manager-pubkey-2021-09-20.pem : The raw, PEM-encoded public key used for signing. Cannot be used with GPG (and therefore helm), but should be used for other verification types.","title":"What do we Serve?"},{"location":"contributing/signing-keys/#background-architecture","text":"Code signing for cert-manager artifacts is done entirely using cloud KMS keys, to ensure that nobody can get access to the private keys in plain-text; all signing operations using the key are therefore done through cloud APIs and are logged. Currently, all keys are on Google KMS, since the rest of cert-manager's release infrastructure is also in GCP. The key - and the role bindings which allow access to it - are specified in terraform in a closed source Jetstack repo.","title":"Background / Architecture"},{"location":"contributing/signing-keys/#why-bootstrap","text":"While the private key is not retrievable for a KMS key, the public key is and must be retrieved so that end-users can verify signatures made by the key. In GCP, retrieving the public key is itself an API call which returns the raw key in a PEM encoded format. That PEM-encoded public key works for some cases (e.g. verifying container signature made using cosign ) but it's not sufficient for Helm chart verification, since Helm chart signing (sadly) requires the use of PGP.","title":"Why Bootstrap?"},{"location":"contributing/signing-keys/#bootstrapping-a-pgp-identity","text":"It's possible to use a shim to use GCP KMS as a PGP key which enables us to avoid having two separate signing keys, but PGP public identities are slightly more complicated than plain public keys; they also contain a name, creation time, comment and email address to identify the signer. This public \"identity\" must itself be signed by the private key (to prove that the information in the identity is legitimate). This bootstrapping can be done using the cert-manager release tool, cmrel : # note that the key name might not exactly match this in the future $ cmrel bootstrap-pgp --key \"projects/cert-manager-release/locations/europe-west1/keyRings/cert-manager-release/cryptoKeys/cert-manager-release-signing-key/cryptoKeyVersions/1\" This will trigger a cloud build job which will output both the armored PGP identity and the raw PEM public key; the values can be copied from the job output.","title":"Bootstrapping a PGP Identity"},{"location":"contributing/signing-keys/#gpg-keyring","text":"As an additional UX feature, we can also generate a GPG keyring from the PGP identity, since the keyring is what's required by the Helm CLI to actually validate a chart: # Example of verifying a chart. $ helm verify --keyring cert_manager_keyring_1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg /path/to/chart.tgz Signed by: cert-manager Maintainers <cert-manager-maintainers@googlegroups.com> Using Key With Fingerprint: 1020.... Chart Hash Verified: sha256:bb86... The keyring can be generated using this script .","title":"GPG Keyring"},{"location":"contributing/third-party-code-donation/","text":"The cert-manager project welcomes external contributions and has benefited greatly from thousands of commits from hundreds of different contributors. Most code is usually committed through pull requests to a specific repo, whether that be the main cert-manager repository or one of the associated repositories such as the website. Some contributions aren't as well suited to that kind of workflow, however. That would most likely be because their functionality doesn't belong in any particular existing cert-manager repo, while still relating to the cert-manager project. This document aims to address the donation of code to the cert-manager project, and to provide a framework for sustainable contributions which can be tested and relied upon going forwards by both cert-manager maintainers and users. The requirements in this document are based in part on what's done for CoreDNS, Envoy, Kubernetes and containerd. Requirements \u00b6 Code must be licensed appropriately, including any dependencies We'd prefer Apache 2.0 since that's what cert-manager uses , but the license must be OSI approved . Code must conform to CNCF standards and due diligence requirements You don't need to go over this with a fine-toothed comb; the intent here is that no code donation should have a negative effect on cert-manager's progress as a CNCF project. See the CNCF due diligence template Must be sponsored by an existing maintainer An existing regular contributor to cert-manager must sponsor the adoption of any third party code donation. This ensures that there's a single point of contact for the party donating the code. Must pass cert-manager conformance tests This might not apply to all donations, but where conformance tests exist any donated code must pass them. E.g. for external issuers Must provide a point-of-contact for questions about the project for at least 3 months after acceptance We don't anticipate that we'd need to reach out often after the donation has been accepted, but it's important to have someone we can reach out to if we need to. The donation must be a defined extension type or justify why it doesn't belong in the main repositories E.g. an ACME DNS solver, a custom issuer or an ACME HTTP solver Code must have a similar level of quality to cert-manager itself This could be enforced by, for example, running static analysis tools on the code base similar to those used by cert-manager. Code must have a non-trivial test suite, including both unit tests and end-to-end tests These tests must be able to be run in their entirety after a PR is raised against the repo. We don't need 100% code coverage, but there should be tests for important functionality. The project must adopt the cert-manager security policy and link back to the policy, as in e.g. the istio-csr SECURITY.md Must have DCO sign-offs or coverage for all commits To ensure that all code can legally be donated, all commits should have DCO sign-off or else have a positive affirmation made by each contributor prior to donation. See below. Preferences \u00b6 These items are not absolutely necessary but they definitely help if a code donation is to be accepted. Should be written in Go We don't need code to be written in Go, but we'd much prefer that it is. Since cert-manager itself is written in Go, code donations in Go allow us to use existing experience and tooling on Go code. DCO Signoff \u00b6 As a method of ensuring that the donator has permission to donate the code, we require DCO sign-offs - or something equivalent - to be in place at the time of the donation. The cert-manager DCO signoff process would be appropriate. Existing contributors could bootstrap this process by creating an empty signed-off with a note that previous code should be considered signed off as of that commit: git commit --allow-empty --signoff --message = \"bootstrapping DCO signoff for past commits\" After Donation \u00b6 Code files in the donated repository must be updated to include the relevant cert-manager boilerplate","title":"Donating Third Party Code to cert-manager"},{"location":"contributing/third-party-code-donation/#requirements","text":"Code must be licensed appropriately, including any dependencies We'd prefer Apache 2.0 since that's what cert-manager uses , but the license must be OSI approved . Code must conform to CNCF standards and due diligence requirements You don't need to go over this with a fine-toothed comb; the intent here is that no code donation should have a negative effect on cert-manager's progress as a CNCF project. See the CNCF due diligence template Must be sponsored by an existing maintainer An existing regular contributor to cert-manager must sponsor the adoption of any third party code donation. This ensures that there's a single point of contact for the party donating the code. Must pass cert-manager conformance tests This might not apply to all donations, but where conformance tests exist any donated code must pass them. E.g. for external issuers Must provide a point-of-contact for questions about the project for at least 3 months after acceptance We don't anticipate that we'd need to reach out often after the donation has been accepted, but it's important to have someone we can reach out to if we need to. The donation must be a defined extension type or justify why it doesn't belong in the main repositories E.g. an ACME DNS solver, a custom issuer or an ACME HTTP solver Code must have a similar level of quality to cert-manager itself This could be enforced by, for example, running static analysis tools on the code base similar to those used by cert-manager. Code must have a non-trivial test suite, including both unit tests and end-to-end tests These tests must be able to be run in their entirety after a PR is raised against the repo. We don't need 100% code coverage, but there should be tests for important functionality. The project must adopt the cert-manager security policy and link back to the policy, as in e.g. the istio-csr SECURITY.md Must have DCO sign-offs or coverage for all commits To ensure that all code can legally be donated, all commits should have DCO sign-off or else have a positive affirmation made by each contributor prior to donation. See below.","title":"Requirements"},{"location":"contributing/third-party-code-donation/#preferences","text":"These items are not absolutely necessary but they definitely help if a code donation is to be accepted. Should be written in Go We don't need code to be written in Go, but we'd much prefer that it is. Since cert-manager itself is written in Go, code donations in Go allow us to use existing experience and tooling on Go code.","title":"Preferences"},{"location":"contributing/third-party-code-donation/#dco-signoff","text":"As a method of ensuring that the donator has permission to donate the code, we require DCO sign-offs - or something equivalent - to be in place at the time of the donation. The cert-manager DCO signoff process would be appropriate. Existing contributors could bootstrap this process by creating an empty signed-off with a note that previous code should be considered signed off as of that commit: git commit --allow-empty --signoff --message = \"bootstrapping DCO signoff for past commits\"","title":"DCO Signoff"},{"location":"contributing/third-party-code-donation/#after-donation","text":"Code files in the donated repository must be updated to include the relevant cert-manager boilerplate","title":"After Donation"},{"location":"contributing/google-season-of-docs/","text":"The cert-manager organization has registered for the Google Season of Docs! Check out our 2022 proposals!","title":"Google Season of Docs"},{"location":"contributing/google-season-of-docs/2022/","text":"We registered our interest to participate in Google Season of Docs 2022! There's one project proposal: Improve the Navigation and Structure of the cert-manager Website","title":"Google Season of Docs 2022"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/","text":"Project Updates \u00b6 7 Sept 2022: The Webhook Debugging Guide \u00b6 At the start of the Google Season of Docs program, we built friction logs for common user tasks, such as debugging the error \"connect: connection refused\". The friction log for this task, visible in the GSoD work document , was to serve as a reference point to see whether the improvements we aimed to bring would have an impact or not. The friction log showed a consistent pattern: the user searches the error on Google, is confused by GitHub issues that don't have any solutions, then clicks the second link in the Google results, without much luck. We realized that one improvement we could make was to add a link to the FAQ page \"Troubleshooting Problems with the Webhook\". We found two problems with this FAQ page: It could not be found by anyone because the error messages were not listed in the page, meaning that Google would not show the page in the search results. Many error messages were not listed in the page. We set ourselves to rewrite this page with the goal of making it error-focused, meaning that the user would just be able to look for their particular error and start debugging it. We called it \"The Definitive Debugging Guide for the cert-manager Webhook Pod\", and it can be found here . 12 Aug 2022: Improved the layout of the navigation menu \u00b6 On displays >=1280px the left-hand menu was too narrow to display the nested menu items clearly, On smaller displays the responsive CSS actually made the menu larger. So we've widened it by 1 column on displays >=1280px and reduced the width of the content by 1 column to compensate. This makes the menu much easier to read on laptop and desktop computer screens. We fixed an inconsistency in the vertical spacing between menu items with sub-menus and those without. And finally, we moved the version selector to the bottom of the side-bar to avoid distracting the reader. 3 August 2022: The cert-manager.io Documentation Survey is now closed \u00b6 Thank you to everyone who participated in our documentation survey. We will use the results to prioritize sections of the website for restructuring and rewriting. Before the conclusion of this Season-of-Docs we will select a random winner from among the responses and contact you about your prize. 18 July 2022: The cert-manager.io Documentation Survey \u00b6 We have created a short survey, to help us identify what are the top-priorities for the cert-manager.io documentation. We want identify the most useful documentation, so that we don't go and change things that are already working well. We want to know which documentation is not useful, so that we can make improvements. We'd like to hear from new and experienced users about how and how often you use the documentation. And we'd like to know where else you find good information about cert-manager, outside of the cert-manager.io website, so that we can try and incorporate some of those sources. We've added a link to the survey to the banner at the top of this site and we will also be sharing the link in our Slack channels and mailing lists. Please take 10 minutes to fill in the survey . 15 July 2022: New \"Getting Started\" pages \u00b6 We have been auditing the existing documentation to identify some key tasks that our users and potential new users need to carry out. We have created \"friction logs\" for some of these tasks. What this means is that we imagine ourselves in the place of the user and ask, for example, How can I get a Let's Encrypt certificate for my server in Kubernetes? So we searched Google and DuckDuckGo for \"Let's Encrypt Kubernetes\" and to our surprise, cert-manager.io does not feature among the top search results. Among the results are some excellent third-party tutorials and videos about using cert-manager to create Let's Encrypt certificates, and we are grateful to the authors for taking the time to write such detailed content. But inevitably, some of these refer to much older versions of cert-manager and Kubernetes. So we have decided to write some official guides, for the cert-manager.io website which demonstrate how to quickly install cert-manager and configure it for Let's Encrypt. We hope that in time these will be indexed by the search engines and that they will reach the top of the search results for \"Let's Encrypt Kubernetes\". The advantages will be that users and potential users will find up-to-date information, and the cert-manager.io maintainers will receive fewer support requests from new users who are attempting this task. Go and read the new Getting Started Guide for GKE Users and tell us what you think. 5 May 2022: Announcing Mehak Saeed as Technical Writer \u00b6 We are delighted to announce that Mehak Saeed will be the technical writer working on this project. We were extremely impressed with Mehak's presentation during her interview and impressed with her detailed preparations and planning. We look forward to working with her. Thank you to all the other technical writers who applied for this project. 14 April 2022: Project Accepted \u00b6 This project was accepted on 14 April 2022 . 24 March 2022: Project Registered \u00b6 We have registered our interest to participate in Google Season of Docs 2022 , and have submitted a single project proposal detailed in the remaining of this page. You have until 27 April 2022 18:00 UTC to apply for the technical writer role. We will be sharing the name of the selected candidate on Wed 4 May 2022 at 15:00 London Time (14:00 UTC) on Slack in the channel #cert-manager-dev . To apply as a technical writer, please let us know by one of the two ways below: e-mail us at cert-manager-maintainers@googlegroups.com with the prefix GSoD2022: in the e-mail subject. or open an issue on cert-manager/website with the prefix GSoD2022: in the issue title. You can join our open standup (every day at 10:30 UK time), and join the Kubernetes Slack channel #cert-manager-dev to know more about this project proposal. About cert-manager \u00b6 cert-manager (current version 1.8.0, first release in October 2017) is an Apache-2.0 licensed Kubernetes add-on to automate the management and issuance of TLS certificates. Our typical contributors are Go developers from around the world with experience of the Kubernetes ecosystem with experience contributing to core Kubernetes components and Kubernetes operators. Our users are often developers and system administrators who are trying to automate the rotation of TLS certificates for applications running in their Kubernetes clusters. Our largest users have cert-manager installed on multiple Kubernetes clusters and managing many thousands of TLS certificates. Project Overview \u00b6 Right now the content is not designed with our target audiences in mind. For example a new user will not easily find a guide explaining how to install cert-manager on AWS and configure it for Let\u2019s Encrypt. Nor will a Cluster Administrator easily find information about how to optimize cert-manager for a large cluster with many Certificates. The information exists but is spread across multiple pages and is often not at the obvious page. As a visual example, a user looking for a guide on how the Certificate resource can be used may feel helpless when realizing that the \"Certificate\" page exists twice: once under the \"Usage\" section, and once under the \"Concepts\" section. (NB: This screenshot is from our old site design but the text and layout are broadly the same) We would like a technical writer: to help us identify our target audiences, and to identify the key tasks of each of these audiences, and re-structure the cert-manager.io website with this in mind. For example, we have discussed the following audiences and tasks: Beginner, Cluster Administrator, User, Integrator, New Contributor and each of these people will be interested in a different set of tasks. We would like them to quickly and easily find the information they need. By making it easier for each group to find the information they need we aim to reduce the number of support queries. Scope \u00b6 The scope of this project is as follows: Identify and describe three target audiences. Identify three key top tasks for each of these audiences. Audit the existing documentation and create a friction log of the current documentation. Using the friction log as a baseline, re-organize the documentation to minimize friction for three top tasks. Incorporate feedback from documentation testers (volunteers in the project) and the wider cert-manager community. Work with the cert-manager team to publish the documentation on cert-manager.io. Create documentation for website contributors explaining how we structure our content around audiences and tasks. Measuring success \u00b6 After the technical writer has helped us identify the 3 key tasks for each audience we will measure a baseline number of clicks required to achieve the task and we will aim to minimize the number of clicks for each task. Timeline \u00b6 Dates Action Items May Orientation May / June Identify audiences and tasks May / June Audit and friction log June Restructuring tasks June / July Incorporating feedback June / July Publish to cert-manager.io July Finish writing guidance for website contributors July Project Completion Budget \u00b6 Budget item Amount ($) Running Total ($) Notes Technical writer audit and restructuring of the cert-manager.io documentation 12,000 12,000 Volunteer stipends 1,500 13,500 3 volunteer stipends x 500 each TOTAL 13,500 Regarding the amount of $12,000, we assume that it will be enough to fund one experienced technical writer part-time (for example, they could work half day from Tuesday to Friday, for a total of 24 days, for 3 months at a daily rate of $500). We will give the \"volunteer stipend\" to contributors who can show they have one PR within the project time frame (from 1 st May to 30 th July) in which a re-write of one page or a set of pages. Before starting the rewriting, the volunteer will suggest which page they wish to work on either on Slack (Kubernetes Slack, channel #cert-manager-dev), or in an issue on GitHub, and make sure by asking the team whether it makes sense to rework this page. As long as at least one positive reaction, the volunteer can start working. For the stipend to be validated, the PR needs to be reviewed and merged.","title":"Improve the Navigation and Structure of the cert-manager Website"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#project-updates","text":"","title":"Project Updates"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#7-sept-2022-the-webhook-debugging-guide","text":"At the start of the Google Season of Docs program, we built friction logs for common user tasks, such as debugging the error \"connect: connection refused\". The friction log for this task, visible in the GSoD work document , was to serve as a reference point to see whether the improvements we aimed to bring would have an impact or not. The friction log showed a consistent pattern: the user searches the error on Google, is confused by GitHub issues that don't have any solutions, then clicks the second link in the Google results, without much luck. We realized that one improvement we could make was to add a link to the FAQ page \"Troubleshooting Problems with the Webhook\". We found two problems with this FAQ page: It could not be found by anyone because the error messages were not listed in the page, meaning that Google would not show the page in the search results. Many error messages were not listed in the page. We set ourselves to rewrite this page with the goal of making it error-focused, meaning that the user would just be able to look for their particular error and start debugging it. We called it \"The Definitive Debugging Guide for the cert-manager Webhook Pod\", and it can be found here .","title":"7 Sept 2022: The Webhook Debugging Guide"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#12-aug-2022-improved-the-layout-of-the-navigation-menu","text":"On displays >=1280px the left-hand menu was too narrow to display the nested menu items clearly, On smaller displays the responsive CSS actually made the menu larger. So we've widened it by 1 column on displays >=1280px and reduced the width of the content by 1 column to compensate. This makes the menu much easier to read on laptop and desktop computer screens. We fixed an inconsistency in the vertical spacing between menu items with sub-menus and those without. And finally, we moved the version selector to the bottom of the side-bar to avoid distracting the reader.","title":"12 Aug 2022: Improved the layout of the navigation menu"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#3-august-2022-the-cert-managerio-documentation-survey-is-now-closed","text":"Thank you to everyone who participated in our documentation survey. We will use the results to prioritize sections of the website for restructuring and rewriting. Before the conclusion of this Season-of-Docs we will select a random winner from among the responses and contact you about your prize.","title":"3 August 2022: The cert-manager.io Documentation Survey is now closed"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#18-july-2022-the-cert-managerio-documentation-survey","text":"We have created a short survey, to help us identify what are the top-priorities for the cert-manager.io documentation. We want identify the most useful documentation, so that we don't go and change things that are already working well. We want to know which documentation is not useful, so that we can make improvements. We'd like to hear from new and experienced users about how and how often you use the documentation. And we'd like to know where else you find good information about cert-manager, outside of the cert-manager.io website, so that we can try and incorporate some of those sources. We've added a link to the survey to the banner at the top of this site and we will also be sharing the link in our Slack channels and mailing lists. Please take 10 minutes to fill in the survey .","title":"18 July 2022: The cert-manager.io Documentation Survey"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#15-july-2022-new-getting-started-pages","text":"We have been auditing the existing documentation to identify some key tasks that our users and potential new users need to carry out. We have created \"friction logs\" for some of these tasks. What this means is that we imagine ourselves in the place of the user and ask, for example, How can I get a Let's Encrypt certificate for my server in Kubernetes? So we searched Google and DuckDuckGo for \"Let's Encrypt Kubernetes\" and to our surprise, cert-manager.io does not feature among the top search results. Among the results are some excellent third-party tutorials and videos about using cert-manager to create Let's Encrypt certificates, and we are grateful to the authors for taking the time to write such detailed content. But inevitably, some of these refer to much older versions of cert-manager and Kubernetes. So we have decided to write some official guides, for the cert-manager.io website which demonstrate how to quickly install cert-manager and configure it for Let's Encrypt. We hope that in time these will be indexed by the search engines and that they will reach the top of the search results for \"Let's Encrypt Kubernetes\". The advantages will be that users and potential users will find up-to-date information, and the cert-manager.io maintainers will receive fewer support requests from new users who are attempting this task. Go and read the new Getting Started Guide for GKE Users and tell us what you think.","title":"15 July 2022: New \"Getting Started\" pages"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#5-may-2022-announcing-mehak-saeed-as-technical-writer","text":"We are delighted to announce that Mehak Saeed will be the technical writer working on this project. We were extremely impressed with Mehak's presentation during her interview and impressed with her detailed preparations and planning. We look forward to working with her. Thank you to all the other technical writers who applied for this project.","title":"5 May 2022: Announcing Mehak Saeed as Technical Writer"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#14-april-2022-project-accepted","text":"This project was accepted on 14 April 2022 .","title":"14 April 2022: Project Accepted"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#24-march-2022-project-registered","text":"We have registered our interest to participate in Google Season of Docs 2022 , and have submitted a single project proposal detailed in the remaining of this page. You have until 27 April 2022 18:00 UTC to apply for the technical writer role. We will be sharing the name of the selected candidate on Wed 4 May 2022 at 15:00 London Time (14:00 UTC) on Slack in the channel #cert-manager-dev . To apply as a technical writer, please let us know by one of the two ways below: e-mail us at cert-manager-maintainers@googlegroups.com with the prefix GSoD2022: in the e-mail subject. or open an issue on cert-manager/website with the prefix GSoD2022: in the issue title. You can join our open standup (every day at 10:30 UK time), and join the Kubernetes Slack channel #cert-manager-dev to know more about this project proposal.","title":"24 March 2022: Project Registered"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#about-cert-manager","text":"cert-manager (current version 1.8.0, first release in October 2017) is an Apache-2.0 licensed Kubernetes add-on to automate the management and issuance of TLS certificates. Our typical contributors are Go developers from around the world with experience of the Kubernetes ecosystem with experience contributing to core Kubernetes components and Kubernetes operators. Our users are often developers and system administrators who are trying to automate the rotation of TLS certificates for applications running in their Kubernetes clusters. Our largest users have cert-manager installed on multiple Kubernetes clusters and managing many thousands of TLS certificates.","title":"About cert-manager"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#project-overview","text":"Right now the content is not designed with our target audiences in mind. For example a new user will not easily find a guide explaining how to install cert-manager on AWS and configure it for Let\u2019s Encrypt. Nor will a Cluster Administrator easily find information about how to optimize cert-manager for a large cluster with many Certificates. The information exists but is spread across multiple pages and is often not at the obvious page. As a visual example, a user looking for a guide on how the Certificate resource can be used may feel helpless when realizing that the \"Certificate\" page exists twice: once under the \"Usage\" section, and once under the \"Concepts\" section. (NB: This screenshot is from our old site design but the text and layout are broadly the same) We would like a technical writer: to help us identify our target audiences, and to identify the key tasks of each of these audiences, and re-structure the cert-manager.io website with this in mind. For example, we have discussed the following audiences and tasks: Beginner, Cluster Administrator, User, Integrator, New Contributor and each of these people will be interested in a different set of tasks. We would like them to quickly and easily find the information they need. By making it easier for each group to find the information they need we aim to reduce the number of support queries.","title":"Project Overview"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#scope","text":"The scope of this project is as follows: Identify and describe three target audiences. Identify three key top tasks for each of these audiences. Audit the existing documentation and create a friction log of the current documentation. Using the friction log as a baseline, re-organize the documentation to minimize friction for three top tasks. Incorporate feedback from documentation testers (volunteers in the project) and the wider cert-manager community. Work with the cert-manager team to publish the documentation on cert-manager.io. Create documentation for website contributors explaining how we structure our content around audiences and tasks.","title":"Scope"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#measuring-success","text":"After the technical writer has helped us identify the 3 key tasks for each audience we will measure a baseline number of clicks required to achieve the task and we will aim to minimize the number of clicks for each task.","title":"Measuring success"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#timeline","text":"Dates Action Items May Orientation May / June Identify audiences and tasks May / June Audit and friction log June Restructuring tasks June / July Incorporating feedback June / July Publish to cert-manager.io July Finish writing guidance for website contributors July Project Completion","title":"Timeline"},{"location":"contributing/google-season-of-docs/2022/improve-navigation-and-structure/#budget","text":"Budget item Amount ($) Running Total ($) Notes Technical writer audit and restructuring of the cert-manager.io documentation 12,000 12,000 Volunteer stipends 1,500 13,500 3 volunteer stipends x 500 each TOTAL 13,500 Regarding the amount of $12,000, we assume that it will be enough to fund one experienced technical writer part-time (for example, they could work half day from Tuesday to Friday, for a total of 24 days, for 3 months at a daily rate of $500). We will give the \"volunteer stipend\" to contributors who can show they have one PR within the project time frame (from 1 st May to 30 th July) in which a re-write of one page or a set of pages. Before starting the rewriting, the volunteer will suggest which page they wish to work on either on Slack (Kubernetes Slack, channel #cert-manager-dev), or in an issue on GitHub, and make sure by asking the team whether it makes sense to rework this page. As long as at least one positive reaction, the volunteer can start working. For the stipend to be validated, the PR needs to be reviewed and merged.","title":"Budget"},{"location":"faq/","text":"On this page you will find answers to some frequently asked questions about cert-manager. Terminology \u00b6 What does publicly trusted and self-signed mean? \u00b6 These terms are defined in the TLS Terminology page . What do the terms root , intermediate and leaf certificate mean? \u00b6 These terms are defined in the TLS Terminology page . Certificates \u00b6 Can I trigger a renewal from cert-manager at will? \u00b6 This is a feature in cert-manager starting in v0.16 using the cmctl CLI. More information can be found on the renew command's page When do certs get re-issued? \u00b6 To determine if a certificate needs to be re-issued, cert-manager looks at the the spec of Certificate resource and latest CertificateRequest s as well as the data in Secret containing the X.509 certificate. The issuance process will always get triggered if the: Secret named on Certificate 's spec, does not exist, is missing private key or certificate data or contains corrupt data private key stored in the Secret does not match the private key spec on Certificate public key of the issued certificate does not match the private key stored in the Secret cert-manager issuer annotations on the Secret do not match the issuer specified on the Certificate DNS names, IP addresses, URLS or email addresses on the issued certificate do not match those on the Certificate spec certificate needs to be renewed (because it has expired or the renewal time is now or in the past) certificate has been marked for renewal manually using cmctl Additionally, if the latest CertificateRequest for the Certificate is found, cert-manager will also re-issue if: the common name on the CSR found on the CertificateRequest does not match that on the Certificate spec the subject fields on the CSR found on the CertificateRequest do not match the subject fields of the Certificate spec the duration on the CertificateRequest does not match the duration on the Certificate spec isCA field value on the Certificate spec does not match that on the CertificateRequest the DNS names, IP addresses, URLS or email addresses on the CertificateRequest spec do not match those on the Certificate spec key usages on the CertificateRequest spec do not match those on the Certificate spec Note that for certain fields re-issuance on change gets triggered only if there is a CertificateRequest that cert-manager can use to determine whether Certificate 's spec has changed since the previous issuance. This is because some issuers may not respect the requested values for these fields, so we cannot rely on the values in the issued X.509 certificates. One such field is .spec.duration - change to this field will only trigger re-issuance if there is a CertificateRequest to compare with. In case where you need to re-issue, but re-issuance does not get triggered automatically due to there being no CertificateRequest (i.e after backup and restore), you can use cmctl renew to trigger it manually. Why isn't my root certificate in my issued Secret's tls.crt ? \u00b6 Occasionally, people work with systems which have made a flawed choice regarding TLS chains. The TLS spec has the following section for the \"Server Certificate\" section of the TLS handshake: This is a sequence (chain) of certificates. The sender's certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case. In a standard, secure and correctly configured TLS environment, adding a root certificate to the chain is almost always unnecessary and wasteful. There are two ways that a certificate can be trusted: explicitly, by including it in a trust store. through a signature, by following the certificate's chain back up to an explicitly trusted certificate. Crucially, root certificates are by definition self-signed and they cannot be validated through a signature. As such, if we have a client trying to validate the certificate chain sent by the server, the client must already have the root before the connection is started. If the client already has the root, there was no point in it being sent by the server! The same logic with not sending root certificates applies for servers trying to validate client certificates; the same justification is given in the TLS RFC. How can I see all the historic events related to a certificate object? \u00b6 cert-manager publishes all events to the Kubernetes events mechanism, you can get the events for your specific resources using kubectl describe <resource> <name> . Due to the nature of the Kubernetes event mechanism these will be purged after a while. If you're using a dedicated logging system it might be able or is already also storing Kubernetes events. What happens if issuance fails? Will it be retried? \u00b6 {/* This empty link preserves old links to #what-happens-if-a-renewal-doesn't happen?-will-it-be-tried-again-after-some-time?\", which matched the old title of this section */} cert-manager will retry a failed issuance except for a few rare edge cases where manual intervention is needed. If an issuance fails because of a temporary error, it will be retried again with a short exponential backoff (currently 5 seconds to 5 minutes). A temporary error is one that does not result in a failed CertificateRequest . If the issuance fails with an error that resulted in a failed CertificateRequest , it will be retried with a longer binary exponential backoff (1 hour to 32 hours) to avoid overwhelming external services. You can always trigger immediate renewal using the cmctl renew command Is ECC (elliptic-curve cryptography) supported? \u00b6 cert-manager supports ECDSA key pairs! You can set your certificate to use ECDSA in the privateKey part of your Certificate resource. For example: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : ecdsa spec : secretName : ecdsa-cert isCA : false privateKey : algorithm : ECDSA size : 256 dnsNames : - ecdsa.example.com issuerRef : [ ... ] If renewBefore or duration is not defined, what will be the default value? \u00b6 Default duration is 90 days . If renewBefore has not been set, Certificate will be renewed \u2154 through its actual duration. Miscellaneous \u00b6 Kubernetes has a builtin CertificateSigningRequest API. Why not use that? \u00b6 Kubernetes has a Certificate Signing Requests API , and a [ kubectl certificates command] which allows you to approve certificate signing requests and have them signed by the certificate authority (CA) of the Kubernetes cluster. This API and CLI have occasionally been misused to sign certificates for use by non-control-plane Pods but this is a mistake. For the security of the Kubernetes cluster, it is important to limit access to the Kubernetes certificate authority, and it is important that you do not use that certificate authority to sign certificates which are used outside of the control-plane, because such certificates increase the opportunity for attacks on the Kubernetes API server. In Kubernetes 1.19 the Certificate Signing Requests API has reached V1 and it can be used more generally by following (or automating) the Request Signing Process . cert-manager currently has some limited experimental support for this resource. How to write \"cert-manager\" \u00b6 cert-manager should always be written in lowercase. Even when it would normally be capitalized such as in titles or at the start of sentences. A hyphen should always be used between the words, don't replace it with a space and don't remove it.","title":"FAQ"},{"location":"faq/#terminology","text":"","title":"Terminology"},{"location":"faq/#what-does-publicly-trusted-and-self-signed-mean","text":"These terms are defined in the TLS Terminology page .","title":"What does publicly trusted and self-signed mean?"},{"location":"faq/#what-do-the-terms-root-intermediate-and-leaf-certificate-mean","text":"These terms are defined in the TLS Terminology page .","title":"What do the terms root, intermediate and leaf certificate mean?"},{"location":"faq/#certificates","text":"","title":"Certificates"},{"location":"faq/#can-i-trigger-a-renewal-from-cert-manager-at-will","text":"This is a feature in cert-manager starting in v0.16 using the cmctl CLI. More information can be found on the renew command's page","title":"Can I trigger a renewal from cert-manager at will?"},{"location":"faq/#when-do-certs-get-re-issued","text":"To determine if a certificate needs to be re-issued, cert-manager looks at the the spec of Certificate resource and latest CertificateRequest s as well as the data in Secret containing the X.509 certificate. The issuance process will always get triggered if the: Secret named on Certificate 's spec, does not exist, is missing private key or certificate data or contains corrupt data private key stored in the Secret does not match the private key spec on Certificate public key of the issued certificate does not match the private key stored in the Secret cert-manager issuer annotations on the Secret do not match the issuer specified on the Certificate DNS names, IP addresses, URLS or email addresses on the issued certificate do not match those on the Certificate spec certificate needs to be renewed (because it has expired or the renewal time is now or in the past) certificate has been marked for renewal manually using cmctl Additionally, if the latest CertificateRequest for the Certificate is found, cert-manager will also re-issue if: the common name on the CSR found on the CertificateRequest does not match that on the Certificate spec the subject fields on the CSR found on the CertificateRequest do not match the subject fields of the Certificate spec the duration on the CertificateRequest does not match the duration on the Certificate spec isCA field value on the Certificate spec does not match that on the CertificateRequest the DNS names, IP addresses, URLS or email addresses on the CertificateRequest spec do not match those on the Certificate spec key usages on the CertificateRequest spec do not match those on the Certificate spec Note that for certain fields re-issuance on change gets triggered only if there is a CertificateRequest that cert-manager can use to determine whether Certificate 's spec has changed since the previous issuance. This is because some issuers may not respect the requested values for these fields, so we cannot rely on the values in the issued X.509 certificates. One such field is .spec.duration - change to this field will only trigger re-issuance if there is a CertificateRequest to compare with. In case where you need to re-issue, but re-issuance does not get triggered automatically due to there being no CertificateRequest (i.e after backup and restore), you can use cmctl renew to trigger it manually.","title":"When do certs get re-issued?"},{"location":"faq/#why-isnt-my-root-certificate-in-my-issued-secrets-tlscrt","text":"Occasionally, people work with systems which have made a flawed choice regarding TLS chains. The TLS spec has the following section for the \"Server Certificate\" section of the TLS handshake: This is a sequence (chain) of certificates. The sender's certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case. In a standard, secure and correctly configured TLS environment, adding a root certificate to the chain is almost always unnecessary and wasteful. There are two ways that a certificate can be trusted: explicitly, by including it in a trust store. through a signature, by following the certificate's chain back up to an explicitly trusted certificate. Crucially, root certificates are by definition self-signed and they cannot be validated through a signature. As such, if we have a client trying to validate the certificate chain sent by the server, the client must already have the root before the connection is started. If the client already has the root, there was no point in it being sent by the server! The same logic with not sending root certificates applies for servers trying to validate client certificates; the same justification is given in the TLS RFC.","title":"Why isn't my root certificate in my issued Secret's tls.crt?"},{"location":"faq/#how-can-i-see-all-the-historic-events-related-to-a-certificate-object","text":"cert-manager publishes all events to the Kubernetes events mechanism, you can get the events for your specific resources using kubectl describe <resource> <name> . Due to the nature of the Kubernetes event mechanism these will be purged after a while. If you're using a dedicated logging system it might be able or is already also storing Kubernetes events.","title":"How can I see all the historic events related to a certificate object?"},{"location":"faq/#what-happens-if-issuance-fails-will-it-be-retried","text":"{/* This empty link preserves old links to #what-happens-if-a-renewal-doesn't happen?-will-it-be-tried-again-after-some-time?\", which matched the old title of this section */} cert-manager will retry a failed issuance except for a few rare edge cases where manual intervention is needed. If an issuance fails because of a temporary error, it will be retried again with a short exponential backoff (currently 5 seconds to 5 minutes). A temporary error is one that does not result in a failed CertificateRequest . If the issuance fails with an error that resulted in a failed CertificateRequest , it will be retried with a longer binary exponential backoff (1 hour to 32 hours) to avoid overwhelming external services. You can always trigger immediate renewal using the cmctl renew command","title":"What happens if issuance fails? Will it be retried?"},{"location":"faq/#is-ecc-elliptic-curve-cryptography-supported","text":"cert-manager supports ECDSA key pairs! You can set your certificate to use ECDSA in the privateKey part of your Certificate resource. For example: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : ecdsa spec : secretName : ecdsa-cert isCA : false privateKey : algorithm : ECDSA size : 256 dnsNames : - ecdsa.example.com issuerRef : [ ... ]","title":"Is ECC (elliptic-curve cryptography) supported?"},{"location":"faq/#if-renewbefore-or-duration-is-not-defined-what-will-be-the-default-value","text":"Default duration is 90 days . If renewBefore has not been set, Certificate will be renewed \u2154 through its actual duration.","title":"If renewBefore or duration is not defined, what will be the default value?"},{"location":"faq/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"faq/#kubernetes-has-a-builtin-certificatesigningrequest-api-why-not-use-that","text":"Kubernetes has a Certificate Signing Requests API , and a [ kubectl certificates command] which allows you to approve certificate signing requests and have them signed by the certificate authority (CA) of the Kubernetes cluster. This API and CLI have occasionally been misused to sign certificates for use by non-control-plane Pods but this is a mistake. For the security of the Kubernetes cluster, it is important to limit access to the Kubernetes certificate authority, and it is important that you do not use that certificate authority to sign certificates which are used outside of the control-plane, because such certificates increase the opportunity for attacks on the Kubernetes API server. In Kubernetes 1.19 the Certificate Signing Requests API has reached V1 and it can be used more generally by following (or automating) the Request Signing Process . cert-manager currently has some limited experimental support for this resource.","title":"Kubernetes has a builtin CertificateSigningRequest API. Why not use that?"},{"location":"faq/#how-to-write-cert-manager","text":"cert-manager should always be written in lowercase. Even when it would normally be capitalized such as in titles or at the start of sentences. A hyphen should always be used between the words, don't replace it with a space and don't remove it.","title":"How to write \"cert-manager\""},{"location":"getting-started/","text":"Learn how to deploy cert-manager on Google Kubernetes Engine and how to configure it to sign SSL certificates for Ingress using Let's Encrypt . Learn how to deploy cert-manager and how to configure it to sign SSL certificates for the NGINX Ingress controller using Let's Encrypt .","title":"\u5165\u95e8"},{"location":"installation/","text":"Learn about the various ways you can install cert-manager and how to choose between them. Default static install \u00b6 You don't require any tweaking of the cert-manager install parameters. The default static configuration can be installed as follows: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml \ud83d\udcd6 Read more about installing cert-manager using kubectl apply and static manifests . Getting started \u00b6 You quickly want to learn how to use cert-manager and what it can be used for. \ud83d\udcd6 kubectl apply : For new users we recommend installing cert-manager using kubectl apply and static manifests . \ud83d\udcd6 helm : You can use helm to install cert-manager and this also allows you to customize the installation if necessary. \ud83d\udcd6 OperatorHub : If you have an OpenShift cluster, consider installing cert-manager via OperatorHub , which you can do from the OpenShift web console. \ud83d\udea7 cmctl : Try the experimental cmctl x install command to quickly install cert-manager. Continuous deployment \u00b6 You know how to configure your cert-manager setup and want to automate this. \ud83d\udcd6 helm : You can use the cert-manager Helm chart directly with systems like Flux, ArgoCD and Anthos. \ud83d\udcd6 helm template : You can use helm template to generate customized cert-manager installation manifests. See Output YAML using helm template for more details. This templated cert-manager manifest can be piped into your preferred deployment tool.","title":"\u4ecb\u7ecd"},{"location":"installation/#default-static-install","text":"You don't require any tweaking of the cert-manager install parameters. The default static configuration can be installed as follows: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml \ud83d\udcd6 Read more about installing cert-manager using kubectl apply and static manifests .","title":"Default static install"},{"location":"installation/#getting-started","text":"You quickly want to learn how to use cert-manager and what it can be used for. \ud83d\udcd6 kubectl apply : For new users we recommend installing cert-manager using kubectl apply and static manifests . \ud83d\udcd6 helm : You can use helm to install cert-manager and this also allows you to customize the installation if necessary. \ud83d\udcd6 OperatorHub : If you have an OpenShift cluster, consider installing cert-manager via OperatorHub , which you can do from the OpenShift web console. \ud83d\udea7 cmctl : Try the experimental cmctl x install command to quickly install cert-manager.","title":"Getting started"},{"location":"installation/#continuous-deployment","text":"You know how to configure your cert-manager setup and want to automate this. \ud83d\udcd6 helm : You can use the cert-manager Helm chart directly with systems like Flux, ArgoCD and Anthos. \ud83d\udcd6 helm template : You can use helm template to generate customized cert-manager installation manifests. See Output YAML using helm template for more details. This templated cert-manager manifest can be piped into your preferred deployment tool.","title":"Continuous deployment"},{"location":"installation/api-compatibility/","text":"cert-manager aims to abide by the same API compatibility policy as upstream Kubernetes APIs as documented in the Kubernetes Deprecation Policy . This is to ensure a smooth upgrade and downgrade experience for users, i.e to make sure that users' cert-manager custom resources keep functioning in the same way after an upgrade or downgrade of cert-manager. In some cases, we may need to require users to take actions before upgrading or may need to diverge from the API compatibility promise but we'll treat this as an absolute last resort. In general the main criteria by which we'd determine whether a change is acceptable would be user value. For example in the event of a truly critical bug, a fix that breaks the API compatibility promise by changing the default behavior of an API field might be acceptable. As of yet, though, there has never been a need for such a change. Alpha / Beta API Versions \u00b6 As in upstream Kubernetes, We don't commit to preserving alpha or beta API versions indefinitely. In cert-manager v1.7 all alpha and beta API versions prior to v1 were removed . NB: The Kubernetes deprecation policy notes that API removal introduces an issue with objects stored at the removed versions. To fix this, we wrote a custom tool that users could run once to migrate their resources.","title":"API compatibility"},{"location":"installation/api-compatibility/#alpha-beta-api-versions","text":"As in upstream Kubernetes, We don't commit to preserving alpha or beta API versions indefinitely. In cert-manager v1.7 all alpha and beta API versions prior to v1 were removed . NB: The Kubernetes deprecation policy notes that API removal introduces an issue with objects stored at the removed versions. To fix this, we wrote a custom tool that users could run once to migrate their resources.","title":"Alpha / Beta API Versions"},{"location":"installation/code-signing/","text":"To help prevent supply chain attacks , some cert-manager release artifacts are cryptographically signed so you can be sure that the version of cert-manager you're about to install is actually built by and provided by the cert-manager maintainers. This signing is vitally important if for any reason you need to use a mirrored version of cert-manager; it allows you to confirm that the mirror hasn't tampered with the code you're about to install. Signing keys required for verification are all available on this website, but the actual key that you need might depend on the artifact you're trying to validate in the future. At the time of writing, all signing is done using the same underlying key. Container Images / Cosign \u00b6 For all cert-manager versions from v1.8.0 and later, cert-manager container images are signed and verifiable using cosign . The simplest way to verify signatures is to download the public key and then pass it to the cosign CLI directly: curl -sSOL https://cert-manager.io/public-keys/cert-manager-pubkey-2021-09-20.pem IMAGE_TAG=v1.10.1 # change as needed cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-acmesolver:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-cainjector:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-ctl:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-controller:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-webhook:$IMAGE_TAG For a more fully-featured signature verification process in Kubernetes, check out connaisseur . PEM-encoded public key: cert-manager-pubkey-2021-09-20.pem Helm Charts \u00b6 Helm requires the use of PGP for verification; the key format is different. Trying to use \"plain\" PEM encoded public keys during verification will fail. For all cert-manager versions from v1.6.0 and later, Helm charts are signed and verifiable through the Helm CLI. The easiest way to verify is to grab the GPG keyring directly, which can then be passed into helm verify like so: curl -sSL https://cert-manager.io/public-keys/cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg > cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg helm verify --keyring cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg /path/to/cert-manager-vx.y.z.tgz GPG keyring: cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg If you know what you're doing and you want the signing key in a format that's easy to import into GPG, it's available in an ASCII armored version: ASCII-armored signing key: cert-manager-pgp-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.asc","title":"cert-manager Signature Verification"},{"location":"installation/code-signing/#container-images-cosign","text":"For all cert-manager versions from v1.8.0 and later, cert-manager container images are signed and verifiable using cosign . The simplest way to verify signatures is to download the public key and then pass it to the cosign CLI directly: curl -sSOL https://cert-manager.io/public-keys/cert-manager-pubkey-2021-09-20.pem IMAGE_TAG=v1.10.1 # change as needed cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-acmesolver:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-cainjector:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-ctl:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-controller:$IMAGE_TAG cosign verify --signature-digest-algorithm sha512 --key cert-manager-pubkey-2021-09-20.pem quay.io/jetstack/cert-manager-webhook:$IMAGE_TAG For a more fully-featured signature verification process in Kubernetes, check out connaisseur . PEM-encoded public key: cert-manager-pubkey-2021-09-20.pem","title":"Container Images / Cosign"},{"location":"installation/code-signing/#helm-charts","text":"Helm requires the use of PGP for verification; the key format is different. Trying to use \"plain\" PEM encoded public keys during verification will fail. For all cert-manager versions from v1.6.0 and later, Helm charts are signed and verifiable through the Helm CLI. The easiest way to verify is to grab the GPG keyring directly, which can then be passed into helm verify like so: curl -sSL https://cert-manager.io/public-keys/cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg > cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg helm verify --keyring cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg /path/to/cert-manager-vx.y.z.tgz GPG keyring: cert-manager-keyring-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.gpg If you know what you're doing and you want the signing key in a format that's easy to import into GPG, it's available in an ASCII armored version: ASCII-armored signing key: cert-manager-pgp-2021-09-20-1020CF3C033D4F35BAE1C19E1226061C665DF13E.asc","title":"Helm Charts"},{"location":"installation/compatibility/","text":"Below you will find details on various compatibility issues and quirks that you may be affected by when deploying cert-manager. If you believe we've missed something please feel free to raise an issue or a pull request with the details! If you're using AWS Fargate or else if you've specifically configured cert-manager to run the host's network, be aware that kubelet listens on port `10250` by default which clashes with the default port for the cert-manager webhook. As such, you'll need to change the webhook's port when setting up cert-manager. For installations using Helm, you can set the `webhook.securePort` parameter when installing cert-manager either using a command line flag or an entry in your `values.yaml` file. If you have a port clash, you could see confusing error messages regarding untrusted certs. See [#3237](https://github.com/cert-manager/cert-manager/issues/3237) for more details. GKE \u00b6 When Google configure the control plane for private clusters, they automatically configure VPC peering between your Kubernetes cluster's network and a separate Google-managed project. In order to restrict what Google are able to access within your cluster, the firewall rules configured restrict access to your Kubernetes pods. This means that the webhook won't work, and you'll see errors such as Internal error occurred: failed calling admission webhook ... the server is currently unable to handle the request . In order to use the webhook component with a GKE private cluster, you must configure an additional firewall rule to allow the GKE control plane access to your webhook pod. You can read more information on how to add firewall rules for the GKE control plane nodes in the GKE docs . GKE Autopilot \u00b6 GKE Autopilot mode with Kubernetes < 1.21 does not support cert-manager, due to a restriction on mutating admission webhooks . As of October 2021, only the \"rapid\" Autopilot release channel has rolled out version 1.21 for Kubernetes masters. Installation via the helm chart may end in an error message but cert-manager is reported to be working by some users. Feedback and PRs are welcome. Problem : GKE Autopilot does not allow modifications to the kube-system -namespace. Historically we've used the kube-system namespace to prevent multiple installations of cert-manager in the same cluster. Installing cert-manager in these environments with default configuration can cause issues with bootstrapping. Some signals are: cert-manager-cainjector logging errors like: E0425 09:04:01.520150 1 leaderelection.go:334] error initially creating leader election record: leases.coordination.k8s.io is forbidden: User \"system:serviceaccount:cert-manager:cert-manager-cainjector\" cannot create resource \"leases\" in API group \"coordination.k8s.io\" in the namespace \"kube-system\": GKEAutopilot authz: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied cert-manager-startupapicheck not completing and logging messages like: Not ready: the cert-manager webhook CA bundle is not injected yet Solution : Configure cert-manager to use a different namespace for leader election, like this: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version ${CERT_MANAGER_VERSION} --set global.leaderElection.namespace=cert-manager AWS EKS \u00b6 When using a custom CNI (such as Weave or Calico) on EKS, the webhook cannot be reached by cert-manager. This happens because the control plane cannot be configured to run on a custom CNI on EKS, so the CNIs differ between control plane and worker nodes. To address this, the webhook can be run in the host network so it can be reached by cert-manager, by setting the webhook.hostNetwork key to true on your deployment, or, if using Helm, configuring it in your values.yaml file. Note that running on the host network will necessitate changing the webhook's port; see the warning at the top of the page for details. AWS Fargate \u00b6 It's worth noting that using AWS Fargate doesn't allow much network configuration and will cause the webhook's port to clash with the kubelet running on port 10250, as seen in #3237 . When deploying cert-manager on Fargate, you must change the port on which the webhook listens. See the warning at the top of this page for more details. Because Fargate forces you to use its networking, you cannot manually set the networking type and options such as webhook.hostNetwork on the helm chart will cause your cert-manager deployment to fail in surprising ways.","title":"\u4e91\u517c\u5bb9\u6027"},{"location":"installation/compatibility/#gke","text":"When Google configure the control plane for private clusters, they automatically configure VPC peering between your Kubernetes cluster's network and a separate Google-managed project. In order to restrict what Google are able to access within your cluster, the firewall rules configured restrict access to your Kubernetes pods. This means that the webhook won't work, and you'll see errors such as Internal error occurred: failed calling admission webhook ... the server is currently unable to handle the request . In order to use the webhook component with a GKE private cluster, you must configure an additional firewall rule to allow the GKE control plane access to your webhook pod. You can read more information on how to add firewall rules for the GKE control plane nodes in the GKE docs .","title":"GKE"},{"location":"installation/compatibility/#gke-autopilot","text":"GKE Autopilot mode with Kubernetes < 1.21 does not support cert-manager, due to a restriction on mutating admission webhooks . As of October 2021, only the \"rapid\" Autopilot release channel has rolled out version 1.21 for Kubernetes masters. Installation via the helm chart may end in an error message but cert-manager is reported to be working by some users. Feedback and PRs are welcome. Problem : GKE Autopilot does not allow modifications to the kube-system -namespace. Historically we've used the kube-system namespace to prevent multiple installations of cert-manager in the same cluster. Installing cert-manager in these environments with default configuration can cause issues with bootstrapping. Some signals are: cert-manager-cainjector logging errors like: E0425 09:04:01.520150 1 leaderelection.go:334] error initially creating leader election record: leases.coordination.k8s.io is forbidden: User \"system:serviceaccount:cert-manager:cert-manager-cainjector\" cannot create resource \"leases\" in API group \"coordination.k8s.io\" in the namespace \"kube-system\": GKEAutopilot authz: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied cert-manager-startupapicheck not completing and logging messages like: Not ready: the cert-manager webhook CA bundle is not injected yet Solution : Configure cert-manager to use a different namespace for leader election, like this: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version ${CERT_MANAGER_VERSION} --set global.leaderElection.namespace=cert-manager","title":"GKE Autopilot"},{"location":"installation/compatibility/#aws-eks","text":"When using a custom CNI (such as Weave or Calico) on EKS, the webhook cannot be reached by cert-manager. This happens because the control plane cannot be configured to run on a custom CNI on EKS, so the CNIs differ between control plane and worker nodes. To address this, the webhook can be run in the host network so it can be reached by cert-manager, by setting the webhook.hostNetwork key to true on your deployment, or, if using Helm, configuring it in your values.yaml file. Note that running on the host network will necessitate changing the webhook's port; see the warning at the top of the page for details.","title":"AWS EKS"},{"location":"installation/compatibility/#aws-fargate","text":"It's worth noting that using AWS Fargate doesn't allow much network configuration and will cause the webhook's port to clash with the kubelet running on port 10250, as seen in #3237 . When deploying cert-manager on Fargate, you must change the port on which the webhook listens. See the warning at the top of this page for more details. Because Fargate forces you to use its networking, you cannot manually set the networking type and options such as webhook.hostNetwork on the helm chart will cause your cert-manager deployment to fail in surprising ways.","title":"AWS Fargate"},{"location":"installation/helm/","text":"Installing with Helm \u00b6 cert-manager provides Helm charts as a first-class method of installation on both Kubernetes and OpenShift. Be sure never to embed cert-manager as a sub-chart of other Helm charts; cert-manager manages non-namespaced resources in your cluster and care must be taken to ensure that it is installed exactly once. Prerequisites \u00b6 Install Helm version 3 or later . Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform. Steps \u00b6 1. Add the Helm repository \u00b6 This repository is the only supported source of cert-manager charts. There are some other mirrors and copies across the internet, but those are entirely unofficial and could present a security risk. Notably, the \"Helm stable repository\" version of cert-manager is deprecated and should not be used. helm repo add jetstack https://charts.jetstack.io 2. Update your local Helm chart repository cache: \u00b6 helm repo update 3. Install CustomResourceDefinitions \u00b6 cert-manager requires a number of CRD resources, which can be installed manually using kubectl , or using the installCRDs option when installing the Helm chart. Option 1: installing CRDs with kubectl \u00b6 kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.crds.yaml Option 2: install CRDs as part of the Helm release \u00b6 To automatically install and manage the CRDs as part of your Helm release, you must add the --set installCRDs=true flag to your Helm installation command. Uncomment the relevant line in the next steps to enable this. Note that if you're using a helm version based on Kubernetes v1.18 or below (Helm v3.2 ), installCRDs will not work with cert-manager v0.16 . See the v0.16 upgrade notes for more details. 4. Install cert-manager \u00b6 To install the cert-manager Helm chart, use the Helm install command as described below. helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ # --set installCRDs=true A full list of available Helm values is on cert-manager's ArtifactHub page . The example below shows how to tune the cert-manager installation by overwriting the default Helm values: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4 # Example: changing the webhook timeout using a Helm parameter Once you have deployed cert-manager, you can verify the installation. Installing cert-manager as subchart \u00b6 If you have configured cert-manager as a subchart all the components of cert-manager will be installed into the namespace of the helm release you are installing. There may be a situation where you want to specify the namespace to install cert-manager different to the umbrella chart's namespace. This is a known issue with helm and subcharts, that you can't specify the namespace for the subchart and is being solved by most public charts by allowing users to set the namespace via the values file, but needs to be a capability added to the chart by the maintainers. This capability is now available in the cert-manager chart and can be set either in the values file or via the --set switch. Example usage \u00b6 Below is an example Chart.yaml with cert-manager as a subchart apiVersion : v2 name : example_chart description : A Helm chart with cert-manager as subchart type : application version : 0.1.0 appVersion : \"0.1.0\" dependencies : - name : cert-manager version : v1.10.1 repository : https://charts.jetstack.io alias : cert-manager condition : cert-manager.enabled You can then override the namespace in 2 ways 1. In Values.yaml file cert-manager : #defined by either the name or alias of your dependency in Chart.yaml namespace : security 2. In the helm command using --set helm install example example_chart \\ --namespace example \\ --create-namespace \\ --set cert-manager.namespace = security The above example will install cert-manager into the security namespace. Output YAML \u00b6 Instead of directly installing cert-manager using Helm, a static YAML manifest can be created using the Helm template command . This static manifest can be tuned by providing the flags to overwrite the default Helm values: helm template \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ # --set prometheus.enabled=false \\ # Example: disabling prometheus using a Helm parameter # --set installCRDs=true \\ # Uncomment to also template CRDs > cert-manager.custom.yaml Uninstalling \u00b6 Warning : To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process whether cert-manager has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that all cert-manager resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Issuers,ClusterIssuers,Certificates,CertificateRequests,Orders,Challenges --all-namespaces Once all these resources have been deleted you are ready to uninstall cert-manager using the procedure determined by how you installed. Uninstalling with Helm \u00b6 Uninstalling cert-manager from a helm installation is a case of running the installation process, in reverse , using the delete command on both kubectl and helm . helm --namespace cert-manager delete cert-manager Next, delete the cert-manager namespace: kubectl delete namespace cert-manager Finally, delete the cert-manager CustomResourceDefinitions using the link to the version vX.Y.Z you installed: Warning : This command will also remove installed cert-manager CRDs. All cert-manager resources (e.g. certificates.cert-manager.io resources) will be removed by Kubernetes' garbage collector. kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.crds.yaml Namespace Stuck in Terminating State \u00b6 If the namespace has been marked for deletion without deleting the cert-manager installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you're still experiencing issues then run: kubectl delete apiservice v1beta1.webhook.cert-manager.io","title":"Helm"},{"location":"installation/helm/#installing-with-helm","text":"cert-manager provides Helm charts as a first-class method of installation on both Kubernetes and OpenShift. Be sure never to embed cert-manager as a sub-chart of other Helm charts; cert-manager manages non-namespaced resources in your cluster and care must be taken to ensure that it is installed exactly once.","title":"Installing with Helm"},{"location":"installation/helm/#prerequisites","text":"Install Helm version 3 or later . Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform.","title":"Prerequisites"},{"location":"installation/helm/#steps","text":"","title":"Steps"},{"location":"installation/helm/#1-add-the-helm-repository","text":"This repository is the only supported source of cert-manager charts. There are some other mirrors and copies across the internet, but those are entirely unofficial and could present a security risk. Notably, the \"Helm stable repository\" version of cert-manager is deprecated and should not be used. helm repo add jetstack https://charts.jetstack.io","title":"1. Add the Helm repository"},{"location":"installation/helm/#2-update-your-local-helm-chart-repository-cache","text":"helm repo update","title":"2. Update your local Helm chart repository cache:"},{"location":"installation/helm/#3-install-customresourcedefinitions","text":"cert-manager requires a number of CRD resources, which can be installed manually using kubectl , or using the installCRDs option when installing the Helm chart.","title":"3. Install CustomResourceDefinitions"},{"location":"installation/helm/#option-1-installing-crds-with-kubectl","text":"kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.crds.yaml","title":"Option 1: installing CRDs with kubectl"},{"location":"installation/helm/#option-2-install-crds-as-part-of-the-helm-release","text":"To automatically install and manage the CRDs as part of your Helm release, you must add the --set installCRDs=true flag to your Helm installation command. Uncomment the relevant line in the next steps to enable this. Note that if you're using a helm version based on Kubernetes v1.18 or below (Helm v3.2 ), installCRDs will not work with cert-manager v0.16 . See the v0.16 upgrade notes for more details.","title":"Option 2: install CRDs as part of the Helm release"},{"location":"installation/helm/#4-install-cert-manager","text":"To install the cert-manager Helm chart, use the Helm install command as described below. helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ # --set installCRDs=true A full list of available Helm values is on cert-manager's ArtifactHub page . The example below shows how to tune the cert-manager installation by overwriting the default Helm values: helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4 # Example: changing the webhook timeout using a Helm parameter Once you have deployed cert-manager, you can verify the installation.","title":"4. Install cert-manager"},{"location":"installation/helm/#installing-cert-manager-as-subchart","text":"If you have configured cert-manager as a subchart all the components of cert-manager will be installed into the namespace of the helm release you are installing. There may be a situation where you want to specify the namespace to install cert-manager different to the umbrella chart's namespace. This is a known issue with helm and subcharts, that you can't specify the namespace for the subchart and is being solved by most public charts by allowing users to set the namespace via the values file, but needs to be a capability added to the chart by the maintainers. This capability is now available in the cert-manager chart and can be set either in the values file or via the --set switch.","title":"Installing cert-manager as subchart"},{"location":"installation/helm/#example-usage","text":"Below is an example Chart.yaml with cert-manager as a subchart apiVersion : v2 name : example_chart description : A Helm chart with cert-manager as subchart type : application version : 0.1.0 appVersion : \"0.1.0\" dependencies : - name : cert-manager version : v1.10.1 repository : https://charts.jetstack.io alias : cert-manager condition : cert-manager.enabled You can then override the namespace in 2 ways 1. In Values.yaml file cert-manager : #defined by either the name or alias of your dependency in Chart.yaml namespace : security 2. In the helm command using --set helm install example example_chart \\ --namespace example \\ --create-namespace \\ --set cert-manager.namespace = security The above example will install cert-manager into the security namespace.","title":"Example usage"},{"location":"installation/helm/#output-yaml","text":"Instead of directly installing cert-manager using Helm, a static YAML manifest can be created using the Helm template command . This static manifest can be tuned by providing the flags to overwrite the default Helm values: helm template \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.10.1 \\ # --set prometheus.enabled=false \\ # Example: disabling prometheus using a Helm parameter # --set installCRDs=true \\ # Uncomment to also template CRDs > cert-manager.custom.yaml","title":"Output YAML"},{"location":"installation/helm/#uninstalling","text":"Warning : To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process whether cert-manager has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that all cert-manager resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Issuers,ClusterIssuers,Certificates,CertificateRequests,Orders,Challenges --all-namespaces Once all these resources have been deleted you are ready to uninstall cert-manager using the procedure determined by how you installed.","title":"Uninstalling"},{"location":"installation/helm/#uninstalling-with-helm","text":"Uninstalling cert-manager from a helm installation is a case of running the installation process, in reverse , using the delete command on both kubectl and helm . helm --namespace cert-manager delete cert-manager Next, delete the cert-manager namespace: kubectl delete namespace cert-manager Finally, delete the cert-manager CustomResourceDefinitions using the link to the version vX.Y.Z you installed: Warning : This command will also remove installed cert-manager CRDs. All cert-manager resources (e.g. certificates.cert-manager.io resources) will be removed by Kubernetes' garbage collector. kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.crds.yaml","title":"Uninstalling with Helm"},{"location":"installation/helm/#namespace-stuck-in-terminating-state","text":"If the namespace has been marked for deletion without deleting the cert-manager installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you're still experiencing issues then run: kubectl delete apiservice v1beta1.webhook.cert-manager.io","title":"Namespace Stuck in Terminating State"},{"location":"installation/kubectl/","text":"Learn how to install cert-manager using kubectl and static manifests. Prerequisites \u00b6 Install kubectl version >= v1.19.0 . (otherwise, you'll have issues updating the CRDs - see v0.16 upgrade notes ) Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform. Steps \u00b6 All resources (the CustomResourceDefinitions and the cert-manager, cainjector and webhook components) are included in a single YAML manifest file: Install all cert-manager components: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml By default, cert-manager will be installed into the cert-manager namespace. It is possible to run cert-manager in a different namespace, although you'll need to make modifications to the deployment manifests. Once you have deployed cert-manager, you can verify the installation . Permissions Errors on Google Kubernetes Engine \u00b6 When running on GKE (Google Kubernetes Engine), you might encounter a 'permission denied' error when creating some of the required resources. This is a nuance of the way GKE handles RBAC and IAM permissions, and as such you might need to elevate your own privileges to that of a \"cluster-admin\" before running kubectl apply . If you have already run kubectl apply , you should run it again after elevating your permissions: kubectl create clusterrolebinding cluster-admin-binding \\ --clusterrole = cluster-admin \\ --user = $( gcloud config get-value core/account ) Uninstalling \u00b6 Warning : To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process whether cert-manager has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that unwanted cert-manager resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Issuers,ClusterIssuers,Certificates,CertificateRequests,Orders,Challenges --all-namespaces It is recommended that you delete all these resources before uninstalling cert-manager. If plan on reinstalling later and don't want to lose some custom resources, you can keep them. However, this can potentially lead to problems with finalizers. Some resources, like Challenges , should be deleted to avoid getting stuck in a pending state . Once the unneeded resources have been deleted, you are ready to uninstall cert-manager using the procedure determined by how you installed. Warning : Uninstalling cert-manager or simply deleting a Certificate resource can result in TLS Secret s being deleted if they have metadata.ownerReferences set by cert-manager. You can control whether owner references are added to Secret s using the --enable-certificate-owner-ref controller flag. By default, this flag is set to false, which means that no owner references are added. However, in cert-manager v1.8 and older, changing the flag's value from true to false did not result in existing owner references being removed. This behavior was fixed in cert-manager v1.8. Do check the owner references to confirm that they actually are removed. Uninstalling with regular manifests \u00b6 Uninstalling from an installation with regular manifests is a case of running the installation process, in reverse , using the delete command of kubectl . Delete the installation manifests using a link to your currently running version vX.Y.Z like so: Warning : This command will also remove installed cert-manager CRDs. All cert-manager resources (e.g. certificates.cert-manager.io resources) will be removed by Kubernetes' garbage collector. You cannot keep any custom resources if you delete the CustomResourceDefinition s. If you want to keep resources, you should manage CustomResourceDefinition s separately. kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.yaml Namespace Stuck in Terminating State \u00b6 If the namespace has been marked for deletion without deleting the cert-manager installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you're still experiencing issues then run: kubectl delete apiservice v1beta1.webhook.cert-manager.io Deleting pending challenges \u00b6 Challenge s can get stuck in a pending state when the finalizer is unable to complete and Kubernetes is waiting for the cert-manager controller to finish. This happens when the controller is no longer running to remove the flag, and the resources are defined as needing to wait. You can fix this problem by doing what the controller does manually. First, delete existing cert-manager webhook configurations, if any: kubectl delete mutatingwebhookconfigurations cert-manager-webhook Then change the .metadata.finalizers field to an empty list by editing the challenge resource: kubectl edit challenge <the-challenge>","title":"kubectl apply"},{"location":"installation/kubectl/#prerequisites","text":"Install kubectl version >= v1.19.0 . (otherwise, you'll have issues updating the CRDs - see v0.16 upgrade notes ) Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform.","title":"Prerequisites"},{"location":"installation/kubectl/#steps","text":"All resources (the CustomResourceDefinitions and the cert-manager, cainjector and webhook components) are included in a single YAML manifest file: Install all cert-manager components: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml By default, cert-manager will be installed into the cert-manager namespace. It is possible to run cert-manager in a different namespace, although you'll need to make modifications to the deployment manifests. Once you have deployed cert-manager, you can verify the installation .","title":"Steps"},{"location":"installation/kubectl/#permissions-errors-on-google-kubernetes-engine","text":"When running on GKE (Google Kubernetes Engine), you might encounter a 'permission denied' error when creating some of the required resources. This is a nuance of the way GKE handles RBAC and IAM permissions, and as such you might need to elevate your own privileges to that of a \"cluster-admin\" before running kubectl apply . If you have already run kubectl apply , you should run it again after elevating your permissions: kubectl create clusterrolebinding cluster-admin-binding \\ --clusterrole = cluster-admin \\ --user = $( gcloud config get-value core/account )","title":"Permissions Errors on Google Kubernetes Engine"},{"location":"installation/kubectl/#uninstalling","text":"Warning : To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process whether cert-manager has been installed from static manifests or Helm can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening. Before continuing, ensure that unwanted cert-manager resources that have been created by users have been deleted. You can check for any existing resources with the following command: kubectl get Issuers,ClusterIssuers,Certificates,CertificateRequests,Orders,Challenges --all-namespaces It is recommended that you delete all these resources before uninstalling cert-manager. If plan on reinstalling later and don't want to lose some custom resources, you can keep them. However, this can potentially lead to problems with finalizers. Some resources, like Challenges , should be deleted to avoid getting stuck in a pending state . Once the unneeded resources have been deleted, you are ready to uninstall cert-manager using the procedure determined by how you installed. Warning : Uninstalling cert-manager or simply deleting a Certificate resource can result in TLS Secret s being deleted if they have metadata.ownerReferences set by cert-manager. You can control whether owner references are added to Secret s using the --enable-certificate-owner-ref controller flag. By default, this flag is set to false, which means that no owner references are added. However, in cert-manager v1.8 and older, changing the flag's value from true to false did not result in existing owner references being removed. This behavior was fixed in cert-manager v1.8. Do check the owner references to confirm that they actually are removed.","title":"Uninstalling"},{"location":"installation/kubectl/#uninstalling-with-regular-manifests","text":"Uninstalling from an installation with regular manifests is a case of running the installation process, in reverse , using the delete command of kubectl . Delete the installation manifests using a link to your currently running version vX.Y.Z like so: Warning : This command will also remove installed cert-manager CRDs. All cert-manager resources (e.g. certificates.cert-manager.io resources) will be removed by Kubernetes' garbage collector. You cannot keep any custom resources if you delete the CustomResourceDefinition s. If you want to keep resources, you should manage CustomResourceDefinition s separately. kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.yaml","title":"Uninstalling with regular manifests"},{"location":"installation/kubectl/#namespace-stuck-in-terminating-state","text":"If the namespace has been marked for deletion without deleting the cert-manager installation first, the namespace may become stuck in a terminating state. This is typically due to the fact that the APIService resource still exists however the webhook is no longer running so is no longer reachable. To resolve this, ensure you have run the above commands correctly, and if you're still experiencing issues then run: kubectl delete apiservice v1beta1.webhook.cert-manager.io","title":"Namespace Stuck in Terminating State"},{"location":"installation/kubectl/#deleting-pending-challenges","text":"Challenge s can get stuck in a pending state when the finalizer is unable to complete and Kubernetes is waiting for the cert-manager controller to finish. This happens when the controller is no longer running to remove the flag, and the resources are defined as needing to wait. You can fix this problem by doing what the controller does manually. First, delete existing cert-manager webhook configurations, if any: kubectl delete mutatingwebhookconfigurations cert-manager-webhook Then change the .metadata.finalizers field to an empty list by editing the challenge resource: kubectl edit challenge <the-challenge>","title":"Deleting pending challenges"},{"location":"installation/operator-lifecycle-manager/","text":"Installation managed by OLM \u00b6 Prerequisites \u00b6 Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform. Option 1: Installing from OperatorHub Web Console on OpenShift \u00b6 cert-manager is in the Red Hat-provided Operator catalog called \"community-operators\". On OpenShift 4 you can install cert-manager from the OperatorHub web console or from the command line. These installation methods are described in Red Hat's Adding Operators to a cluster documentation. \u26a0\ufe0f In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook . \ud83d\udcd6 Read the Breaking Changes section in the 1.10 release notes before installing or upgrading. Option 2: Installing from OperatorHub.io \u00b6 Browse to the cert-manager page on OperatorHub.io , click the \"Install\" button and follow the installation instructions. Option 3: Manual install via kubectl operator plugin \u00b6 Install OLM and [install the kubectl operator plugin][] from the Krew Kubectl plugins index and then use that to install the cert-manager as follows: operator-sdk olm install kubectl krew install operator kubectl operator install cert-manager -n operators --channel stable --approval Automatic You can monitor the progress of the installation as follows: kubectl get events -w -n operators And you can see the status of the installation with: kubectl operator list Release Channels \u00b6 Whichever installation method you chose, there will now be an OLM Subscription resource for cert-manager, tracking the \"stable\" release channel. E.g. $ kubectl get subscription cert-manager -n operators -o yaml ... spec: channel: stable installPlanApproval: Automatic name: cert-manager ... status: currentCSV: cert-manager.v1.7.1 state: AtLatestKnown ... This means that OLM will discover new cert-manager releases in the stable channel, and, depending on the Subscription settings it will upgrade cert-manager automatically, when new releases become available. Read Manually Approving Upgrades via Subscriptions for information about automatic and manual upgrades. NOTE: There is a single release channel called \"stable\" which will contain all cert-manager releases, shortly after they are released. In future we may introduce other release channels with alternative release schedules, in accordance with OLM's Recommended Channel Naming . Debugging installation issues \u00b6 If you have any issues with your installation, please refer to the FAQ . Configuration \u00b6 The configuration options are quite limited when you install cert-manager using OLM. There are a few Deployment settings which can be overridden permanently in the Subscription and most other elements of the cert-manager manifests can be changed by editing the ClusterServiceVersion, but changes to the ClusterServiceVersion are temporary and will be lost if OLM upgrades cert-manager, because an upgrade results in a new ClusterServiceVersion resource. Configuration Via Subscription \u00b6 When you create an OLM Subscription you can override some of the cert-manager Deployment settings, but the options are quite limited. The configuration which you add to the Subscription will be applied immediately to the current cert-manager Deployments. It will also be re-applied if OLM upgrades cert-manager. \ud83d\udd30 Read the Configuring Operators deployed by OLM design doc in the OLM repository. \ud83d\udd30 Refer to the Subscription API documentation . Here are some examples of configuration that can be achieved by modifying the Subscription resource. In each case we assume that you are starting with the following default Subscription from OperatorHub.io : # cert-manager.yaml apiVersion : operators.coreos.com/v1alpha1 kind : Subscription metadata : name : my-cert-manager namespace : operators spec : channel : stable name : cert-manager source : operatorhubio-catalog sourceNamespace : olm kubectl create -f https://operatorhub.io/install/cert-manager.yaml Change the Resource Requests and Limits \u00b6 It is possible to change the resource requests and limits by adding a config stanza to the Subscription: # resources-patch.yaml spec : config : resources : requests : memory : \"64Mi\" cpu : \"250m\" limits : memory : \"128Mi\" cpu : \"500m\" kubectl -n operators patch subscription my-cert-manager --type merge --patch-file resources-patch.yaml You will see all the cert-manager Pods are restarted with the new resources: $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,mem:.spec.containers[*].resources\" name mem cert-manager-669867589c-n8dcn map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] cert-manager-cainjector-7b7fff8b9c-dxw6b map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] cert-manager-webhook-975bc87b5-tqdj4 map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] \u26a0\ufe0f This configuration will apply to all the cert-manager Deployments. This is a known limitation of OLM which does not support configuration of individual Deployments . Change the NodeSelector \u00b6 It is possible to change the nodeSelector for cert-manager Pods by adding the following stanza to the Subscription: # nodeselector-patch.yaml spec : config : nodeSelector : kubernetes.io/arch : amd64 kubectl -n operators patch subscription my-cert-manager --type merge --patch-file nodeselector-patch.yaml You will see all the cert-manager Pods are restarted with the new nodeSelector : $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,nodeselector:.spec.nodeSelector\" name nodeselector cert-manager-5b6b8f7d74-k7l94 map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] cert-manager-cainjector-b89cd6f46-kdkk2 map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] cert-manager-webhook-8464bc7cc8-64b4w map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] \u26a0\ufe0f This configuration will apply to all the cert-manager Deployments. This is a known limitation of OLM which does not support configuration of individual Deployments . Configuration Via ClusterServiceVersion (CSV) \u00b6 The ClusterServiceVersion (CSV) resource contains the templates for all the cert-manager Deployments. If you patch these templates, OLM will immediately roll out the changes to the Deployments. \u26a0\ufe0f If OLM upgrades cert-manager your changes will be lost because it will create a new CSV with default Deployment templates. Nevertheless, editing (patching) the CSV can be a useful way to override certain cert-manager settings. An example: Change the log level of cert-manager components \u00b6 The following JSON patch will append -v=6 to command line arguments of the cert-manager controller-manager (the first container of the first Deployment). kubectl patch csv cert-manager.v1.10.1 \\ --type json \\ -p '[{\"op\": \"add\", \"path\": \"/spec/install/spec/deployments/0/spec/template/spec/containers/0/args/-\", \"value\": \"-v=6\" }]' You will see the controller-manager Pod is restarted with the new arguments. $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,args:.spec.containers[0].args\" name args cert-manager-797979cbdb-g444r [-v=2 --cluster-resource-namespace=$(POD_NAMESPACE) --leader-election-namespace=kube-system -v=6] ... \ud83d\udd30 Refer to the ClusterServiceVersion API documentation . Uninstall \u00b6 Below is the processes for uninstalling cert-manager on OpenShift. \u26a0\ufe0f To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening.","title":"OperatorHub (OLM)"},{"location":"installation/operator-lifecycle-manager/#installation-managed-by-olm","text":"","title":"Installation managed by OLM"},{"location":"installation/operator-lifecycle-manager/#prerequisites","text":"Install a supported version of Kubernetes or OpenShift . Read Compatibility with Kubernetes Platform Providers if you are using Kubernetes on a cloud platform.","title":"Prerequisites"},{"location":"installation/operator-lifecycle-manager/#option-1-installing-from-operatorhub-web-console-on-openshift","text":"cert-manager is in the Red Hat-provided Operator catalog called \"community-operators\". On OpenShift 4 you can install cert-manager from the OperatorHub web console or from the command line. These installation methods are described in Red Hat's Adding Operators to a cluster documentation. \u26a0\ufe0f In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook . \ud83d\udcd6 Read the Breaking Changes section in the 1.10 release notes before installing or upgrading.","title":"Option 1: Installing from OperatorHub Web Console on OpenShift"},{"location":"installation/operator-lifecycle-manager/#option-2-installing-from-operatorhubio","text":"Browse to the cert-manager page on OperatorHub.io , click the \"Install\" button and follow the installation instructions.","title":"Option 2: Installing from OperatorHub.io"},{"location":"installation/operator-lifecycle-manager/#option-3-manual-install-via-kubectl-operator-plugin","text":"Install OLM and [install the kubectl operator plugin][] from the Krew Kubectl plugins index and then use that to install the cert-manager as follows: operator-sdk olm install kubectl krew install operator kubectl operator install cert-manager -n operators --channel stable --approval Automatic You can monitor the progress of the installation as follows: kubectl get events -w -n operators And you can see the status of the installation with: kubectl operator list","title":"Option 3: Manual install via kubectl operator plugin"},{"location":"installation/operator-lifecycle-manager/#release-channels","text":"Whichever installation method you chose, there will now be an OLM Subscription resource for cert-manager, tracking the \"stable\" release channel. E.g. $ kubectl get subscription cert-manager -n operators -o yaml ... spec: channel: stable installPlanApproval: Automatic name: cert-manager ... status: currentCSV: cert-manager.v1.7.1 state: AtLatestKnown ... This means that OLM will discover new cert-manager releases in the stable channel, and, depending on the Subscription settings it will upgrade cert-manager automatically, when new releases become available. Read Manually Approving Upgrades via Subscriptions for information about automatic and manual upgrades. NOTE: There is a single release channel called \"stable\" which will contain all cert-manager releases, shortly after they are released. In future we may introduce other release channels with alternative release schedules, in accordance with OLM's Recommended Channel Naming .","title":"Release Channels"},{"location":"installation/operator-lifecycle-manager/#debugging-installation-issues","text":"If you have any issues with your installation, please refer to the FAQ .","title":"Debugging installation issues"},{"location":"installation/operator-lifecycle-manager/#configuration","text":"The configuration options are quite limited when you install cert-manager using OLM. There are a few Deployment settings which can be overridden permanently in the Subscription and most other elements of the cert-manager manifests can be changed by editing the ClusterServiceVersion, but changes to the ClusterServiceVersion are temporary and will be lost if OLM upgrades cert-manager, because an upgrade results in a new ClusterServiceVersion resource.","title":"Configuration"},{"location":"installation/operator-lifecycle-manager/#configuration-via-subscription","text":"When you create an OLM Subscription you can override some of the cert-manager Deployment settings, but the options are quite limited. The configuration which you add to the Subscription will be applied immediately to the current cert-manager Deployments. It will also be re-applied if OLM upgrades cert-manager. \ud83d\udd30 Read the Configuring Operators deployed by OLM design doc in the OLM repository. \ud83d\udd30 Refer to the Subscription API documentation . Here are some examples of configuration that can be achieved by modifying the Subscription resource. In each case we assume that you are starting with the following default Subscription from OperatorHub.io : # cert-manager.yaml apiVersion : operators.coreos.com/v1alpha1 kind : Subscription metadata : name : my-cert-manager namespace : operators spec : channel : stable name : cert-manager source : operatorhubio-catalog sourceNamespace : olm kubectl create -f https://operatorhub.io/install/cert-manager.yaml","title":"Configuration Via Subscription"},{"location":"installation/operator-lifecycle-manager/#change-the-resource-requests-and-limits","text":"It is possible to change the resource requests and limits by adding a config stanza to the Subscription: # resources-patch.yaml spec : config : resources : requests : memory : \"64Mi\" cpu : \"250m\" limits : memory : \"128Mi\" cpu : \"500m\" kubectl -n operators patch subscription my-cert-manager --type merge --patch-file resources-patch.yaml You will see all the cert-manager Pods are restarted with the new resources: $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,mem:.spec.containers[*].resources\" name mem cert-manager-669867589c-n8dcn map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] cert-manager-cainjector-7b7fff8b9c-dxw6b map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] cert-manager-webhook-975bc87b5-tqdj4 map[limits:map[cpu:500m memory:128Mi] requests:map[cpu:250m memory:100Mi]] \u26a0\ufe0f This configuration will apply to all the cert-manager Deployments. This is a known limitation of OLM which does not support configuration of individual Deployments .","title":"Change the Resource Requests and Limits"},{"location":"installation/operator-lifecycle-manager/#change-the-nodeselector","text":"It is possible to change the nodeSelector for cert-manager Pods by adding the following stanza to the Subscription: # nodeselector-patch.yaml spec : config : nodeSelector : kubernetes.io/arch : amd64 kubectl -n operators patch subscription my-cert-manager --type merge --patch-file nodeselector-patch.yaml You will see all the cert-manager Pods are restarted with the new nodeSelector : $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,nodeselector:.spec.nodeSelector\" name nodeselector cert-manager-5b6b8f7d74-k7l94 map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] cert-manager-cainjector-b89cd6f46-kdkk2 map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] cert-manager-webhook-8464bc7cc8-64b4w map[kubernetes.io/arch:amd64 kubernetes.io/os:linux] \u26a0\ufe0f This configuration will apply to all the cert-manager Deployments. This is a known limitation of OLM which does not support configuration of individual Deployments .","title":"Change the NodeSelector"},{"location":"installation/operator-lifecycle-manager/#configuration-via-clusterserviceversion-csv","text":"The ClusterServiceVersion (CSV) resource contains the templates for all the cert-manager Deployments. If you patch these templates, OLM will immediately roll out the changes to the Deployments. \u26a0\ufe0f If OLM upgrades cert-manager your changes will be lost because it will create a new CSV with default Deployment templates. Nevertheless, editing (patching) the CSV can be a useful way to override certain cert-manager settings. An example:","title":"Configuration Via ClusterServiceVersion (CSV)"},{"location":"installation/operator-lifecycle-manager/#change-the-log-level-of-cert-manager-components","text":"The following JSON patch will append -v=6 to command line arguments of the cert-manager controller-manager (the first container of the first Deployment). kubectl patch csv cert-manager.v1.10.1 \\ --type json \\ -p '[{\"op\": \"add\", \"path\": \"/spec/install/spec/deployments/0/spec/template/spec/containers/0/args/-\", \"value\": \"-v=6\" }]' You will see the controller-manager Pod is restarted with the new arguments. $ kubectl -n operators get pods -o \"custom-columns=name:.metadata.name,args:.spec.containers[0].args\" name args cert-manager-797979cbdb-g444r [-v=2 --cluster-resource-namespace=$(POD_NAMESPACE) --leader-election-namespace=kube-system -v=6] ... \ud83d\udd30 Refer to the ClusterServiceVersion API documentation .","title":"Change the log level of cert-manager components"},{"location":"installation/operator-lifecycle-manager/#uninstall","text":"Below is the processes for uninstalling cert-manager on OpenShift. \u26a0\ufe0f To uninstall cert-manager you should always use the same process for installing but in reverse. Deviating from the following process can cause issues and potentially broken states. Please ensure you follow the below steps when uninstalling to prevent this happening.","title":"Uninstall"},{"location":"installation/other-tools/","text":"kubeprod \u00b6 Bitnami Kubernetes Production Runtime ( BKPR , kubeprod ) is a curated collection of the services you would need to deploy on top of your Kubernetes cluster to enable logging, monitoring, certificate management, automatic discovery of Kubernetes resources via public DNS servers and other common infrastructure needs. It depends on cert-manager for certificate management, and it is regularly tested so the components are known to work together for GKE, AKS, and EKS clusters. For its ingress stack it creates a DNS entry in the configured DNS zone and requests a TLS certificate from the Let's Encrypt staging server. BKPR can be deployed using the kubeprod install command, which will deploy cert-manager as part of it. Details available in the BKPR installation guide .","title":"\u5176\u4ed6\u5de5\u5177"},{"location":"installation/other-tools/#kubeprod","text":"Bitnami Kubernetes Production Runtime ( BKPR , kubeprod ) is a curated collection of the services you would need to deploy on top of your Kubernetes cluster to enable logging, monitoring, certificate management, automatic discovery of Kubernetes resources via public DNS servers and other common infrastructure needs. It depends on cert-manager for certificate management, and it is regularly tested so the components are known to work together for GKE, AKS, and EKS clusters. For its ingress stack it creates a DNS entry in the configured DNS zone and requests a TLS certificate from the Let's Encrypt staging server. BKPR can be deployed using the kubeprod install command, which will deploy cert-manager as part of it. Details available in the BKPR installation guide .","title":"kubeprod"},{"location":"installation/supported-releases/","text":"{/* Inspired by https://istio.io/latest/about/supported-releases/ */} This page lists the status, timeline and policy for currently supported releases. Each release is supported for a period of four months, and we aim to create a new release roughly every two months, accounting for holiday periods, major conferences and other world events. cert-manager expects that ServerSideApply is enabled in the cluster for all version of Kubernetes from 1.24 and above. Currently supported releases Release Release Date End of Life Supported Kubernetes versions Supported OpenShift versions 1.10 Oct 17, 2022 Release of 1.12 1.20 \u2192 1.26 4.7 \u2192 4.13 1.9 Jul 22, 2022 Release of 1.11 1.20 \u2192 1.24 4.7 \u2192 4.11 *ServerSideApply should be enabled in the cluster Upcoming releases \u00b6 Release Release Date End of Life Supported Kubernetes versions Supported OpenShift versions 1.11 Jan 11, 2023 Mid May, 2023 1.21 \u2192 1.26 4.8 \u2192 4.13 [1.12][] ~Mar 15, 2023 Mid July, 2023 1.22 \u2192 1.26 4.9 \u2192 4.13 Dates in the future are uncertain and might change. Old releases \u00b6 Release Release Date EOL Compatible Kubernetes versions Compatible OpenShift versions 1.8 Apr 05, 2022 Oct 17, 2022 1.19 \u2192 1.24 4.6 \u2192 4.11 1.7 Jan 26, 2021 Jul 22, 2022 1.18 \u2192 1.23 4.5 \u2192 4.9 1.6 Oct 26, 2021 Apr 05, 2022 1.17 \u2192 1.22 4.4 \u2192 4.9 1.5 Aug 11, 2021 Jan 26, 2022 1.16 \u2192 1.22 4.3 \u2192 4.8 1.4 Jun 15, 2021 Oct 26, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.3 Apr 08, 2021 Aug 11, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.2 Feb 10, 2021 Jun 15, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.1 Nov 24, 2020 Apr 08, 2021 1.11 \u2192 1.21 3.11 \u2192 4.7 1.0 Sep 02, 2020 Feb 10, 2021 1.11 \u2192 1.21 3.11 \u2192 4.7 0.16 Jul 23, 2020 Nov 24, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.15 May 06, 2020 Sep 02, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.14 Mar 11, 2020 Jul 23, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.13 Jan 21, 2020 May 06, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.12 Nov 27, 2019 Mar 11, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.11 Oct 10, 2019 Jan 21, 2020 1.9 \u2192 1.21 3.09 \u2192 4.7 We list cert-manager releases on GitHub , and release notes on cert-manager.io . We also maintain detailed upgrade instructions . Support policy \u00b6 What we mean by support \u00b6 Our support window is four months for each release branch. In the below diagram, release-1.2 is an example of a release branch. The support window corresponds to the two latest releases, given that we produce a new final release every two months. We offer two types of support: Technical support , Security and bug fixes . For example, imagining that the latest release is v1.2.0 , you can expect support for both v1.2.0 and v1.1.0 . Only the last patch release of each branch is actually supported. v1.0.0 ^ Sep 2, 2020 | UNSUPPORTED ------+---------------------------------------------> release-1.0 | RELEASES \\ v \\ \\ v1.1.0 \\ Nov 24, 2020 ^ ---------+-------------------------------> release-1.1 | \\ | SUPPORTED \\ | RELEASES \\ v1.2.0 | = the two \\ Feb 10, 2021 | last ------------+--------------> release-1.2 | releases \\ v \\ \\ \\ -----------> master branch April 1, 2021 Technical support Technical assistance is offered on a best-effort basis for supported releases only. You can request support from the community on Kubernetes Slack (in the #cert-manager channel), using GitHub Discussions or using the cert-manager-dev Google group. Security and bug fixes We back-port important bug fixes \u2014 including security fixes \u2014 to all currently supported releases. Security issues , Critical bugs , Long-standing bugs . Security issues Security issues are fixed as soon as possible. They get back-ported to the last two releases, and a new patch release is immediately created for them. Critical bugs Critical bugs include both regression bugs as well as upgrade bugs. Regressions are functionalities that worked in a previous release but no longer work. #4142 , #3393 and #2857 are three examples of regressions. Upgrade bugs are issues (often Helm-related) preventing users from upgrading to currently supported releases from earlier releases of cert-manager. #3882 and #3644 are examples of upgrade bugs. Note that intentional breaking changes do not belong to this category. Fixes for critical bugs are (usually) immediately back-ported by creating a new patch release for the currently supported releases. Long-standing bugs Long-standing bug : sometimes a bug exists for a long time, and may have known workarounds. #3444 is an example of a long-standing bug. Where we feel that back-porting would be difficult or might be a stability risk to clusters running cert-manager, we'll make the fix in a major release but avoid back-porting the fix. Breaking changes Breaking changes are changes that intentionally break the cert-manager Kubernetes API or the command line flags. We avoid making breaking changes where possible, and where they're required we'll give as much notice as possible. Other back-ports We aim to be conservative in what we back-port. That applies especially for anything which could be a runtime change - that is, a change which might alter behavior for someone upgrading between patch releases. That means that if a candidate for back-porting has a chance of having a runtime impact we're unlikely to accept the change unless it addresses a security issue or a critical bug. We reserve the right to back-port other changes which are unlikely to have a runtime impact, such as documentation or tooling changes. An example would be #5209 which updated how we perform a release of cert-manager but didn't have any realistic chance of having a runtime impact. Generally we'll seek to be pragmatic. A rule of thumb might be to ask: \"Does this back-port improve cert-manager, bearing in mind that we really value stability for already-released versions?\" How we determine supported Kubernetes versions The list of supported Kubernetes versions displayed in the Supported Releases section depends on what the cert-manager maintainers think is reasonable to support and to test. In practice, this is largely determined based on what versions of kind are available for testing, and which versions of Kubernetes are provided by major upstream cloud Kubernetes vendors including EKS, GKE, AKS and OpenShift. Vendor Oldest Kubernetes Release* Other Older Kubernetes Releases EKS 1.21 (EOL Feb 2023) 1.22 (EOL May 2023) GKE 1.21 (EOL Feb 2023) 1.22 (EOL May 2023) AKS 1.23 (EOL ~Feb 2023) OpenShift 4 1.21 (4.8 EUS, EOL Feb 2023) 1.22 (4.9, EOL Apr 2023) *Oldest release relevant to the next cert-manager release, as of 2022-07-18 OpenShift \u00b6 cert-manager supports versions of OpenShift 4 based on the version of Kubernetes that each version maps to. For convenience, the following table shows these version mappings: OpenShift versions Kubernetes version 4.13 1.26 4.12 1.25 4.11 1.24 4.10, 4.10 EUS 1.23 4.9 1.22 4.8, 4.8 EUS 1.21 4.7 1.20 4.6, 4.6 EUS 1.19 Note that some OpenShift versions listed above may be predicted, since an updated version of OpenShift may not yet be available for the latest Kubernetes releases. The last version of cert-manager to support OpenShift 3 was cert-manager 1.2, which is no longer maintained. Terminology \u00b6 The term \"release\" (or \"minor release\") refers to one minor version of cert-manager. For example, 1.2 and 1.3 are two releases. Note that we do not use the prefix v for releases (just \"1.2\"). This is because releases are not used as git tags. Patch releases use the v prefix (e.g., v1.2.0 , v1.3.1 ...) since one patch release = one git tag. The initial patch release is called \"final release\": Type of release Example of git tag Corresponding release Corresponding release branch* Final release v1.3.0 1.3 release-1.3 Patch release v1.3.1 1.3 release-1.3 Pre-release v1.4.0-alpha.0 N/A** release-1.4 *For maintainers: each release has an associated long-lived branch that we call the \u201crelease branch\u201d. For example, release-1.2 is the release branch for release 1.2. **Pre-releases (e.g., v1.3.0-alpha.0 ) don't have a corresponding release (e.g., 1.3) since a release only exists after a final release (e.g., v1.3.0 ) has been created. Our naming scheme mostly follows Semantic Versioning 2.0.0 with v prepended to git tags and docker images: v<major>.<minor>.<patch> where <minor> is increased for each release, and <patch> counts the number of patches for the current <minor> release. A patch is usually a small change relative to the <minor> release.","title":"\u652f\u6301\u7248\u672c"},{"location":"installation/supported-releases/#upcoming-releases","text":"Release Release Date End of Life Supported Kubernetes versions Supported OpenShift versions 1.11 Jan 11, 2023 Mid May, 2023 1.21 \u2192 1.26 4.8 \u2192 4.13 [1.12][] ~Mar 15, 2023 Mid July, 2023 1.22 \u2192 1.26 4.9 \u2192 4.13 Dates in the future are uncertain and might change.","title":"Upcoming releases"},{"location":"installation/supported-releases/#old-releases","text":"Release Release Date EOL Compatible Kubernetes versions Compatible OpenShift versions 1.8 Apr 05, 2022 Oct 17, 2022 1.19 \u2192 1.24 4.6 \u2192 4.11 1.7 Jan 26, 2021 Jul 22, 2022 1.18 \u2192 1.23 4.5 \u2192 4.9 1.6 Oct 26, 2021 Apr 05, 2022 1.17 \u2192 1.22 4.4 \u2192 4.9 1.5 Aug 11, 2021 Jan 26, 2022 1.16 \u2192 1.22 4.3 \u2192 4.8 1.4 Jun 15, 2021 Oct 26, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.3 Apr 08, 2021 Aug 11, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.2 Feb 10, 2021 Jun 15, 2021 1.16 \u2192 1.21 4.3 \u2192 4.7 1.1 Nov 24, 2020 Apr 08, 2021 1.11 \u2192 1.21 3.11 \u2192 4.7 1.0 Sep 02, 2020 Feb 10, 2021 1.11 \u2192 1.21 3.11 \u2192 4.7 0.16 Jul 23, 2020 Nov 24, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.15 May 06, 2020 Sep 02, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.14 Mar 11, 2020 Jul 23, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.13 Jan 21, 2020 May 06, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.12 Nov 27, 2019 Mar 11, 2020 1.11 \u2192 1.21 3.11 \u2192 4.7 0.11 Oct 10, 2019 Jan 21, 2020 1.9 \u2192 1.21 3.09 \u2192 4.7 We list cert-manager releases on GitHub , and release notes on cert-manager.io . We also maintain detailed upgrade instructions .","title":"Old releases"},{"location":"installation/supported-releases/#support-policy","text":"","title":"Support policy"},{"location":"installation/supported-releases/#what-we-mean-by-support","text":"Our support window is four months for each release branch. In the below diagram, release-1.2 is an example of a release branch. The support window corresponds to the two latest releases, given that we produce a new final release every two months. We offer two types of support: Technical support , Security and bug fixes . For example, imagining that the latest release is v1.2.0 , you can expect support for both v1.2.0 and v1.1.0 . Only the last patch release of each branch is actually supported. v1.0.0 ^ Sep 2, 2020 | UNSUPPORTED ------+---------------------------------------------> release-1.0 | RELEASES \\ v \\ \\ v1.1.0 \\ Nov 24, 2020 ^ ---------+-------------------------------> release-1.1 | \\ | SUPPORTED \\ | RELEASES \\ v1.2.0 | = the two \\ Feb 10, 2021 | last ------------+--------------> release-1.2 | releases \\ v \\ \\ \\ -----------> master branch April 1, 2021","title":"What we mean by support"},{"location":"installation/supported-releases/#openshift","text":"cert-manager supports versions of OpenShift 4 based on the version of Kubernetes that each version maps to. For convenience, the following table shows these version mappings: OpenShift versions Kubernetes version 4.13 1.26 4.12 1.25 4.11 1.24 4.10, 4.10 EUS 1.23 4.9 1.22 4.8, 4.8 EUS 1.21 4.7 1.20 4.6, 4.6 EUS 1.19 Note that some OpenShift versions listed above may be predicted, since an updated version of OpenShift may not yet be available for the latest Kubernetes releases. The last version of cert-manager to support OpenShift 3 was cert-manager 1.2, which is no longer maintained.","title":"OpenShift"},{"location":"installation/supported-releases/#terminology","text":"The term \"release\" (or \"minor release\") refers to one minor version of cert-manager. For example, 1.2 and 1.3 are two releases. Note that we do not use the prefix v for releases (just \"1.2\"). This is because releases are not used as git tags. Patch releases use the v prefix (e.g., v1.2.0 , v1.3.1 ...) since one patch release = one git tag. The initial patch release is called \"final release\": Type of release Example of git tag Corresponding release Corresponding release branch* Final release v1.3.0 1.3 release-1.3 Patch release v1.3.1 1.3 release-1.3 Pre-release v1.4.0-alpha.0 N/A** release-1.4 *For maintainers: each release has an associated long-lived branch that we call the \u201crelease branch\u201d. For example, release-1.2 is the release branch for release 1.2. **Pre-releases (e.g., v1.3.0-alpha.0 ) don't have a corresponding release (e.g., 1.3) since a release only exists after a final release (e.g., v1.3.0 ) has been created. Our naming scheme mostly follows Semantic Versioning 2.0.0 with v prepended to git tags and docker images: v<major>.<minor>.<patch> where <minor> is increased for each release, and <patch> counts the number of patches for the current <minor> release. A patch is usually a small change relative to the <minor> release.","title":"Terminology"},{"location":"installation/uninstall/","text":"cert-manager supports running on Kubernetes and OpenShift . The uninstallation process between the two platforms is similar. Select the method that was used for installing cert-manager to go to the relevant uninstall documentation. kubectl helm","title":"Uninstall"},{"location":"installation/verify/","text":"Check cert-manager API \u00b6 First, make sure that cmctl is installed . cmctl performs a dry-run certificate creation check against the Kubernetes cluster. If successful, the message The cert-manager API is ready is displayed. $ cmctl check api The cert-manager API is ready The command can also be used to wait for the check to be successful. Here is an output example of running the command at the same time that cert-manager is being installed: $ cmctl check api --wait = 2m Not ready: the cert-manager CRDs are not yet installed on the Kubernetes API server Not ready: the cert-manager CRDs are not yet installed on the Kubernetes API server Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet The cert-manager API is ready Manual verification \u00b6 Once you've installed cert-manager, you can verify it is deployed correctly by checking the cert-manager namespace for running pods: $ kubectl get pods --namespace cert-manager NAME READY STATUS RESTARTS AGE cert-manager-5c6866597-zw7kh 1 /1 Running 0 2m cert-manager-cainjector-577f6d9fd7-tr77l 1 /1 Running 0 2m cert-manager-webhook-787858fcdb-nlzsq 1 /1 Running 0 2m You should see the cert-manager , cert-manager-cainjector , and cert-manager-webhook pods in a Running state. The webhook might take a little longer to successfully provision than the others. If you experience problems, first check the FAQ . Create an Issuer to test the webhook works okay. $ cat <<EOF > test-resources.yaml apiVersion: v1 kind: Namespace metadata: name: cert-manager-test --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: test-selfsigned namespace: cert-manager-test spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: selfsigned-cert namespace: cert-manager-test spec: dnsNames: - example.com secretName: selfsigned-cert-tls issuerRef: name: test-selfsigned EOF Create the test resources. $ kubectl apply -f test-resources.yaml Check the status of the newly created certificate. You may need to wait a few seconds before cert-manager processes the certificate request. $ kubectl describe certificate -n cert-manager-test ... Spec: Common Name: example.com Issuer Ref: Name: test-selfsigned Secret Name: selfsigned-cert-tls Status: Conditions: Last Transition Time: 2019 -01-29T17:34:30Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -04-29T17:34:29Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CertIssued 4s cert-manager Certificate issued successfully Clean up the test resources. $ kubectl delete -f test-resources.yaml If all the above steps have completed without error, you're good to go! Community-maintained tool \u00b6 Alternatively, to automatically check if cert-manager is correctly configured, you can run the community-maintained cert-manager-verifier tool.","title":"\u9a8c\u8bc1"},{"location":"installation/verify/#check-cert-manager-api","text":"First, make sure that cmctl is installed . cmctl performs a dry-run certificate creation check against the Kubernetes cluster. If successful, the message The cert-manager API is ready is displayed. $ cmctl check api The cert-manager API is ready The command can also be used to wait for the check to be successful. Here is an output example of running the command at the same time that cert-manager is being installed: $ cmctl check api --wait = 2m Not ready: the cert-manager CRDs are not yet installed on the Kubernetes API server Not ready: the cert-manager CRDs are not yet installed on the Kubernetes API server Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet Not ready: the cert-manager webhook deployment is not ready yet The cert-manager API is ready","title":"Check cert-manager API"},{"location":"installation/verify/#manual-verification","text":"Once you've installed cert-manager, you can verify it is deployed correctly by checking the cert-manager namespace for running pods: $ kubectl get pods --namespace cert-manager NAME READY STATUS RESTARTS AGE cert-manager-5c6866597-zw7kh 1 /1 Running 0 2m cert-manager-cainjector-577f6d9fd7-tr77l 1 /1 Running 0 2m cert-manager-webhook-787858fcdb-nlzsq 1 /1 Running 0 2m You should see the cert-manager , cert-manager-cainjector , and cert-manager-webhook pods in a Running state. The webhook might take a little longer to successfully provision than the others. If you experience problems, first check the FAQ . Create an Issuer to test the webhook works okay. $ cat <<EOF > test-resources.yaml apiVersion: v1 kind: Namespace metadata: name: cert-manager-test --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: test-selfsigned namespace: cert-manager-test spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: selfsigned-cert namespace: cert-manager-test spec: dnsNames: - example.com secretName: selfsigned-cert-tls issuerRef: name: test-selfsigned EOF Create the test resources. $ kubectl apply -f test-resources.yaml Check the status of the newly created certificate. You may need to wait a few seconds before cert-manager processes the certificate request. $ kubectl describe certificate -n cert-manager-test ... Spec: Common Name: example.com Issuer Ref: Name: test-selfsigned Secret Name: selfsigned-cert-tls Status: Conditions: Last Transition Time: 2019 -01-29T17:34:30Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -04-29T17:34:29Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CertIssued 4s cert-manager Certificate issued successfully Clean up the test resources. $ kubectl delete -f test-resources.yaml If all the above steps have completed without error, you're good to go!","title":"Manual verification"},{"location":"installation/verify/#community-maintained-tool","text":"Alternatively, to automatically check if cert-manager is correctly configured, you can run the community-maintained cert-manager-verifier tool.","title":"Community-maintained tool"},{"location":"installation/upgrading/","text":"This section contains information on upgrading cert-manager. It also contains documents detailing breaking changes between cert-manager versions, and information on things to look out for when upgrading. Note: Before performing upgrades of cert-manager, it is advised to take a backup of all your cert-manager resources just in case an issue occurs whilst upgrading. You can read how to backup and restore cert-manager in the backup and restore guide. We recommend that you upgrade cert-manager one minor version at a time, always choosing the latest patch version for the minor version. You should always read the release notes for the minor version to which you are upgrading. In cases where a large version jump is needed to get an installation up to date, it may be possible to do a full uninstall and re-install of cert-manager without application downtime and/or unnecessary re-issuances, however we do not guarantee that this will work for your particular setup see Reinstalling cert-manager . Upgrading with Helm \u00b6 If you installed cert-manager using Helm, you can easily upgrade using the Helm CLI. Note: Before upgrading, please read the relevant instructions at the links below for your from and to version. Once you have read the relevant upgrading notes and taken any appropriate actions, you can begin the upgrade process like so - replacing <release_name> with the name of your Helm release for cert-manager (usually this is cert-manager ) and replacing <version> with the version number you want to install. Add the Jetstack Helm repository (if you haven't already) and update it. helm repo add jetstack https://charts.jetstack.io helm repo update jetstack The helm upgrade command will upgrade cert-manager to the specified or latest version of cert-manager, as listed on the cert-manager Helm chart documentation page . Note: You can find out your release name using helm list | grep cert-manager . CRDs managed separately \u00b6 If you have installed the CRDs separately (instead of with the --set installCRDs=true option added to your Helm install command), you should upgrade your CRD resources first: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/<version>/cert-manager.crds.yaml And then upgrade the Helm chart: helm upgrade --version <version> <release_name> jetstack/cert-manager CRDs managed using helm \u00b6 If you have installed the CRDs together with the helm install command, you should include CRD resources when upgrading the Helm chart: helm upgrade --set installCRDs = true --version <version> <release_name> jetstack/cert-manager Upgrading using static manifests \u00b6 If you installed cert-manager using the static deployment manifests published on each release, you can upgrade them in a similar way to how you first installed them. Note: Before upgrading, please read the relevant instructions at the links below Note: for your from and to version. Once you have read the relevant notes and taken any appropriate actions, you can begin the upgrade process like so - replacing <version> with the version number you want to install: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/<version>/cert-manager.yaml Once you have deployed the new version of cert-manager, you can verify the installation. Reinstalling cert-manager \u00b6 In some cases there may be a need to do a full uninstall and re-install of cert-manager. An example could be when a very old cert-manager version needs to be brought up to date and it isn't feasible to upgrade one minor version at a time, which is our default recommended upgrade strategy. If cert-manager CustomResourceDefinition s are also uninstalled, this will mean loss of associated cert-manager custom resources such as Certificate s. The main concern associated with this is application downtime and unnecessary certificate reissuance, that could happen if Secret s with the X.509 certificates get deleted. You can use --enable-certificate-owner-ref flag on the cert-manager controller to configure whether the Secret s should be deleted. If this flag is set to true, each Secret will have an owner reference to the Certificate for which it was created and when the Certificate is deleted, the Secret will be garbage collected. The default value for this flag is false. If the Certificate s get deleted and re-applied, but the Secret s remain in the cluster, the newly applied Certificate s should be able to pick up the same Secret s and should not unnecessarily reissue the X.509 certs. When uninstalling and re-installing in order to upgrade, you should still read through the release notes for each skipped version. Some things to look out for when considering uninstalling and re-installing cert-manager including the CRDs : Is --enable-certificate-owner-ref flag currently set to true or could it have been set to true at some point previously? Due to an earlier bug, the owner reference that gets added to Secret s is not removed when the value of --enable-certificate-owner-ref is changed from true to false, see cert-manager#4788 Are there currently any certificate issuances in progress? If so, with the custom resources deleted, the progress will be lost. This could potentially cause duplicated issuances. Is there a need to convert cert-manager custom resource manifests to v1 API? You can use cmctl convert command to do that.","title":"Upgrading"},{"location":"installation/upgrading/#upgrading-with-helm","text":"If you installed cert-manager using Helm, you can easily upgrade using the Helm CLI. Note: Before upgrading, please read the relevant instructions at the links below for your from and to version. Once you have read the relevant upgrading notes and taken any appropriate actions, you can begin the upgrade process like so - replacing <release_name> with the name of your Helm release for cert-manager (usually this is cert-manager ) and replacing <version> with the version number you want to install. Add the Jetstack Helm repository (if you haven't already) and update it. helm repo add jetstack https://charts.jetstack.io helm repo update jetstack The helm upgrade command will upgrade cert-manager to the specified or latest version of cert-manager, as listed on the cert-manager Helm chart documentation page . Note: You can find out your release name using helm list | grep cert-manager .","title":"Upgrading with Helm"},{"location":"installation/upgrading/#crds-managed-separately","text":"If you have installed the CRDs separately (instead of with the --set installCRDs=true option added to your Helm install command), you should upgrade your CRD resources first: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/<version>/cert-manager.crds.yaml And then upgrade the Helm chart: helm upgrade --version <version> <release_name> jetstack/cert-manager","title":"CRDs managed separately"},{"location":"installation/upgrading/#crds-managed-using-helm","text":"If you have installed the CRDs together with the helm install command, you should include CRD resources when upgrading the Helm chart: helm upgrade --set installCRDs = true --version <version> <release_name> jetstack/cert-manager","title":"CRDs managed using helm"},{"location":"installation/upgrading/#upgrading-using-static-manifests","text":"If you installed cert-manager using the static deployment manifests published on each release, you can upgrade them in a similar way to how you first installed them. Note: Before upgrading, please read the relevant instructions at the links below Note: for your from and to version. Once you have read the relevant notes and taken any appropriate actions, you can begin the upgrade process like so - replacing <version> with the version number you want to install: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/<version>/cert-manager.yaml Once you have deployed the new version of cert-manager, you can verify the installation.","title":"Upgrading using static manifests"},{"location":"installation/upgrading/#reinstalling-cert-manager","text":"In some cases there may be a need to do a full uninstall and re-install of cert-manager. An example could be when a very old cert-manager version needs to be brought up to date and it isn't feasible to upgrade one minor version at a time, which is our default recommended upgrade strategy. If cert-manager CustomResourceDefinition s are also uninstalled, this will mean loss of associated cert-manager custom resources such as Certificate s. The main concern associated with this is application downtime and unnecessary certificate reissuance, that could happen if Secret s with the X.509 certificates get deleted. You can use --enable-certificate-owner-ref flag on the cert-manager controller to configure whether the Secret s should be deleted. If this flag is set to true, each Secret will have an owner reference to the Certificate for which it was created and when the Certificate is deleted, the Secret will be garbage collected. The default value for this flag is false. If the Certificate s get deleted and re-applied, but the Secret s remain in the cluster, the newly applied Certificate s should be able to pick up the same Secret s and should not unnecessarily reissue the X.509 certs. When uninstalling and re-installing in order to upgrade, you should still read through the release notes for each skipped version. Some things to look out for when considering uninstalling and re-installing cert-manager including the CRDs : Is --enable-certificate-owner-ref flag currently set to true or could it have been set to true at some point previously? Due to an earlier bug, the owner reference that gets added to Secret s is not removed when the value of --enable-certificate-owner-ref is changed from true to false, see cert-manager#4788 Are there currently any certificate issuances in progress? If so, with the custom resources deleted, the progress will be lost. This could potentially cause duplicated issuances. Is there a need to convert cert-manager custom resource manifests to v1 API? You can use cmctl convert command to do that.","title":"Reinstalling cert-manager"},{"location":"installation/upgrading/ingress-class-compatibility/","text":"In cert-manager v1.5.4 we made a change to the HTTP-01 code which was not backwards compatible. See Regression: HTTP-01 challenges fail with Istio, Traefik, ingress-gce and Azure AGIC . In v1.5.5, v1.6.2 and 1.7.1 we fixed this problem. If you have cert-manager v1.5.3 (or below) you should skip v1.5.4 and instead: upgrade to v1.5.5 then the newest version of cert-manager 1.6 and then the newest version of cert-manager 1.7 and you can ignore the rest of this document. The following notes apply to anyone upgrading from cert-manager v1.5.4, v1.6.0, v1.6.1 on Kubernetes v1.19 or later. Background \u00b6 cert-manager 1.5 was released to coincide with Kubernetes 1.22, which removed the v1beta1 Ingress API. As cert-manager creates Ingress resources to solve HTTP-01 challenges, this code path needed to be updated. In the v1beta1 spec, Ingress Class was a string annotation that was adopted by all popular Ingress controllers by convention. In the v1 spec, IngressClass is now its own resource type, and the .spec.ingressClassName field on v1 Ingresses is now a reference to that object. As the Kubernetes documentation points out, the old and new specs are not directly equivalent. During the 1.5 and 1.6 cert-manager release cycles, we discovered that ingress controllers have handled the graduation of Ingress to v1 differently. Some treat the class as an opaque string, similarly to the annotation. Some were unintentionally broken, as their default ingress class name contains characters that are disallowed in object references, e.g. ( / ). Some now require you to create an IngressClass object matching the field to work. cert-manager aims to be compatible with as many ingress controllers as possible. According to the Ingress v1 Kubernetes enhancement proposal , the deprecated annotation, if present, takes precedence over the new field. From our perspective, the option that maintains the highest compatibility is to only use the annotation, even when creating v1 Ingresses. Notes For Specific Ingress Controllers \u00b6 ingress-nginx \u00b6 If you chose not to use the IngressClass nginx that is created by default by the Helm chart (e.g., you named the IngressClass nginx-outside ), you will need to add the flags --ingress-class and --ingress-class-by-name to your ingress-nginx deployment: --ingress-class=nginx-outside --ingress-class-by-name=true In case you are using the Helm chart, you will need to use at least these values: ingressClassResource : name : nginx-outside controllerValue : k8s.io/ingress-nginx-outside ingressClassByName : true ingressClass : nginx-outside Istio \u00b6 If you are using Istio and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6 and you chose to create an IngressClass that isn't named istio (e.g., you named it istio-internal ), you will need to change the class field on those Issuers back to istio . Traefik \u00b6 If you are using Traefik and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6 and the IngressClass you created isn't named traefik (for example, you called the IngressClass traefik-external ), you will need to add a command-line argument to your Traefik deployment: --providers.kubernetesingress.ingressclass=traefik-external Ambassador \u00b6 If you are using Ambassador and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6, and the IngressClass you created isn't named ambassador (e.g., ambassador-internal ), you will need to change the class field on the affected Issuers back to ambassador .","title":"Notes on Ingress Class Compatibility"},{"location":"installation/upgrading/ingress-class-compatibility/#background","text":"cert-manager 1.5 was released to coincide with Kubernetes 1.22, which removed the v1beta1 Ingress API. As cert-manager creates Ingress resources to solve HTTP-01 challenges, this code path needed to be updated. In the v1beta1 spec, Ingress Class was a string annotation that was adopted by all popular Ingress controllers by convention. In the v1 spec, IngressClass is now its own resource type, and the .spec.ingressClassName field on v1 Ingresses is now a reference to that object. As the Kubernetes documentation points out, the old and new specs are not directly equivalent. During the 1.5 and 1.6 cert-manager release cycles, we discovered that ingress controllers have handled the graduation of Ingress to v1 differently. Some treat the class as an opaque string, similarly to the annotation. Some were unintentionally broken, as their default ingress class name contains characters that are disallowed in object references, e.g. ( / ). Some now require you to create an IngressClass object matching the field to work. cert-manager aims to be compatible with as many ingress controllers as possible. According to the Ingress v1 Kubernetes enhancement proposal , the deprecated annotation, if present, takes precedence over the new field. From our perspective, the option that maintains the highest compatibility is to only use the annotation, even when creating v1 Ingresses.","title":"Background"},{"location":"installation/upgrading/ingress-class-compatibility/#notes-for-specific-ingress-controllers","text":"","title":"Notes For Specific Ingress Controllers"},{"location":"installation/upgrading/ingress-class-compatibility/#ingress-nginx","text":"If you chose not to use the IngressClass nginx that is created by default by the Helm chart (e.g., you named the IngressClass nginx-outside ), you will need to add the flags --ingress-class and --ingress-class-by-name to your ingress-nginx deployment: --ingress-class=nginx-outside --ingress-class-by-name=true In case you are using the Helm chart, you will need to use at least these values: ingressClassResource : name : nginx-outside controllerValue : k8s.io/ingress-nginx-outside ingressClassByName : true ingressClass : nginx-outside","title":"ingress-nginx"},{"location":"installation/upgrading/ingress-class-compatibility/#istio","text":"If you are using Istio and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6 and you chose to create an IngressClass that isn't named istio (e.g., you named it istio-internal ), you will need to change the class field on those Issuers back to istio .","title":"Istio"},{"location":"installation/upgrading/ingress-class-compatibility/#traefik","text":"If you are using Traefik and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6 and the IngressClass you created isn't named traefik (for example, you called the IngressClass traefik-external ), you will need to add a command-line argument to your Traefik deployment: --providers.kubernetesingress.ingressclass=traefik-external","title":"Traefik"},{"location":"installation/upgrading/ingress-class-compatibility/#ambassador","text":"If you are using Ambassador and you had to create an IngressClass while migrating to cert-manager 1.5 or 1.6, and the IngressClass you created isn't named ambassador (e.g., ambassador-internal ), you will need to change the class field on the affected Issuers back to ambassador .","title":"Ambassador"},{"location":"installation/upgrading/remove-deprecated-apis/","text":"The following cert-manager APIs were deprecated in cert-manager v1.4 : cert-manager.io/v1alpha2 cert-manager.io/v1alpha3 cert-manager.io/v1beta1 acme.cert-manager.io/v1alpha2 acme.cert-manager.io/v1alpha3 acme.cert-manager.io/v1beta1 These APIs are no longer served in cert-manager 1.6 and are fully removed in cert-manager 1.7. If you have a cert-manager installation that is using or has previously used these deprecated APIs you might need to upgrade your cert-manager custom resources and CRDs. This should be done before upgrading to cert-manager 1.6 or later. An earlier version of this document listed a number of kubectl commands to run to migrate resources. These steps have now been encoded in [`cmctl upgrade migrate-api-version` command](../../reference/cmctl.md#migrate-api-version). If you have already run the kubectl commands, your resources should have been migrated and there should be no need to also run the `cmctl` command. However, if you are not sure, you can still run the `cmctl` command as well- it will be a no-op if no actions are needed. Upgrading existing cert-manager resources \u00b6 Familiarize yourself with the official Kubernetes documentation on CRD versioning. Make sure your cert-manager deployment is currently at version v1.0 or later. Make sure that any cert-manager custom resource manifests that refer to the deprecated APIs are updated to use the cert-manager.io/v1 API and re-applied. You can use the cmctl convert command to convert manifests. Run the command cmctl upgrade migrate-api-version . It automates the steps described in Upgrade existing objects to a new stored version .","title":"Migrating Deprecated API Resources"},{"location":"installation/upgrading/remove-deprecated-apis/#upgrading-existing-cert-manager-resources","text":"Familiarize yourself with the official Kubernetes documentation on CRD versioning. Make sure your cert-manager deployment is currently at version v1.0 or later. Make sure that any cert-manager custom resource manifests that refer to the deprecated APIs are updated to use the cert-manager.io/v1 API and re-applied. You can use the cmctl convert command to convert manifests. Run the command cmctl upgrade migrate-api-version . It automates the steps described in Upgrade existing objects to a new stored version .","title":"Upgrading existing cert-manager resources"},{"location":"installation/upgrading/upgrading-0.10-0.11/","text":"The v0.11 release marks the removal of the v1alpha1 API that was used in previous versions of cert-manager, as well as our API group changing to be cert-manager.io instead of certmanager.k8s.io . We have also removed support for the old configuration format that was deprecated in the v0.8 release. This means you must transition to using the new solvers style configuration format for your ACME issuers before upgrading to v0.11 . For more information, see the upgrading to v0.8 guide. This makes for a fairly significant breaking change for users, as all cert-manager resources, or even Ingresses that reference cert-manager resources, will need to be updated to reflect these changes. This upgrade should be performed in a few steps: Back up existing cert-manager resources, as per the backup and restore guide . Uninstall cert-manager . Ensure the old cert-manager CRD resources have also been deleted: kubectl get crd | grep certmanager.k8s.io Update the apiVersion on all your backed up resources from certmanager.k8s.io/v1alpha1 to cert-manager.io/v1alpha2 . Re-install cert-manager from scratch according to the installation guide . You must be sure to properly backup , uninstall , re-install and restore your installation in order to ensure the upgrade is successful. Additional annotation changes \u00b6 As well as changing the API group used by our CRDs, we have also changed the annotation-based configuration key to also reflect the new API group. This means that if you use any cert-manager annotations on any of your other resources (such as Ingresses, {Validating,Mutating}WebhookConfiguration , etc) you will need to update them to reflect the new API group. A full table of annotations, including the old and new equivalents: Old Annotation New Annotation certmanager.k8s.io/acme-http01-edit-in-place acme.cert-manager.io/http01-edit-in-place certmanager.k8s.io/acme-http01-ingress-class acme.cert-manager.io/http01-ingress-class certmanager.k8s.io/issuer cert-manager.io/issuer certmanager.k8s.io/cluster-issuer cert-manager.io/cluster-issuer certmanager.k8s.io/acme-challenge-type DEPRECATED certmanager.k8s.io/acme-dns01-provider DEPRECATED certmanager.k8s.io/alt-names cert-manager.io/alt-names certmanager.k8s.io/ip-sans cert-manager.io/ip-sans certmanager.k8s.io/common-name cert-manager.io/common-name certmanager.k8s.io/issuer-name cert-manager.io/issuer-name certmanager.k8s.io/issuer-kind cert-manager.io/issuer-kind You can use the following bash magic to print a list of Ingress resources that still contain an old annotation: $ kubectl get ingress \\ --all-namespaces \\ -o json | \\ jq '.items[] | select(.metadata.annotations| to_entries | map(.key)[] | test(\"certmanager\")) | \"Ingress resource \\(.metadata.namespace)/\\(.metadata.name) contains old annotations: (\\( .metadata.annotations | to_entries | map(.key)[] | select( . | test(\"certmanager\") ) ))\"' Ingress resource \"demo/testcrt contains old annotations: (certmanager.k8s.io/cluster-issuer)\" Ingress resource \"example/ingress-resource contains old annotations: (certmanager.k8s.io/cluster-issuer)\" In order to help with this migration, the following CLI tool will automatically migrate these annotations for you. Note that it will not make any changes to your cluster for you. Firstly, download the binary for your given platform $ wget -O api-migration https://github.com/cert-manager/cert-manager/releases/download/v0.11.0/api-migration-linux Or for Darwin $ wget -O api-migration https://github.com/cert-manager/cert-manager/releases/download/v0.11.0/api-migration-darwin Mark the binary as executable and run the binary against your cluster $ chmod +x api-migration && ./api-migration --kubeconfig /path/to/my/kubeconfig.yaml Follow the CLI output and check for the difference that has been made in files $ diff ingress.yaml ingress-migrated.yaml Finally, once the new ingress resources have been reviewed, apply the manifests $ kubectl apply -f ingress-migrated.yaml --kubeconfig /path/to/my/kubeconfig.yaml You should make sure to update all Ingress resources to ensure that your certificates continue to be kept up to date. Issuer/ClusterIssuer solvers \u00b6 Support for the deprecated spec.http01 or spec.dns01 fields in Issuer and ClusterIssuer have been removed. Any Issuer or ClusterIssuer objects must be converted to use the equivalent spec.solvers[].http01 or spec.solvers[].dns01 syntax. You can read more about the Issuer resource in the configuration documentation . Any issuers that haven't been converted will result the cert-manager pod being unable to find any solvers at the expected location. This will result in errors like the following: no configured challenge solvers can be used for this challenge","title":"Upgrading from v0.10 to v0.11"},{"location":"installation/upgrading/upgrading-0.10-0.11/#additional-annotation-changes","text":"As well as changing the API group used by our CRDs, we have also changed the annotation-based configuration key to also reflect the new API group. This means that if you use any cert-manager annotations on any of your other resources (such as Ingresses, {Validating,Mutating}WebhookConfiguration , etc) you will need to update them to reflect the new API group. A full table of annotations, including the old and new equivalents: Old Annotation New Annotation certmanager.k8s.io/acme-http01-edit-in-place acme.cert-manager.io/http01-edit-in-place certmanager.k8s.io/acme-http01-ingress-class acme.cert-manager.io/http01-ingress-class certmanager.k8s.io/issuer cert-manager.io/issuer certmanager.k8s.io/cluster-issuer cert-manager.io/cluster-issuer certmanager.k8s.io/acme-challenge-type DEPRECATED certmanager.k8s.io/acme-dns01-provider DEPRECATED certmanager.k8s.io/alt-names cert-manager.io/alt-names certmanager.k8s.io/ip-sans cert-manager.io/ip-sans certmanager.k8s.io/common-name cert-manager.io/common-name certmanager.k8s.io/issuer-name cert-manager.io/issuer-name certmanager.k8s.io/issuer-kind cert-manager.io/issuer-kind You can use the following bash magic to print a list of Ingress resources that still contain an old annotation: $ kubectl get ingress \\ --all-namespaces \\ -o json | \\ jq '.items[] | select(.metadata.annotations| to_entries | map(.key)[] | test(\"certmanager\")) | \"Ingress resource \\(.metadata.namespace)/\\(.metadata.name) contains old annotations: (\\( .metadata.annotations | to_entries | map(.key)[] | select( . | test(\"certmanager\") ) ))\"' Ingress resource \"demo/testcrt contains old annotations: (certmanager.k8s.io/cluster-issuer)\" Ingress resource \"example/ingress-resource contains old annotations: (certmanager.k8s.io/cluster-issuer)\" In order to help with this migration, the following CLI tool will automatically migrate these annotations for you. Note that it will not make any changes to your cluster for you. Firstly, download the binary for your given platform $ wget -O api-migration https://github.com/cert-manager/cert-manager/releases/download/v0.11.0/api-migration-linux Or for Darwin $ wget -O api-migration https://github.com/cert-manager/cert-manager/releases/download/v0.11.0/api-migration-darwin Mark the binary as executable and run the binary against your cluster $ chmod +x api-migration && ./api-migration --kubeconfig /path/to/my/kubeconfig.yaml Follow the CLI output and check for the difference that has been made in files $ diff ingress.yaml ingress-migrated.yaml Finally, once the new ingress resources have been reviewed, apply the manifests $ kubectl apply -f ingress-migrated.yaml --kubeconfig /path/to/my/kubeconfig.yaml You should make sure to update all Ingress resources to ensure that your certificates continue to be kept up to date.","title":"Additional annotation changes"},{"location":"installation/upgrading/upgrading-0.10-0.11/#issuerclusterissuer-solvers","text":"Support for the deprecated spec.http01 or spec.dns01 fields in Issuer and ClusterIssuer have been removed. Any Issuer or ClusterIssuer objects must be converted to use the equivalent spec.solvers[].http01 or spec.solvers[].dns01 syntax. You can read more about the Issuer resource in the configuration documentation . Any issuers that haven't been converted will result the cert-manager pod being unable to find any solvers at the expected location. This will result in errors like the following: no configured challenge solvers can be used for this challenge","title":"Issuer/ClusterIssuer solvers"},{"location":"installation/upgrading/upgrading-0.11-0.12/","text":"The focus of this release has been on stability and bug fixes, as well as overhauling and improving the documentation website. As such, there has been minimal changes that effect end users bar two changes which require action when upgrading. After addressing the following points, you should then follow the standard upgrade process here . Changes to the Vault Kubernetes Auth Mount Path \u00b6 If you are using Kubernetes authentication for Vault Issuers then there has been a change to the required mount path. This value now requires the entire mount path. For example, if the previous path had been set to kubernetes , the new path will now require /v1/auth/kubernetes . You can read why this change was made here . Removal of the Webhook API service \u00b6 The Webhook component now no longer makes use of a Kubernetes APIService , and as such, should be removed. This action is only required if you have installed cert-manager using static manifests. The following command will delete the service and can be done before or after applying the upgrade. $ kubectl delete apiservice v1beta1.webhook.cert-manager.io","title":"Upgrading from v0.11 to v0.12"},{"location":"installation/upgrading/upgrading-0.11-0.12/#changes-to-the-vault-kubernetes-auth-mount-path","text":"If you are using Kubernetes authentication for Vault Issuers then there has been a change to the required mount path. This value now requires the entire mount path. For example, if the previous path had been set to kubernetes , the new path will now require /v1/auth/kubernetes . You can read why this change was made here .","title":"Changes to the Vault Kubernetes Auth Mount Path"},{"location":"installation/upgrading/upgrading-0.11-0.12/#removal-of-the-webhook-api-service","text":"The Webhook component now no longer makes use of a Kubernetes APIService , and as such, should be removed. This action is only required if you have installed cert-manager using static manifests. The following command will delete the service and can be done before or after applying the upgrade. $ kubectl delete apiservice v1beta1.webhook.cert-manager.io","title":"Removal of the Webhook API service"},{"location":"installation/upgrading/upgrading-0.12-0.13/","text":"When upgrading from v0.12 to v0.13 , no special upgrade steps are required. Follow the regular upgrade process here .","title":"Upgrading from v0.12 to v0.13"},{"location":"installation/upgrading/upgrading-0.13-0.14/","text":"Due to changes in the Deployment selector you will need to remove the deployments first before being able to upgrade. You should run the following before upgrading: $ kubectl delete -n cert-manager deployment cert-manager cert-manager-cainjector cert-manager-webhook If you're using Helm to install cert-manager with a deployment name different than cert-manager you might need to change the deployment names in the command above. This will delete the deployment so they can be replaced when you apply the upgrade. This step will not affect any existing certificates but will stop renewal or new issuance while upgrading. Version v0.14 now comes in 2 versions of static manifests, you will need to use the correct new one: Kubernetes 1.15 or higher: you can use the normal cert-manager.yaml Kubernetes 1.14 or lower: you have to now use the cert-manager-legacy.yaml version OpenShift 4: you can now use the normal cert-manager.yaml OpenShift 3: you have to now use the cert-manager-legacy.yaml version instead of the OpenShift version Note : If you're using the cert-manager-legacy.yaml version you will not have API version conversion and thus only support cert-manager.io/v1alpha2 API resources. The webhook is now a required component, meaning that no-webhook variant of the manifests are no longer available in this release. Please use the appropriate manifests as mentioned above according to your Kubernetes version. From here on you can follow the regular upgrade process .","title":"Upgrading from v0.13 to v0.14"},{"location":"installation/upgrading/upgrading-0.14-0.15/","text":"New installCRDs addition \u00b6 If you're using Helm to install cert-manager you now have the option installCRDs . This will let Helm install CRDs like other cluster resources. If you deployed cert-manager before do NOT use this option as it does not support upgrading from manually installed CRDs. Note : If enabled, when uninstalling, CRD resources will be deleted causing all installed custom resources to be DELETED. Removal of 00-crds.yaml file \u00b6 As part of changes to the way we publish release artifacts, the 00-crds.yaml file is no longer made available as part of our repository. You can now find the appropriate version of the CRD resources to install attached to the GitHub release. You will need to select the appropriate 'legacy' or full manifest variant depending on the Kubernetes or OpenShift version you are running. From here on you can follow the regular upgrade process .","title":"Upgrading from v0.14 to v0.15"},{"location":"installation/upgrading/upgrading-0.14-0.15/#new-installcrds-addition","text":"If you're using Helm to install cert-manager you now have the option installCRDs . This will let Helm install CRDs like other cluster resources. If you deployed cert-manager before do NOT use this option as it does not support upgrading from manually installed CRDs. Note : If enabled, when uninstalling, CRD resources will be deleted causing all installed custom resources to be DELETED.","title":"New installCRDs addition"},{"location":"installation/upgrading/upgrading-0.14-0.15/#removal-of-00-crdsyaml-file","text":"As part of changes to the way we publish release artifacts, the 00-crds.yaml file is no longer made available as part of our repository. You can now find the appropriate version of the CRD resources to install attached to the GitHub release. You will need to select the appropriate 'legacy' or full manifest variant depending on the Kubernetes or OpenShift version you are running. From here on you can follow the regular upgrade process .","title":"Removal of 00-crds.yaml file"},{"location":"installation/upgrading/upgrading-0.15-0.16/","text":"Issue with older versions of kubectl \u00b6 kubectl versions with patch versions lower than v1.18.8 v1.17.11 or v1.16.14 have issues updating the v0.16 CRD files, due to a bug when handling deeply nested CRDs . This bug will make kubectl apply -f [...] hang. This bug only happens during a re-apply of the v0.16 CRDs. Initial upgrade does not cause issues. If you have this issue please upgrade your kubectl to the latest patch release. Versions of kubectl of v1.15.x or below are not being supported anymore as these are unsupported by the Kubernetes community. Helm \u00b6 Helm users who use installCRDs=true MUST upgrade to Helm v3.3.1 before upgrading. From here on you can follow the regular upgrade process .","title":"Upgrading from v0.15 to v0.16"},{"location":"installation/upgrading/upgrading-0.15-0.16/#issue-with-older-versions-of-kubectl","text":"kubectl versions with patch versions lower than v1.18.8 v1.17.11 or v1.16.14 have issues updating the v0.16 CRD files, due to a bug when handling deeply nested CRDs . This bug will make kubectl apply -f [...] hang. This bug only happens during a re-apply of the v0.16 CRDs. Initial upgrade does not cause issues. If you have this issue please upgrade your kubectl to the latest patch release. Versions of kubectl of v1.15.x or below are not being supported anymore as these are unsupported by the Kubernetes community.","title":"Issue with older versions of kubectl"},{"location":"installation/upgrading/upgrading-0.15-0.16/#helm","text":"Helm users who use installCRDs=true MUST upgrade to Helm v3.3.1 before upgrading. From here on you can follow the regular upgrade process .","title":"Helm"},{"location":"installation/upgrading/upgrading-0.16-1.0/","text":"The upgrade process for upgrading to v1.0 is very Kubernetes version specific. Please check the version of your cluster using kubectl version and follow the steps required for your version of Kubernetes. Issue with older versions of kubectl \u00b6 kubectl versions with patch versions lower than v1.18.8 v1.17.11 or v1.16.14 have issues updating from the v0.16 CRD files, due to a bug when handling deeply nested CRDs . This bug will make kubectl apply -f [...] hang. This bug only happens during a re-apply of the v0.16 CRDs or upgrading from it. Upgrades from lower versions do not cause issues. If you have this issue please upgrade your kubectl to the latest patch release. Versions of kubectl of v1.15.x or below are not being supported anymore as these are unsupported by the Kubernetes community. Helm \u00b6 Helm users who use installCRDs=true MUST upgrade to Helm v3.3.1 or later before upgrading. Upgrade instructions per Kubernetes version \u00b6 Kubernetes 1.16 and above \u00b6 These are the upgrade instructions to upgrade from cert-manager v0.14.0 or higher, please consult other upgrade guides first before upgrading to v1.0 if you run an older version of cert-manager. No special requirements, you can follow the regular upgrade process . Kubernetes 1.15.x \u00b6 cert-manager now uses apiextensions.k8s.io/v1 to install CRDs inside Kubernetes. This got added in Kubernetes 1.16 . Our legacy installation will still be using apiextensions.k8s.io/v1beta1 . For this reason Kubernetes 1.15 users now need to install the legacy version of the cert-manager manifests. You can follow the instructions of \"Kubernetes 1.14\" below on how to upgrade to the legacy version of v1.0 . Note : The legacy version only supports a single CRD version. We advise you to consider upgrading to Kubernetes 1.16 or above for an easier migration. Kubernetes 1.14 and below \u00b6 These are the upgrade instructions to upgrade from cert-manager v0.11.0 or higher, please consult other upgrade guides first before upgrading to v1.0 if you run an older version of cert-manager. Note : Due to the lack of support for conversion webhooks in your Kubernetes version this will not be an easy migration. We advise you to consider upgrading to Kubernetes 1.16 or higher before upgrading. Upgrading your Kubernetes cluster might be easier than upgrading cert-manager. We have released our cert-manager.io/v1 API that replaces cert-manager.io/v1alpha2 . Since the legacy version for Kubernetes 1.15 and below only supports one CRD version you have to transition all resources to cert-manager.io/v1 . This makes for a fairly significant breaking change for users, as all cert-manager resources will need to be updated to reflect these changes. Ingress annotations will stay the same, this means if you only use ingress-shim you do not have to convert these resources over but it is recommended. However you should convert the (Cluster)Issuers and delete the old CRD versions. This upgrade MUST be performed in the following sequence of steps: Back up existing cert-manager resources. See the backup section. Uninstall cert-manager . Update the apiVersion on all your backed up resources from cert-manager.io/v1alpha2 to cert-manager.io/v1 . See the converting section for that. Ensure the old cert-manager CRD resources have also been deleted: kubectl get crd | grep cert-manager.io Re-install cert-manager v1.0 from scratch according to the installation guide . Apply the backed up resources again. You must be sure to properly backup , uninstall , re-install and restore your installation in order to ensure the upgrade is successful. Backing up resources \u00b6 You can backup the custom resources you or cert-manager created using the following kubectl command: kubectl get -o yaml \\ --all-namespaces \\ issuer,clusterissuer,certificates,certificaterequests > cert-manager-backup.yaml Note that this will not export private keys or secrets. Converting resources \u00b6 You can use our kubectl plugin to automatically convert your backup from v1alpha2 to v1 using the following command: kubectl cert-manager convert --output-version cert-manager.io/v1 -f cert-manager-backup.yaml > cert-manager-v1.yaml Tip: you can use kubectl apply --dry-run on a local/test cluster with cert-manager v1.0 installed to validate your conversion Uninstall cert-manager \u00b6 Next step is to uninstall cert-manager. This will cause a temporary halt to renewal of certificates but will not affect any TLS traffic. How you do this depends on how you installed cert-manager. Using Helm: $ helm --namespace cert-manager delete cert-manager Using kubectl : kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.yaml Make sure you also delete the CRDs. This will delete all cert-manager resources, so make sure your backup is complete. You can do this manually by executing the following commands: kubectl delete crd certificaterequests.cert-manager.io kubectl delete crd certificates.cert-manager.io kubectl delete crd challenges.acme.cert-manager.io kubectl delete crd clusterissuers.cert-manager.io kubectl delete crd issuers.cert-manager.io kubectl delete crd orders.acme.cert-manager.io For more info see the uninstall cert-manager guide . Reinstall and restore \u00b6 To install cert-manager again you can follow the normal installation guide . Once it has been fully installed you can re-apply the converted resources: kubectl apply -f cert-manager-v1.yaml Congratulations you're now fully upgraded to cert-manager v1.0","title":"Upgrading from v0.16 to v1.0"},{"location":"installation/upgrading/upgrading-0.16-1.0/#issue-with-older-versions-of-kubectl","text":"kubectl versions with patch versions lower than v1.18.8 v1.17.11 or v1.16.14 have issues updating from the v0.16 CRD files, due to a bug when handling deeply nested CRDs . This bug will make kubectl apply -f [...] hang. This bug only happens during a re-apply of the v0.16 CRDs or upgrading from it. Upgrades from lower versions do not cause issues. If you have this issue please upgrade your kubectl to the latest patch release. Versions of kubectl of v1.15.x or below are not being supported anymore as these are unsupported by the Kubernetes community.","title":"Issue with older versions of kubectl"},{"location":"installation/upgrading/upgrading-0.16-1.0/#helm","text":"Helm users who use installCRDs=true MUST upgrade to Helm v3.3.1 or later before upgrading.","title":"Helm"},{"location":"installation/upgrading/upgrading-0.16-1.0/#upgrade-instructions-per-kubernetes-version","text":"","title":"Upgrade instructions per Kubernetes version"},{"location":"installation/upgrading/upgrading-0.16-1.0/#kubernetes-116-and-above","text":"These are the upgrade instructions to upgrade from cert-manager v0.14.0 or higher, please consult other upgrade guides first before upgrading to v1.0 if you run an older version of cert-manager. No special requirements, you can follow the regular upgrade process .","title":"Kubernetes 1.16 and above"},{"location":"installation/upgrading/upgrading-0.16-1.0/#kubernetes-115x","text":"cert-manager now uses apiextensions.k8s.io/v1 to install CRDs inside Kubernetes. This got added in Kubernetes 1.16 . Our legacy installation will still be using apiextensions.k8s.io/v1beta1 . For this reason Kubernetes 1.15 users now need to install the legacy version of the cert-manager manifests. You can follow the instructions of \"Kubernetes 1.14\" below on how to upgrade to the legacy version of v1.0 . Note : The legacy version only supports a single CRD version. We advise you to consider upgrading to Kubernetes 1.16 or above for an easier migration.","title":"Kubernetes 1.15.x"},{"location":"installation/upgrading/upgrading-0.16-1.0/#kubernetes-114-and-below","text":"These are the upgrade instructions to upgrade from cert-manager v0.11.0 or higher, please consult other upgrade guides first before upgrading to v1.0 if you run an older version of cert-manager. Note : Due to the lack of support for conversion webhooks in your Kubernetes version this will not be an easy migration. We advise you to consider upgrading to Kubernetes 1.16 or higher before upgrading. Upgrading your Kubernetes cluster might be easier than upgrading cert-manager. We have released our cert-manager.io/v1 API that replaces cert-manager.io/v1alpha2 . Since the legacy version for Kubernetes 1.15 and below only supports one CRD version you have to transition all resources to cert-manager.io/v1 . This makes for a fairly significant breaking change for users, as all cert-manager resources will need to be updated to reflect these changes. Ingress annotations will stay the same, this means if you only use ingress-shim you do not have to convert these resources over but it is recommended. However you should convert the (Cluster)Issuers and delete the old CRD versions. This upgrade MUST be performed in the following sequence of steps: Back up existing cert-manager resources. See the backup section. Uninstall cert-manager . Update the apiVersion on all your backed up resources from cert-manager.io/v1alpha2 to cert-manager.io/v1 . See the converting section for that. Ensure the old cert-manager CRD resources have also been deleted: kubectl get crd | grep cert-manager.io Re-install cert-manager v1.0 from scratch according to the installation guide . Apply the backed up resources again. You must be sure to properly backup , uninstall , re-install and restore your installation in order to ensure the upgrade is successful.","title":"Kubernetes 1.14 and below"},{"location":"installation/upgrading/upgrading-0.16-1.0/#backing-up-resources","text":"You can backup the custom resources you or cert-manager created using the following kubectl command: kubectl get -o yaml \\ --all-namespaces \\ issuer,clusterissuer,certificates,certificaterequests > cert-manager-backup.yaml Note that this will not export private keys or secrets.","title":"Backing up resources"},{"location":"installation/upgrading/upgrading-0.16-1.0/#converting-resources","text":"You can use our kubectl plugin to automatically convert your backup from v1alpha2 to v1 using the following command: kubectl cert-manager convert --output-version cert-manager.io/v1 -f cert-manager-backup.yaml > cert-manager-v1.yaml Tip: you can use kubectl apply --dry-run on a local/test cluster with cert-manager v1.0 installed to validate your conversion","title":"Converting resources"},{"location":"installation/upgrading/upgrading-0.16-1.0/#uninstall-cert-manager","text":"Next step is to uninstall cert-manager. This will cause a temporary halt to renewal of certificates but will not affect any TLS traffic. How you do this depends on how you installed cert-manager. Using Helm: $ helm --namespace cert-manager delete cert-manager Using kubectl : kubectl delete -f https://github.com/cert-manager/cert-manager/releases/download/vX.Y.Z/cert-manager.yaml Make sure you also delete the CRDs. This will delete all cert-manager resources, so make sure your backup is complete. You can do this manually by executing the following commands: kubectl delete crd certificaterequests.cert-manager.io kubectl delete crd certificates.cert-manager.io kubectl delete crd challenges.acme.cert-manager.io kubectl delete crd clusterissuers.cert-manager.io kubectl delete crd issuers.cert-manager.io kubectl delete crd orders.acme.cert-manager.io For more info see the uninstall cert-manager guide .","title":"Uninstall cert-manager"},{"location":"installation/upgrading/upgrading-0.16-1.0/#reinstall-and-restore","text":"To install cert-manager again you can follow the normal installation guide . Once it has been fully installed you can re-apply the converted resources: kubectl apply -f cert-manager-v1.yaml Congratulations you're now fully upgraded to cert-manager v1.0","title":"Reinstall and restore"},{"location":"installation/upgrading/upgrading-0.2-0.3/","text":"During the v0.3 release, a number of breaking changes were made that require you to update either deployment configuration and runtime configuration (e.g. Certificate , Issuer and ClusterIssuer resources). After reading these instructions, you should then proceed to upgrade cert-manager according to your deployment configuration (e.g. using helm upgrade if installing via Helm chart, or kubectl apply if installing with raw manifests). A brief summary: Supporting resources for ClusterIssuers (e.g. signing CA certificates, or ACME account private keys) will now be stored in the same namespace as cert-manager, instead of kube-system in previous versions ( #329 , @munnerz ) Switch to ConfigMaps instead of Endpoints for leader election ( #327 , @mikebryant ) Removing support for ACMEv1 in favor of ACMEv2 ( #309 , @munnerz ) Removing ingress-shim and compiling it into cert-manager itself ( #502 , @munnerz ) Change to the default behavior of ingress-shim. It now generates Certificates with the ingressClass field set instead of the ingress field. This will mean users of ingress controllers that assign a single IP to a single Ingress (e.g. the GCE ingress controller) will no longer work without adding a new annotation to your ingress resource. Supporting resources for ClusterIssuers moving into the cert-manager namespace \u00b6 In the past, the cert-manager controller was hard coded to look for supplemental resources, such as Secrets containing DNS provider credentials, in the kube-system namespace. We now store these resources in the same namespace as the cert-manager pod itself runs within. When upgrading, you should make sure to move any of these supplemental resources into the cert-manager deployment namespace, or otherwise deploy cert-manager into kube-system itself. You can also change the 'cluster resource namespace' when deploying cert-manager: With the helm chart: --set clusterResourceNamespace=kube-system . Or if using the static deployment manifests, by adding the --cluster-resource-namespace flag to the args field of the cert-manager container. Switch to ConfigMaps instead of Endpoints for leader election \u00b6 cert-manager-controller performs leader election to allow you to run 'hot standby' replicas of cert-manager. In the past, we used Endpoint resources to perform this election. The new best practice is to use ConfigMap resources in order to reduce API overhead in large clusters. As such, v0.3 switches us to use ConfigMap resources for leader election. During the upgrade, you should first scale your cert-manager-controller deployment to 0 to ensure no other replicas of cert-manager are running when the new v0.3 deployment starts: $ kubectl scale --namespace <deployment-namespace> --replicas = 0 deployment <cert-manager-deployment-name> Removing support for ACMEv1 in favor of ACMEv2 \u00b6 The ACME v2 specification is now in production with Let's Encrypt. In order to support this new spec, which includes support for wildcard certificates, we have removed support for the v1 protocol altogether. If you have any ACME Issuer or ClusterIssuer resources, you should update the server fields of these to the new ACMEv2 endpoints. For example, if you have a Let's Encrypt production issuer, you should update the server URL: apiVersion : certmanager.k8s.io/v1alpha2 kind : Issuer ... spec : acme : # server: https://acme-v01.api.letsencrypt.org/directory server : https://acme-v02.api.letsencrypt.org/directory # we switch 'v01' to 'v02' Removing ingress-shim and compiling it into cert-manager itself \u00b6 In v0.3 we removed the ingress-shim component and instead now compile in its functionality into the main cert-manager binary. This change also introduces a change to the way you configure default Issuers and ClusterIssuers at deployment time. The deployment documentation has been updated accordingly, but instead of setting ingressShim.extraArgs={--default-issuer-name=letsencrypt-pod} there are now dedicated Helm chart fields: --set ingressShim.defaultIssuerName = letsencrypt-prod \\ --set ingressShim.defaultIssuerKind = ClusterIssuer Change to the default behavior of ingress-shim \u00b6 In the past, when using ingress-shim, we set the ingress field on the Certificate resource to trigger cert-manager to edit the specified Ingress resource to solve the challenge. The alternate option is to set the ingressClass field, which causes cert-manager to create temporary Ingress resources to solve the challenge. This behavior provides better compatibility with ingress controllers like nginx-ingress . In v0.3 we have changed the default behavior of ingress-shim to set the ingressClass field instead of ingress . This will cause validations for ingress controllers like ingress-gce to fail without additional configuration in your Ingress resources annotations. Add the follow annotation to your Ingress resources if you are using the GCE ingress controller, in addition to the usual ingress-shim annotation(s):","title":"Upgrading from v0.2 to v0.3"},{"location":"installation/upgrading/upgrading-0.2-0.3/#supporting-resources-for-clusterissuers-moving-into-the-cert-manager-namespace","text":"In the past, the cert-manager controller was hard coded to look for supplemental resources, such as Secrets containing DNS provider credentials, in the kube-system namespace. We now store these resources in the same namespace as the cert-manager pod itself runs within. When upgrading, you should make sure to move any of these supplemental resources into the cert-manager deployment namespace, or otherwise deploy cert-manager into kube-system itself. You can also change the 'cluster resource namespace' when deploying cert-manager: With the helm chart: --set clusterResourceNamespace=kube-system . Or if using the static deployment manifests, by adding the --cluster-resource-namespace flag to the args field of the cert-manager container.","title":"Supporting resources for ClusterIssuers moving into the cert-manager namespace"},{"location":"installation/upgrading/upgrading-0.2-0.3/#switch-to-configmaps-instead-of-endpoints-for-leader-election","text":"cert-manager-controller performs leader election to allow you to run 'hot standby' replicas of cert-manager. In the past, we used Endpoint resources to perform this election. The new best practice is to use ConfigMap resources in order to reduce API overhead in large clusters. As such, v0.3 switches us to use ConfigMap resources for leader election. During the upgrade, you should first scale your cert-manager-controller deployment to 0 to ensure no other replicas of cert-manager are running when the new v0.3 deployment starts: $ kubectl scale --namespace <deployment-namespace> --replicas = 0 deployment <cert-manager-deployment-name>","title":"Switch to ConfigMaps instead of Endpoints for leader election"},{"location":"installation/upgrading/upgrading-0.2-0.3/#removing-support-for-acmev1-in-favor-of-acmev2","text":"The ACME v2 specification is now in production with Let's Encrypt. In order to support this new spec, which includes support for wildcard certificates, we have removed support for the v1 protocol altogether. If you have any ACME Issuer or ClusterIssuer resources, you should update the server fields of these to the new ACMEv2 endpoints. For example, if you have a Let's Encrypt production issuer, you should update the server URL: apiVersion : certmanager.k8s.io/v1alpha2 kind : Issuer ... spec : acme : # server: https://acme-v01.api.letsencrypt.org/directory server : https://acme-v02.api.letsencrypt.org/directory # we switch 'v01' to 'v02'","title":"Removing support for ACMEv1 in favor of ACMEv2"},{"location":"installation/upgrading/upgrading-0.2-0.3/#removing-ingress-shim-and-compiling-it-into-cert-manager-itself","text":"In v0.3 we removed the ingress-shim component and instead now compile in its functionality into the main cert-manager binary. This change also introduces a change to the way you configure default Issuers and ClusterIssuers at deployment time. The deployment documentation has been updated accordingly, but instead of setting ingressShim.extraArgs={--default-issuer-name=letsencrypt-pod} there are now dedicated Helm chart fields: --set ingressShim.defaultIssuerName = letsencrypt-prod \\ --set ingressShim.defaultIssuerKind = ClusterIssuer","title":"Removing ingress-shim and compiling it into cert-manager itself"},{"location":"installation/upgrading/upgrading-0.2-0.3/#change-to-the-default-behavior-of-ingress-shim","text":"In the past, when using ingress-shim, we set the ingress field on the Certificate resource to trigger cert-manager to edit the specified Ingress resource to solve the challenge. The alternate option is to set the ingressClass field, which causes cert-manager to create temporary Ingress resources to solve the challenge. This behavior provides better compatibility with ingress controllers like nginx-ingress . In v0.3 we have changed the default behavior of ingress-shim to set the ingressClass field instead of ingress . This will cause validations for ingress controllers like ingress-gce to fail without additional configuration in your Ingress resources annotations. Add the follow annotation to your Ingress resources if you are using the GCE ingress controller, in addition to the usual ingress-shim annotation(s):","title":"Change to the default behavior of ingress-shim"},{"location":"installation/upgrading/upgrading-0.3-0.4/","text":"There are no special notes or considerations when upgrading from v0.3 to v0.4 .","title":"Upgrading from v0.3 to v0.4"},{"location":"installation/upgrading/upgrading-0.4-0.5/","text":"Version 0.5 of cert-manager introduces a new 'webhook' component, which is used by the Kubernetes apiserver to validate our CRD resource types. This should help in future to reduce errors caused by misconfigured Certificate and Issuer resources. When upgrading from a previous release using Helm, it is essential that you perform one extra step before upgrading. Disabling resource validation on the cert-manager namespace \u00b6 Before upgrading, you should add the certmanager.k8s.io/disable-validation: \"true\" label to the cert-manager namespace. This will allow the system resources that cert-manager requires to bootstrap TLS to be created in its own namespace.","title":"Upgrading from v0.4 to v0.5"},{"location":"installation/upgrading/upgrading-0.4-0.5/#disabling-resource-validation-on-the-cert-manager-namespace","text":"Before upgrading, you should add the certmanager.k8s.io/disable-validation: \"true\" label to the cert-manager namespace. This will allow the system resources that cert-manager requires to bootstrap TLS to be created in its own namespace.","title":"Disabling resource validation on the cert-manager namespace"},{"location":"installation/upgrading/upgrading-0.5-0.6/","text":"Warning : If you are upgrading from a release older than v0.5 , please read the Upgrading from older versions using Helm note at the bottom of this document! The upgrade process from v0.5 to v0.6 should be fairly seamless for most users. As part of the new release, we have changed how we ship the CustomResourceDefinition resources that cert-manager needs in order to operate (as well as introducing two new CRD types). Depending on the way you have installed cert-manager in the past, your upgrade process will slightly vary: Upgrading with the Helm chart \u00b6 If you have previously deployed cert-manager v0.5 using the Helm installation method, you will now need to perform one extra step before upgrading. Due to issues with the way Helm handles CRD resources in Helm charts, we have now moved the installation of these resources into a separate YAML manifest that must be installed with kubectl apply before upgrading the chart. You can follow the regular upgrade guide as usual in order to upgrade from v0.5 to v0.6 . Upgrading with static manifests \u00b6 The static manifests have moved into the deploy/manifests directory for this release. We now also no longer ship different manifests for different configurations, in favor of a single cert-manager.yaml file which should work for all Kubernetes clusters from Kubernetes v1.9 onward. You can follow the regular upgrade guide as usual in order to upgrade from v0.5 to v0.6 . Upgrading from older versions using Helm \u00b6 If you are upgrading from a version older than v0.5 and have installed with Helm , you will need to perform a fresh installation of cert-manager due to issues with the Helm upgrade process. This will involve the removal of all cert-manager custom resources . This will not delete the Secret resources being used by your apps. Before upgrading you will need to: Read and follow the backup guide to create a backup of your configuration. Delete the existing cert-manager Helm release (replacing 'cert-manager' with the name of your Helm release): Uninstall the Helm chart. $ helm delete --purge cert-manager Ensure the cert-manager CustomResourceDefinition resources do not exist: $ kubectl delete crd \\ certificates.certmanager.k8s.io \\ issuers.certmanager.k8s.io \\ clusterissuers.certmanager.k8s.io Perform a fresh install (as per the installation guide Install the cert-manager CRDs $ kubectl apply \\ -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.6/deploy/manifests/00-crds.yaml Update helm repository cache $ helm repo update Install cert-manager $ helm install \\ --name cert-manager \\ --namespace cert-manager \\ --version v0.6.6 \\ stable/cert-manager Follow the steps in the restore guide to restore your configuration. Verify that your Issuers and Certificate resources are 'Ready': $ kubectl get clusterissuer,issuer,certificates --all-namespaces NAMESPACE NAME READY SECRET AGE cert-manager cert-manager-webhook-ca True cert-manager-webhook-ca 1m cert-manager cert-manager-webhook-webhook-tls True cert-manager-webhook-webhook-tls 1m example-com example-com-tls True example-com-tls 11s","title":"Upgrading from v0.5 to v0.6"},{"location":"installation/upgrading/upgrading-0.5-0.6/#upgrading-with-the-helm-chart","text":"If you have previously deployed cert-manager v0.5 using the Helm installation method, you will now need to perform one extra step before upgrading. Due to issues with the way Helm handles CRD resources in Helm charts, we have now moved the installation of these resources into a separate YAML manifest that must be installed with kubectl apply before upgrading the chart. You can follow the regular upgrade guide as usual in order to upgrade from v0.5 to v0.6 .","title":"Upgrading with the Helm chart"},{"location":"installation/upgrading/upgrading-0.5-0.6/#upgrading-with-static-manifests","text":"The static manifests have moved into the deploy/manifests directory for this release. We now also no longer ship different manifests for different configurations, in favor of a single cert-manager.yaml file which should work for all Kubernetes clusters from Kubernetes v1.9 onward. You can follow the regular upgrade guide as usual in order to upgrade from v0.5 to v0.6 .","title":"Upgrading with static manifests"},{"location":"installation/upgrading/upgrading-0.5-0.6/#upgrading-from-older-versions-using-helm","text":"If you are upgrading from a version older than v0.5 and have installed with Helm , you will need to perform a fresh installation of cert-manager due to issues with the Helm upgrade process. This will involve the removal of all cert-manager custom resources . This will not delete the Secret resources being used by your apps. Before upgrading you will need to: Read and follow the backup guide to create a backup of your configuration. Delete the existing cert-manager Helm release (replacing 'cert-manager' with the name of your Helm release): Uninstall the Helm chart. $ helm delete --purge cert-manager Ensure the cert-manager CustomResourceDefinition resources do not exist: $ kubectl delete crd \\ certificates.certmanager.k8s.io \\ issuers.certmanager.k8s.io \\ clusterissuers.certmanager.k8s.io Perform a fresh install (as per the installation guide Install the cert-manager CRDs $ kubectl apply \\ -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.6/deploy/manifests/00-crds.yaml Update helm repository cache $ helm repo update Install cert-manager $ helm install \\ --name cert-manager \\ --namespace cert-manager \\ --version v0.6.6 \\ stable/cert-manager Follow the steps in the restore guide to restore your configuration. Verify that your Issuers and Certificate resources are 'Ready': $ kubectl get clusterissuer,issuer,certificates --all-namespaces NAMESPACE NAME READY SECRET AGE cert-manager cert-manager-webhook-ca True cert-manager-webhook-ca 1m cert-manager cert-manager-webhook-webhook-tls True cert-manager-webhook-webhook-tls 1m example-com example-com-tls True example-com-tls 11s","title":"Upgrading from older versions using Helm"},{"location":"installation/upgrading/upgrading-0.6-0.7/","text":"There are no special notes or considerations when upgrading from v0.6 to v0.7 .","title":"Upgrading from v0.6 to v0.7"},{"location":"installation/upgrading/upgrading-0.7-0.8/","text":"Upgrading from v0.7 to v0.8 is possible using the regular upgrade guide . All resources should continue to operate as before. As part of v0.8 , a new format for configure ACME Certificate resources has been introduced. Notably, challenge solver configuration has moved from the Certificate resource (under certificate.spec.acme ) and now resides on your configure Issuer resource, under issuer.spec.acme.solvers . This allows Certificate resources to be portable between different Issuer types. Both the old and the new format of configuration are supported in the v0.8 release, so it is possible to incrementally upgrade your resources if you have a large, multi-team deployment of cert-manager that makes it complex to upgrade all manifests at once in place. After upgrading, it is strongly recommended that you update your ACME Issuer and Certificate resources to the new format . We will be removing support for the old format ahead of the 1.0 release. The documentation has been updated to reflect configuring using the new format, and as such, exhaustive information can be found in the document . Performing an incremental switch to the new format \u00b6 The following guide assumes you have 2 'solver types' currently in use across your cert-manager deployment - one for DNS01 and another for HTTP01 using an ingress class of nginx . The nginx based HTTP01 solver will be configured as the default solver type for Certificate resources that reference our issuer. You can adjust the instructions below to fit your own configuration, either with more or less solvers as appropriate. First, we will modify our ACME Issuer to add the new HTTP01 and DNS01 solvers. This operation will not effect any existing Certificates that already explicitly set a certificate.spec.acme field: apiVersion : certmanager.k8s.io/v1alpha2 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key # The HTTP01 and DNS01 fields are now **deprecated**. # We leave them in place here so that any Certificates that still # specify a `certificate.spec.acme` stanza will continue to operate # correctly. # cert-manager will decide which configuration to use based on whether # the Certificate contains a `certificate.spec.acme` stanza. http01 : {} dns01 : providers : - name : cloudflare cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key # Configure the challenge solvers. solvers : # An empty selector will 'match' all Certificate resources that # reference this Issuer. - selector : {} http01 : ingress : class : nginx - selector : # Any Certificate resources, or Ingress resources that use # ingress-shim and match the below label selector will use this # configured solver type instead of the default nginx based HTTP01 # solver above. # You can continue to add new solver types if needed. # The most specific 'match' will be used. matchLabels : use-cloudflare-solver : \"true\" dns01 : # Adjust the configuration below according to your environment. # You can view more example configurations for different DNS01 # providers in the documentation: https://cert-manager.io/docs/tutorials/acme/dns-validation/ cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key By retaining both the old and the new configuration format on the Issuer resource, we can begin the process of incrementally upgrading our Certificate resources. Any Certificate resources that you have manually created (i.e. not managed by ingress-shim) must then be updated to remove the certificate.spec.acme stanza. Given the above configuration, certificates will use the HTTP01 solver with the nginx ingress class in order to solve ACME challenges. If a particular certificate requires a wildcard, or you simply want to use DNS01 for that certificate instead of HTTP01, you can add the use-cloudflare-solver: \"true\" label to your Certificate resources and the appropriate ACME challenge solver will be used. Upgrading ingress-shim managed certificates to the new format \u00b6 When using ingress-shim, cert-manager itself will create and manage your Certificate resource for you. In order to support both the old and the new format simultaneously, ingress-shim will continue to set the certificate.spec.acme field on Certificate resources it manages. In order to force ingress-shim to also use the new format, you must remove the old format configuration from your Issuer resources (i.e. issuer.spec.acme.http01 and issuer.spec.acme.dns01 ). When ingress-shim detects that these fields are not specified, it will clear/not set the certificate.spec.acme field. If you are managing a certificate using ingress-shim that requires an alternative solver type (other than the default solver configured on the issuer which in this instance is the HTTP01 nginx solver), you can add labels to the Ingress resource which will be automatically copied across to the Certificate resource: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : my-test-ingress labels : use-cloudflare-solver : \"true\" Confirming all Certificate resources are upgraded \u00b6 In order to check if any of your Certificate resources still have the old configuration format, you can run the following command: $ kubectl get certificate --all-namespaces \\ -o custom-columns = \"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].kind,OLD FORMAT:.spec.acme\" NAMESPACE NAME OWNER OLD FORMAT default test <none> <none> default test2 Ingress map [ config: [ map [ domains: [ abc.com ] http01:map [ ingressClass:nginx ]]]] In the above example, we can see there are two Certificate resources. The test resource has been updated to no longer include the certificate.spec.acme field. The test2 resource still specifies the old configuration format, however it also has an OwnerReference linking it to an Ingress resource. This is because the test2 Certificate resource is managed by ingress-shim. As mentioned in the previous section, ingress-shim managed certificates will only switch to the new format once the old format configuration on the Issuer resource has been removed. This means we need to continue to the next section in order to remove the old format configuration altogether from Issuer resource in order for ingress-shim to automatically migrate the test2 Certificate resource. Removing old configuration altogether \u00b6 Once we've verified that all non-ingress-shim managed Certificate resources have been updated to not specify the certificate.spec.acme stanza using the command above, we can proceed to remove the issuer.spec.acme.http01 and issuer.spec.acme.dns01 stanzas from our Issuer resources. Once completed, the Issuer resource from the previous section should look like the following: apiVersion : certmanager.k8s.io/v1alpha2 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key # Configure the challenge solvers. solvers : # An empty selector will 'match' all Certificate resources that # reference this Issuer. - selector : {} http01 : ingress : class : nginx - selector : # Any Certificate resources, or Ingress resources that use # ingress-shim and match the below label selector will use this # configured solver type instead of the default nginx based HTTP01 # solver above. # You can continue to add new solver types if needed. # The most specific 'match' will be used. matchLabels : use-cloudflare-solver : \"true\" dns01 : # Adjust the configuration below according to your environment. # You can view more example configurations for different DNS01 # providers in the documentation: https://cert-manager.io/docs/tutorials/acme/dns-validation/ cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key After applying the above Issuer resource, you should re-run the command from the last section to verify that the remaining ingress-shim managed Certificate resources have also been updated to the new format: $ kubectl get certificate --all-namespaces \\ -o custom-columns = \"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].kind,OLD FORMAT:.spec.acme\" NAMESPACE NAME OWNER OLD FORMAT default test <none> <none> default test2 Ingress <none> Manually triggering a Certificate to be issued to validate the full configuration \u00b6 To be certain that you've correctly configured your new Issuer/Certificate resources, it is advised you attempt to issue a new Certificate after removing the old configuration format. To do so, you can either: update the secretName field of an existing Certificate resource add an additional dnsName to one of your existing Certificate resources create a new Certificate resource You should ensure that your Certificates are still be issued correctly to avoid any potential issues at renewal time. Special notes for ingress-gce users \u00b6 Users of the ingress-gce ingress controller may find that their experience configuring cert-manager to solve challenges using HTTP01 validation is slightly more painful using the new format, as it requires the ingressName field to be specified as a distinct solver on the Issuer resource (as opposed to in the past where the ingressName could be specified as a field on the Certificate resource). This is a known issue , and a workaround is scheduled to be completed for v0.9 . In the meantime, ingress-gce users can either choose to manually create a new solver entry per Ingress resource they want to use to solve challenges, or otherwise continue to use the old format until a suitable alternative appears in v0.9 .","title":"Upgrading from v0.7 to v0.8"},{"location":"installation/upgrading/upgrading-0.7-0.8/#performing-an-incremental-switch-to-the-new-format","text":"The following guide assumes you have 2 'solver types' currently in use across your cert-manager deployment - one for DNS01 and another for HTTP01 using an ingress class of nginx . The nginx based HTTP01 solver will be configured as the default solver type for Certificate resources that reference our issuer. You can adjust the instructions below to fit your own configuration, either with more or less solvers as appropriate. First, we will modify our ACME Issuer to add the new HTTP01 and DNS01 solvers. This operation will not effect any existing Certificates that already explicitly set a certificate.spec.acme field: apiVersion : certmanager.k8s.io/v1alpha2 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key # The HTTP01 and DNS01 fields are now **deprecated**. # We leave them in place here so that any Certificates that still # specify a `certificate.spec.acme` stanza will continue to operate # correctly. # cert-manager will decide which configuration to use based on whether # the Certificate contains a `certificate.spec.acme` stanza. http01 : {} dns01 : providers : - name : cloudflare cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key # Configure the challenge solvers. solvers : # An empty selector will 'match' all Certificate resources that # reference this Issuer. - selector : {} http01 : ingress : class : nginx - selector : # Any Certificate resources, or Ingress resources that use # ingress-shim and match the below label selector will use this # configured solver type instead of the default nginx based HTTP01 # solver above. # You can continue to add new solver types if needed. # The most specific 'match' will be used. matchLabels : use-cloudflare-solver : \"true\" dns01 : # Adjust the configuration below according to your environment. # You can view more example configurations for different DNS01 # providers in the documentation: https://cert-manager.io/docs/tutorials/acme/dns-validation/ cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key By retaining both the old and the new configuration format on the Issuer resource, we can begin the process of incrementally upgrading our Certificate resources. Any Certificate resources that you have manually created (i.e. not managed by ingress-shim) must then be updated to remove the certificate.spec.acme stanza. Given the above configuration, certificates will use the HTTP01 solver with the nginx ingress class in order to solve ACME challenges. If a particular certificate requires a wildcard, or you simply want to use DNS01 for that certificate instead of HTTP01, you can add the use-cloudflare-solver: \"true\" label to your Certificate resources and the appropriate ACME challenge solver will be used.","title":"Performing an incremental switch to the new format"},{"location":"installation/upgrading/upgrading-0.7-0.8/#upgrading-ingress-shim-managed-certificates-to-the-new-format","text":"When using ingress-shim, cert-manager itself will create and manage your Certificate resource for you. In order to support both the old and the new format simultaneously, ingress-shim will continue to set the certificate.spec.acme field on Certificate resources it manages. In order to force ingress-shim to also use the new format, you must remove the old format configuration from your Issuer resources (i.e. issuer.spec.acme.http01 and issuer.spec.acme.dns01 ). When ingress-shim detects that these fields are not specified, it will clear/not set the certificate.spec.acme field. If you are managing a certificate using ingress-shim that requires an alternative solver type (other than the default solver configured on the issuer which in this instance is the HTTP01 nginx solver), you can add labels to the Ingress resource which will be automatically copied across to the Certificate resource: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : my-test-ingress labels : use-cloudflare-solver : \"true\"","title":"Upgrading ingress-shim managed certificates to the new format"},{"location":"installation/upgrading/upgrading-0.7-0.8/#confirming-all-certificate-resources-are-upgraded","text":"In order to check if any of your Certificate resources still have the old configuration format, you can run the following command: $ kubectl get certificate --all-namespaces \\ -o custom-columns = \"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].kind,OLD FORMAT:.spec.acme\" NAMESPACE NAME OWNER OLD FORMAT default test <none> <none> default test2 Ingress map [ config: [ map [ domains: [ abc.com ] http01:map [ ingressClass:nginx ]]]] In the above example, we can see there are two Certificate resources. The test resource has been updated to no longer include the certificate.spec.acme field. The test2 resource still specifies the old configuration format, however it also has an OwnerReference linking it to an Ingress resource. This is because the test2 Certificate resource is managed by ingress-shim. As mentioned in the previous section, ingress-shim managed certificates will only switch to the new format once the old format configuration on the Issuer resource has been removed. This means we need to continue to the next section in order to remove the old format configuration altogether from Issuer resource in order for ingress-shim to automatically migrate the test2 Certificate resource.","title":"Confirming all Certificate resources are upgraded"},{"location":"installation/upgrading/upgrading-0.7-0.8/#removing-old-configuration-altogether","text":"Once we've verified that all non-ingress-shim managed Certificate resources have been updated to not specify the certificate.spec.acme stanza using the command above, we can proceed to remove the issuer.spec.acme.http01 and issuer.spec.acme.dns01 stanzas from our Issuer resources. Once completed, the Issuer resource from the previous section should look like the following: apiVersion : certmanager.k8s.io/v1alpha2 kind : ClusterIssuer metadata : name : letsencrypt-staging spec : acme : email : user@example.com server : https://acme-staging-v02.api.letsencrypt.org/directory privateKeySecretRef : name : example-issuer-account-key # Configure the challenge solvers. solvers : # An empty selector will 'match' all Certificate resources that # reference this Issuer. - selector : {} http01 : ingress : class : nginx - selector : # Any Certificate resources, or Ingress resources that use # ingress-shim and match the below label selector will use this # configured solver type instead of the default nginx based HTTP01 # solver above. # You can continue to add new solver types if needed. # The most specific 'match' will be used. matchLabels : use-cloudflare-solver : \"true\" dns01 : # Adjust the configuration below according to your environment. # You can view more example configurations for different DNS01 # providers in the documentation: https://cert-manager.io/docs/tutorials/acme/dns-validation/ cloudflare : email : my-cloudflare-acc@example.com apiKeySecretRef : name : cloudflare-api-key-secret key : api-key After applying the above Issuer resource, you should re-run the command from the last section to verify that the remaining ingress-shim managed Certificate resources have also been updated to the new format: $ kubectl get certificate --all-namespaces \\ -o custom-columns = \"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].kind,OLD FORMAT:.spec.acme\" NAMESPACE NAME OWNER OLD FORMAT default test <none> <none> default test2 Ingress <none>","title":"Removing old configuration altogether"},{"location":"installation/upgrading/upgrading-0.7-0.8/#manually-triggering-a-certificate-to-be-issued-to-validate-the-full-configuration","text":"To be certain that you've correctly configured your new Issuer/Certificate resources, it is advised you attempt to issue a new Certificate after removing the old configuration format. To do so, you can either: update the secretName field of an existing Certificate resource add an additional dnsName to one of your existing Certificate resources create a new Certificate resource You should ensure that your Certificates are still be issued correctly to avoid any potential issues at renewal time.","title":"Manually triggering a Certificate to be issued to validate the full configuration"},{"location":"installation/upgrading/upgrading-0.7-0.8/#special-notes-for-ingress-gce-users","text":"Users of the ingress-gce ingress controller may find that their experience configuring cert-manager to solve challenges using HTTP01 validation is slightly more painful using the new format, as it requires the ingressName field to be specified as a distinct solver on the Issuer resource (as opposed to in the past where the ingressName could be specified as a field on the Certificate resource). This is a known issue , and a workaround is scheduled to be completed for v0.9 . In the meantime, ingress-gce users can either choose to manually create a new solver entry per Ingress resource they want to use to solve challenges, or otherwise continue to use the old format until a suitable alternative appears in v0.9 .","title":"Special notes for ingress-gce users"},{"location":"installation/upgrading/upgrading-0.8-0.9/","text":"Due to a change in the API group that cert-manager deployments use ( apps/v1beta1 to apps/v1 ), cert-manager deployments must first be deleted before applying the new version. This will cause downtime until the new version has been applied. No data loss will occur during this operation however it is always advised to backup your data during an upgrade, which you can follow here . To perform this action run: $ kubectl delete deployments --namespace cert-manager \\ cert-manager \\ cert-manager-cainjector \\ cert-manager-webhook After this operation, follow the standard upgrade process as defined in the upgrade guide .","title":"Upgrading from v0.8 to v0.9"},{"location":"installation/upgrading/upgrading-0.9-0.10/","text":"Due to changes in the way the webhook component's TLS is bootstrapped in v0.10 , you will need to delete your webhook's Certificate and Issuer resources. If you are using a deployment tool that automatically handles this (i.e. Helm), there should be no additional action to take. If you are using the 'static manifests' to install, you should run the following after upgrading: $ kubectl delete -n cert-manager issuer cert-manager-webhook-ca cert-manager-webhook-selfsign $ kubectl delete -n cert-manager certificate cert-manager-webhook-ca cert-manager-webhook-webhook-tls $ kubectl delete apiservice v1beta1.admission.certmanager.k8s.io The Secret resources used to contain TLS assets for the webhook are now automatically handled internally by cert-manager, so these resources are no longer required.","title":"Upgrading from v0.9 to v0.10"},{"location":"installation/upgrading/upgrading-1.0-1.1/","text":"When upgrading from v1.0 to v1.1 , no special upgrade steps are required \ud83c\udf89. From here on you can follow the regular upgrade process .","title":"Upgrading from v1.0 to v1.1"},{"location":"installation/upgrading/upgrading-1.1-1.2/","text":"In an effort to introduce new features whilst keeping the project maintainable, cert-manager now only supports Kubernetes down to version v1.16 . This means the legacy manifests have now been removed. Some users experience issues when upgrading the legacy CRD s to v1.2 . To solve this, you could replace the CRD s: 1. Backup cert-manager resources as described in the docs 2. Run kubectl replace -f https://github.com/cert-manager/cert-manager/releases/download/v1.2.0/cert-manager.crds.yaml to replace the CRDs. 3. Follow the standard upgrade process. You can read more about supported Kubernetes versions here . In this release some features have been deprecated. Please read the version 1.2 release notes for more details and consider whether you are using any of these deprecated features before you proceed with the upgrade. From here on you can follow the regular upgrade process .","title":"Upgrading from v1.1 to v1.2"},{"location":"installation/upgrading/upgrading-1.2-1.3/","text":"Upgrade notes for users of the Venafi Cloud Issuer \u00b6 This release updates the Venafi Cloud Issuer to use OutagePREDICT instead of DevOpsACCELERATE . The only impact to Venafi Cloud users is the change in zone syntax. The zone is now <Application Name>\\<Issuing Template Alias> (e.g. My Application\\My CIT ). Background \u00b6 Venafi are currently transitioning Venafi Cloud users to the OutagePREDICT (\"OP\") product, from DevOpsACCELERATE (\"DA\"), which will be sunset later in 2021. The Venafi Cloud Issuer in cert-manager relies upon the VCert library, and the [ VCert v4.13.0 ][] release marks this \"DA2OP\" transition. The VCert module dependencies in cert-manager have been updated in order for cert-manager to complete the transition as well. With this update, cert-manager users with Venafi Cloud issuers will need to be aware that the zone format changes from a UUID (DA Zone ID) to a string of the form <Application Name>\\<Issuing Template Alias> . This means users will need to create an Application in OutagePREDICT and associate an Issuing Template with it (the same Issuing Templates assigned to DA Projects Zones can be used since Issuing Templates are shared between Venafi Cloud products). Next Steps \u00b6 You should now follow the regular upgrade process .","title":"Upgrading from v1.2 to v1.3"},{"location":"installation/upgrading/upgrading-1.2-1.3/#upgrade-notes-for-users-of-the-venafi-cloud-issuer","text":"This release updates the Venafi Cloud Issuer to use OutagePREDICT instead of DevOpsACCELERATE . The only impact to Venafi Cloud users is the change in zone syntax. The zone is now <Application Name>\\<Issuing Template Alias> (e.g. My Application\\My CIT ).","title":"Upgrade notes for users of the Venafi Cloud Issuer"},{"location":"installation/upgrading/upgrading-1.2-1.3/#background","text":"Venafi are currently transitioning Venafi Cloud users to the OutagePREDICT (\"OP\") product, from DevOpsACCELERATE (\"DA\"), which will be sunset later in 2021. The Venafi Cloud Issuer in cert-manager relies upon the VCert library, and the [ VCert v4.13.0 ][] release marks this \"DA2OP\" transition. The VCert module dependencies in cert-manager have been updated in order for cert-manager to complete the transition as well. With this update, cert-manager users with Venafi Cloud issuers will need to be aware that the zone format changes from a UUID (DA Zone ID) to a string of the form <Application Name>\\<Issuing Template Alias> . This means users will need to create an Application in OutagePREDICT and associate an Issuing Template with it (the same Issuing Templates assigned to DA Projects Zones can be used since Issuing Templates are shared between Venafi Cloud products).","title":"Background"},{"location":"installation/upgrading/upgrading-1.2-1.3/#next-steps","text":"You should now follow the regular upgrade process .","title":"Next Steps"},{"location":"installation/upgrading/upgrading-1.3-1.4/","text":"Removal of the cert-manager operator package on Red Hat Marketplace \u00b6 Since cert-manager v0.15 there has been a package for cert-manager on Red Hat Marketplace , but this has now been removed because it was not maintained and was found to be unreliable: #4055 #3732 #436 It is replaced by a new package which is generated via the Community Operators Repository , and which is therefore available on OperatorHub.io , OpenShift Container Platform and OKD . Please uninstall the existing cert-manager package and re-install by following the OLM Installation Documentation . Now Follow the Regular Upgrade Process \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.3 to v1.4"},{"location":"installation/upgrading/upgrading-1.3-1.4/#removal-of-the-cert-manager-operator-package-on-red-hat-marketplace","text":"Since cert-manager v0.15 there has been a package for cert-manager on Red Hat Marketplace , but this has now been removed because it was not maintained and was found to be unreliable: #4055 #3732 #436 It is replaced by a new package which is generated via the Community Operators Repository , and which is therefore available on OperatorHub.io , OpenShift Container Platform and OKD . Please uninstall the existing cert-manager package and re-install by following the OLM Installation Documentation .","title":"Removal of the cert-manager operator package on Red Hat Marketplace"},{"location":"installation/upgrading/upgrading-1.3-1.4/#now-follow-the-regular-upgrade-process","text":"From here on you can follow the regular upgrade process .","title":"Now Follow the Regular Upgrade Process"},{"location":"installation/upgrading/upgrading-1.4-1.5/","text":"If you are currently using HTTP-01 challenges or the Ingress shim annotations, please read the Ingress class compatibility notes to see if your Ingress controller has any known issues with the migration to Ingress v1. Now Follow the Regular Upgrade Process \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.4 to v1.5"},{"location":"installation/upgrading/upgrading-1.4-1.5/#now-follow-the-regular-upgrade-process","text":"From here on you can follow the regular upgrade process .","title":"Now Follow the Regular Upgrade Process"},{"location":"installation/upgrading/upgrading-1.5-1.6/","text":"Upgrading cert-manager CRDs and stored versions of cert-manager custom resources \u00b6 Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 are no longer served. This means if your deployment manifests contain any of these API versions, you will not be able to deploy them after upgrading. Our new cmctl utility or old kubectl cert-manager plugin can convert old manifests to v1 for you. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **before you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](./remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page. If you are currently using HTTP-01 challenges or the Ingress shim annotations, please read the Ingress class compatibility notes to see if your Ingress controller has any known issues with the migration to Ingress v1. Now Follow the Regular Upgrade Process \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.5 to v1.6"},{"location":"installation/upgrading/upgrading-1.5-1.6/#upgrading-cert-manager-crds-and-stored-versions-of-cert-manager-custom-resources","text":"Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 are no longer served. This means if your deployment manifests contain any of these API versions, you will not be able to deploy them after upgrading. Our new cmctl utility or old kubectl cert-manager plugin can convert old manifests to v1 for you. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **before you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](./remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page. If you are currently using HTTP-01 challenges or the Ingress shim annotations, please read the Ingress class compatibility notes to see if your Ingress controller has any known issues with the migration to Ingress v1.","title":"Upgrading cert-manager CRDs and stored versions of cert-manager custom resources"},{"location":"installation/upgrading/upgrading-1.5-1.6/#now-follow-the-regular-upgrade-process","text":"From here on you can follow the regular upgrade process .","title":"Now Follow the Regular Upgrade Process"},{"location":"installation/upgrading/upgrading-1.6-1.7/","text":"\u26a0 Following their deprecation in version 1.5, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 have been removed. You must ensure that all cert-manager custom resources are stored in etcd at version v1 and that all cert-manager CustomResourceDefinition s have only v1 as the stored version before upgrading. Please read Migrating Deprecated API Resources for full instructions. If you are currently using HTTP-01 challenges or the Ingress shim annotations, please read the Ingress class compatibility notes to see if your Ingress controller has any known issues with the migration to Ingress v1. If running Kubernetes versions before v1.22 , the ServerSideApply feature gate must be enabled in the cluster. This beta feature is enabled by default on supported versions before v1.22 . Now Follow the Regular Upgrade Process \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.6 to v1.7"},{"location":"installation/upgrading/upgrading-1.6-1.7/#now-follow-the-regular-upgrade-process","text":"From here on you can follow the regular upgrade process .","title":"Now Follow the Regular Upgrade Process"},{"location":"installation/upgrading/upgrading-1.7-1.8/","text":"Validation of the rotationPolicy field \u00b6 The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. Before upgrading to 1.8.0, you will need to check that all the Certificate YAML manifests you have stored in Git if you are using a GitOps flow (or any other \"source of truth\") have a correct rotationPolicy value. To help you find out which Certificate YAML manifests need updating, you can run the following command: kubectl get cert -A -ojson | jq -r \\ '.items[] | select(.spec.privateKey.rotationPolicy | strings | . != \"Always\" and . != \"Never\") | \"\\(.metadata.name) in namespace \\(.metadata.namespace) has rotationPolicy=\\(.spec.privateKey.rotationPolicy)\"' This command will show you, the name and namespace of each Certificate resource that needs to be updated in Git. For example: smoketest-cert in namespace default has rotationPolicy=Foo Server-Side Apply \u00b6 Server-Side Apply is an alpha feature of cert-manager introduced in 1.8. By default, the feature is disabled, in which case you can skip this section. If you are using Server-Side Apply, i.e., you are running the cert-manager controller with the flag --feature-gates=ServerSideApply=true Then you need to take action before upgrading to cert-manager 1.8. You will have to make sure that there are no Challenge resources currently in the cluster. If there are some, you will need to manually delete them once they are in a 'valid' state. The reason the Challenge resources need to be removed before upgrading to 1.8 when using the new Server-Side Apply feature is that cert-manager post-1.8 is not able to clean up Challenge resources that were created pre-1.8. If running Kubernetes versions before v1.22 , the ServerSideApply feature gate must be enabled in the cluster. This beta feature is enabled by default on supported versions before v1.22 . Migrating from the Gateway API v1alpha1 to v1alpha2 \u00b6 This section only applies to you if you are using the feature gate ExperimentalGatewayAPISupport . cert-manager 1.8 drops support for the Gateway API v1alpha1, and now only supports v1alpha2. Before upgrading cert-manager, you will need to: remove all existing Gateway API v1alpha1 resources, upgrade the Gateway API CRDs to v1alpha2, re-create the Gateway API resources with the v1alpha2. This manual intervention is needed because the Gateway API project does not come with a conversion webhook that would allow an easier migration from v1alpha1 to v1alpha2. After upgrading cert-manager to 1.8, you will need to remove the labels field, and add the parentRefs : apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: letsencrypt namespace: default spec: acme: solvers: - http01: gatewayHTTPRoute: - labels: - gateway: traefik + parentRefs: + - name: traefik + namespace: traefik + kind: Gateway Now, Follow the Regular Upgrade Process \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.7 to v1.8"},{"location":"installation/upgrading/upgrading-1.7-1.8/#validation-of-the-rotationpolicy-field","text":"The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. Before upgrading to 1.8.0, you will need to check that all the Certificate YAML manifests you have stored in Git if you are using a GitOps flow (or any other \"source of truth\") have a correct rotationPolicy value. To help you find out which Certificate YAML manifests need updating, you can run the following command: kubectl get cert -A -ojson | jq -r \\ '.items[] | select(.spec.privateKey.rotationPolicy | strings | . != \"Always\" and . != \"Never\") | \"\\(.metadata.name) in namespace \\(.metadata.namespace) has rotationPolicy=\\(.spec.privateKey.rotationPolicy)\"' This command will show you, the name and namespace of each Certificate resource that needs to be updated in Git. For example: smoketest-cert in namespace default has rotationPolicy=Foo","title":"Validation of the rotationPolicy field"},{"location":"installation/upgrading/upgrading-1.7-1.8/#server-side-apply","text":"Server-Side Apply is an alpha feature of cert-manager introduced in 1.8. By default, the feature is disabled, in which case you can skip this section. If you are using Server-Side Apply, i.e., you are running the cert-manager controller with the flag --feature-gates=ServerSideApply=true Then you need to take action before upgrading to cert-manager 1.8. You will have to make sure that there are no Challenge resources currently in the cluster. If there are some, you will need to manually delete them once they are in a 'valid' state. The reason the Challenge resources need to be removed before upgrading to 1.8 when using the new Server-Side Apply feature is that cert-manager post-1.8 is not able to clean up Challenge resources that were created pre-1.8. If running Kubernetes versions before v1.22 , the ServerSideApply feature gate must be enabled in the cluster. This beta feature is enabled by default on supported versions before v1.22 .","title":"Server-Side Apply"},{"location":"installation/upgrading/upgrading-1.7-1.8/#migrating-from-the-gateway-api-v1alpha1-to-v1alpha2","text":"This section only applies to you if you are using the feature gate ExperimentalGatewayAPISupport . cert-manager 1.8 drops support for the Gateway API v1alpha1, and now only supports v1alpha2. Before upgrading cert-manager, you will need to: remove all existing Gateway API v1alpha1 resources, upgrade the Gateway API CRDs to v1alpha2, re-create the Gateway API resources with the v1alpha2. This manual intervention is needed because the Gateway API project does not come with a conversion webhook that would allow an easier migration from v1alpha1 to v1alpha2. After upgrading cert-manager to 1.8, you will need to remove the labels field, and add the parentRefs : apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: letsencrypt namespace: default spec: acme: solvers: - http01: gatewayHTTPRoute: - labels: - gateway: traefik + parentRefs: + - name: traefik + namespace: traefik + kind: Gateway","title":"Migrating from the Gateway API v1alpha1 to v1alpha2"},{"location":"installation/upgrading/upgrading-1.7-1.8/#now-follow-the-regular-upgrade-process","text":"From here on you can follow the regular upgrade process .","title":"Now, Follow the Regular Upgrade Process"},{"location":"installation/upgrading/upgrading-1.8-1.9/","text":"If running Kubernetes versions before v1.22 , the ServerSideApply feature gate must be enabled in the cluster. This beta feature is enabled by default on supported versions before v1.22 . From here on you can follow the regular upgrade process .","title":"Upgrading from v1.8 to v1.9"},{"location":"installation/upgrading/upgrading-1.9-1.10/","text":"On OpenShift the cert-manager Pods may fail until you modify Security Context Constraints \u00b6 In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook . \ud83d\udcd6 Read the Breaking Changes section in the 1.10 release notes before upgrading. Next Steps \u00b6 From here on you can follow the regular upgrade process .","title":"Upgrading from v1.9 to v1.10"},{"location":"installation/upgrading/upgrading-1.9-1.10/#on-openshift-the-cert-manager-pods-may-fail-until-you-modify-security-context-constraints","text":"In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook . \ud83d\udcd6 Read the Breaking Changes section in the 1.10 release notes before upgrading.","title":"On OpenShift the cert-manager Pods may fail until you modify Security Context Constraints"},{"location":"installation/upgrading/upgrading-1.9-1.10/#next-steps","text":"From here on you can follow the regular upgrade process .","title":"Next Steps"},{"location":"projects/","text":"The cert-manager project has a number of satellite projects that extend the project's functionality, and complement the core cert-manager feature-set. These tools help with security, compliance and control. istio-csr : Secure Istio service mesh with istio-csr which is an agent that allows for Istio workload and control plane components to be secured using cert-manager. approver-policy : a cert-manager approver that will automatically approve or deny certificate requests based on defined policy. csi-driver : a Container Storage Interface (CSI) driver plugin for Kubernetes to work along cert-manager. The goal for this plugin is to seamlessly request and mount certificate key pairs to pods. This is useful for facilitating mTLS, or otherwise securing connections of pods with guaranteed present certificates whilst having all of the features that cert-manager provides. csi-driver-spiffe : another CSI driver plugin to work along cert-manager. This CSI driver transparently delivers SPIFFE SVIDs in the form of X.509 certificate key pairs to mounting Kubernetes Pods. The end result is all and any Pod running in Kubernetes can securely request their SPIFFE identity document from a Trust Domain with minimal configuration. trust-manager : an operator to distribute trust bundles, like CA certificates, across a Kubernetes cluster.","title":"\u5185\u5bb9"},{"location":"projects/approver-policy/","text":"approver-policy is a cert-manager approver that will approve or deny CertificateRequests based on CRD defined policies. Installation \u00b6 cert-manager is required to be installed with approver-policy. \u26a0\ufe0f It is important that the default approver is disabled in cert-manager . If the default approver is not disabled in cert-manager, approver-policy will race with cert-manager and thus policy becomes useless. $ helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set extraArgs={--controllers='*\\,-certificaterequests-approver'} --set installCRDs=true --create-namespace \u26a0\ufe0f To install approver-policy: $ helm repo add jetstack https://charts.jetstack.io --force-update $ helm upgrade -i -n cert-manager cert-manager-approver-policy jetstack/cert-manager-approver-policy --wait If you are using approver-policy with external issuers , you must include their signer names so that approver-policy has permissions to approve and deny CertificateRequests that reference them . For example, if using approver-policy for the internal issuer types, along with google-ca-issuer , and aws-privateca-issuer , set the following values when installing: $ helm upgrade -i -n cert-manager cert-manager-approver-policy jetstack/cert-manager-approver-policy --wait \\ --set app.approveSignerNames=\"{\\ issuers.cert-manager.io/*,clusterissuers.cert-manager.io/*,\\ googlecasclusterissuers.cas-issuer.jetstack.io/*,googlecasissuers.cas-issuer.jetstack.io/*,\\ awspcaclusterissuers.awspca.cert-manager.io/*,awspcaissuers.awspca.cert-manager.io/*\\ }\" Configuration \u00b6 Example policy resources can be found here . When a CertificateRequest is created, approver-policy will evaluate whether the request is appropriate for any existing policy, and if so, evaluate whether it should be approved or denied. For a CertificateRequest to be appropriate for a policy and therefore be evaluated by it, it must be both bound via RBAC and be selected by the policy selector. CertificateRequestPolicy currently only supports issuerRef as a selector. If at least one policy permits the request, the request is approved. If at least one policy is appropriate for the request but none of those permit the request, the request is denied. CertificateRequestPolicies are cluster scoped resources that can be thought of as \"policy profiles\". They describe any request that is approved by that policy. Policies are bound to Kubernetes users and ServiceAccounts using RBAC. Below is an example of a policy that is bound to all Kubernetes users who may only request certificates that have the common name of \"hello.world\" . apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : test-policy spec : allowed : commonName : value : \"hello.world\" required : true selector : # Select all IssuerRef issuerRef : {} --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cert-manager-policy:hello-world rules : - apiGroups : [ \"policy.cert-manager.io\" ] resources : [ \"certificaterequestpolicies\" ] verbs : [ \"use\" ] # Name of the CertificateRequestPolicies to be used. resourceNames : [ \"test-policy\" ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : cert-manager-policy:hello-world roleRef : # ClusterRole or Role _must_ be bound to a user for the policy to be considered. apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-policy:hello-world subjects : # The users who should be bound to the policies defined. # Note that in the case of users creating Certificate resources, cert-manager # is the entity that is creating the actual CertificateRequests, and so the # cert-manager controller's # Service Account should be bound instead. - kind : Group name : system:authenticated apiGroup : rbac.authorization.k8s.io Behavior \u00b6 CertificateRequestPolicy are split into 4 parts; allowed , contraints , selector , and plugins . Allowed \u00b6 Allowed is the block that defines attributes that match against the corresponding attribute in the request. A request is permitted by the policy if the request omits an allowed attribute, but will deny the request if it contains an attribute which is not present in the allowed block. An allowed attribute can be marked as required , which if true, will enforce that the attribute has been defined in the request. A field can only be marked as required if the corresponding field is also defined. The required field is not available for isCA or usages . In the following CertificateRequestPolicy, a request will be permitted if it does not request a DNS name, requests the DNS name \"example.com\" , but will be denied when requesting \"bar.example.com\" . spec : ... allowed : dnsNames : values : - \"example.com\" - \"foo.example.com\" ... In the following, a request will be denied if the request contains no Common Name, but will permit requests whose Common Name ends in \".com\". spec : ... allowed : commonName : value : \"*.com\" required : true ... If an allowed field is omitted, that attribute is considered \"deny all\" for requests. Allowed string fields accept wildcards \"*\" within its values. Wildcards \"*\" in patterns represent any string that has a length of 0 or more. A pattern containing only \"*\" will match anything. A pattern containing \"\\*foo\" will match \"foo\" as well as any string which ends in \"foo\" (e.g. \"bar-foo\" ). A pattern containing \"\\*.foo\" will match \"bar-123.foo\" , but not \"barfoo\" . Allowed fields that are lists will permit requests that are a subset of that list. This means that if usages contains [\"server auth\", \"client auth\"] , then a request containing only [\"server auth\"] would be permitted, but not [\"server auth\", \"cert sign\"] . Below is an example including all supported allowed fields of CertificateRequestPolicy. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : allowed : commonName : value : \"example.com\" dnsNames : values : - \"example.com\" - \"*.example.com\" ipAddresses : values : - \"1.2.3.4\" - \"10.0.1.*\" uris : values : - \"spiffe://example.org/ns/*/sa/*\" emailAddresses : values : - \"*@example.com\" required : true isCA : false usages : - \"server auth\" - \"client auth\" subject : organizations : values : [ \"hello-world\" ] countries : values : [ \"*\" ] organizationalUnits : values : [ \"*\" ] localities : values : [ \"*\" ] provinces : values : [ \"*\" ] streetAddresses : values : [ \"*\" ] postalCodes : values : [ \"*\" ] serialNumber : value : \"*\" ... Constraints \u00b6 Constraints is the block that is used to limit what attributes the request can have. If a constraint is not defined, then the attribute is considered \"allow all\". Below is an example containing all supported constraints fields of CertificateRequestPolicy. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : ... constraints : minDuration : 1h maxDuration : 24h privateKey : algorithm : RSA minSize : 2048 maxSize : 4096 ... Selector \u00b6 Selector is a required field that is used for matching CertificateRequestPolicies against a CertificateRequest for evaluation. approver-policy currently only supports selecting over the issuerRef of a request. issuerRef values accept wildcards \"*\". If an issuerRef is set to an empty object \"{}\", then the policy will match against all RBAC bound requests. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : ... selector : issuerRef : - name : \"my-ca\" kind : \"*Issuer\" group : \"cert-manager.io\" apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : match-all-requests spec : ... selector : issuerRef : {} \u26a0\ufe0f Note that the user must still be bound by RBAC for the policy to be considered for evaluation against a request. Plugins \u00b6 Plugins are external approvers that are built into approver-policy at compile time. Plugins are designed to be used as extensions to the existing policy checks where the user requires special functionality that the existing checks can't provide. Plugins are defined as a block on the CertificateRequestPolicy Spec. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : plugins spec : ... plugins : my-plugin : values : val-1 : key-1 There are currently no none open source plugins.","title":"approver-policy"},{"location":"projects/approver-policy/#installation","text":"cert-manager is required to be installed with approver-policy. \u26a0\ufe0f It is important that the default approver is disabled in cert-manager . If the default approver is not disabled in cert-manager, approver-policy will race with cert-manager and thus policy becomes useless. $ helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set extraArgs={--controllers='*\\,-certificaterequests-approver'} --set installCRDs=true --create-namespace \u26a0\ufe0f To install approver-policy: $ helm repo add jetstack https://charts.jetstack.io --force-update $ helm upgrade -i -n cert-manager cert-manager-approver-policy jetstack/cert-manager-approver-policy --wait If you are using approver-policy with external issuers , you must include their signer names so that approver-policy has permissions to approve and deny CertificateRequests that reference them . For example, if using approver-policy for the internal issuer types, along with google-ca-issuer , and aws-privateca-issuer , set the following values when installing: $ helm upgrade -i -n cert-manager cert-manager-approver-policy jetstack/cert-manager-approver-policy --wait \\ --set app.approveSignerNames=\"{\\ issuers.cert-manager.io/*,clusterissuers.cert-manager.io/*,\\ googlecasclusterissuers.cas-issuer.jetstack.io/*,googlecasissuers.cas-issuer.jetstack.io/*,\\ awspcaclusterissuers.awspca.cert-manager.io/*,awspcaissuers.awspca.cert-manager.io/*\\ }\"","title":"Installation"},{"location":"projects/approver-policy/#configuration","text":"Example policy resources can be found here . When a CertificateRequest is created, approver-policy will evaluate whether the request is appropriate for any existing policy, and if so, evaluate whether it should be approved or denied. For a CertificateRequest to be appropriate for a policy and therefore be evaluated by it, it must be both bound via RBAC and be selected by the policy selector. CertificateRequestPolicy currently only supports issuerRef as a selector. If at least one policy permits the request, the request is approved. If at least one policy is appropriate for the request but none of those permit the request, the request is denied. CertificateRequestPolicies are cluster scoped resources that can be thought of as \"policy profiles\". They describe any request that is approved by that policy. Policies are bound to Kubernetes users and ServiceAccounts using RBAC. Below is an example of a policy that is bound to all Kubernetes users who may only request certificates that have the common name of \"hello.world\" . apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : test-policy spec : allowed : commonName : value : \"hello.world\" required : true selector : # Select all IssuerRef issuerRef : {} --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRole metadata : name : cert-manager-policy:hello-world rules : - apiGroups : [ \"policy.cert-manager.io\" ] resources : [ \"certificaterequestpolicies\" ] verbs : [ \"use\" ] # Name of the CertificateRequestPolicies to be used. resourceNames : [ \"test-policy\" ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : ClusterRoleBinding metadata : name : cert-manager-policy:hello-world roleRef : # ClusterRole or Role _must_ be bound to a user for the policy to be considered. apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-policy:hello-world subjects : # The users who should be bound to the policies defined. # Note that in the case of users creating Certificate resources, cert-manager # is the entity that is creating the actual CertificateRequests, and so the # cert-manager controller's # Service Account should be bound instead. - kind : Group name : system:authenticated apiGroup : rbac.authorization.k8s.io","title":"Configuration"},{"location":"projects/approver-policy/#behavior","text":"CertificateRequestPolicy are split into 4 parts; allowed , contraints , selector , and plugins .","title":"Behavior"},{"location":"projects/approver-policy/#allowed","text":"Allowed is the block that defines attributes that match against the corresponding attribute in the request. A request is permitted by the policy if the request omits an allowed attribute, but will deny the request if it contains an attribute which is not present in the allowed block. An allowed attribute can be marked as required , which if true, will enforce that the attribute has been defined in the request. A field can only be marked as required if the corresponding field is also defined. The required field is not available for isCA or usages . In the following CertificateRequestPolicy, a request will be permitted if it does not request a DNS name, requests the DNS name \"example.com\" , but will be denied when requesting \"bar.example.com\" . spec : ... allowed : dnsNames : values : - \"example.com\" - \"foo.example.com\" ... In the following, a request will be denied if the request contains no Common Name, but will permit requests whose Common Name ends in \".com\". spec : ... allowed : commonName : value : \"*.com\" required : true ... If an allowed field is omitted, that attribute is considered \"deny all\" for requests. Allowed string fields accept wildcards \"*\" within its values. Wildcards \"*\" in patterns represent any string that has a length of 0 or more. A pattern containing only \"*\" will match anything. A pattern containing \"\\*foo\" will match \"foo\" as well as any string which ends in \"foo\" (e.g. \"bar-foo\" ). A pattern containing \"\\*.foo\" will match \"bar-123.foo\" , but not \"barfoo\" . Allowed fields that are lists will permit requests that are a subset of that list. This means that if usages contains [\"server auth\", \"client auth\"] , then a request containing only [\"server auth\"] would be permitted, but not [\"server auth\", \"cert sign\"] . Below is an example including all supported allowed fields of CertificateRequestPolicy. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : allowed : commonName : value : \"example.com\" dnsNames : values : - \"example.com\" - \"*.example.com\" ipAddresses : values : - \"1.2.3.4\" - \"10.0.1.*\" uris : values : - \"spiffe://example.org/ns/*/sa/*\" emailAddresses : values : - \"*@example.com\" required : true isCA : false usages : - \"server auth\" - \"client auth\" subject : organizations : values : [ \"hello-world\" ] countries : values : [ \"*\" ] organizationalUnits : values : [ \"*\" ] localities : values : [ \"*\" ] provinces : values : [ \"*\" ] streetAddresses : values : [ \"*\" ] postalCodes : values : [ \"*\" ] serialNumber : value : \"*\" ...","title":"Allowed"},{"location":"projects/approver-policy/#constraints","text":"Constraints is the block that is used to limit what attributes the request can have. If a constraint is not defined, then the attribute is considered \"allow all\". Below is an example containing all supported constraints fields of CertificateRequestPolicy. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : ... constraints : minDuration : 1h maxDuration : 24h privateKey : algorithm : RSA minSize : 2048 maxSize : 4096 ...","title":"Constraints"},{"location":"projects/approver-policy/#selector","text":"Selector is a required field that is used for matching CertificateRequestPolicies against a CertificateRequest for evaluation. approver-policy currently only supports selecting over the issuerRef of a request. issuerRef values accept wildcards \"*\". If an issuerRef is set to an empty object \"{}\", then the policy will match against all RBAC bound requests. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : my-policy spec : ... selector : issuerRef : - name : \"my-ca\" kind : \"*Issuer\" group : \"cert-manager.io\" apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : match-all-requests spec : ... selector : issuerRef : {} \u26a0\ufe0f Note that the user must still be bound by RBAC for the policy to be considered for evaluation against a request.","title":"Selector"},{"location":"projects/approver-policy/#plugins","text":"Plugins are external approvers that are built into approver-policy at compile time. Plugins are designed to be used as extensions to the existing policy checks where the user requires special functionality that the existing checks can't provide. Plugins are defined as a block on the CertificateRequestPolicy Spec. apiVersion : policy.cert-manager.io/v1alpha1 kind : CertificateRequestPolicy metadata : name : plugins spec : ... plugins : my-plugin : values : val-1 : key-1 There are currently no none open source plugins.","title":"Plugins"},{"location":"projects/csi-driver-spiffe/","text":"csi-driver-spiffe is a Container Storage Interface (CSI) driver plugin for Kubernetes to work along cert-manager . This CSI driver transparently delivers SPIFFE SVIDs in the form of X.509 certificate key pairs to mounting Kubernetes Pods. The end result is all and any Pod running in Kubernetes can securely request their SPIFFE identity document from a Trust Domain with minimal configuration. These documents are: - automatically renewed; \u2714\ufe0f - private key never leaves the node's virtual memory; \u2714\ufe0f - each Pod's document is unique; \u2714\ufe0f - the document shares the same life cycle as the Pod and is destroyed on Pod termination. \u2714\ufe0f ... volumeMounts : - mountPath : \"/var/run/secrets/spiffe.io\" name : spiffe volumes : - name : spiffe csi : driver : spiffe.csi.cert-manager.io readOnly : true SPIFFE documents can be used for mutual TLS (mTLS) or authentication by Pod's within its Trust Domain. Components \u00b6 The project is split into two components; CSI Driver \u00b6 The CSI driver runs as DaemonSet on the cluster which is responsible for generating, requesting, and mounting the certificate key pair to Pods on the node it manages. The CSI driver creates and manages a tmpfs directory which is used to create and mount Pod volumes from. When a Pod is created with the CSI volume configured, the driver will locally generate a private key, and create a cert-manager CertificateRequest in the same Namespace as the Pod. The driver uses CSI Token Request to both discover the Pod's identity to form the SPIFFE identity contained in the X.509 certificate signing request, as well as securely impersonate its ServiceAccount when creating the CertificateRequest. Once signed by the pre-configured target signer, the driver will mount the private key and signed certificate into the Pod's Volume to be made available as a Volume Mount. This certificate key pair is regularly renewed based on the expiry of the signed certificate. Approver \u00b6 A distinct cert-manager approver Deployment is responsible for managing the approval and denial condition of created CertificateRequests that target the configured SPIFFE Trust Domain signer. The approver ensures that requests have: the correct key type (ECDSA P-521); acceptable key usages (Key Encipherment, Digital Signature, Client Auth, Server Auth); the requested duration matches the enforced duration (default 1 hour); no SANs or other identifiable attributes except a single URI SANs ; the single URI SAN is the SPIFFE identity of the ServiceAccount who created the CertificateRequest; the SPIFFE ID Trust Domain is the same as configured. If any of these checks do not pass, the CertificateRequest will be marked as Denied, else it will be marked as Approved. The approver will only manage CertificateRequests who request from the same IssuerRef that has been configured. Installation \u00b6 Requires Kubernetes version v1.21 + or v1.20 with the --feature-gates=CSIServiceAccountToken=true flag. Requires cert-manager v1.3 or higher. cert-manager is required to be installed with csi-driver-spiffe. It is important that the default approver is disabled in cert-manager . If the default approver is not disabled in cert-manager, the csi-driver-spiffe approver will race with cert-manager and thus its policy enforcement becomes useless. $ helm repo add jetstack https://charts.jetstack.io --force-update $ helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set extraArgs={--controllers='*\\,-certificaterequests-approver'} --set installCRDs=true --create-namespace Install or configure a ClusterIssuer to give cert-manager the ability to sign against your Trust Domain. If a namespace scoped Issuer is desired, then that Issuer must be created in every namespace that Pods will mount volumes from. You must use an Issuer type which is compatible with signing URI SAN certificates and the private does not need to be available to the signer, for example CA , Vault , Venafi , AWS PCA , Google CAS , Small Step . Issuers such as SelfSigned or ACME will not work . An example demo ClusterIssuer can be found here . This Trust Domain's root CA is self-signed by cert-manager and private key is stored in the cluster . $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/clusterissuer.yaml # We must also approve the CertificateRequest since we have disabled the default approver $ kubectl cert-manager approve -n cert-manager $(kubectl get cr -n cert-manager -ojsonpath='{.items[0].metadata.name}') Install csi-driver-spiffe into the cluster using the issuer we configured. We must also configure the issuer resource type and name of the issuer we configured so that the approver has permissions to approve referencing CertificateRequests . Change signer name to match your issuer type. Change name, kind, and group to your issuer. $ helm upgrade -i -n cert-manager cert-manager-csi-driver-spiffe jetstack/cert-manager-csi-driver-spiffe --wait \\ --set \"app.logLevel=1\" \\ --set \"app.trustDomain=my.trust.domain\" \\ --set \"app.approver.signerName=clusterissuers.cert-manager.io/csi-driver-spiffe-ca\" \\ \\ --set \"app.issuer.name=csi-driver-spiffe-ca\" \\ --set \"app.issuer.kind=ClusterIssuer\" \\ --set \"app.issuer.group=cert-manager.io\" Usage \u00b6 Once the driver is successfully installed, Pods can begin to request and mount their key and SPIFFE certificate. Since the Pod's ServiceAccount is impersonated when creating CertificateRequests, every ServiceAccount must be given that permission which intends to use the volume. Example manifest with a dummy Deployment: $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/example-app.yaml $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep Issuer: Issuer: CN = csi-driver-spiffe-ca $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep URI: URI:spiffe://foo.bar/ns/sandbox/sa/example-app FS-Group \u00b6 When running Pods with a specified user or group, the volume will not be readable by default due to Unix based file system permissions. The mounting volumes file group can be specified using the following volume attribute: ... securityContext : runAsUser : 123 runAsGroup : 456 volumes : - name : spiffe csi : driver : spiffe.csi.cert-manager.io readOnly : true volumeAttributes : spiffe.csi.cert-manager.io/fs-group : \"456\" $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/fs-group-app.yaml $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app-fs-group -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep URI: URI:spiffe://foo.bar/ns/sandbox/sa/fs-group-app Root CA Bundle \u00b6 By default, the CSI driver will only mount the Pod's private key and signed certificate. csi-driver-spiffe can be optionally configured to also mount a statically defined CA bundle from a volume that will be written to all Pod volumes. If the CSI driver detects this bundle has changed (through overwrite, renewal, etc), the new bundle will be written to all existing volumes. The following example mounts the CA certificate used by the Trust Domain ClusterIssuer. $ helm upgrade -i -n cert-manager cert-manager-csi-driver-spiffe jetstack/cert-manager-csi-driver-spiffe --wait \\ --set \"app.logLevel=1\" \\ --set \"app.trustDomain=my.trust.domain\" \\ --set \"app.approver.signerName=clusterissuers.cert-manager.io/csi-driver-spiffe-ca\" \\ \\ --set \"app.issuer.name=csi-driver-spiffe-ca\" \\ --set \"app.issuer.kind=ClusterIssuer\" \\ --set \"app.issuer.group=cert-manager.io\" \\ \\ --set \"app.driver.volumes[0].name=root-cas\" \\ --set \"app.driver.volumes[0].secret.secretName=csi-driver-spiffe-ca\" \\ --set \"app.driver.volumeMounts[0].name=root-cas\" \\ --set \"app.driver.volumeMounts[0].mountPath=/var/run/secrets/cert-manager-csi-driver-spiffe\" \\ --set \"app.driver.sourceCABundle=/var/run/secrets/cert-manager-csi-driver-spiffe/ca.crt\" $ kubectl rollout restart deployment -n sandbox my-csi-app $ kubectl exec -it -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- ls /var/run/secrets/spiffe.io/ ca.crt tls.crt tls.key","title":"csi-driver-spiffe"},{"location":"projects/csi-driver-spiffe/#components","text":"The project is split into two components;","title":"Components"},{"location":"projects/csi-driver-spiffe/#csi-driver","text":"The CSI driver runs as DaemonSet on the cluster which is responsible for generating, requesting, and mounting the certificate key pair to Pods on the node it manages. The CSI driver creates and manages a tmpfs directory which is used to create and mount Pod volumes from. When a Pod is created with the CSI volume configured, the driver will locally generate a private key, and create a cert-manager CertificateRequest in the same Namespace as the Pod. The driver uses CSI Token Request to both discover the Pod's identity to form the SPIFFE identity contained in the X.509 certificate signing request, as well as securely impersonate its ServiceAccount when creating the CertificateRequest. Once signed by the pre-configured target signer, the driver will mount the private key and signed certificate into the Pod's Volume to be made available as a Volume Mount. This certificate key pair is regularly renewed based on the expiry of the signed certificate.","title":"CSI Driver"},{"location":"projects/csi-driver-spiffe/#approver","text":"A distinct cert-manager approver Deployment is responsible for managing the approval and denial condition of created CertificateRequests that target the configured SPIFFE Trust Domain signer. The approver ensures that requests have: the correct key type (ECDSA P-521); acceptable key usages (Key Encipherment, Digital Signature, Client Auth, Server Auth); the requested duration matches the enforced duration (default 1 hour); no SANs or other identifiable attributes except a single URI SANs ; the single URI SAN is the SPIFFE identity of the ServiceAccount who created the CertificateRequest; the SPIFFE ID Trust Domain is the same as configured. If any of these checks do not pass, the CertificateRequest will be marked as Denied, else it will be marked as Approved. The approver will only manage CertificateRequests who request from the same IssuerRef that has been configured.","title":"Approver"},{"location":"projects/csi-driver-spiffe/#installation","text":"Requires Kubernetes version v1.21 + or v1.20 with the --feature-gates=CSIServiceAccountToken=true flag. Requires cert-manager v1.3 or higher. cert-manager is required to be installed with csi-driver-spiffe. It is important that the default approver is disabled in cert-manager . If the default approver is not disabled in cert-manager, the csi-driver-spiffe approver will race with cert-manager and thus its policy enforcement becomes useless. $ helm repo add jetstack https://charts.jetstack.io --force-update $ helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set extraArgs={--controllers='*\\,-certificaterequests-approver'} --set installCRDs=true --create-namespace Install or configure a ClusterIssuer to give cert-manager the ability to sign against your Trust Domain. If a namespace scoped Issuer is desired, then that Issuer must be created in every namespace that Pods will mount volumes from. You must use an Issuer type which is compatible with signing URI SAN certificates and the private does not need to be available to the signer, for example CA , Vault , Venafi , AWS PCA , Google CAS , Small Step . Issuers such as SelfSigned or ACME will not work . An example demo ClusterIssuer can be found here . This Trust Domain's root CA is self-signed by cert-manager and private key is stored in the cluster . $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/clusterissuer.yaml # We must also approve the CertificateRequest since we have disabled the default approver $ kubectl cert-manager approve -n cert-manager $(kubectl get cr -n cert-manager -ojsonpath='{.items[0].metadata.name}') Install csi-driver-spiffe into the cluster using the issuer we configured. We must also configure the issuer resource type and name of the issuer we configured so that the approver has permissions to approve referencing CertificateRequests . Change signer name to match your issuer type. Change name, kind, and group to your issuer. $ helm upgrade -i -n cert-manager cert-manager-csi-driver-spiffe jetstack/cert-manager-csi-driver-spiffe --wait \\ --set \"app.logLevel=1\" \\ --set \"app.trustDomain=my.trust.domain\" \\ --set \"app.approver.signerName=clusterissuers.cert-manager.io/csi-driver-spiffe-ca\" \\ \\ --set \"app.issuer.name=csi-driver-spiffe-ca\" \\ --set \"app.issuer.kind=ClusterIssuer\" \\ --set \"app.issuer.group=cert-manager.io\"","title":"Installation"},{"location":"projects/csi-driver-spiffe/#usage","text":"Once the driver is successfully installed, Pods can begin to request and mount their key and SPIFFE certificate. Since the Pod's ServiceAccount is impersonated when creating CertificateRequests, every ServiceAccount must be given that permission which intends to use the volume. Example manifest with a dummy Deployment: $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/example-app.yaml $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep Issuer: Issuer: CN = csi-driver-spiffe-ca $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep URI: URI:spiffe://foo.bar/ns/sandbox/sa/example-app","title":"Usage"},{"location":"projects/csi-driver-spiffe/#fs-group","text":"When running Pods with a specified user or group, the volume will not be readable by default due to Unix based file system permissions. The mounting volumes file group can be specified using the following volume attribute: ... securityContext : runAsUser : 123 runAsGroup : 456 volumes : - name : spiffe csi : driver : spiffe.csi.cert-manager.io readOnly : true volumeAttributes : spiffe.csi.cert-manager.io/fs-group : \"456\" $ kubectl apply -f https://raw.githubusercontent.com/cert-manager/csi-driver-spiffe/main/deploy/example/fs-group-app.yaml $ kubectl exec -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app-fs-group -o jsonpath='{.items[0].metadata.name}') -- cat /var/run/secrets/spiffe.io/tls.crt | openssl x509 --noout --text | grep URI: URI:spiffe://foo.bar/ns/sandbox/sa/fs-group-app","title":"FS-Group"},{"location":"projects/csi-driver-spiffe/#root-ca-bundle","text":"By default, the CSI driver will only mount the Pod's private key and signed certificate. csi-driver-spiffe can be optionally configured to also mount a statically defined CA bundle from a volume that will be written to all Pod volumes. If the CSI driver detects this bundle has changed (through overwrite, renewal, etc), the new bundle will be written to all existing volumes. The following example mounts the CA certificate used by the Trust Domain ClusterIssuer. $ helm upgrade -i -n cert-manager cert-manager-csi-driver-spiffe jetstack/cert-manager-csi-driver-spiffe --wait \\ --set \"app.logLevel=1\" \\ --set \"app.trustDomain=my.trust.domain\" \\ --set \"app.approver.signerName=clusterissuers.cert-manager.io/csi-driver-spiffe-ca\" \\ \\ --set \"app.issuer.name=csi-driver-spiffe-ca\" \\ --set \"app.issuer.kind=ClusterIssuer\" \\ --set \"app.issuer.group=cert-manager.io\" \\ \\ --set \"app.driver.volumes[0].name=root-cas\" \\ --set \"app.driver.volumes[0].secret.secretName=csi-driver-spiffe-ca\" \\ --set \"app.driver.volumeMounts[0].name=root-cas\" \\ --set \"app.driver.volumeMounts[0].mountPath=/var/run/secrets/cert-manager-csi-driver-spiffe\" \\ --set \"app.driver.sourceCABundle=/var/run/secrets/cert-manager-csi-driver-spiffe/ca.crt\" $ kubectl rollout restart deployment -n sandbox my-csi-app $ kubectl exec -it -n sandbox $(kubectl get pod -n sandbox -l app=my-csi-app -o jsonpath='{.items[0].metadata.name}') -- ls /var/run/secrets/spiffe.io/ ca.crt tls.crt tls.key","title":"Root CA Bundle"},{"location":"projects/csi-driver/","text":"csi-driver is a Container Storage Interface (CSI) driver plugin for Kubernetes to work along cert-manager. The goal for this plugin is to seamlessly request and mount certificate key pairs to pods. This is useful for facilitating mTLS, or otherwise securing connections of pods with guaranteed present certificates whilst having all of the features that cert-manager provides. Why a CSI Driver? \u00b6 Ensure private keys never leave the node and are never sent over the network. All private keys are stored locally on the node. Unique key and certificate per application replica with a grantee to be present on application run time. Reduce resource management overhead by defining certificate request spec in-line of the Kubernetes Pod template. Automatic renewal of certificates based on expiry of each individual certificate. Keys and certificates are destroyed during application termination. Scope for extending plugin behavior with visibility on each replica's certificate request and termination. Requirements and Installation \u00b6 This CSI driver plugin makes use of the 'CSI inline volume' feature - Alpha as of v1.15 and beta in v1.16 . Kubernetes versions v1.16 and higher require no extra configuration however v1.15 requires the following feature gate set: --feature-gates=CSIInlineVolume=true You must have a working installation of cert-manager present on the cluster. Instructions on how to install cert-manager can be found on cert-manager.io . To install the csi-driver, use helm install: helm repo add jetstack https://charts.jetstack.io --force-update helm upgrade -i -n cert-manager cert-manager-csi-driver jetstack/cert-manager-csi-driver --wait Or apply the static manifests to your cluster: helm repo add jetstack https://charts.jetstack.io --force-update helm template jetstack/cert-manager-csi-driver | kubectl apply -n cert-manager -f - You can verify the installation has completed correctly by checking the presence of the CSIDriver resource as well as a CSINode resource present for each node, referencing csi.cert-manager.io . $ kubectl get csidrivers NAME CREATED AT csi.cert-manager.io 2019-09-06T16:55:19Z $ kubectl get csinodes -o yaml apiVersion: v1 items: - apiVersion: storage.k8s.io/v1beta1 kind: CSINode metadata: name: kind-control-plane ownerReferences: - apiVersion: v1 kind: Node name: kind-control-plane ... spec: drivers: - name: csi.cert-manager.io nodeID: kind-control-plane topologyKeys: null ... The CSI driver is now installed and is ready to be used for pods in the cluster. Requesting and Mounting Certificates \u00b6 To request certificates from cert-manager, simply define a volume mount where the key and certificate will be written to, along with a volume with attributes that define the cert-manager request. The following is a dummy app that mounts a key certificate pair to /tls and has been signed by the ca-issuer with a DNS name valid for my-service.sandbox.svc.cluster.local . apiVersion: v1 kind: Pod metadata: name: my-csi-app namespace: sandbox labels: app: my-csi-app spec: containers: - name: my-frontend image: busybox volumeMounts: - mountPath: \"/tls\" name: tls command: [ \"sleep\", \"1000000\" ] volumes: - name: tls csi: driver: csi.cert-manager.io volumeAttributes: csi.cert-manager.io/issuer-name: ca-issuer csi.cert-manager.io/dns-names: ${POD_NAME}.${POD_NAMESPACE}.svc.cluster.local Once created, the CSI driver will generate a private key locally, request a certificate from cert-manager based on the given attributes, then store both locally to be mounted to the pod. The pod will remain in a pending state until this process has been completed. For more information on how to set up issuers for your cluster, refer to the cert-manager documentation here . Note it is not possible to use SelfSigned Issuers with the CSI Driver. In order for cert-manager to self sign a certificate, it needs access to the secret containing the private key that signed the certificate request to sign the end certificate. This secret is not used and so not available in the CSI driver use case. Supported Volume Attributes \u00b6 The csi-driver driver aims to have complete feature parity with all possible values available through the cert-manager API however currently supports the following values; Attribute Description Default Example csi.cert-manager.io/issuer-name The Issuer name to sign the certificate request. ca-issuer csi.cert-manager.io/issuer-kind The Issuer kind to sign the certificate request. Issuer ClusterIssuer csi.cert-manager.io/issuer-group The group name the Issuer belongs to. cert-manager.io out.of.tree.foo csi.cert-manager.io/common-name Certificate common name (supports variables). my-cert.foo csi.cert-manager.io/dns-names DNS names the certificate will be requested for. At least a DNS Name, IP or URI name must be present (supports variables). a.b.foo.com,c.d.foo.com csi.cert-manager.io/ip-sans IP addresses the certificate will be requested for. 192.0.0.1,192.0.0.2 csi.cert-manager.io/uri-sans URI names the certificate will be requested for (supports variables). spiffe://foo.bar.cluster.local csi.cert-manager.io/duration Requested duration the signed certificate will be valid for. 720h 1880h csi.cert-manager.io/is-ca Mark the certificate as a certificate authority. false true csi.cert-manager.io/key-usages Set the key usages on the certificate request. digital signature,key encipherment server auth,client auth csi.cert-manager.io/key-encoding Set the key encoding format (PKCS1 or PKCS8). PKCS1 PKCS8 csi.cert-manager.io/certificate-file File name to store the certificate file at. tls.crt foo.crt csi.cert-manager.io/ca-file File name to store the ca certificate file at. ca.crt foo.ca csi.cert-manager.io/privatekey-file File name to store the key file at. tls.key foo.key csi.cert-manager.io/fs-group Set the FS Group of written files. Should be paired with and match the value of the consuming container runAsGroup . 2000 csi.cert-manager.io/renew-before The time to renew the certificate before expiry. Defaults to a third of the requested duration. $CERT_DURATION/3 72h csi.cert-manager.io/reuse-private-key Re-use the same private when when renewing certificates. false true csi.cert-manager.io/pkcs12-enable Enable writing the signed certificate chain and private key as a PKCS12 file. true csi.cert-manager.io/pkcs12-filename File location to write the PKCS12 file. Requires csi.cert-manager.io/keystore-pkcs12-enable be set to true . keystore.p12 tls.p12 csi.cert-manager.io/pkcs12-password Password used to encode the PKCS12 file. Required when PKCS12 is enabled ( csi.cert-manager.io/keystore-pkcs12-enable: true ). my-password Variables \u00b6 The following attributes support variables that are evaluated when a request is made for the mounting Pod. These variables are useful for constructing requests with SANs that contain values from the mounting Pod. `csi.cert-manager.io/common-name` `csi.cert-manager.io/dns-names` `csi.cert-manager.io/uri-sans` Variables follow the go os.Expand structure, which is generally what you would expect on a UNIX shell. The CSI driver has access to the following variables: ${POD_NAME} ${POD_NAMESPACE} ${POD_UID} ${SERVICE_ACCOUNT_NAME} Example Usage \u00b6 volumeAttributes : csi.cert-manager.io/issuer-name : ca-issuer csi.cert-manager.io/dns-names : \"${POD_NAME}.${POD_NAMESPACE}.svc.cluster.local\" csi.cert-manager.io/uri-sans : \"spiffe://cluster.local/ns/${POD_NAMESPACE}/pod/${POD_NAME}/${POD_UID}\" csi.cert-manager.io/common-name : \"${SERVICE_ACCOUNT_NAME}.${POD_NAMESPACE}\" Requesting Certificates using the mounting Pod's ServiceAccount \u00b6 If the flag --use-token-request is enabled on the csi-driver DaemonSet, the CertificateRequest resource will be created by the mounting Pod's ServiceAccount. This can be pared with approver-policy to enable advanced policy on a per ServiceAccount basis. Ensure to give permissions to Pod ServiceAccounts to create CertificateRequests with this flag enabled, i.e: # WARNING: This RBAC will enable any identiy in the cluster to create # CertificateRequests. This may or may not be problimatic based on your security # model. It is likely worth scoping the set of identities in the # `ClusterRoleBinding` `subjects` stanza. kind : ClusterRole apiVersion : rbac.authorization.k8s.io/v1 metadata : name : cert-manager-csi-driver-all-cr-create rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"certificaterequests\" ] verbs : [ \"create\" ] --- kind : ClusterRoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : cert-manager-csi-driver-all-cr-create roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-csi-driver-all-cr-create subjects : - apiGroup : rbac.authorization.k8s.io kind : Group name : system:authenticated","title":"csi-driver"},{"location":"projects/csi-driver/#why-a-csi-driver","text":"Ensure private keys never leave the node and are never sent over the network. All private keys are stored locally on the node. Unique key and certificate per application replica with a grantee to be present on application run time. Reduce resource management overhead by defining certificate request spec in-line of the Kubernetes Pod template. Automatic renewal of certificates based on expiry of each individual certificate. Keys and certificates are destroyed during application termination. Scope for extending plugin behavior with visibility on each replica's certificate request and termination.","title":"Why a CSI Driver?"},{"location":"projects/csi-driver/#requirements-and-installation","text":"This CSI driver plugin makes use of the 'CSI inline volume' feature - Alpha as of v1.15 and beta in v1.16 . Kubernetes versions v1.16 and higher require no extra configuration however v1.15 requires the following feature gate set: --feature-gates=CSIInlineVolume=true You must have a working installation of cert-manager present on the cluster. Instructions on how to install cert-manager can be found on cert-manager.io . To install the csi-driver, use helm install: helm repo add jetstack https://charts.jetstack.io --force-update helm upgrade -i -n cert-manager cert-manager-csi-driver jetstack/cert-manager-csi-driver --wait Or apply the static manifests to your cluster: helm repo add jetstack https://charts.jetstack.io --force-update helm template jetstack/cert-manager-csi-driver | kubectl apply -n cert-manager -f - You can verify the installation has completed correctly by checking the presence of the CSIDriver resource as well as a CSINode resource present for each node, referencing csi.cert-manager.io . $ kubectl get csidrivers NAME CREATED AT csi.cert-manager.io 2019-09-06T16:55:19Z $ kubectl get csinodes -o yaml apiVersion: v1 items: - apiVersion: storage.k8s.io/v1beta1 kind: CSINode metadata: name: kind-control-plane ownerReferences: - apiVersion: v1 kind: Node name: kind-control-plane ... spec: drivers: - name: csi.cert-manager.io nodeID: kind-control-plane topologyKeys: null ... The CSI driver is now installed and is ready to be used for pods in the cluster.","title":"Requirements and Installation"},{"location":"projects/csi-driver/#requesting-and-mounting-certificates","text":"To request certificates from cert-manager, simply define a volume mount where the key and certificate will be written to, along with a volume with attributes that define the cert-manager request. The following is a dummy app that mounts a key certificate pair to /tls and has been signed by the ca-issuer with a DNS name valid for my-service.sandbox.svc.cluster.local . apiVersion: v1 kind: Pod metadata: name: my-csi-app namespace: sandbox labels: app: my-csi-app spec: containers: - name: my-frontend image: busybox volumeMounts: - mountPath: \"/tls\" name: tls command: [ \"sleep\", \"1000000\" ] volumes: - name: tls csi: driver: csi.cert-manager.io volumeAttributes: csi.cert-manager.io/issuer-name: ca-issuer csi.cert-manager.io/dns-names: ${POD_NAME}.${POD_NAMESPACE}.svc.cluster.local Once created, the CSI driver will generate a private key locally, request a certificate from cert-manager based on the given attributes, then store both locally to be mounted to the pod. The pod will remain in a pending state until this process has been completed. For more information on how to set up issuers for your cluster, refer to the cert-manager documentation here . Note it is not possible to use SelfSigned Issuers with the CSI Driver. In order for cert-manager to self sign a certificate, it needs access to the secret containing the private key that signed the certificate request to sign the end certificate. This secret is not used and so not available in the CSI driver use case.","title":"Requesting and Mounting Certificates"},{"location":"projects/csi-driver/#supported-volume-attributes","text":"The csi-driver driver aims to have complete feature parity with all possible values available through the cert-manager API however currently supports the following values; Attribute Description Default Example csi.cert-manager.io/issuer-name The Issuer name to sign the certificate request. ca-issuer csi.cert-manager.io/issuer-kind The Issuer kind to sign the certificate request. Issuer ClusterIssuer csi.cert-manager.io/issuer-group The group name the Issuer belongs to. cert-manager.io out.of.tree.foo csi.cert-manager.io/common-name Certificate common name (supports variables). my-cert.foo csi.cert-manager.io/dns-names DNS names the certificate will be requested for. At least a DNS Name, IP or URI name must be present (supports variables). a.b.foo.com,c.d.foo.com csi.cert-manager.io/ip-sans IP addresses the certificate will be requested for. 192.0.0.1,192.0.0.2 csi.cert-manager.io/uri-sans URI names the certificate will be requested for (supports variables). spiffe://foo.bar.cluster.local csi.cert-manager.io/duration Requested duration the signed certificate will be valid for. 720h 1880h csi.cert-manager.io/is-ca Mark the certificate as a certificate authority. false true csi.cert-manager.io/key-usages Set the key usages on the certificate request. digital signature,key encipherment server auth,client auth csi.cert-manager.io/key-encoding Set the key encoding format (PKCS1 or PKCS8). PKCS1 PKCS8 csi.cert-manager.io/certificate-file File name to store the certificate file at. tls.crt foo.crt csi.cert-manager.io/ca-file File name to store the ca certificate file at. ca.crt foo.ca csi.cert-manager.io/privatekey-file File name to store the key file at. tls.key foo.key csi.cert-manager.io/fs-group Set the FS Group of written files. Should be paired with and match the value of the consuming container runAsGroup . 2000 csi.cert-manager.io/renew-before The time to renew the certificate before expiry. Defaults to a third of the requested duration. $CERT_DURATION/3 72h csi.cert-manager.io/reuse-private-key Re-use the same private when when renewing certificates. false true csi.cert-manager.io/pkcs12-enable Enable writing the signed certificate chain and private key as a PKCS12 file. true csi.cert-manager.io/pkcs12-filename File location to write the PKCS12 file. Requires csi.cert-manager.io/keystore-pkcs12-enable be set to true . keystore.p12 tls.p12 csi.cert-manager.io/pkcs12-password Password used to encode the PKCS12 file. Required when PKCS12 is enabled ( csi.cert-manager.io/keystore-pkcs12-enable: true ). my-password","title":"Supported Volume Attributes"},{"location":"projects/csi-driver/#variables","text":"The following attributes support variables that are evaluated when a request is made for the mounting Pod. These variables are useful for constructing requests with SANs that contain values from the mounting Pod. `csi.cert-manager.io/common-name` `csi.cert-manager.io/dns-names` `csi.cert-manager.io/uri-sans` Variables follow the go os.Expand structure, which is generally what you would expect on a UNIX shell. The CSI driver has access to the following variables: ${POD_NAME} ${POD_NAMESPACE} ${POD_UID} ${SERVICE_ACCOUNT_NAME}","title":"Variables"},{"location":"projects/csi-driver/#example-usage","text":"volumeAttributes : csi.cert-manager.io/issuer-name : ca-issuer csi.cert-manager.io/dns-names : \"${POD_NAME}.${POD_NAMESPACE}.svc.cluster.local\" csi.cert-manager.io/uri-sans : \"spiffe://cluster.local/ns/${POD_NAMESPACE}/pod/${POD_NAME}/${POD_UID}\" csi.cert-manager.io/common-name : \"${SERVICE_ACCOUNT_NAME}.${POD_NAMESPACE}\"","title":"Example Usage"},{"location":"projects/csi-driver/#requesting-certificates-using-the-mounting-pods-serviceaccount","text":"If the flag --use-token-request is enabled on the csi-driver DaemonSet, the CertificateRequest resource will be created by the mounting Pod's ServiceAccount. This can be pared with approver-policy to enable advanced policy on a per ServiceAccount basis. Ensure to give permissions to Pod ServiceAccounts to create CertificateRequests with this flag enabled, i.e: # WARNING: This RBAC will enable any identiy in the cluster to create # CertificateRequests. This may or may not be problimatic based on your security # model. It is likely worth scoping the set of identities in the # `ClusterRoleBinding` `subjects` stanza. kind : ClusterRole apiVersion : rbac.authorization.k8s.io/v1 metadata : name : cert-manager-csi-driver-all-cr-create rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"certificaterequests\" ] verbs : [ \"create\" ] --- kind : ClusterRoleBinding apiVersion : rbac.authorization.k8s.io/v1 metadata : name : cert-manager-csi-driver-all-cr-create roleRef : apiGroup : rbac.authorization.k8s.io kind : ClusterRole name : cert-manager-csi-driver-all-cr-create subjects : - apiGroup : rbac.authorization.k8s.io kind : Group name : system:authenticated","title":"Requesting Certificates using the mounting Pod's ServiceAccount"},{"location":"projects/istio-csr/","text":"istio-csr is an agent that allows for Istio workload and control plane components to be secured using cert-manager . Certificates facilitating mTLS \u2014 both inter and intra-cluster \u2014 will be signed, delivered and renewed using cert-manager issuers . Getting Started Guide For istio-csr \u00b6 We have a guide for setting up istio-csr in a fresh kind cluster. Following the guide is the best way to see istio-csr in action. If you've already seen istio-csr in action or if you're experienced with running Istio and just want quick installation instructions, read on for more details. Lower-Level Details (For Experienced Istio Users) \u00b6 \u26a0\ufe0f The getting started guide is a better place if you just want to try istio-csr out! Running istio-csr requires a few steps and preconditions in order: A cluster without Istio already installed cert-manager installed in the cluster An Issuer or ClusterIssuer which will be used to issue Istio certificates istio-csr installed (likely via helm) Istio installed with some custom config required, e.g. using the example config from the repository . Why Custom Istio Install Manifests? \u00b6 If you take a look at the contents of the example Istio install manifests there are a few custom configuration options which are important. Required changes include setting ENABLE_CA_SERVER to false and setting the caAddress from which Istio will request certificates; replacing the CA server is the whole point of istio-csr! Mounting and statically specifying the root CA is also an important recommended step. Without a manually specified root CA istio-csr defaults to trying to discover root CAs automatically, which could theoretically lead to a signer hijacking attack if for example a signer's token was stolen (such as the cert-manager controller's token). Issuer or ClusterIssuer? \u00b6 Unless you know you need a ClusterIssuer we'd recommend starting with an Issuer , since it should be easier to reason about the access controls for an Issuer; they're namespaced and so naturally a little more limited in scope. That said, if you view your entire Kubernetes cluster as being a trust domain itself, then a ClusterIssuer is the more natural fit. The best choice will depend on your specific situation. Our getting started guide uses an Issuer . Which Issuer Type? \u00b6 Whether you choose to use an Issuer or a ClusterIssuer , you'll also need to choose the type of issuer you want such as: CA Vault or an external issuer The key requirement is that arbitrary values can be placed into the subjectAltName (SAN) X.509 extension, since Istio places SPIFFE IDs there. That means that the ACME issuer will not work \u2014 publicly trusted certificates such as those issued by Let's Encrypt don't allow arbitrary entries in the SAN, for very good reasons. If you're already using HashiCorp Vault then the Vault issuer is an obvious choice. If you want to control your own PKI entirely, we'd recommend the CA issuer. The choice is ultimately yours. Installing istio-csr After Istio \u00b6 This is unsupported because it's exceptionally difficult to do safely. It's likely that installing istio-csr after Istio isn't possible to do without downtime, since installing istio-csr second would require a time period where all Istio sidecars trust both the old Istio-managed CA and the new cert-manager controlled CA. How Does istio-csr Work? \u00b6 istio-csr implements the gRPC Istio certificate service which authenticates, authorizes, and signs incoming certificate signing requests from Istio workloads, routing all certificate handling through cert-manager installed in the cluster. This seamlessly matches the behavior of istiod in a typical installation, while allowing certificate management through cert-manager.","title":"istio-csr"},{"location":"projects/istio-csr/#getting-started-guide-for-istio-csr","text":"We have a guide for setting up istio-csr in a fresh kind cluster. Following the guide is the best way to see istio-csr in action. If you've already seen istio-csr in action or if you're experienced with running Istio and just want quick installation instructions, read on for more details.","title":"Getting Started Guide For istio-csr"},{"location":"projects/istio-csr/#lower-level-details-for-experienced-istio-users","text":"\u26a0\ufe0f The getting started guide is a better place if you just want to try istio-csr out! Running istio-csr requires a few steps and preconditions in order: A cluster without Istio already installed cert-manager installed in the cluster An Issuer or ClusterIssuer which will be used to issue Istio certificates istio-csr installed (likely via helm) Istio installed with some custom config required, e.g. using the example config from the repository .","title":"Lower-Level Details (For Experienced Istio Users)"},{"location":"projects/istio-csr/#why-custom-istio-install-manifests","text":"If you take a look at the contents of the example Istio install manifests there are a few custom configuration options which are important. Required changes include setting ENABLE_CA_SERVER to false and setting the caAddress from which Istio will request certificates; replacing the CA server is the whole point of istio-csr! Mounting and statically specifying the root CA is also an important recommended step. Without a manually specified root CA istio-csr defaults to trying to discover root CAs automatically, which could theoretically lead to a signer hijacking attack if for example a signer's token was stolen (such as the cert-manager controller's token).","title":"Why Custom Istio Install Manifests?"},{"location":"projects/istio-csr/#issuer-or-clusterissuer","text":"Unless you know you need a ClusterIssuer we'd recommend starting with an Issuer , since it should be easier to reason about the access controls for an Issuer; they're namespaced and so naturally a little more limited in scope. That said, if you view your entire Kubernetes cluster as being a trust domain itself, then a ClusterIssuer is the more natural fit. The best choice will depend on your specific situation. Our getting started guide uses an Issuer .","title":"Issuer or ClusterIssuer?"},{"location":"projects/istio-csr/#which-issuer-type","text":"Whether you choose to use an Issuer or a ClusterIssuer , you'll also need to choose the type of issuer you want such as: CA Vault or an external issuer The key requirement is that arbitrary values can be placed into the subjectAltName (SAN) X.509 extension, since Istio places SPIFFE IDs there. That means that the ACME issuer will not work \u2014 publicly trusted certificates such as those issued by Let's Encrypt don't allow arbitrary entries in the SAN, for very good reasons. If you're already using HashiCorp Vault then the Vault issuer is an obvious choice. If you want to control your own PKI entirely, we'd recommend the CA issuer. The choice is ultimately yours.","title":"Which Issuer Type?"},{"location":"projects/istio-csr/#installing-istio-csr-after-istio","text":"This is unsupported because it's exceptionally difficult to do safely. It's likely that installing istio-csr after Istio isn't possible to do without downtime, since installing istio-csr second would require a time period where all Istio sidecars trust both the old Istio-managed CA and the new cert-manager controlled CA.","title":"Installing istio-csr After Istio"},{"location":"projects/istio-csr/#how-does-istio-csr-work","text":"istio-csr implements the gRPC Istio certificate service which authenticates, authorizes, and signs incoming certificate signing requests from Istio workloads, routing all certificate handling through cert-manager installed in the cluster. This seamlessly matches the behavior of istiod in a typical installation, while allowing certificate management through cert-manager.","title":"How Does istio-csr Work?"},{"location":"projects/trust-manager/","text":"Distributing Trust Bundles in Kubernetes \u00b6 trust-manager is an operator for distributing trust bundles across a Kubernetes cluster. trust-manager is designed to complement cert-manager by enabling services to trust X.509 certificates signed by Issuers, as well as external CAs which may not be known to cert-manager at all. Usage \u00b6 trust ships with a single cluster scoped Bundle resource. A Bundle represents a set of data that should be distributed and made available across the cluster. There are no constraints on what data can be distributed. The Bundle gathers and appends trust data from a number of sources located in the trust namespace (where the trust controller is deployed), and syncs them to a target in every namespace. A typical Bundle looks like the following: apiVersion : trust.cert-manager.io/v1alpha1 kind : Bundle metadata : name : my-org.com spec : sources : # A Secret in the trust namespace created via a cert-manager Certificate - secret : name : \"my-db-tls\" key : \"ca.crt\" # A ConfigMap in the trust namespace - configMap : name : \"my-org.net\" key : \"root-certs.pem\" # An In Line - inLine : | # my-org.com CA -----BEGIN CERTIFICATE----- MIIC5zCCAc+gAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJl .... 0V3NCaQrXoh+3xrXgX/vMdijYLUSo/YPEWmo -----END CERTIFICATE----- target : # Data synced to the ConfigMap `my-org.com` at the key `root-certs.pem` in # every namespace that has the label \"linkerd.io/inject=enabled\". configMap : key : \"root-certs.pem\" namespaceSelector : matchLabels : linkerd.io/inject : \"enabled\" Bundle currently supports the source types configMap , secret and inLine , and target type configMap . Namespace Selector \u00b6 The target namespaceSelector can be used for scoping which Namespaces targets are synced to, supporting the field matchLabels . Please see here for more information and how label selectors are configured. If namespaceSelector is empty, a bundle target will be synced to all Namespaces. Installation \u00b6 First, install cert-manager to the cluster, and then the trust operator. It is advised to run the trust operator in the cert-manager namespace. helm repo add jetstack https://charts.jetstack.io --force-update helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set installCRDs = true --wait --create-namespace helm upgrade -i -n cert-manager trust-manager jetstack/trust-manager --wait Quick Start Example \u00b6 kubectl create -n cert-manager configmap source-1 --from-literal = cm-key = 123 kubectl create -n cert-manager secret generic source-2 --from-literal = sec-key = ABC kubectl apply -f - <<EOF apiVersion: trust.cert-manager.io/v1alpha1 kind: Bundle metadata: name: example-bundle spec: sources: - configMap: name: \"source-1\" key: \"cm-key\" - secret: name: \"source-2\" key: \"sec-key\" - inLine: | hello world! target: configMap: key: \"target-key\" EOF kubectl get bundle NAME TARGET SYNCED REASON AGE example-bundle target-key True Synced 5s kubectl get cm -A --field-selector = metadata.name = example-bundle NAMESPACE NAME DATA AGE cert-manager example-bundle 1 2m18s default example-bundle 1 2m18s kube-node-lease example-bundle 1 2m18s kube-public example-bundle 1 2m18s kube-system example-bundle 1 2m18s local-path-storage example-bundle 1 2m18s kubectl get cm -n kube-system example-bundle -o jsonpath = \"{.data['target-key']}\" 123 ABC hello world!","title":"trust-manager"},{"location":"projects/trust-manager/#distributing-trust-bundles-in-kubernetes","text":"trust-manager is an operator for distributing trust bundles across a Kubernetes cluster. trust-manager is designed to complement cert-manager by enabling services to trust X.509 certificates signed by Issuers, as well as external CAs which may not be known to cert-manager at all.","title":"Distributing Trust Bundles in Kubernetes"},{"location":"projects/trust-manager/#usage","text":"trust ships with a single cluster scoped Bundle resource. A Bundle represents a set of data that should be distributed and made available across the cluster. There are no constraints on what data can be distributed. The Bundle gathers and appends trust data from a number of sources located in the trust namespace (where the trust controller is deployed), and syncs them to a target in every namespace. A typical Bundle looks like the following: apiVersion : trust.cert-manager.io/v1alpha1 kind : Bundle metadata : name : my-org.com spec : sources : # A Secret in the trust namespace created via a cert-manager Certificate - secret : name : \"my-db-tls\" key : \"ca.crt\" # A ConfigMap in the trust namespace - configMap : name : \"my-org.net\" key : \"root-certs.pem\" # An In Line - inLine : | # my-org.com CA -----BEGIN CERTIFICATE----- MIIC5zCCAc+gAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJl .... 0V3NCaQrXoh+3xrXgX/vMdijYLUSo/YPEWmo -----END CERTIFICATE----- target : # Data synced to the ConfigMap `my-org.com` at the key `root-certs.pem` in # every namespace that has the label \"linkerd.io/inject=enabled\". configMap : key : \"root-certs.pem\" namespaceSelector : matchLabels : linkerd.io/inject : \"enabled\" Bundle currently supports the source types configMap , secret and inLine , and target type configMap .","title":"Usage"},{"location":"projects/trust-manager/#namespace-selector","text":"The target namespaceSelector can be used for scoping which Namespaces targets are synced to, supporting the field matchLabels . Please see here for more information and how label selectors are configured. If namespaceSelector is empty, a bundle target will be synced to all Namespaces.","title":"Namespace Selector"},{"location":"projects/trust-manager/#installation","text":"First, install cert-manager to the cluster, and then the trust operator. It is advised to run the trust operator in the cert-manager namespace. helm repo add jetstack https://charts.jetstack.io --force-update helm upgrade -i -n cert-manager cert-manager jetstack/cert-manager --set installCRDs = true --wait --create-namespace helm upgrade -i -n cert-manager trust-manager jetstack/trust-manager --wait","title":"Installation"},{"location":"projects/trust-manager/#quick-start-example","text":"kubectl create -n cert-manager configmap source-1 --from-literal = cm-key = 123 kubectl create -n cert-manager secret generic source-2 --from-literal = sec-key = ABC kubectl apply -f - <<EOF apiVersion: trust.cert-manager.io/v1alpha1 kind: Bundle metadata: name: example-bundle spec: sources: - configMap: name: \"source-1\" key: \"cm-key\" - secret: name: \"source-2\" key: \"sec-key\" - inLine: | hello world! target: configMap: key: \"target-key\" EOF kubectl get bundle NAME TARGET SYNCED REASON AGE example-bundle target-key True Synced 5s kubectl get cm -A --field-selector = metadata.name = example-bundle NAMESPACE NAME DATA AGE cert-manager example-bundle 1 2m18s default example-bundle 1 2m18s kube-node-lease example-bundle 1 2m18s kube-public example-bundle 1 2m18s kube-system example-bundle 1 2m18s local-path-storage example-bundle 1 2m18s kubectl get cm -n kube-system example-bundle -o jsonpath = \"{.data['target-key']}\" 123 ABC hello world!","title":"Quick Start Example"},{"location":"reference/","text":"This section contains reference material including TLS terminology, API documentation, and information about the command line flags of the cert-manager components. TLS Terminology : Learn about the TLS terminology used in the cert-manager documentation such as publicly trusted , self-signed , root , intermediate and leaf certificate . Components / Docker Images : Learn about the command line flags of the cert-manager Docker images: controller , webhook , cainjector , acmesolver , which run in containers in your cluster. API Reference : Learn about the cert-manager API which includes Custom Resources such as Certificate, CertificateRequest, Issuer and ClusterIssuer.","title":"\u4ecb\u7ecd"},{"location":"reference/api-docs/","text":"Learn about the cert-manager API which includes Custom Resources such as Certificate, CertificateRequest, Issuer and ClusterIssuer. Packages: acme.cert-manager.io/v1 cert-manager.io/v1 meta.cert-manager.io/v1 webhook.config.cert-manager.io/v1alpha1 acme.cert-manager.io/v1 Package v1 is the v1 version of the API. Resource Types: Challenge Order Challenge Challenge is a type to represent a Challenge request with an ACME server Field Description apiVersion string acme.cert-manager.io/v1 kind string Challenge metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ChallengeSpec url string The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge. authorizationURL string The URL to the ACME Authorization resource that this challenge is a part of. dnsName string dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a \u2018wildcard\u2019, this field MUST be set to the non-wildcard domain, e.g. for *.example.com , it must be example.com . wildcard bool (Optional) wildcard will be true if this challenge is for a wildcard identifier, for example \u2018*.example.com\u2019. type ACMEChallengeType The type of ACME challenge this resource represents. One of \u201cHTTP-01\u201d or \u201cDNS-01\u201d. token string The ACME challenge token for this challenge. This is the raw value returned from the ACME server. key string The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: <private key JWK thumbprint>.<key from acme server for challenge> . For DNS01 challenges, this is the base64 encoded SHA256 sum of the <private key JWK thumbprint>.<key from acme server for challenge> text that must be set as the TXT record content. solver ACMEChallengeSolver Contains the domain solving configuration that should be used to solve this challenge resource. issuerRef ObjectReference References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an \u2018ACME\u2019 Issuer, an error will be returned and the Challenge will be marked as failed. status ChallengeStatus (Optional) Order Order is a type to represent an Order with an ACME server Field Description apiVersion string acme.cert-manager.io/v1 kind string Order metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec OrderSpec request []byte Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order. issuerRef ObjectReference IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an \u2018ACME\u2019 Issuer, an error will be returned and the Order will be marked as failed. commonName string (Optional) CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in dnsNames or ipAddresses . This field must match the corresponding field on the DER encoded CSR. dnsNames []string (Optional) DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR. ipAddresses []string (Optional) IPAddresses is a list of IP addresses that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR. duration Kubernetes meta/v1.Duration (Optional) Duration is the duration for the not after date for the requested certificate. this is set on order creation as pe the ACME spec. status OrderStatus (Optional) ACMEAuthorization ( Appears on: OrderStatus ) ACMEAuthorization contains data returned from the ACME server on an authorization that must be completed in order validate a DNS name on an ACME Order resource. Field Description url string URL is the URL of the Authorization that must be completed identifier string (Optional) Identifier is the DNS name to be validated as part of this authorization wildcard bool (Optional) Wildcard will be true if this authorization is for a wildcard DNS name. If this is true, the identifier will be the non-wildcard version of the DNS name. For example, if \u2018*.example.com\u2019 is the DNS name being validated, this field will be \u2018true\u2019 and the \u2018identifier\u2019 field will be \u2018example.com\u2019. initialState State (Optional) InitialState is the initial state of the ACME authorization when first fetched from the ACME server. If an Authorization is already \u2018valid\u2019, the Order controller will not create a Challenge resource for the authorization. This will occur when working with an ACME server that enables \u2018authz reuse\u2019 (such as Let\u2019s Encrypt\u2019s production endpoint). If not set and \u2018identifier\u2019 is set, the state is assumed to be pending and a Challenge will be created. challenges []ACMEChallenge (Optional) Challenges specifies the challenge types offered by the ACME server. One of these challenge types will be selected when validating the DNS name and an appropriate Challenge resource will be created to perform the ACME challenge process. ACMEChallenge ( Appears on: ACMEAuthorization ) Challenge specifies a challenge offered by the ACME server for an Order. An appropriate Challenge resource can be created to perform the ACME challenge process. Field Description url string URL is the URL of this challenge. It can be used to retrieve additional metadata about the Challenge from the ACME server. token string Token is the token that must be presented for this challenge. This is used to compute the \u2018key\u2019 that must also be presented. type string Type is the type of challenge being offered, e.g. \u2018http-01\u2019, \u2018dns-01\u2019, \u2018tls-sni-01\u2019, etc. This is the raw value retrieved from the ACME server. Only \u2018http-01\u2019 and \u2018dns-01\u2019 are supported by cert-manager, other values will be ignored. ACMEChallengeSolver ( Appears on: ACMEIssuer , ChallengeSpec ) An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of. A selector may be provided to use different solving strategies for different DNS names. Only one of HTTP01 or DNS01 must be provided. Field Description selector CertificateDNSNameSelector (Optional) Selector selects a set of DNSNames on the Certificate resource that should be solved using this challenge solver. If not specified, the solver will be treated as the \u2018default\u2019 solver with the lowest priority, i.e. if any other solver has a more specific match, it will be used instead. http01 ACMEChallengeSolverHTTP01 (Optional) Configures cert-manager to attempt to complete authorizations by performing the HTTP01 challenge flow. It is not possible to obtain certificates for wildcard domain names (e.g. *.example.com ) using the HTTP01 challenge mechanism. dns01 ACMEChallengeSolverDNS01 (Optional) Configures cert-manager to attempt to complete authorizations by performing the DNS01 challenge flow. ACMEChallengeSolverDNS01 ( Appears on: ACMEChallengeSolver ) Used to configure a DNS01 challenge provider to be used when solving DNS01 challenges. Only one DNS provider may be configured per solver. Field Description cnameStrategy CNAMEStrategy (Optional) CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones. akamai ACMEIssuerDNS01ProviderAkamai (Optional) Use the Akamai DNS zone management API to manage DNS01 challenge records. cloudDNS ACMEIssuerDNS01ProviderCloudDNS (Optional) Use the Google Cloud DNS API to manage DNS01 challenge records. cloudflare ACMEIssuerDNS01ProviderCloudflare (Optional) Use the Cloudflare API to manage DNS01 challenge records. route53 ACMEIssuerDNS01ProviderRoute53 (Optional) Use the AWS Route53 API to manage DNS01 challenge records. azureDNS ACMEIssuerDNS01ProviderAzureDNS (Optional) Use the Microsoft Azure DNS API to manage DNS01 challenge records. digitalocean ACMEIssuerDNS01ProviderDigitalOcean (Optional) Use the DigitalOcean DNS API to manage DNS01 challenge records. acmeDNS ACMEIssuerDNS01ProviderAcmeDNS (Optional) Use the \u2018ACME DNS\u2019 ( https://github.com/joohoi/acme-dns ) API to manage DNS01 challenge records. rfc2136 ACMEIssuerDNS01ProviderRFC2136 (Optional) Use RFC2136 (\u201cDynamic Updates in the Domain Name System\u201d) ( https://datatracker.ietf.org/doc/rfc2136/ ) to manage DNS01 challenge records. webhook ACMEIssuerDNS01ProviderWebhook (Optional) Configure an external webhook based DNS01 challenge solver to manage DNS01 challenge records. ACMEChallengeSolverHTTP01 ( Appears on: ACMEChallengeSolver ) ACMEChallengeSolverHTTP01 contains configuration detailing how to solve HTTP01 challenges within a Kubernetes cluster. Typically this is accomplished through creating \u2018routes\u2019 of some description that configure ingress controllers to direct traffic to \u2018solver pods\u2019, which are responsible for responding to the ACME server\u2019s HTTP requests. Only one of Ingress / Gateway can be specified. Field Description ingress ACMEChallengeSolverHTTP01Ingress (Optional) The ingress based HTTP01 challenge solver will solve challenges by creating or modifying Ingress resources in order to route requests for \u2018/.well-known/acme-challenge/XYZ\u2019 to \u2018challenge solver\u2019 pods that are provisioned by cert-manager for each Challenge to be completed. gatewayHTTPRoute ACMEChallengeSolverHTTP01GatewayHTTPRoute (Optional) The Gateway API is a sig-network community API that models service networking in Kubernetes ( https://gateway-api.sigs.k8s.io/ ). The Gateway solver will create HTTPRoutes with the specified labels in the same namespace as the challenge. This solver is experimental, and fields / behaviour may change in the future. ACMEChallengeSolverHTTP01GatewayHTTPRoute ( Appears on: ACMEChallengeSolverHTTP01 ) The ACMEChallengeSolverHTTP01GatewayHTTPRoute solver will create HTTPRoute objects for a Gateway class routing to an ACME challenge solver pod. Field Description serviceType Kubernetes core/v1.ServiceType (Optional) Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort. labels map[string]string (Optional) Custom labels that will be applied to HTTPRoutes created by cert-manager while solving HTTP-01 challenges. parentRefs []sigs.k8s.io/gateway-api/apis/v1alpha2.ParentReference When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute. cert-manager needs to know which parentRefs should be used when creating the HTTPRoute. Usually, the parentRef references a Gateway. See: https://gateway-api.sigs.k8s.io/v1alpha2/api-types/httproute/#attaching-to-gateways ACMEChallengeSolverHTTP01Ingress ( Appears on: ACMEChallengeSolverHTTP01 ) Field Description serviceType Kubernetes core/v1.ServiceType (Optional) Optional service type for Kubernetes solver service. Supported values are NodePort or ClusterIP. If unset, defaults to NodePort. class string (Optional) The ingress class to use when creating Ingress resources to solve ACME challenges that use this challenge solver. Only one of \u2018class\u2019 or \u2018name\u2019 may be specified. name string (Optional) The name of the ingress resource that should have ACME challenge solving routes inserted into it in order to solve HTTP01 challenges. This is typically used in conjunction with ingress controllers like ingress-gce, which maintains a 1:1 mapping between external IPs and ingress resources. podTemplate ACMEChallengeSolverHTTP01IngressPodTemplate (Optional) Optional pod template used to configure the ACME challenge solver pods used for HTTP01 challenges. ingressTemplate ACMEChallengeSolverHTTP01IngressTemplate (Optional) Optional ingress template used to configure the ACME challenge solver ingress used for HTTP01 challenges. ACMEChallengeSolverHTTP01IngressObjectMeta ( Appears on: ACMEChallengeSolverHTTP01IngressTemplate ) Field Description annotations map[string]string (Optional) Annotations that should be added to the created ACME HTTP01 solver ingress. labels map[string]string (Optional) Labels that should be added to the created ACME HTTP01 solver ingress. ACMEChallengeSolverHTTP01IngressPodObjectMeta ( Appears on: ACMEChallengeSolverHTTP01IngressPodTemplate ) Field Description annotations map[string]string (Optional) Annotations that should be added to the create ACME HTTP01 solver pods. labels map[string]string (Optional) Labels that should be added to the created ACME HTTP01 solver pods. ACMEChallengeSolverHTTP01IngressPodSpec ( Appears on: ACMEChallengeSolverHTTP01IngressPodTemplate ) Field Description nodeSelector map[string]string (Optional) NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node\u2019s labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/ affinity Kubernetes core/v1.Affinity (Optional) If specified, the pod\u2019s scheduling constraints tolerations []Kubernetes core/v1.Toleration (Optional) If specified, the pod\u2019s tolerations. priorityClassName string (Optional) If specified, the pod\u2019s priorityClassName. serviceAccountName string (Optional) If specified, the pod\u2019s service account ACMEChallengeSolverHTTP01IngressPodTemplate ( Appears on: ACMEChallengeSolverHTTP01Ingress ) Field Description metadata ACMEChallengeSolverHTTP01IngressPodObjectMeta (Optional) ObjectMeta overrides for the pod used to solve HTTP01 challenges. Only the \u2018labels\u2019 and \u2018annotations\u2019 fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values. spec ACMEChallengeSolverHTTP01IngressPodSpec (Optional) PodSpec defines overrides for the HTTP01 challenge solver pod. Only the \u2018priorityClassName\u2019, \u2018nodeSelector\u2019, \u2018affinity\u2019, \u2018serviceAccountName\u2019 and \u2018tolerations\u2019 fields are supported currently. All other fields will be ignored. nodeSelector map[string]string (Optional) NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node\u2019s labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/ affinity Kubernetes core/v1.Affinity (Optional) If specified, the pod\u2019s scheduling constraints tolerations []Kubernetes core/v1.Toleration (Optional) If specified, the pod\u2019s tolerations. priorityClassName string (Optional) If specified, the pod\u2019s priorityClassName. serviceAccountName string (Optional) If specified, the pod\u2019s service account ACMEChallengeSolverHTTP01IngressTemplate ( Appears on: ACMEChallengeSolverHTTP01Ingress ) Field Description metadata ACMEChallengeSolverHTTP01IngressObjectMeta (Optional) ObjectMeta overrides for the ingress used to solve HTTP01 challenges. Only the \u2018labels\u2019 and \u2018annotations\u2019 fields may be set. If labels or annotations overlap with in-built values, the values here will override the in-built values. ACMEChallengeType ( string alias) ( Appears on: ChallengeSpec ) The type of ACME challenge. Only HTTP-01 and DNS-01 are supported. Value Description \"DNS-01\" ACMEChallengeTypeDNS01 denotes a Challenge is of type dns-01 More info: https://letsencrypt.org/docs/challenge-types/#dns-01-challenge \"HTTP-01\" ACMEChallengeTypeHTTP01 denotes a Challenge is of type http-01 More info: https://letsencrypt.org/docs/challenge-types/#http-01-challenge ACMEExternalAccountBinding ( Appears on: ACMEIssuer ) ACMEExternalAccountBinding is a reference to a CA external account of the ACME server. Field Description keyID string keyID is the ID of the CA key that the External Account is bound to. keySecretRef SecretKeySelector keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes Secret which holds the symmetric MAC key of the External Account Binding. The key is the index string that is paired with the key data in the Secret and should not be confused with the key data itself, or indeed with the External Account Binding keyID above. The secret key stored in the Secret must be un-padded, base64 URL encoded data. keyAlgorithm HMACKeyAlgorithm (Optional) Deprecated: keyAlgorithm field exists for historical compatibility reasons and should not be used. The algorithm is now hardcoded to HS256 in golang/x/crypto/acme. ACMEIssuer ( Appears on: IssuerConfig ) ACMEIssuer contains the specification for an ACME issuer. This uses the RFC8555 specification to obtain certificates by completing \u2018challenges\u2019 to prove ownership of domain identifiers. Earlier draft versions of the ACME specification are not supported. Field Description email string (Optional) Email is the email address to be associated with the ACME account. This field is optional, but it is strongly recommended to be set. It will be used to contact you in case of issues with your account or certificates, including expiry notification emails. This field may be updated after the account is initially registered. server string Server is the URL used to access the ACME server\u2019s \u2018directory\u2019 endpoint. For example, for Let\u2019s Encrypt\u2019s staging endpoint, you would use: \u201c https://acme-staging-v02.api.letsencrypt.org/directory\u201d . Only ACME v2 endpoints (i.e. RFC 8555) are supported. preferredChain string (Optional) PreferredChain is the chain to use if the ACME server outputs multiple. PreferredChain is no guarantee that this one gets delivered by the ACME endpoint. For example, for Let\u2019s Encrypt\u2019s DST crosssign you would use: \u201cDST Root CA X3\u201d or \u201cISRG Root X1\u201d for the newer Let\u2019s Encrypt root CA. This value picks the first certificate bundle in the ACME alternative chains that has a certificate with this value as its issuer\u2019s CN skipTLSVerify bool (Optional) Enables or disables validation of the ACME server TLS certificate. If true, requests to the ACME server will not have their TLS certificate validated (i.e. insecure connections will be allowed). Only enable this option in development environments. The cert-manager system installed roots will be used to verify connections to the ACME server if this is false. Defaults to false. externalAccountBinding ACMEExternalAccountBinding (Optional) ExternalAccountBinding is a reference to a CA external account of the ACME server. If set, upon registration cert-manager will attempt to associate the given external account credentials with the registered ACME account. privateKeySecretRef SecretKeySelector PrivateKey is the name of a Kubernetes Secret resource that will be used to store the automatically generated ACME account private key. Optionally, a key may be specified to select a specific entry within the named Secret resource. If key is not specified, a default of tls.key will be used. solvers []ACMEChallengeSolver (Optional) Solvers is a list of challenge solvers that will be used to solve ACME challenges for the matching domains. Solver configurations must be provided in order to obtain certificates from an ACME server. For more information, see: https://cert-manager.io/docs/configuration/acme/ disableAccountKeyGeneration bool (Optional) Enables or disables generating a new ACME account key. If true, the Issuer resource will not request a new account but will expect the account key to be supplied via an existing secret. If false, the cert-manager system will generate a new ACME account key for the Issuer. Defaults to false. enableDurationFeature bool (Optional) Enables requesting a Not After date on certificates that matches the duration of the certificate. This is not supported by all ACME servers like Let\u2019s Encrypt. If set to true when the ACME server does not support it it will create an error on the Order. Defaults to false. ACMEIssuerDNS01ProviderAcmeDNS ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderAcmeDNS is a structure containing the configuration for ACME-DNS servers Field Description host string accountSecretRef SecretKeySelector ACMEIssuerDNS01ProviderAkamai ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderAkamai is a structure containing the DNS configuration for Akamai DNS\u2014Zone Record Management API Field Description serviceConsumerDomain string clientTokenSecretRef SecretKeySelector clientSecretSecretRef SecretKeySelector accessTokenSecretRef SecretKeySelector ACMEIssuerDNS01ProviderAzureDNS ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderAzureDNS is a structure containing the configuration for Azure DNS Field Description clientID string (Optional) if both this and ClientSecret are left unset MSI will be used clientSecretSecretRef SecretKeySelector (Optional) if both this and ClientID are left unset MSI will be used subscriptionID string ID of the Azure subscription tenantID string (Optional) when specifying ClientID and ClientSecret then this field is also needed resourceGroupName string resource group the DNS zone is located in hostedZoneName string (Optional) name of the DNS zone that should be used environment AzureDNSEnvironment (Optional) name of the Azure environment (default AzurePublicCloud) managedIdentity AzureManagedIdentity (Optional) managed identity configuration, can not be used at the same time as clientID, clientSecretSecretRef or tenantID ACMEIssuerDNS01ProviderCloudDNS ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderCloudDNS is a structure containing the DNS configuration for Google Cloud DNS Field Description serviceAccountSecretRef SecretKeySelector (Optional) project string hostedZoneName string (Optional) HostedZoneName is an optional field that tells cert-manager in which Cloud DNS zone the challenge record has to be created. If left empty cert-manager will automatically choose a zone. ACMEIssuerDNS01ProviderCloudflare ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderCloudflare is a structure containing the DNS configuration for Cloudflare. One of apiKeySecretRef or apiTokenSecretRef must be provided. Field Description email string (Optional) Email of the account, only required when using API key based authentication. apiKeySecretRef SecretKeySelector (Optional) API key to use to authenticate with Cloudflare. Note: using an API token to authenticate is now the recommended method as it allows greater control of permissions. apiTokenSecretRef SecretKeySelector (Optional) API token used to authenticate with Cloudflare. ACMEIssuerDNS01ProviderDigitalOcean ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderDigitalOcean is a structure containing the DNS configuration for DigitalOcean Domains Field Description tokenSecretRef SecretKeySelector ACMEIssuerDNS01ProviderRFC2136 ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderRFC2136 is a structure containing the configuration for RFC2136 DNS Field Description nameserver string The IP address or hostname of an authoritative DNS server supporting RFC2136 in the form host:port. If the host is an IPv6 address it must be enclosed in square brackets (e.g [2001:db8::1]) ; port is optional. This field is required. tsigSecretSecretRef SecretKeySelector (Optional) The name of the secret containing the TSIG value. If tsigKeyName is defined, this field is required. tsigKeyName string (Optional) The TSIG Key name configured in the DNS. If tsigSecretSecretRef is defined, this field is required. tsigAlgorithm string (Optional) The TSIG Algorithm configured in the DNS supporting RFC2136. Used only when tsigSecretSecretRef and tsigKeyName are defined. Supported values are (case-insensitive): HMACMD5 (default), HMACSHA1 , HMACSHA256 or HMACSHA512 . ACMEIssuerDNS01ProviderRoute53 ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderRoute53 is a structure containing the Route 53 configuration for AWS Field Description accessKeyID string (Optional) The AccessKeyID is used for authentication. Cannot be set when SecretAccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials accessKeyIDSecretRef SecretKeySelector (Optional) The SecretAccessKey is used for authentication. If set, pull the AWS access key ID from a key within a Kubernetes Secret. Cannot be set when AccessKeyID is set. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials secretAccessKeySecretRef SecretKeySelector (Optional) The SecretAccessKey is used for authentication. If neither the Access Key nor Key ID are set, we fall-back to using env vars, shared credentials file or AWS Instance metadata, see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials role string (Optional) Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata hostedZoneID string (Optional) If set, the provider will manage only this zone in Route53 and will not do an lookup using the route53:ListHostedZonesByName api call. region string Always set the region when using AccessKeyID and SecretAccessKey ACMEIssuerDNS01ProviderWebhook ( Appears on: ACMEChallengeSolverDNS01 ) ACMEIssuerDNS01ProviderWebhook specifies configuration for a webhook DNS01 provider, including where to POST ChallengePayload resources. Field Description groupName string The API group name that should be used when POSTing ChallengePayload resources to the webhook apiserver. This should be the same as the GroupName specified in the webhook provider implementation. solverName string The name of the solver to use, as defined in the webhook provider implementation. This will typically be the name of the provider, e.g. \u2018cloudflare\u2019. config Kubernetes apiextensions/v1.JSON (Optional) Additional configuration that should be passed to the webhook apiserver when challenges are processed. This can contain arbitrary JSON data. Secret values should not be specified in this stanza. If secret values are needed (e.g. credentials for a DNS service), you should use a SecretKeySelector to reference a Secret resource. For details on the schema of this field, consult the webhook provider implementation\u2019s documentation. ACMEIssuerStatus ( Appears on: IssuerStatus ) Field Description uri string (Optional) URI is the unique account identifier, which can also be used to retrieve account details from the CA lastRegisteredEmail string (Optional) LastRegisteredEmail is the email associated with the latest registered ACME account, in order to track changes made to registered account associated with the Issuer AzureDNSEnvironment ( string alias) ( Appears on: ACMEIssuerDNS01ProviderAzureDNS ) Value Description \"AzureChinaCloud\" \"AzureGermanCloud\" \"AzurePublicCloud\" \"AzureUSGovernmentCloud\" AzureManagedIdentity ( Appears on: ACMEIssuerDNS01ProviderAzureDNS ) Field Description clientID string (Optional) client ID of the managed identity, can not be used at the same time as resourceID resourceID string (Optional) resource ID of the managed identity, can not be used at the same time as clientID CNAMEStrategy ( string alias) ( Appears on: ACMEChallengeSolverDNS01 ) CNAMEStrategy configures how the DNS01 provider should handle CNAME records when found in DNS zones. By default, the None strategy will be applied (i.e. do not follow CNAMEs). CertificateDNSNameSelector ( Appears on: ACMEChallengeSolver ) CertificateDNSNameSelector selects certificates using a label selector, and can optionally select individual DNS names within those certificates. If both MatchLabels and DNSNames are empty, this selector will match all certificates and DNS names within them. Field Description matchLabels map[string]string (Optional) A label selector that is used to refine the set of certificate\u2019s that this challenge solver will apply to. dnsNames []string (Optional) List of DNSNames that this solver will be used to solve. If specified and a match is found, a dnsNames selector will take precedence over a dnsZones selector. If multiple solvers match with the same dnsNames value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. dnsZones []string (Optional) List of DNSZones that this solver will be used to solve. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com. If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. ChallengeSpec ( Appears on: Challenge ) Field Description url string The URL of the ACME Challenge resource for this challenge. This can be used to lookup details about the status of this challenge. authorizationURL string The URL to the ACME Authorization resource that this challenge is a part of. dnsName string dnsName is the identifier that this challenge is for, e.g. example.com. If the requested DNSName is a \u2018wildcard\u2019, this field MUST be set to the non-wildcard domain, e.g. for *.example.com , it must be example.com . wildcard bool (Optional) wildcard will be true if this challenge is for a wildcard identifier, for example \u2018*.example.com\u2019. type ACMEChallengeType The type of ACME challenge this resource represents. One of \u201cHTTP-01\u201d or \u201cDNS-01\u201d. token string The ACME challenge token for this challenge. This is the raw value returned from the ACME server. key string The ACME challenge key for this challenge For HTTP01 challenges, this is the value that must be responded with to complete the HTTP01 challenge in the format: <private key JWK thumbprint>.<key from acme server for challenge> . For DNS01 challenges, this is the base64 encoded SHA256 sum of the <private key JWK thumbprint>.<key from acme server for challenge> text that must be set as the TXT record content. solver ACMEChallengeSolver Contains the domain solving configuration that should be used to solve this challenge resource. issuerRef ObjectReference References a properly configured ACME-type Issuer which should be used to create this Challenge. If the Issuer does not exist, processing will be retried. If the Issuer is not an \u2018ACME\u2019 Issuer, an error will be returned and the Challenge will be marked as failed. ChallengeStatus ( Appears on: Challenge ) Field Description processing bool (Optional) Used to denote whether this challenge should be processed or not. This field will only be set to true by the \u2018scheduling\u2019 component. It will only be set to false by the \u2018challenges\u2019 controller, after the challenge has reached a final state or timed out. If this field is set to false, the challenge controller will not take any more action. presented bool (Optional) presented will be set to true if the challenge values for this challenge are currently \u2018presented\u2019. This does not imply the self check is passing. Only that the values have been \u2018submitted\u2019 for the appropriate challenge mechanism (i.e. the DNS01 TXT record has been presented, or the HTTP01 configuration has been configured). reason string (Optional) Contains human readable information on why the Challenge is in the current state. state State (Optional) Contains the current \u2018state\u2019 of the challenge. If not set, the state of the challenge is unknown. HMACKeyAlgorithm ( string alias) ( Appears on: ACMEExternalAccountBinding ) HMACKeyAlgorithm is the name of a key algorithm used for HMAC encryption Value Description \"HS256\" \"HS384\" \"HS512\" OrderSpec ( Appears on: Order ) Field Description request []byte Certificate signing request bytes in DER encoding. This will be used when finalizing the order. This field must be set on the order. issuerRef ObjectReference IssuerRef references a properly configured ACME-type Issuer which should be used to create this Order. If the Issuer does not exist, processing will be retried. If the Issuer is not an \u2018ACME\u2019 Issuer, an error will be returned and the Order will be marked as failed. commonName string (Optional) CommonName is the common name as specified on the DER encoded CSR. If specified, this value must also be present in dnsNames or ipAddresses . This field must match the corresponding field on the DER encoded CSR. dnsNames []string (Optional) DNSNames is a list of DNS names that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR. ipAddresses []string (Optional) IPAddresses is a list of IP addresses that should be included as part of the Order validation process. This field must match the corresponding field on the DER encoded CSR. duration Kubernetes meta/v1.Duration (Optional) Duration is the duration for the not after date for the requested certificate. this is set on order creation as pe the ACME spec. OrderStatus ( Appears on: Order ) Field Description url string (Optional) URL of the Order. This will initially be empty when the resource is first created. The Order controller will populate this field when the Order is first processed. This field will be immutable after it is initially set. finalizeURL string (Optional) FinalizeURL of the Order. This is used to obtain certificates for this order once it has been completed. authorizations []ACMEAuthorization (Optional) Authorizations contains data returned from the ACME server on what authorizations must be completed in order to validate the DNS names specified on the Order. certificate []byte (Optional) Certificate is a copy of the PEM encoded certificate for this Order. This field will be populated after the order has been successfully finalized with the ACME server, and the order has transitioned to the \u2018valid\u2019 state. state State (Optional) State contains the current state of this Order resource. States \u2018success\u2019 and \u2018expired\u2019 are \u2018final\u2019 reason string (Optional) Reason optionally provides more information about a why the order is in the current state. failureTime Kubernetes meta/v1.Time (Optional) FailureTime stores the time that this order failed. This is used to influence garbage collection and back-off. State ( string alias) ( Appears on: ACMEAuthorization , ChallengeStatus , OrderStatus ) State represents the state of an ACME resource, such as an Order. The possible options here map to the corresponding values in the ACME specification. Full details of these values can be found here: https://tools.ietf.org/html/draft-ietf-acme-acme-15#section-7.1.6 Clients utilising this type must also gracefully handle unknown values, as the contents of this enumeration may be added to over time. Value Description \"errored\" Errored signifies that the ACME resource has errored for some reason. This is a catch-all state, and is used for marking internal cert-manager errors such as validation failures. This is a final state. \"expired\" Expired signifies that an ACME resource has expired. If an Order is marked \u2018Expired\u2019, one of its validations may have expired or the Order itself. This is a final state. \"invalid\" Invalid signifies that an ACME resource is invalid for some reason. If an Order is marked \u2018invalid\u2019, one of its validations be have invalid for some reason. This is a final state. \"pending\" Pending signifies that an ACME resource is still pending and is not yet ready. If an Order is marked \u2018Pending\u2019, the validations for that Order are still in progress. This is a transient state. \"processing\" Processing signifies that an ACME resource is being processed by the server. If an Order is marked \u2018Processing\u2019, the validations for that Order are currently being processed. This is a transient state. \"ready\" Ready signifies that an ACME resource is in a ready state. If an order is \u2018ready\u2019, all of its challenges have been completed successfully and the order is ready to be finalized. Once finalized, it will transition to the Valid state. This is a transient state. \"\" Unknown is not a real state as part of the ACME spec. It is used to represent an unrecognised value. \"valid\" Valid signifies that an ACME resource is in a valid state. If an order is \u2018valid\u2019, it has been finalized with the ACME server and the certificate can be retrieved from the ACME server using the certificate URL stored in the Order\u2019s status subresource. This is a final state. cert-manager.io/v1 Package v1 is the v1 version of the API. Resource Types: Certificate CertificateRequest ClusterIssuer Issuer Certificate A Certificate resource should be created to ensure an up to date and signed x509 certificate is stored in the Kubernetes Secret resource named in spec.secretName . The stored certificate will be renewed before it expires (as configured by spec.renewBefore ). Field Description apiVersion string cert-manager.io/v1 kind string Certificate metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec CertificateSpec Desired state of the Certificate resource. subject X509Subject (Optional) Full X509 name specification ( https://golang.org/pkg/crypto/x509/pkix/#Name ). literalSubject string (Optional) LiteralSubject is an LDAP formatted string that represents the X.509 Subject field . Use this instead of the Subject field if you need to ensure the correct ordering of the RDN sequence, such as when issuing certs for LDAP authentication. See https://github.com/cert-manager/cert-manager/issues/3203 , https://github.com/cert-manager/cert-manager/issues/4424 . This field is alpha level and is only supported by cert-manager installations where LiteralCertificateSubject feature gate is enabled on both cert-manager controller and webhook. commonName string (Optional) CommonName is a common name to be used on the Certificate. The CommonName should have a length of 64 characters or fewer to avoid generating invalid CSRs. This value is ignored by TLS clients when any subject alt name is set. This is x509 behaviour: https://tools.ietf.org/html/rfc6125#section-6.4.4 duration Kubernetes meta/v1.Duration (Optional) The requested \u2018duration\u2019 (i.e. lifetime) of the Certificate. This option may be ignored/overridden by some issuer types. If unset this defaults to 90 days. Certificate will be renewed either 2 \u2044 3 through its duration or renewBefore period before its expiry, whichever is later. Minimum accepted duration is 1 hour. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration renewBefore Kubernetes meta/v1.Duration (Optional) How long before the currently issued certificate\u2019s expiry cert-manager should renew the certificate. The default is 2 \u2044 3 of the issued certificate\u2019s duration. Minimum accepted value is 5 minutes. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration dnsNames []string (Optional) DNSNames is a list of DNS subjectAltNames to be set on the Certificate. ipAddresses []string (Optional) IPAddresses is a list of IP address subjectAltNames to be set on the Certificate. uris []string (Optional) URIs is a list of URI subjectAltNames to be set on the Certificate. emailAddresses []string (Optional) EmailAddresses is a list of email subjectAltNames to be set on the Certificate. secretName string SecretName is the name of the secret resource that will be automatically created and managed by this Certificate resource. It will be populated with a private key and certificate, signed by the denoted issuer. secretTemplate CertificateSecretTemplate (Optional) SecretTemplate defines annotations and labels to be copied to the Certificate\u2019s Secret. Labels and annotations on the Secret will be changed as they appear on the SecretTemplate when added or removed. SecretTemplate annotations are added in conjunction with, and cannot overwrite, the base set of annotations cert-manager sets on the Certificate\u2019s Secret. keystores CertificateKeystores (Optional) Keystores configures additional keystore output formats stored in the secretName Secret resource. issuerRef ObjectReference IssuerRef is a reference to the issuer for this certificate. If the kind field is not set, or set to Issuer , an Issuer resource with the given name in the same namespace as the Certificate will be used. If the kind field is set to ClusterIssuer , a ClusterIssuer with the provided name will be used. The name field in this stanza is required at all times. isCA bool (Optional) IsCA will mark this Certificate as valid for certificate signing. This will automatically add the cert sign usage to the list of usages . usages []KeyUsage (Optional) Usages is the set of x509 usages that are requested for the certificate. Defaults to digital signature and key encipherment if not specified. privateKey CertificatePrivateKey (Optional) Options to control private keys used for the Certificate. encodeUsagesInRequest bool (Optional) EncodeUsagesInRequest controls whether key usages should be present in the CertificateRequest revisionHistoryLimit int32 (Optional) revisionHistoryLimit is the maximum number of CertificateRequest revisions that are maintained in the Certificate\u2019s history. Each revision represents a single CertificateRequest created by this Certificate, either when it was created, renewed, or Spec was changed. Revisions will be removed by oldest first if the number of revisions exceeds this number. If set, revisionHistoryLimit must be a value of 1 or greater. If unset ( nil ), revisions will not be garbage collected. Default value is nil . additionalOutputFormats []CertificateAdditionalOutputFormat (Optional) AdditionalOutputFormats defines extra output formats of the private key and signed certificate chain to be written to this Certificate\u2019s target Secret. This is an Alpha Feature and is only enabled with the --feature-gates=AdditionalCertificateOutputFormats=true option on both the controller and webhook components. status CertificateStatus (Optional) Status of the Certificate. This is set and managed automatically. CertificateRequest A CertificateRequest is used to request a signed certificate from one of the configured issuers. All fields within the CertificateRequest\u2019s spec are immutable after creation. A CertificateRequest will either succeed or fail, as denoted by its status.state field. A CertificateRequest is a one-shot resource, meaning it represents a single point in time request for a certificate and cannot be re-used. Field Description apiVersion string cert-manager.io/v1 kind string CertificateRequest metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec CertificateRequestSpec Desired state of the CertificateRequest resource. duration Kubernetes meta/v1.Duration (Optional) The requested \u2018duration\u2019 (i.e. lifetime) of the Certificate. This option may be ignored/overridden by some issuer types. issuerRef ObjectReference IssuerRef is a reference to the issuer for this CertificateRequest. If the kind field is not set, or set to Issuer , an Issuer resource with the given name in the same namespace as the CertificateRequest will be used. If the kind field is set to ClusterIssuer , a ClusterIssuer with the provided name will be used. The name field in this stanza is required at all times. The group field refers to the API group of the issuer which defaults to cert-manager.io if empty. request []byte The PEM-encoded x509 certificate signing request to be submitted to the CA for signing. isCA bool (Optional) IsCA will request to mark the certificate as valid for certificate signing when submitting to the issuer. This will automatically add the cert sign usage to the list of usages . usages []KeyUsage (Optional) Usages is the set of x509 usages that are requested for the certificate. If usages are set they SHOULD be encoded inside the CSR spec Defaults to digital signature and key encipherment if not specified. username string (Optional) Username contains the name of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. uid string (Optional) UID contains the uid of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. groups []string (Optional) Groups contains group membership of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. extra map[string][]string (Optional) Extra contains extra attributes of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. status CertificateRequestStatus (Optional) Status of the CertificateRequest. This is set and managed automatically. ClusterIssuer A ClusterIssuer represents a certificate issuing authority which can be referenced as part of issuerRef fields. It is similar to an Issuer, however it is cluster-scoped and therefore can be referenced by resources that exist in any namespace, not just the same namespace as the referent. Field Description apiVersion string cert-manager.io/v1 kind string ClusterIssuer metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec IssuerSpec Desired state of the ClusterIssuer resource. IssuerConfig IssuerConfig (Members of IssuerConfig are embedded into this type.) status IssuerStatus (Optional) Status of the ClusterIssuer. This is set and managed automatically. Issuer An Issuer represents a certificate issuing authority which can be referenced as part of issuerRef fields. It is scoped to a single namespace and can therefore only be referenced by resources within the same namespace. Field Description apiVersion string cert-manager.io/v1 kind string Issuer metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec IssuerSpec Desired state of the Issuer resource. IssuerConfig IssuerConfig (Members of IssuerConfig are embedded into this type.) status IssuerStatus (Optional) Status of the Issuer. This is set and managed automatically. CAIssuer ( Appears on: IssuerConfig ) Field Description secretName string SecretName is the name of the secret used to sign Certificates issued by this Issuer. crlDistributionPoints []string (Optional) The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set, certificates will be issued without distribution points set. ocspServers []string (Optional) The OCSP server list is an X.509 v3 extension that defines a list of URLs of OCSP responders. The OCSP responders can be queried for the revocation status of an issued certificate. If not set, the certificate will be issued with no OCSP servers set. For example, an OCSP server URL could be \u201c http://ocsp.int-x3.letsencrypt.org\u201d . CertificateAdditionalOutputFormat ( Appears on: CertificateSpec ) CertificateAdditionalOutputFormat defines an additional output format of a Certificate resource. These contain supplementary data formats of the signed certificate chain and paired private key. Field Description type CertificateOutputFormatType Type is the name of the format type that should be written to the Certificate\u2019s target Secret. CertificateCondition ( Appears on: CertificateStatus ) CertificateCondition contains condition information for an Certificate. Field Description type CertificateConditionType Type of the condition, known values are ( Ready , Issuing ). status ConditionStatus Status of the condition, one of ( True , False , Unknown ). lastTransitionTime Kubernetes meta/v1.Time (Optional) LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string (Optional) Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. observedGeneration int64 (Optional) If set, this represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.condition[x].observedGeneration is 9, the condition is out of date with respect to the current state of the Certificate. CertificateConditionType ( string alias) ( Appears on: CertificateCondition ) CertificateConditionType represents an Certificate condition value. Value Description \"Issuing\" A condition added to Certificate resources when an issuance is required. This condition will be automatically added and set to true if: * No keypair data exists in the target Secret * The data stored in the Secret cannot be decoded * The private key and certificate do not have matching public keys * If a CertificateRequest for the current revision exists and the certificate data stored in the Secret does not match the status.certificate on the CertificateRequest. * If no CertificateRequest resource exists for the current revision, the options on the Certificate resource are compared against the x509 data in the Secret, similar to what\u2019s done in earlier versions. If there is a mismatch, an issuance is triggered. This condition may also be added by external API consumers to trigger a re-issuance manually for any other reason. It will be removed by the \u2018issuing\u2019 controller upon completing issuance. \"Ready\" CertificateConditionReady indicates that a certificate is ready for use. This is defined as: - The target secret exists - The target secret contains a certificate that has not expired - The target secret contains a private key valid for the certificate - The commonName and dnsNames attributes match those specified on the Certificate CertificateKeystores ( Appears on: CertificateSpec ) CertificateKeystores configures additional keystore output formats to be created in the Certificate\u2019s output Secret. Field Description jks JKSKeystore (Optional) JKS configures options for storing a JKS keystore in the spec.secretName Secret resource. pkcs12 PKCS12Keystore (Optional) PKCS12 configures options for storing a PKCS12 keystore in the spec.secretName Secret resource. CertificateOutputFormatType ( string alias) ( Appears on: CertificateAdditionalOutputFormat ) CertificateOutputFormatType specifies which additional output formats should be written to the Certificate\u2019s target Secret. Allowed values are DER or CombinedPEM . When Type is set to DER an additional entry key.der will be written to the Secret, containing the binary format of the private key. When Type is set to CombinedPEM an additional entry tls-combined.pem will be written to the Secret, containing the PEM formatted private key and signed certificate chain (tls.key + tls.crt concatenated). Value Description \"CombinedPEM\" CertificateOutputFormatCombinedPEM writes the Certificate\u2019s signed certificate chain and private key, in PEM format, to the tls-combined.pem target Secret Data key. The value at this key will include the private key PEM document, followed by at least one new line character, followed by the chain of signed certificate PEM documents ( <private key> + \\n + <signed certificate chain> ). \"DER\" CertificateOutputFormatDER writes the Certificate\u2019s private key in DER binary format to the key.der target Secret Data key. CertificatePrivateKey ( Appears on: CertificateSpec ) CertificatePrivateKey contains configuration options for private keys used by the Certificate controller. This allows control of how private keys are rotated. Field Description rotationPolicy PrivateKeyRotationPolicy (Optional) RotationPolicy controls how private keys should be regenerated when a re-issuance is being processed. If set to Never, a private key will only be generated if one does not already exist in the target spec.secretName . If one does exists but it does not have the correct algorithm or size, a warning will be raised to await user intervention. If set to Always, a private key matching the specified requirements will be generated whenever a re-issuance occurs. Default is \u2018Never\u2019 for backward compatibility. encoding PrivateKeyEncoding (Optional) The private key cryptography standards (PKCS) encoding for this certificate\u2019s private key to be encoded in. If provided, allowed values are PKCS1 and PKCS8 standing for PKCS#1 and PKCS#8, respectively. Defaults to PKCS1 if not specified. algorithm PrivateKeyAlgorithm (Optional) Algorithm is the private key algorithm of the corresponding private key for this certificate. If provided, allowed values are either RSA , Ed25519 or ECDSA If algorithm is specified and size is not provided, key size of 256 will be used for ECDSA key algorithm and key size of 2048 will be used for RSA key algorithm. key size is ignored when using the Ed25519 key algorithm. size int (Optional) Size is the key bit size of the corresponding private key for this certificate. If algorithm is set to RSA , valid values are 2048 , 4096 or 8192 , and will default to 2048 if not specified. If algorithm is set to ECDSA , valid values are 256 , 384 or 521 , and will default to 256 if not specified. If algorithm is set to Ed25519 , Size is ignored. No other values are allowed. CertificateRequestCondition ( Appears on: CertificateRequestStatus ) CertificateRequestCondition contains condition information for a CertificateRequest. Field Description type CertificateRequestConditionType Type of the condition, known values are ( Ready , InvalidRequest , Approved , Denied ). status ConditionStatus Status of the condition, one of ( True , False , Unknown ). lastTransitionTime Kubernetes meta/v1.Time (Optional) LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string (Optional) Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. CertificateRequestConditionType ( string alias) ( Appears on: CertificateRequestCondition ) CertificateRequestConditionType represents an Certificate condition value. Value Description \"Approved\" CertificateRequestConditionApproved indicates that a certificate request is approved and ready for signing. Condition must never have a status of False , and cannot be modified once set. Cannot be set alongside Denied . \"Denied\" CertificateRequestConditionDenied indicates that a certificate request is denied, and must never be signed. Condition must never have a status of False , and cannot be modified once set. Cannot be set alongside Approved . \"InvalidRequest\" CertificateRequestConditionInvalidRequest indicates that a certificate signer has refused to sign the request due to at least one of the input parameters being invalid. Additional information about why the request was rejected can be found in the reason and message fields. \"Ready\" CertificateRequestConditionReady indicates that a certificate is ready for use. This is defined as: - The target certificate exists in CertificateRequest.Status CertificateRequestSpec ( Appears on: CertificateRequest ) CertificateRequestSpec defines the desired state of CertificateRequest Field Description duration Kubernetes meta/v1.Duration (Optional) The requested \u2018duration\u2019 (i.e. lifetime) of the Certificate. This option may be ignored/overridden by some issuer types. issuerRef ObjectReference IssuerRef is a reference to the issuer for this CertificateRequest. If the kind field is not set, or set to Issuer , an Issuer resource with the given name in the same namespace as the CertificateRequest will be used. If the kind field is set to ClusterIssuer , a ClusterIssuer with the provided name will be used. The name field in this stanza is required at all times. The group field refers to the API group of the issuer which defaults to cert-manager.io if empty. request []byte The PEM-encoded x509 certificate signing request to be submitted to the CA for signing. isCA bool (Optional) IsCA will request to mark the certificate as valid for certificate signing when submitting to the issuer. This will automatically add the cert sign usage to the list of usages . usages []KeyUsage (Optional) Usages is the set of x509 usages that are requested for the certificate. If usages are set they SHOULD be encoded inside the CSR spec Defaults to digital signature and key encipherment if not specified. username string (Optional) Username contains the name of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. uid string (Optional) UID contains the uid of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. groups []string (Optional) Groups contains group membership of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. extra map[string][]string (Optional) Extra contains extra attributes of the user that created the CertificateRequest. Populated by the cert-manager webhook on creation and immutable. CertificateRequestStatus ( Appears on: CertificateRequest ) CertificateRequestStatus defines the observed state of CertificateRequest and resulting signed certificate. Field Description conditions []CertificateRequestCondition (Optional) List of status conditions to indicate the status of a CertificateRequest. Known condition types are Ready and InvalidRequest . certificate []byte (Optional) The PEM encoded x509 certificate resulting from the certificate signing request. If not set, the CertificateRequest has either not been completed or has failed. More information on failure can be found by checking the conditions field. ca []byte (Optional) The PEM encoded x509 certificate of the signer, also known as the CA (Certificate Authority). This is set on a best-effort basis by different issuers. If not set, the CA is assumed to be unknown/not available. failureTime Kubernetes meta/v1.Time (Optional) FailureTime stores the time that this CertificateRequest failed. This is used to influence garbage collection and back-off. CertificateSecretTemplate ( Appears on: CertificateSpec ) CertificateSecretTemplate defines the default labels and annotations to be copied to the Kubernetes Secret resource named in CertificateSpec.secretName . Field Description annotations map[string]string (Optional) Annotations is a key value map to be copied to the target Kubernetes Secret. labels map[string]string (Optional) Labels is a key value map to be copied to the target Kubernetes Secret. CertificateSpec ( Appears on: Certificate ) CertificateSpec defines the desired state of Certificate. A valid Certificate requires at least one of a CommonName, DNSName, or URISAN to be valid. Field Description subject X509Subject (Optional) Full X509 name specification ( https://golang.org/pkg/crypto/x509/pkix/#Name ). literalSubject string (Optional) LiteralSubject is an LDAP formatted string that represents the X.509 Subject field . Use this instead of the Subject field if you need to ensure the correct ordering of the RDN sequence, such as when issuing certs for LDAP authentication. See https://github.com/cert-manager/cert-manager/issues/3203 , https://github.com/cert-manager/cert-manager/issues/4424 . This field is alpha level and is only supported by cert-manager installations where LiteralCertificateSubject feature gate is enabled on both cert-manager controller and webhook. commonName string (Optional) CommonName is a common name to be used on the Certificate. The CommonName should have a length of 64 characters or fewer to avoid generating invalid CSRs. This value is ignored by TLS clients when any subject alt name is set. This is x509 behaviour: https://tools.ietf.org/html/rfc6125#section-6.4.4 duration Kubernetes meta/v1.Duration (Optional) The requested \u2018duration\u2019 (i.e. lifetime) of the Certificate. This option may be ignored/overridden by some issuer types. If unset this defaults to 90 days. Certificate will be renewed either 2 \u2044 3 through its duration or renewBefore period before its expiry, whichever is later. Minimum accepted duration is 1 hour. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration renewBefore Kubernetes meta/v1.Duration (Optional) How long before the currently issued certificate\u2019s expiry cert-manager should renew the certificate. The default is 2 \u2044 3 of the issued certificate\u2019s duration. Minimum accepted value is 5 minutes. Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration dnsNames []string (Optional) DNSNames is a list of DNS subjectAltNames to be set on the Certificate. ipAddresses []string (Optional) IPAddresses is a list of IP address subjectAltNames to be set on the Certificate. uris []string (Optional) URIs is a list of URI subjectAltNames to be set on the Certificate. emailAddresses []string (Optional) EmailAddresses is a list of email subjectAltNames to be set on the Certificate. secretName string SecretName is the name of the secret resource that will be automatically created and managed by this Certificate resource. It will be populated with a private key and certificate, signed by the denoted issuer. secretTemplate CertificateSecretTemplate (Optional) SecretTemplate defines annotations and labels to be copied to the Certificate\u2019s Secret. Labels and annotations on the Secret will be changed as they appear on the SecretTemplate when added or removed. SecretTemplate annotations are added in conjunction with, and cannot overwrite, the base set of annotations cert-manager sets on the Certificate\u2019s Secret. keystores CertificateKeystores (Optional) Keystores configures additional keystore output formats stored in the secretName Secret resource. issuerRef ObjectReference IssuerRef is a reference to the issuer for this certificate. If the kind field is not set, or set to Issuer , an Issuer resource with the given name in the same namespace as the Certificate will be used. If the kind field is set to ClusterIssuer , a ClusterIssuer with the provided name will be used. The name field in this stanza is required at all times. isCA bool (Optional) IsCA will mark this Certificate as valid for certificate signing. This will automatically add the cert sign usage to the list of usages . usages []KeyUsage (Optional) Usages is the set of x509 usages that are requested for the certificate. Defaults to digital signature and key encipherment if not specified. privateKey CertificatePrivateKey (Optional) Options to control private keys used for the Certificate. encodeUsagesInRequest bool (Optional) EncodeUsagesInRequest controls whether key usages should be present in the CertificateRequest revisionHistoryLimit int32 (Optional) revisionHistoryLimit is the maximum number of CertificateRequest revisions that are maintained in the Certificate\u2019s history. Each revision represents a single CertificateRequest created by this Certificate, either when it was created, renewed, or Spec was changed. Revisions will be removed by oldest first if the number of revisions exceeds this number. If set, revisionHistoryLimit must be a value of 1 or greater. If unset ( nil ), revisions will not be garbage collected. Default value is nil . additionalOutputFormats []CertificateAdditionalOutputFormat (Optional) AdditionalOutputFormats defines extra output formats of the private key and signed certificate chain to be written to this Certificate\u2019s target Secret. This is an Alpha Feature and is only enabled with the --feature-gates=AdditionalCertificateOutputFormats=true option on both the controller and webhook components. CertificateStatus ( Appears on: Certificate ) CertificateStatus defines the observed state of Certificate Field Description conditions []CertificateCondition (Optional) List of status conditions to indicate the status of certificates. Known condition types are Ready and Issuing . lastFailureTime Kubernetes meta/v1.Time (Optional) LastFailureTime is the time as recorded by the Certificate controller of the most recent failure to complete a CertificateRequest for this Certificate resource. If set, cert-manager will not re-request another Certificate until 1 hour has elapsed from this time. notBefore Kubernetes meta/v1.Time (Optional) The time after which the certificate stored in the secret named by this resource in spec.secretName is valid. notAfter Kubernetes meta/v1.Time (Optional) The expiration time of the certificate stored in the secret named by this resource in spec.secretName . renewalTime Kubernetes meta/v1.Time (Optional) RenewalTime is the time at which the certificate will be next renewed. If not set, no upcoming renewal is scheduled. revision int (Optional) The current \u2018revision\u2019 of the certificate as issued. When a CertificateRequest resource is created, it will have the cert-manager.io/certificate-revision set to one greater than the current value of this field. Upon issuance, this field will be set to the value of the annotation on the CertificateRequest resource used to issue the certificate. Persisting the value on the CertificateRequest resource allows the certificates controller to know whether a request is part of an old issuance or if it is part of the ongoing revision\u2019s issuance by checking if the revision value in the annotation is greater than this field. nextPrivateKeySecretName string (Optional) The name of the Secret resource containing the private key to be used for the next certificate iteration. The keymanager controller will automatically set this field if the Issuing condition is set to True . It will automatically unset this field when the Issuing condition is not set or False. failedIssuanceAttempts int (Optional) The number of continuous failed issuance attempts up till now. This field gets removed (if set) on a successful issuance and gets set to 1 if unset and an issuance has failed. If an issuance has failed, the delay till the next issuance will be calculated using formula time.Hour * 2 ^ (failedIssuanceAttempts - 1). GenericIssuer IssuerCondition ( Appears on: IssuerStatus ) IssuerCondition contains condition information for an Issuer. Field Description type IssuerConditionType Type of the condition, known values are ( Ready ). status ConditionStatus Status of the condition, one of ( True , False , Unknown ). lastTransitionTime Kubernetes meta/v1.Time (Optional) LastTransitionTime is the timestamp corresponding to the last status change of this condition. reason string (Optional) Reason is a brief machine readable explanation for the condition\u2019s last transition. message string (Optional) Message is a human readable description of the details of the last transition, complementing reason. observedGeneration int64 (Optional) If set, this represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.condition[x].observedGeneration is 9, the condition is out of date with respect to the current state of the Issuer. IssuerConditionType ( string alias) ( Appears on: IssuerCondition ) IssuerConditionType represents an Issuer condition value. Value Description \"Ready\" IssuerConditionReady represents the fact that a given Issuer condition is in ready state and able to issue certificates. If the status of this condition is False , CertificateRequest controllers should prevent attempts to sign certificates. IssuerConfig ( Appears on: IssuerSpec ) The configuration for the issuer. Only one of these can be set. Field Description acme ACMEIssuer (Optional) ACME configures this issuer to communicate with a RFC8555 (ACME) server to obtain signed x509 certificates. ca CAIssuer (Optional) CA configures this issuer to sign certificates using a signing CA keypair stored in a Secret resource. This is used to build internal PKIs that are managed by cert-manager. vault VaultIssuer (Optional) Vault configures this issuer to sign certificates using a HashiCorp Vault PKI backend. selfSigned SelfSignedIssuer (Optional) SelfSigned configures this issuer to \u2018self sign\u2019 certificates using the private key used to create the CertificateRequest object. venafi VenafiIssuer (Optional) Venafi configures this issuer to sign certificates using a Venafi TPP or Venafi Cloud policy zone. IssuerSpec ( Appears on: ClusterIssuer , Issuer ) IssuerSpec is the specification of an Issuer. This includes any configuration required for the issuer. Field Description IssuerConfig IssuerConfig (Members of IssuerConfig are embedded into this type.) IssuerStatus ( Appears on: ClusterIssuer , Issuer ) IssuerStatus contains status information about an Issuer Field Description conditions []IssuerCondition (Optional) List of status conditions to indicate the status of a CertificateRequest. Known condition types are Ready . acme ACMEIssuerStatus (Optional) ACME specific status options. This field should only be set if the Issuer is configured to use an ACME server to issue certificates. JKSKeystore ( Appears on: CertificateKeystores ) JKS configures options for storing a JKS keystore in the spec.secretName Secret resource. Field Description create bool Create enables JKS keystore creation for the Certificate. If true, a file named keystore.jks will be created in the target Secret resource, encrypted using the password stored in passwordSecretRef . The keystore file will only be updated upon re-issuance. A file named truststore.jks will also be created in the target Secret resource, encrypted using the password stored in passwordSecretRef containing the issuing Certificate Authority passwordSecretRef SecretKeySelector PasswordSecretRef is a reference to a key in a Secret resource containing the password used to encrypt the JKS keystore. KeyUsage ( string alias) ( Appears on: CertificateRequestSpec , CertificateSpec ) KeyUsage specifies valid usage contexts for keys. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3 https://tools.ietf.org/html/rfc5280#section-4.2.1.12 Valid KeyUsage values are as follows: \u201csigning\u201d, \u201cdigital signature\u201d, \u201ccontent commitment\u201d, \u201ckey encipherment\u201d, \u201ckey agreement\u201d, \u201cdata encipherment\u201d, \u201ccert sign\u201d, \u201ccrl sign\u201d, \u201cencipher only\u201d, \u201cdecipher only\u201d, \u201cany\u201d, \u201cserver auth\u201d, \u201cclient auth\u201d, \u201ccode signing\u201d, \u201cemail protection\u201d, \u201cs/mime\u201d, \u201cipsec end system\u201d, \u201cipsec tunnel\u201d, \u201cipsec user\u201d, \u201ctimestamping\u201d, \u201cocsp signing\u201d, \u201cmicrosoft sgc\u201d, \u201cnetscape sgc\u201d Value Description \"any\" \"crl sign\" \"cert sign\" \"client auth\" \"code signing\" \"content commitment\" \"data encipherment\" \"decipher only\" \"digital signature\" \"email protection\" \"encipher only\" \"ipsec end system\" \"ipsec tunnel\" \"ipsec user\" \"key agreement\" \"key encipherment\" \"microsoft sgc\" \"netscape sgc\" \"ocsp signing\" \"s/mime\" \"server auth\" \"signing\" \"timestamping\" PKCS12Keystore ( Appears on: CertificateKeystores ) PKCS12 configures options for storing a PKCS12 keystore in the spec.secretName Secret resource. Field Description create bool Create enables PKCS12 keystore creation for the Certificate. If true, a file named keystore.p12 will be created in the target Secret resource, encrypted using the password stored in passwordSecretRef . The keystore file will only be updated upon re-issuance. A file named truststore.p12 will also be created in the target Secret resource, encrypted using the password stored in passwordSecretRef containing the issuing Certificate Authority passwordSecretRef SecretKeySelector PasswordSecretRef is a reference to a key in a Secret resource containing the password used to encrypt the PKCS12 keystore. PrivateKeyAlgorithm ( string alias) ( Appears on: CertificatePrivateKey ) Value Description \"ECDSA\" Denotes the ECDSA private key type. \"Ed25519\" Denotes the Ed25519 private key type. \"RSA\" Denotes the RSA private key type. PrivateKeyEncoding ( string alias) ( Appears on: CertificatePrivateKey ) Value Description \"PKCS1\" PKCS1 key encoding will produce PEM files that include the type of private key as part of the PEM header, e.g. BEGIN RSA PRIVATE KEY . If the keyAlgorithm is set to \u2018ECDSA\u2019, this will produce private keys that use the BEGIN EC PRIVATE KEY header. \"PKCS8\" PKCS8 key encoding will produce PEM files with the BEGIN PRIVATE KEY header. It encodes the keyAlgorithm of the private key as part of the DER encoded PEM block. PrivateKeyRotationPolicy ( string alias) ( Appears on: CertificatePrivateKey ) Denotes how private keys should be generated or sourced when a Certificate is being issued. SelfSignedIssuer ( Appears on: IssuerConfig ) Configures an issuer to \u2018self sign\u2019 certificates using the private key used to create the CertificateRequest object. Field Description crlDistributionPoints []string (Optional) The CRL distribution points is an X.509 v3 certificate extension which identifies the location of the CRL from which the revocation of this certificate can be checked. If not set certificate will be issued without CDP. Values are strings. VaultAppRole ( Appears on: VaultAuth ) VaultAppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource. Field Description path string Path where the App Role authentication backend is mounted in Vault, e.g: \u201capprole\u201d roleId string RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault. secretRef SecretKeySelector Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The key field must be specified and denotes which entry within the Secret resource is used as the app role secret. VaultAuth ( Appears on: VaultIssuer ) Configuration used to authenticate with a Vault server. Only one of tokenSecretRef , appRole or kubernetes may be specified. Field Description tokenSecretRef SecretKeySelector (Optional) TokenSecretRef authenticates with Vault by presenting a token. appRole VaultAppRole (Optional) AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource. kubernetes VaultKubernetesAuth (Optional) Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server. VaultIssuer ( Appears on: IssuerConfig ) Configures an issuer to sign certificates using a HashiCorp Vault PKI backend. Field Description auth VaultAuth Auth configures how cert-manager authenticates with the Vault server. server string Server is the connection address for the Vault server, e.g: \u201c https://vault.example.com:8200\u201d . path string Path is the mount path of the Vault PKI backend\u2019s sign endpoint, e.g: \u201cmy_pki_mount/sign/my-role-name\u201d. namespace string (Optional) Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: \u201cns1\u201d More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces caBundle []byte (Optional) PEM-encoded CA bundle (base64-encoded) used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection. Mutually exclusive with CABundleSecretRef. If neither CABundle nor CABundleSecretRef are defined, the cert-manager controller system root certificates are used to validate the TLS connection. caBundleSecretRef SecretKeySelector (Optional) CABundleSecretRef is a reference to a Secret which contains the CABundle which will be used when connecting to Vault when using HTTPS. Mutually exclusive with CABundle. If neither CABundleSecretRef nor CABundle are defined, the cert-manager controller system root certificates are used to validate the TLS connection. If no key for the Secret is specified, cert-manager will default to \u2018ca.crt\u2019. VaultKubernetesAuth ( Appears on: VaultAuth ) Authenticate against Vault using a Kubernetes ServiceAccount token stored in a Secret. Field Description mountPath string (Optional) The Vault mountPath here is the mount path to use when authenticating with Vault. For example, setting a value to /v1/auth/foo , will use the path /v1/auth/foo/login to authenticate with Vault. If unspecified, the default value \u201c/v1/auth/kubernetes\u201d will be used. secretRef SecretKeySelector The required Secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. Use of \u2018ambient credentials\u2019 is not supported. role string A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies. VenafiCloud ( Appears on: VenafiIssuer ) VenafiCloud defines connection configuration details for Venafi Cloud Field Description url string (Optional) URL is the base URL for Venafi Cloud. Defaults to \u201c https://api.venafi.cloud/v1\u201d . apiTokenSecretRef SecretKeySelector APITokenSecretRef is a secret key selector for the Venafi Cloud API token. VenafiIssuer ( Appears on: IssuerConfig ) Configures an issuer to sign certificates using a Venafi TPP or Cloud policy zone. Field Description zone string Zone is the Venafi Policy Zone to use for this issuer. All requests made to the Venafi platform will be restricted by the named zone policy. This field is required. tpp VenafiTPP (Optional) TPP specifies Trust Protection Platform configuration settings. Only one of TPP or Cloud may be specified. cloud VenafiCloud (Optional) Cloud specifies the Venafi cloud configuration settings. Only one of TPP or Cloud may be specified. VenafiTPP ( Appears on: VenafiIssuer ) VenafiTPP defines connection configuration details for a Venafi TPP instance Field Description url string URL is the base URL for the vedsdk endpoint of the Venafi TPP instance, for example: \u201c https://tpp.example.com/vedsdk\u201d . credentialsRef LocalObjectReference CredentialsRef is a reference to a Secret containing the username and password for the TPP server. The secret must contain two keys, \u2018username\u2019 and \u2018password\u2019. caBundle []byte (Optional) CABundle is a PEM encoded TLS certificate to use to verify connections to the TPP instance. If specified, system roots will not be used and the issuing CA for the TPP instance must be verifiable using the provided root. If not specified, the connection will be verified using the cert-manager system root certificates. X509Subject ( Appears on: CertificateSpec ) X509Subject Full X509 name specification Field Description organizations []string (Optional) Organizations to be used on the Certificate. countries []string (Optional) Countries to be used on the Certificate. organizationalUnits []string (Optional) Organizational Units to be used on the Certificate. localities []string (Optional) Cities to be used on the Certificate. provinces []string (Optional) State/Provinces to be used on the Certificate. streetAddresses []string (Optional) Street addresses to be used on the Certificate. postalCodes []string (Optional) Postal codes to be used on the Certificate. serialNumber string (Optional) Serial number to be used on the Certificate. meta.cert-manager.io/v1 Package v1 contains meta types for cert-manager APIs Resource Types: ConditionStatus ( string alias) ( Appears on: CertificateCondition , CertificateRequestCondition , IssuerCondition ) ConditionStatus represents a condition\u2019s status. Value Description \"False\" ConditionFalse represents the fact that a given condition is false \"True\" ConditionTrue represents the fact that a given condition is true \"Unknown\" ConditionUnknown represents the fact that a given condition is unknown LocalObjectReference ( Appears on: VenafiTPP , SecretKeySelector ) A reference to an object in the same namespace as the referent. If the referent is a cluster-scoped resource (e.g. a ClusterIssuer), the reference instead refers to the resource with the given name in the configured \u2018cluster resource namespace\u2019, which is set as a flag on the controller component (and defaults to the namespace that cert-manager runs in). Field Description name string Name of the resource being referred to. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names ObjectReference ( Appears on: ChallengeSpec , OrderSpec , CertificateRequestSpec , CertificateSpec ) ObjectReference is a reference to an object with a given name, kind and group. Field Description name string Name of the resource being referred to. kind string (Optional) Kind of the resource being referred to. group string (Optional) Group of the resource being referred to. SecretKeySelector ( Appears on: ACMEExternalAccountBinding , ACMEIssuer , ACMEIssuerDNS01ProviderAcmeDNS , ACMEIssuerDNS01ProviderAkamai , ACMEIssuerDNS01ProviderAzureDNS , ACMEIssuerDNS01ProviderCloudDNS , ACMEIssuerDNS01ProviderCloudflare , ACMEIssuerDNS01ProviderDigitalOcean , ACMEIssuerDNS01ProviderRFC2136 , ACMEIssuerDNS01ProviderRoute53 , JKSKeystore , PKCS12Keystore , VaultAppRole , VaultAuth , VaultIssuer , VaultKubernetesAuth , VenafiCloud ) A reference to a specific \u2018key\u2019 within a Secret resource. In some instances, key is a required field. Field Description LocalObjectReference LocalObjectReference (Members of LocalObjectReference are embedded into this type.) The name of the Secret resource being referred to. key string (Optional) The key of the entry in the Secret resource\u2019s data field to be used. Some instances of this field may be defaulted, in others it may be required. webhook.config.cert-manager.io/v1alpha1 Package v1alpha1 is the v1alpha1 version of the webhook config API. Resource Types: DynamicServingConfig ( Appears on: TLSConfig ) DynamicServingConfig makes the webhook generate a CA and persist it into Secret resources. This CA will be used by all instances of the webhook for signing serving certificates. Field Description secretNamespace string Namespace of the Kubernetes Secret resource containing the TLS certificate used as a CA to sign dynamic serving certificates. secretName string Namespace of the Kubernetes Secret resource containing the TLS certificate used as a CA to sign dynamic serving certificates. dnsNames []string DNSNames that must be present on serving certificates signed by the CA. FilesystemServingConfig ( Appears on: TLSConfig ) FilesystemServingConfig enables using a certificate and private key found on the local filesystem. These files will be periodically polled in case they have changed, and dynamically reloaded. Field Description certFile string Path to a file containing TLS certificate & chain to serve with keyFile string Path to a file containing a TLS private key to server with TLSConfig ( Appears on: WebhookConfiguration ) TLSConfig configures how TLS certificates are sourced for serving. Only one of \u2018filesystem\u2019 or \u2018dynamic\u2019 may be specified. Field Description cipherSuites []string cipherSuites is the list of allowed cipher suites for the server. Values are from tls package constants ( https://golang.org/pkg/crypto/tls/#pkg-constants ). If not specified, the default for the Go version will be used and may change over time. minTLSVersion string minTLSVersion is the minimum TLS version supported. Values are from tls package constants ( https://golang.org/pkg/crypto/tls/#pkg-constants ). If not specified, the default for the Go version will be used and may change over time. filesystem FilesystemServingConfig Filesystem enables using a certificate and private key found on the local filesystem. These files will be periodically polled in case they have changed, and dynamically reloaded. dynamic DynamicServingConfig When Dynamic serving is enabled, the webhook will generate a CA used to sign webhook certificates and persist it into a Kubernetes Secret resource (for other replicas of the webhook to consume). It will then generate a certificate in-memory for itself using this CA to serve with. The CAs certificate can then be copied into the appropriate Validating, Mutating and Conversion webhook configuration objects (typically by cainjector). WebhookConfiguration Field Description securePort int securePort is the port number to listen on for secure TLS connections from the kube-apiserver. Defaults to 6443. healthzPort int healthzPort is the port number to listen on (using plaintext HTTP) for healthz connections. Defaults to 6080. tlsConfig TLSConfig tlsConfig is used to configure the secure listener\u2019s TLS settings. kubeConfig string kubeConfig is the kubeconfig file used to connect to the Kubernetes apiserver. If not specified, the webhook will attempt to load the in-cluster-config. apiServerHost string apiServerHost is used to override the API server connection address. Deprecated: use kubeConfig instead. enablePprof bool enablePprof configures whether pprof is enabled. pprofAddress string pprofAddress configures the address on which /debug/pprof endpoint will be served if enabled. Defaults to \u2018localhost:6060\u2019. featureGates map[string]bool (Optional) featureGates is a map of feature names to bools that enable or disable experimental features. Default: nil Generated with gen-crd-api-reference-docs on git commit da3265115 .","title":"API Reference"},{"location":"reference/cmctl/","text":"cmctl is a command line tool that can help you manage cert-manager and its resources inside your cluster. Installation \u00b6 Homebrew \u00b6 On Mac or Linux if you have Homebrew installed, you can install cmctl with: brew install cmctl This will also install shell completion. Manual Installation \u00b6 You need the cmctl.tar.gz file for the platform you're using, these can be found on our GitHub releases page . In order to use cmctl you need its binary to be accessible under the name cmctl in your $PATH . Run the following commands to set up the CLI. Replace OS and ARCH with your systems equivalents: OS=$(go env GOOS); ARCH=$(go env GOARCH); curl -fsSL -o cmctl.tar.gz https://github.com/cert-manager/cert-manager/releases/latest/download/cmctl-$OS-$ARCH.tar.gz tar xzf cmctl.tar.gz sudo mv cmctl /usr/local/bin You can run cmctl help to test the CLI is set up properly: $ cmctl help cmctl is a CLI tool manage and configure cert-manager resources for Kubernetes Usage: cmctl [command] Available Commands: approve Approve a CertificateRequest check Check cert-manager components completion Generate completion scripts for the cert-manager CLI convert Convert cert-manager config files between different API versions create Create cert-manager resources deny Deny a CertificateRequest experimental Interact with experimental features help Help about any command inspect Get details on certificate related resources renew Mark a Certificate for manual renewal status Get details on current status of cert-manager resources upgrade Tools that assist in upgrading cert-manager version Print the cert-manager CLI version and the deployed cert-manager version Flags: -h, --help help for cmctl --log-flush-frequency duration Maximum number of seconds between log flushes (default 5s) Use \"cmctl [command] --help\" for more information about a command. There is also a legacy kubectl plugin , but it is no longer recommended because the standalone cmctl binary provides better auto-completion . Commands \u00b6 Approve and Deny CertificateRequests \u00b6 CertificateRequests can be approved or denied using their respective cmctl commands: Note : The internal cert-manager approver may automatically approve all CertificateRequests unless disabled with the flag on the cert-manager-controller --controllers=*,-certificaterequests-approver $ cmctl approve -n istio-system mesh-ca --reason \"pki-team\" --message \"this certificate is valid\" Approved CertificateRequest 'istio-system/mesh-ca' $ cmctl deny -n my-app my-app --reason \"example.com\" --message \"violates policy\" Denied CertificateRequest 'my-app/my-app' Convert \u00b6 cmctl convert can be used to convert cert-manager manifest files between different API versions. Both YAML and JSON formats are accepted. The command either takes a file name, directory path, or a URL as input. The contents is converted into the format of the latest API version known to cert-manager, or the one specified by --output-version flag. The default output will be printed to stdout in YAML format. One can use the option -o to change the output destination. For example, this will output cert.yaml in the latest API version: cmctl convert -f cert.yaml Create \u00b6 cmctl create can be used to create cert-manager resources manually. Sub-commands are available to create different resources: CertificateRequest \u00b6 To create a cert-manager CertificateRequest, use cmctl create certificaterequest . The command takes in the name of the CertificateRequest to be created, and creates a new CertificateRequest resource based on the YAML manifest of a Certificate resource as specified by --from-certificate-file flag, by generating a private key locally and creating a 'certificate signing request' to be submitted to a cert-manager Issuer. The private key will be written to a local file, where the default is <name_of_cr>.key , or it can be specified using the --output-key-file flag. If you wish to wait for the CertificateRequest to be signed and store the X.509 certificate in a file, you can set the --fetch-certificate flag. The default timeout when waiting for the issuance of the certificate is 5 minutes, but can be specified with the --timeout flag. The default name of the file storing the X.509 certificate is <name_of_cr>.crt , you can use the --output-certificate-file flag to specify otherwise. Note that the private key and the X.509 certificate are both written to file, and are not stored inside Kubernetes. For example this will create a CertificateRequest resource with the name \"my-cr\" based on the cert-manager Certificate described in my-certificate.yaml while storing the private key and X.509 certificate in my-cr.key and my-cr.crt respectively. cmctl create certificaterequest my-cr --from-certificate-file my-certificate.yaml --fetch-certificate --timeout 20m Renew \u00b6 cmctl allows you to manually trigger a renewal of a specific certificate. This can be done either one certificate at a time, using label selectors ( -l app=example ), or with the --all flag: For example, you can renew the certificate example-com-tls : $ kubectl get certificate NAME READY SECRET AGE example-com-tls True example-com-tls 1d $ cmctl renew example-com-tls Manually triggered issuance of Certificate default/example-com-tls $ kubectl get certificaterequest NAME READY AGE example-com-tls-tls-8rbv2 False 10s You can also renew all certificates in a given namespace: $ cmctl renew --namespace = app --all The renew command allows several options to be specified: * --all renew all Certificates in the given Namespace, or all namespaces when combined with --all-namespaces * -A or --all-namespaces mark Certificates across namespaces for renewal * -l --selector allows set a label query to filter on as well as kubectl like global flags like --context and --namespace . Status Certificate \u00b6 cmctl status certificate outputs the details of the current status of a Certificate resource and related resources like CertificateRequest, Secret, Issuer, as well as Order and Challenges if it is a ACME Certificate. The command outputs information about the resources, including Conditions, Events and resource specific fields like Key Usages and Extended Key Usages of the Secret or Authorizations of the Order. This will be helpful for troubleshooting a Certificate. The command takes in one argument specifying the name of the Certificate resource and the namespace can be specified as usual with the -n or --namespace flag. This example queries the status of the Certificate named my-certificate in namespace my-namespace . cmctl status certificate my-certificate -n my-namespace Completion \u00b6 cmctl supports auto-completion for both subcommands as well as suggestions for runtime objects. $ cmctl approve -n <TAB> <TAB> default kube-node-lease kube-public kube-system local-path-storage Completion can be installed for your environment by following the instructions for the shell you are using. It currently supports bash, fish, zsh, and powershell. $ cmctl completion help Experimental \u00b6 cmctl x has experimental sub-commands for operations which are currently under evaluation to be included into cert-manager proper. The behavior and interface of these commands are subject to change or removal in future releases. Create \u00b6 cmctl x create can be used to create cert-manager resources manually. Sub-commands are available to create different resources: CertificateSigningRequest \u00b6 To create a CertificateSigningRequest , use cmctl x create csr` This command takes the name of the CertificateSigningRequest to be created, as well as a file containing a Certificate manifest ( -f, --from-certificate-file ). This command will generate a private key, based on the options of the Certificate, and write it to the local file <name>.key , or specified by -k, --output-key-file . $ cmctl x create csr -f my-cert.yaml my-req cert-manager **will not** automatically approve CertificateSigningRequests. If you are not running a custom approver in your cluster, you will likely need to manually approve the CertificateSigningRequest: $ kubectl certificate approve <name> This command can also wait for the CertificateSigningRequest to be signed using the flag -w, --fetch-certificate . Once signed it will write the resulting signed certificate to the local file <name>.crt , or specified by -c, --output-certificate-file . $ cmctl x create csr -f my-cert.yaml my-req -w Install \u00b6 cmctl x install This command makes sure that the required CustomResourceDefinitions are installed together with the cert-manager, cainjector and webhook components. Under the hood, a procedure similar to the Helm install procedure is used. You can also use cmctl x install to customize the installation of cert-manager. The example below shows how to tune the cert-manager installation by overriding the default Helm values: cmctl x install \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4s # Example: changing the wehbook timeout using a Helm parameter You can find a full list of the install parameters on cert-manager's ArtifactHub page . These are the same parameters that are available when using the Helm chart. Once you have deployed cert-manager, you can verify the installation. The CLI also allows the user to output the templated manifest to stdout , instead of installing the manifest on the cluster. cmctl x install --dry-run > cert-manager.custom.yaml Uninstall \u00b6 cmctl x uninstall This command uninstalls any Helm-managed release of cert-manager. The CRDs will be deleted if you installed cert-manager with the option --set CRDs=true . Most of the features supported by helm uninstall are also supported by this command. Some example uses: cmctl x uninstall cmctl x uninstall --namespace my-cert-manager cmctl x uninstall --dry-run cmctl x uninstall --no-hooks Upgrade \u00b6 Tools that assist in upgrading cert-manager $ cmctl upgrade --help Migrate API version \u00b6 This command can be used to prepare a cert-manager installation that was created before cert-manager v1 for upgrading to a cert-manager version v1.6 or later. It ensures that any cert-manager custom resources that may have been stored in etcd at a deprecated API version get migrated to v1 . See Migrating Deprecated API Resources for more context. $ cmctl upgrade migrate-api-version --qps 5 --burst 10 Legacy kubectl plugin \u00b6 While the kubectl plugin is supported, it is recommended to use cmctl as this enables a better experience via tab auto-completion. To install the plugin you need the kubectl-cert-manager.tar.gz file for the platform you're using, these can be found on our GitHub releases page . In order to use the kubectl plugin you need its binary to be accessible under the name kubectl-cert_manager in your $PATH . You can run kubectl cert-manager help to test that the plugin is set up properly.","title":"The cert-manager Command Line Tool (cmctl)"},{"location":"reference/cmctl/#installation","text":"","title":"Installation"},{"location":"reference/cmctl/#homebrew","text":"On Mac or Linux if you have Homebrew installed, you can install cmctl with: brew install cmctl This will also install shell completion.","title":"Homebrew"},{"location":"reference/cmctl/#manual-installation","text":"You need the cmctl.tar.gz file for the platform you're using, these can be found on our GitHub releases page . In order to use cmctl you need its binary to be accessible under the name cmctl in your $PATH . Run the following commands to set up the CLI. Replace OS and ARCH with your systems equivalents: OS=$(go env GOOS); ARCH=$(go env GOARCH); curl -fsSL -o cmctl.tar.gz https://github.com/cert-manager/cert-manager/releases/latest/download/cmctl-$OS-$ARCH.tar.gz tar xzf cmctl.tar.gz sudo mv cmctl /usr/local/bin You can run cmctl help to test the CLI is set up properly: $ cmctl help cmctl is a CLI tool manage and configure cert-manager resources for Kubernetes Usage: cmctl [command] Available Commands: approve Approve a CertificateRequest check Check cert-manager components completion Generate completion scripts for the cert-manager CLI convert Convert cert-manager config files between different API versions create Create cert-manager resources deny Deny a CertificateRequest experimental Interact with experimental features help Help about any command inspect Get details on certificate related resources renew Mark a Certificate for manual renewal status Get details on current status of cert-manager resources upgrade Tools that assist in upgrading cert-manager version Print the cert-manager CLI version and the deployed cert-manager version Flags: -h, --help help for cmctl --log-flush-frequency duration Maximum number of seconds between log flushes (default 5s) Use \"cmctl [command] --help\" for more information about a command. There is also a legacy kubectl plugin , but it is no longer recommended because the standalone cmctl binary provides better auto-completion .","title":"Manual Installation"},{"location":"reference/cmctl/#commands","text":"","title":"Commands"},{"location":"reference/cmctl/#approve-and-deny-certificaterequests","text":"CertificateRequests can be approved or denied using their respective cmctl commands: Note : The internal cert-manager approver may automatically approve all CertificateRequests unless disabled with the flag on the cert-manager-controller --controllers=*,-certificaterequests-approver $ cmctl approve -n istio-system mesh-ca --reason \"pki-team\" --message \"this certificate is valid\" Approved CertificateRequest 'istio-system/mesh-ca' $ cmctl deny -n my-app my-app --reason \"example.com\" --message \"violates policy\" Denied CertificateRequest 'my-app/my-app'","title":"Approve and Deny CertificateRequests"},{"location":"reference/cmctl/#convert","text":"cmctl convert can be used to convert cert-manager manifest files between different API versions. Both YAML and JSON formats are accepted. The command either takes a file name, directory path, or a URL as input. The contents is converted into the format of the latest API version known to cert-manager, or the one specified by --output-version flag. The default output will be printed to stdout in YAML format. One can use the option -o to change the output destination. For example, this will output cert.yaml in the latest API version: cmctl convert -f cert.yaml","title":"Convert"},{"location":"reference/cmctl/#create","text":"cmctl create can be used to create cert-manager resources manually. Sub-commands are available to create different resources:","title":"Create"},{"location":"reference/cmctl/#certificaterequest","text":"To create a cert-manager CertificateRequest, use cmctl create certificaterequest . The command takes in the name of the CertificateRequest to be created, and creates a new CertificateRequest resource based on the YAML manifest of a Certificate resource as specified by --from-certificate-file flag, by generating a private key locally and creating a 'certificate signing request' to be submitted to a cert-manager Issuer. The private key will be written to a local file, where the default is <name_of_cr>.key , or it can be specified using the --output-key-file flag. If you wish to wait for the CertificateRequest to be signed and store the X.509 certificate in a file, you can set the --fetch-certificate flag. The default timeout when waiting for the issuance of the certificate is 5 minutes, but can be specified with the --timeout flag. The default name of the file storing the X.509 certificate is <name_of_cr>.crt , you can use the --output-certificate-file flag to specify otherwise. Note that the private key and the X.509 certificate are both written to file, and are not stored inside Kubernetes. For example this will create a CertificateRequest resource with the name \"my-cr\" based on the cert-manager Certificate described in my-certificate.yaml while storing the private key and X.509 certificate in my-cr.key and my-cr.crt respectively. cmctl create certificaterequest my-cr --from-certificate-file my-certificate.yaml --fetch-certificate --timeout 20m","title":"CertificateRequest"},{"location":"reference/cmctl/#renew","text":"cmctl allows you to manually trigger a renewal of a specific certificate. This can be done either one certificate at a time, using label selectors ( -l app=example ), or with the --all flag: For example, you can renew the certificate example-com-tls : $ kubectl get certificate NAME READY SECRET AGE example-com-tls True example-com-tls 1d $ cmctl renew example-com-tls Manually triggered issuance of Certificate default/example-com-tls $ kubectl get certificaterequest NAME READY AGE example-com-tls-tls-8rbv2 False 10s You can also renew all certificates in a given namespace: $ cmctl renew --namespace = app --all The renew command allows several options to be specified: * --all renew all Certificates in the given Namespace, or all namespaces when combined with --all-namespaces * -A or --all-namespaces mark Certificates across namespaces for renewal * -l --selector allows set a label query to filter on as well as kubectl like global flags like --context and --namespace .","title":"Renew"},{"location":"reference/cmctl/#status-certificate","text":"cmctl status certificate outputs the details of the current status of a Certificate resource and related resources like CertificateRequest, Secret, Issuer, as well as Order and Challenges if it is a ACME Certificate. The command outputs information about the resources, including Conditions, Events and resource specific fields like Key Usages and Extended Key Usages of the Secret or Authorizations of the Order. This will be helpful for troubleshooting a Certificate. The command takes in one argument specifying the name of the Certificate resource and the namespace can be specified as usual with the -n or --namespace flag. This example queries the status of the Certificate named my-certificate in namespace my-namespace . cmctl status certificate my-certificate -n my-namespace","title":"Status Certificate"},{"location":"reference/cmctl/#completion","text":"cmctl supports auto-completion for both subcommands as well as suggestions for runtime objects. $ cmctl approve -n <TAB> <TAB> default kube-node-lease kube-public kube-system local-path-storage Completion can be installed for your environment by following the instructions for the shell you are using. It currently supports bash, fish, zsh, and powershell. $ cmctl completion help","title":"Completion"},{"location":"reference/cmctl/#experimental","text":"cmctl x has experimental sub-commands for operations which are currently under evaluation to be included into cert-manager proper. The behavior and interface of these commands are subject to change or removal in future releases.","title":"Experimental"},{"location":"reference/cmctl/#create_1","text":"cmctl x create can be used to create cert-manager resources manually. Sub-commands are available to create different resources:","title":"Create"},{"location":"reference/cmctl/#certificatesigningrequest","text":"To create a CertificateSigningRequest , use cmctl x create csr` This command takes the name of the CertificateSigningRequest to be created, as well as a file containing a Certificate manifest ( -f, --from-certificate-file ). This command will generate a private key, based on the options of the Certificate, and write it to the local file <name>.key , or specified by -k, --output-key-file . $ cmctl x create csr -f my-cert.yaml my-req cert-manager **will not** automatically approve CertificateSigningRequests. If you are not running a custom approver in your cluster, you will likely need to manually approve the CertificateSigningRequest: $ kubectl certificate approve <name> This command can also wait for the CertificateSigningRequest to be signed using the flag -w, --fetch-certificate . Once signed it will write the resulting signed certificate to the local file <name>.crt , or specified by -c, --output-certificate-file . $ cmctl x create csr -f my-cert.yaml my-req -w","title":"CertificateSigningRequest"},{"location":"reference/cmctl/#install","text":"cmctl x install This command makes sure that the required CustomResourceDefinitions are installed together with the cert-manager, cainjector and webhook components. Under the hood, a procedure similar to the Helm install procedure is used. You can also use cmctl x install to customize the installation of cert-manager. The example below shows how to tune the cert-manager installation by overriding the default Helm values: cmctl x install \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4s # Example: changing the wehbook timeout using a Helm parameter You can find a full list of the install parameters on cert-manager's ArtifactHub page . These are the same parameters that are available when using the Helm chart. Once you have deployed cert-manager, you can verify the installation. The CLI also allows the user to output the templated manifest to stdout , instead of installing the manifest on the cluster. cmctl x install --dry-run > cert-manager.custom.yaml","title":"Install"},{"location":"reference/cmctl/#uninstall","text":"cmctl x uninstall This command uninstalls any Helm-managed release of cert-manager. The CRDs will be deleted if you installed cert-manager with the option --set CRDs=true . Most of the features supported by helm uninstall are also supported by this command. Some example uses: cmctl x uninstall cmctl x uninstall --namespace my-cert-manager cmctl x uninstall --dry-run cmctl x uninstall --no-hooks","title":"Uninstall"},{"location":"reference/cmctl/#upgrade","text":"Tools that assist in upgrading cert-manager $ cmctl upgrade --help","title":"Upgrade"},{"location":"reference/cmctl/#migrate-api-version","text":"This command can be used to prepare a cert-manager installation that was created before cert-manager v1 for upgrading to a cert-manager version v1.6 or later. It ensures that any cert-manager custom resources that may have been stored in etcd at a deprecated API version get migrated to v1 . See Migrating Deprecated API Resources for more context. $ cmctl upgrade migrate-api-version --qps 5 --burst 10","title":"Migrate API version"},{"location":"reference/cmctl/#legacy-kubectl-plugin","text":"While the kubectl plugin is supported, it is recommended to use cmctl as this enables a better experience via tab auto-completion. To install the plugin you need the kubectl-cert-manager.tar.gz file for the platform you're using, these can be found on our GitHub releases page . In order to use the kubectl plugin you need its binary to be accessible under the name kubectl-cert_manager in your $PATH . You can run kubectl cert-manager help to test that the plugin is set up properly.","title":"Legacy kubectl plugin"},{"location":"reference/tls-terminology/","text":"Learn about the TLS terminology used in the cert-manager documentation such as publicly trusted , self-signed , root , intermediate and leaf certificate . Overview \u00b6 With TLS being so widely deployed, terminology can sometimes get confused or be used to mean different things, and that reality combined with the complexity of TLS can lead to serious misunderstandings and confusion. For further reference, you might want to check out some relevant RFCs: RFC 5246: TLS 1.2 RFC 8446: TLS 1.3 RFC 5280: X.509 Definitions \u00b6 publicly trusted \u00b6 What does \"publicly trusted\" mean? Broadly speaking, a \"publicly trusted\" certificate is one that you can use on the Internet and expect that most reasonably up-to-date computers will be able to verify it using their system trust store. There isn't a single standard trust store containing certs which are \"publicly trusted\", but generally most of the commonly seen trust stores are similar. An example would be Mozilla's CA Certificate Program . What does \"self-signed\" mean? Is my CA self-signed? \u00b6 Self-signed means exactly what it says; a certificate is self-signed if it is signed by its own private key. Self-signed is a commonly confused term, however, and is very frequently misused to mean \"not publicly trusted\". We tend to use terms like \"private PKI\" to denote the situation where an organization might have their own internal CA certificates which wouldn't be trusted outside of the organization. As an example, there are many self-signed certificates in Mozilla's CA Certificate Program , but all of those certificates would usually be described as \"publicly trusted\". Your certificate is self-signed only if it's signed with its own key. What's the difference between \"root\", \"intermediate\", and \"leaf\" certificates? \u00b6 cert-manager uses the following definitions: Root Certificates \u00b6 Roots are self-signed certificates and almost always marked as CA certificates. They're usually not sent over the wire during a TLS handshake because they need to be explicitly trusted in order to be validated. Roots are sometimes defined as \"CA certificates which are explicitly trusted\"---which can include certificates which aren't self-signed. cert-manager doesn't use this definition. Changing trust stores to include new roots or remove old ones is a non-trivial task which can take months or years for publicly trusted roots. For this reason roots are usually issued with very long lifetimes, often on the order of decades. Intermediate Certificates \u00b6 Intermediates are CA certificates signed by another CA. Most intermediates will be signed by a root certificate, but it's possible to construct longer chains where an intermediate can be signed by another intermediate. Intermediate certificates are usually issued with a much shorter lifetime than the CA which signed them. On the Internet, intermediate certificates are used on network-connected machines for day-to-day issuance so that the highly-valuable root certificates can remain entirely offline. While intermediate certificates can also be explicitly trusted via addition to a trust store, they're usually validated by \"walking up\" the chain and validating signatures until an explicitly trusted self-signed root certificate is found. Leaf Certificates \u00b6 Leaf certificates are usually used to represent a particular identity, rather than being used to sign other certificates. On the Internet leaf certificates usually identify a particular domain, such as example.com . Leaf certificates are sent first in a chain of certificates and represent the end of that chain. They must be sent along with any intermediates required to create a chain which can be validated by verifying signatures up to a trusted root certificate.","title":"TLS Terminology"},{"location":"reference/tls-terminology/#overview","text":"With TLS being so widely deployed, terminology can sometimes get confused or be used to mean different things, and that reality combined with the complexity of TLS can lead to serious misunderstandings and confusion. For further reference, you might want to check out some relevant RFCs: RFC 5246: TLS 1.2 RFC 8446: TLS 1.3 RFC 5280: X.509","title":"Overview"},{"location":"reference/tls-terminology/#definitions","text":"","title":"Definitions"},{"location":"reference/tls-terminology/#publicly-trusted","text":"What does \"publicly trusted\" mean? Broadly speaking, a \"publicly trusted\" certificate is one that you can use on the Internet and expect that most reasonably up-to-date computers will be able to verify it using their system trust store. There isn't a single standard trust store containing certs which are \"publicly trusted\", but generally most of the commonly seen trust stores are similar. An example would be Mozilla's CA Certificate Program .","title":"publicly trusted"},{"location":"reference/tls-terminology/#what-does-self-signed-mean-is-my-ca-self-signed","text":"Self-signed means exactly what it says; a certificate is self-signed if it is signed by its own private key. Self-signed is a commonly confused term, however, and is very frequently misused to mean \"not publicly trusted\". We tend to use terms like \"private PKI\" to denote the situation where an organization might have their own internal CA certificates which wouldn't be trusted outside of the organization. As an example, there are many self-signed certificates in Mozilla's CA Certificate Program , but all of those certificates would usually be described as \"publicly trusted\". Your certificate is self-signed only if it's signed with its own key.","title":"What does \"self-signed\" mean? Is my CA self-signed?"},{"location":"reference/tls-terminology/#whats-the-difference-between-root-intermediate-and-leaf-certificates","text":"cert-manager uses the following definitions:","title":"What's the difference between \"root\", \"intermediate\", and \"leaf\" certificates?"},{"location":"reference/tls-terminology/#root-certificates","text":"Roots are self-signed certificates and almost always marked as CA certificates. They're usually not sent over the wire during a TLS handshake because they need to be explicitly trusted in order to be validated. Roots are sometimes defined as \"CA certificates which are explicitly trusted\"---which can include certificates which aren't self-signed. cert-manager doesn't use this definition. Changing trust stores to include new roots or remove old ones is a non-trivial task which can take months or years for publicly trusted roots. For this reason roots are usually issued with very long lifetimes, often on the order of decades.","title":"Root Certificates"},{"location":"reference/tls-terminology/#intermediate-certificates","text":"Intermediates are CA certificates signed by another CA. Most intermediates will be signed by a root certificate, but it's possible to construct longer chains where an intermediate can be signed by another intermediate. Intermediate certificates are usually issued with a much shorter lifetime than the CA which signed them. On the Internet, intermediate certificates are used on network-connected machines for day-to-day issuance so that the highly-valuable root certificates can remain entirely offline. While intermediate certificates can also be explicitly trusted via addition to a trust store, they're usually validated by \"walking up\" the chain and validating signatures until an explicitly trusted self-signed root certificate is found.","title":"Intermediate Certificates"},{"location":"reference/tls-terminology/#leaf-certificates","text":"Leaf certificates are usually used to represent a particular identity, rather than being used to sign other certificates. On the Internet leaf certificates usually identify a particular domain, such as example.com . Leaf certificates are sent first in a chain of certificates and represent the end of that chain. They must be sent along with any intermediates required to create a chain which can be validated by verifying signatures up to a trusted root certificate.","title":"Leaf Certificates"},{"location":"release-notes/","text":"v1.10 v1.9 v1.8 v1.7 v1.6 v1.5 v1.4 v1.3 v1.2 v1.1 v1.0 v0.16 v0.15 v0.14 v0.13 v0.12 v0.11 v0.10 v0.9 v0.8 v0.7 v0.6 v0.5 v0.4 v0.3 v0.2 v0.1","title":"\u4ecb\u7ecd"},{"location":"release-notes/release-notes-0.1/","text":"This is the first release of cert-manager. It is currently still not in a production ready state, and features are subject to change. Notable features: Automated certificate renewal ACME DNS01 challenge mechanism CloudDNS Route53 CloudFlare ACME HTTP01 challenge mechanism Should be compatible with all ingress controllers following ingress spec (GCE & NGINX tested) Simple CA based issuance Create an Issuer that references a Secret resource containing a signing key pair, and issue/renew certificates from that. Cluster-wide issuers (aka ClusterIssuer ) Backed by CRDs Events logged to the Kubernetes API Status block utilized to store additional state about resources Please check the [README( https://github.com/jetstack-experimental/cert-manager ) for a quick-start guide. We really value any feedback and contributions to the project. If you'd like to get involved, please open some issues, comment or pick something up and get started!","title":"Release Notes"},{"location":"release-notes/release-notes-0.10/","text":"The v0.10 release comes quick on the heels of v0.9 . It continues the work on the new CertificateRequest resource type, moving us towards a world where out-of-tree Issuer types are first class citizens. As a project, we're pushing towards a 'stable' API release and eventually, a v1.0 release. This release, and the releases to follow over the coming months, lay the foundation for these milestones. Keep an eye on the releases page over the coming months for some exciting new developments! You can get started using the new CertificateRequest controllers by enabling the CertificateRequestControllers feature gate - all Issuer types are now supported, and your feedback is extremely valuable before we switch the new implementation to be the default in v0.11 ! We've also simplified the way we bootstrap TLS certificates for the 'webhook' component. Now, instead of creating an Issuer and Certificate resource for the webhook (requiring you to disable validation on the cert-manager namespace), we've implemented a dedicated webhookbootstrap controller which will manage TLS assets for the webhook. This release includes changes from: Alejandro Garrido Mota Alpha Hans Kristian Flaatten James Munnelly Jonas-Taha El Sesiy JoshVanL Marcello Romani Moritz Johner Nicolas Kowenski Olaf Klischat Vasilis Remmas stuart.warren zeeZ Notable Items \u00b6 All Issuer types now supported with CertificateRequests \u00b6 The CertificateRequest design proposal, first implemented in v0.9 , changes the way we request certificates from Issuers in order to allow out-of-tree Issuer types. This required us to refactor and adapt our existing in-tree Issuer types to follow a similar pattern. The v0.10 release finishes this refactoring so that all Issuer types now support the new format. As the feature is currently still in an 'alpha' state, you must set the issuerRef.group field on your Certificate resources to certmanager.k8s.io , as well as enabling the CertificateRequestControllers feature gate on the controller component of cert-manager. Simplified webhook TLS bootstrapping \u00b6 In past releases, we've managed TLS for the webhook component by creating an internal self signed and CA issuer that is used to mint serving certificates for the apiserver to authenticate the webhook's identity. This introduced a number of complexities in our installation process and has caused trouble for users in the past. In order to simplify this process and to support running a CRD conversion webhook in future (to provide seamless migration between API versions), we've introduced a dedicated webhookbootstrap controller that relies on flags and Secret resources in order to configure TLS for the webhook. This will mean easier installation as well as future-proofing for our upcoming plans in future releases. KeyUsages on Certificate resources \u00b6 In order to support a more diverse set of applications, including apps that require client-auth certificates, a new field keyUsages has been added which accepts a list of usages that must be present on a Certificate. These will be automatically added when certificates are issued, just like any other field on the Certificate. Thanks to Stuart Warren from Ocado for this change! Preparation for v1alpha2 and beyond \u00b6 Over the last few releases, we've been making a number of significant changes to our API types (i.e. moving ACME configuration from Certificate resources onto the Issuer resource). This has involved deprecating some old API fields. In a future release, we'll be removing these deprecated fields altogether, requiring users to update their manifests to utilize the new way to specify configuration. A number of steps have been taken in our own code base to support this change, and in a future release, you'll be required to update all your manifests for this new format. Future API revisions (e.g. v1beta1 and v1 ) will be automatically converted using a Kubernetes conversion webhook (available in beta from Kubernetes 1.15 onward). Action Required \u00b6 No special actions are required as part of this release. Changelog \u00b6 General \u00b6 Add DisableDeprecatedACMECertificates feature gate to disable the old deprecated ACME configuration format ( #1923 , @munnerz ) chart: fix formatting of values table in README.md ( #1936 , @Starefossen ) Add internal API version and implement machinery for defaulting & conversion ( #2002 , @munnerz ) Fix concurrent map write panic in certificates controller ( #1980 , @munnerz ) cainjector : allow injecting CAs directly from Secret resources ( #1990 , @munnerz ) Mark spec and status as non-required fields in CRDs ( #1957 , @munnerz ) Add ability to specify key usages and extended key usages in certificates ( #1996 , @stuart-warren ) ACME Issuer \u00b6 Add option to assume role in Route53 DNS01 provider ( #1917 , @moolen ) Fix documentation for AzureDNS service principal creation ( #1960 , @elsesiy ) Webhook \u00b6 Use dedicated controller for webhook TLS bootstrapping ( #1993 , @munnerz ) CertificateRequest \u00b6 Add ACME CertificateRequest controller implementation ( #1943 , @JoshVanL ) Add Vault CertificateRequest controller implementation ( #1934 , @JoshVanL ) Add SelfSigned CertificateRequest controller implementation ( #1906 , @JoshVanL ) Add Venafi CertificateRequest controller implementation ( #1968 , @JoshVanL ) Don't validate issuerRef.kind field if issuerRef.group is set in order to support out-of-tree Issuer types ( #1949 , @munnerz ) Adds CertificateRequest FailureTime . The Certificate controller will re-try failed CertificateRequests at least one hour after this failed time. ( #1979 , @JoshVanL ) Monitoring \u00b6 Added variable to specify custom namespace where to deploy ServiceMonitor resource ( #1970 , @mogaal ) helm: fix labels and add Service for Prometheus ServiceMonitor ( #1942 , @Starefossen )","title":"Release Notes"},{"location":"release-notes/release-notes-0.10/#notable-items","text":"","title":"Notable Items"},{"location":"release-notes/release-notes-0.10/#all-issuer-types-now-supported-with-certificaterequests","text":"The CertificateRequest design proposal, first implemented in v0.9 , changes the way we request certificates from Issuers in order to allow out-of-tree Issuer types. This required us to refactor and adapt our existing in-tree Issuer types to follow a similar pattern. The v0.10 release finishes this refactoring so that all Issuer types now support the new format. As the feature is currently still in an 'alpha' state, you must set the issuerRef.group field on your Certificate resources to certmanager.k8s.io , as well as enabling the CertificateRequestControllers feature gate on the controller component of cert-manager.","title":"All Issuer types now supported with CertificateRequests"},{"location":"release-notes/release-notes-0.10/#simplified-webhook-tls-bootstrapping","text":"In past releases, we've managed TLS for the webhook component by creating an internal self signed and CA issuer that is used to mint serving certificates for the apiserver to authenticate the webhook's identity. This introduced a number of complexities in our installation process and has caused trouble for users in the past. In order to simplify this process and to support running a CRD conversion webhook in future (to provide seamless migration between API versions), we've introduced a dedicated webhookbootstrap controller that relies on flags and Secret resources in order to configure TLS for the webhook. This will mean easier installation as well as future-proofing for our upcoming plans in future releases.","title":"Simplified webhook TLS bootstrapping"},{"location":"release-notes/release-notes-0.10/#keyusages-on-certificate-resources","text":"In order to support a more diverse set of applications, including apps that require client-auth certificates, a new field keyUsages has been added which accepts a list of usages that must be present on a Certificate. These will be automatically added when certificates are issued, just like any other field on the Certificate. Thanks to Stuart Warren from Ocado for this change!","title":"KeyUsages on Certificate resources"},{"location":"release-notes/release-notes-0.10/#preparation-for-v1alpha2-and-beyond","text":"Over the last few releases, we've been making a number of significant changes to our API types (i.e. moving ACME configuration from Certificate resources onto the Issuer resource). This has involved deprecating some old API fields. In a future release, we'll be removing these deprecated fields altogether, requiring users to update their manifests to utilize the new way to specify configuration. A number of steps have been taken in our own code base to support this change, and in a future release, you'll be required to update all your manifests for this new format. Future API revisions (e.g. v1beta1 and v1 ) will be automatically converted using a Kubernetes conversion webhook (available in beta from Kubernetes 1.15 onward).","title":"Preparation for v1alpha2 and beyond"},{"location":"release-notes/release-notes-0.10/#action-required","text":"No special actions are required as part of this release.","title":"Action Required"},{"location":"release-notes/release-notes-0.10/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.10/#general","text":"Add DisableDeprecatedACMECertificates feature gate to disable the old deprecated ACME configuration format ( #1923 , @munnerz ) chart: fix formatting of values table in README.md ( #1936 , @Starefossen ) Add internal API version and implement machinery for defaulting & conversion ( #2002 , @munnerz ) Fix concurrent map write panic in certificates controller ( #1980 , @munnerz ) cainjector : allow injecting CAs directly from Secret resources ( #1990 , @munnerz ) Mark spec and status as non-required fields in CRDs ( #1957 , @munnerz ) Add ability to specify key usages and extended key usages in certificates ( #1996 , @stuart-warren )","title":"General"},{"location":"release-notes/release-notes-0.10/#acme-issuer","text":"Add option to assume role in Route53 DNS01 provider ( #1917 , @moolen ) Fix documentation for AzureDNS service principal creation ( #1960 , @elsesiy )","title":"ACME Issuer"},{"location":"release-notes/release-notes-0.10/#webhook","text":"Use dedicated controller for webhook TLS bootstrapping ( #1993 , @munnerz )","title":"Webhook"},{"location":"release-notes/release-notes-0.10/#certificaterequest","text":"Add ACME CertificateRequest controller implementation ( #1943 , @JoshVanL ) Add Vault CertificateRequest controller implementation ( #1934 , @JoshVanL ) Add SelfSigned CertificateRequest controller implementation ( #1906 , @JoshVanL ) Add Venafi CertificateRequest controller implementation ( #1968 , @JoshVanL ) Don't validate issuerRef.kind field if issuerRef.group is set in order to support out-of-tree Issuer types ( #1949 , @munnerz ) Adds CertificateRequest FailureTime . The Certificate controller will re-try failed CertificateRequests at least one hour after this failed time. ( #1979 , @JoshVanL )","title":"CertificateRequest"},{"location":"release-notes/release-notes-0.10/#monitoring","text":"Added variable to specify custom namespace where to deploy ServiceMonitor resource ( #1970 , @mogaal ) helm: fix labels and add Service for Prometheus ServiceMonitor ( #1942 , @Starefossen )","title":"Monitoring"},{"location":"release-notes/release-notes-0.11/","text":"The v0.11 release is a significant milestone for the cert-manager project, and is full of new features. We are making a number of changes to our CRDs in a backwards incompatible way, in preparation for moving into v1beta1 and eventually v1 in the coming releases: Renaming our API group from certmanager.k8s.io to cert-manager.io Bumping the API version from v1alpha1 to v1alpha2 Removing fields deprecated in v0.8 ( certificate.spec.acme , issuer.spec.http01 and issuer.spec.dns01 ) Renaming annotation prefixes on Ingress & cert-manager resources to use the new cert-manager.io prefix, and in some cases acme.cert-manager.io Using the status subresource for submitting status updates to the API, first introduced in Kubernetes 1.9. Tightening use of common name vs DNS name with ACME certificates We have also switched to using the new [ CertificateRequest ] based Certificate issuance implementation, first introduced in alpha in cert-manager v0.9 . These changes enable exciting new integrations points in cert-manager, enabling new things like: External issuer types, such as the [Smallstep Step Issuer] Deeper integrations into Kubernetes, with an experimental [CSI driver] that can be used to automatically mount signed certificates into pods Experimental integration with Istio, allowing you to utilize any of cert-manager's configured issuer types/CAs with the [node agent] Retrieving certificates without giving cert-manager access to your private keys This is a really exciting time for cert-manager, as these changes have been made possible by refining our past decisions around API types, and they will enable us to push ahead with many new features in the project. Important information \u00b6 With all of these great changes, there is also work to do. The changes to our CRD resources mean that upgrading requires more manual intervention than in previous releases. It's recommended that you backup and completely uninstall cert-manager before re-installing the v0.11 release. You will also need to manually update all your backed up cert-manager resource types to use the new apiVersion setting. A table of resources and their old and new apiVersion s: Kind Old apiVersion New apiVersion Certificate certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 Issuer certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 ClusterIssuer certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 CertificateRequest certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 Order certmanager.k8s.io/v1alpha1 acme.cert-manager.io/v1alpha2 Challenge certmanager.k8s.io/v1alpha1 acme.cert-manager.io/v1alpha2 You must also make sure to update all references to cert-manager in annotations to their new prefix: Annotation Affected resources New annotation certmanager.k8s.io/acme-http01-edit-in-place Ingress acme.cert-manager.io/http01-edit-in-place certmanager.k8s.io/acme-http01-ingress-class Ingress acme.cert-manager.io/http01-ingress-class certmanager.k8s.io/issuer Ingress cert-manager.io/issuer certmanager.k8s.io/cluster-issuer Ingress cert-manager.io/cluster-issuer certmanager.k8s.io/acme-challenge-type Ingress REMOVED certmanager.k8s.io/acme-dns01-provider Ingress REMOVED certmanager.k8s.io/alt-names Ingress, Secret cert-manager.io/alt-names certmanager.k8s.io/ip-sans Ingress, Secret cert-manager.io/ip-sans certmanager.k8s.io/common-name Ingress, Secret cert-manager.io/common-name certmanager.k8s.io/issuer-name Ingress, Secret cert-manager.io/issuer-name Ingress, Secret cert-manager.io/issuer-kind Ingress, Secret cert-manager.io/issuer-group Ingress, Secret cert-manager.io/uri-sans Certificate cert-manager.io/issue-temporary-certificate CertificateRequest cert-manager.io/private-key-secret-name certmanager.k8s.io/certificate-name CertificateRequest, Secret cert-manager.io/certificate-name Contributors \u00b6 This release has seen code contributions from a number of people in the community: Adam Kunicki Alpha Brian Hong Dan Farrell Dig-Doug Galo Navarro Ingo Gottwald James Munnelly JoshVanL Kevin Lefevre Lachlan Cooper Michel Blankleder Toni Menzel Wellington F Silva Woz dulltz As always, a big thank you to those opening issues, replying to issues and helping out in the Slack channel. As well as working in other projects to help users secure services running on Kubernetes. Notable changes \u00b6 Renamed API group \u00b6 Due to new policies in the upstream Kubernetes project, we have renamed the API group from certmanager.k8s.io to cert-manager.io . This is a breaking change to our API surface as mentioned above, but it is a long time coming. The original k8s.io suffix was used when the project first started as there was not official guidance or information on how ThirdPartyResources should be structured. Now that this area of the Kubernetes project has evolved further, we're retrospectively changing this to conform with the new requirements. Moving to v1alpha2 \u00b6 When cert-manager first started, we defined our APIs based on what we thought made sense for end-users. Over time, through gathering feedback and monitoring the way users are actually using cert-manager, we've identified some issues with our original API design. As part of the project moving towards v1 , we've identified certain areas of our APIs that are not fit for purpose. In order to begin the process of moving towards v1 , we first deprecated a number of fields in our v1alpha1 API. We've now dropped these API fields in v1alpha2 , in preparation for declaring this new API as v1beta1 in the coming releases. New CertificateRequest resource type \u00b6 The activation of CertificateRequest controllers are no longer behind a feature and are now instead enabled by default. This means that when requesting certificates using the Certificate resource the CertificateRequest resource will be used as the default and only way to honor the request. The addition of this resource introduces the ability for much greater extension points to cert-manager, notably out-of-tree issuers, Istio integrations, and experimental tooling such as a CSI driver. You can read more about the motivation and design of this resource in the enhancement document . This change should cause no disruption to how end users interact with cert-manager, with the exception of debugging now requiring this resource to be inspected also. Support for out-of-tree issuer types \u00b6 With the graduation of the CertificateRequest resource, cert-manager now supports out-of-tree issuers by default and treats them the same as any other core issuer. This process is facilitated by the addition of the group field on issuer references inside your Certificate and CertificateRequest resources. If you're interested in implementing your own out-of-tree issuer, or if there is a provider you would like see implemented, feel free to reach out either through a GitHub issue or send us a message in the #cert-manager channel on Kubernetes Slack ! New fields on Certificate resources \u00b6 This release includes a new field URISANs on the Certificate resource. With this, you can specify unique resource identifier URLs as subject alternative names on your certificates. This addition unblocks development for an Istio integration where mTLS can be configured using cert-manager as the backend and in turn opens up all cert-manager issuer types as valid certificate providers in your Istio PKI. Improved ACME Order controller design \u00b6 Some users may have noticed issues with the 'Order' resource not automatically detecting changes to their configure 'solvers' on their Issuer resources. In v0.11 , we've rewritten the ACME Order handling code to: 1) better handle updates to Issuers during an Order 2) improve ACME API usage - we now cache more information about the ACME Order process in the Kubernetes API, which allows us to act more reliably and without causing excessive requests to the ACME server. No longer generating 'temporary certificates' by default \u00b6 Previously, we have issued a temporary certificate when a Certificate resource targeting an ACME issuer has been created. This would later be overridden once the real signed certificate has been issued. The reason for this behavior was to facilitate compatibility with ingress-gce however, many users have had trouble with this in the past and has led to lots of confusion - namely where applications would need restarting to take on the signed certificate rather than the temporary. In this release, no temporary certificates will be created unless explicitly requested. This can be done using the annotation \"cert-manager.io/issue-temporary-certificate\": \"true on Certifcate resources. We've additionally changed the behavior of ingress-shim to now add this new annotation to Certificate resources if \"acme.cert-manager.io/http01-edit-in-place\" is present on the Ingress resource. Changelog \u00b6 Action Required \u00b6 Rename certmanager.k8s.io API group to cert-manager.io ( #2096 , @munnerz ) Move Order and Challenge resources to the acme.cert-manager.io API group ( #2093 , @munnerz ) Move v1alpha1 API to v1alpha2 ( #2087 , @munnerz ) Allow controlling whether temporary certificates are issued using a new annotation certmanager.k8s.io/issue-temporary-certificate on Certificate resources. Previously, when an ACME certificate was requested, a temporary certificate would be issued in order to improve compatibility with ingress-gce . ingress-shim has been updated to automatically set this annotation on managed Certificate resources when using the 'edit-in-place' annotation, but users that have manually created their Certificate resources will need to manually add the new annotation to their Certificate resources. ( #2089 , @munnerz ) Other Notable Changes \u00b6 Change the default leader election namespace to kube-system instead of the same namespace as the cert-manager pod, to avoid multiple copies of cert-manager accidentally being run at once ( #2155 , @munnerz ) Adds URISANs field to Certificate.Spec resource. ( #2085 , @JoshVanL ) Move status to a CRD Subresource ( #2097 , @JoshVanL ) Enables supporting out of tree issuers with ingress annotations ( #2105 , @JoshVanL ) Bump Kubernetes dependencies to 1.16.0 ( #2095 , @munnerz ) Adds Certificate conformance suite ( #2034 , @JoshVanL ) Build using Go 1.13.1 ( #2114 , @munnerz ) Adds Kubernetes authentication type for Vault Issue ( #2040 , @JoshVanL ) Service account annotation support in Helm chart ( #2086 , @serialx ) Update AWS Go SDK to 1.24.1 to support IAM Roles for Service Accounts ( #2083 , @serialx ) Remove deprecated API fields and functionality ( #2082 , @munnerz ) Update hack/ci/run-dev-kind.sh script to use the right path of cert-manager charts. ( #2074 , @srvaroa ) Simplify, improve and rewrite the acmeorders controller ( #2041 , @munnerz )","title":"Release Notes"},{"location":"release-notes/release-notes-0.11/#important-information","text":"With all of these great changes, there is also work to do. The changes to our CRD resources mean that upgrading requires more manual intervention than in previous releases. It's recommended that you backup and completely uninstall cert-manager before re-installing the v0.11 release. You will also need to manually update all your backed up cert-manager resource types to use the new apiVersion setting. A table of resources and their old and new apiVersion s: Kind Old apiVersion New apiVersion Certificate certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 Issuer certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 ClusterIssuer certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 CertificateRequest certmanager.k8s.io/v1alpha1 cert-manager.io/v1alpha2 Order certmanager.k8s.io/v1alpha1 acme.cert-manager.io/v1alpha2 Challenge certmanager.k8s.io/v1alpha1 acme.cert-manager.io/v1alpha2 You must also make sure to update all references to cert-manager in annotations to their new prefix: Annotation Affected resources New annotation certmanager.k8s.io/acme-http01-edit-in-place Ingress acme.cert-manager.io/http01-edit-in-place certmanager.k8s.io/acme-http01-ingress-class Ingress acme.cert-manager.io/http01-ingress-class certmanager.k8s.io/issuer Ingress cert-manager.io/issuer certmanager.k8s.io/cluster-issuer Ingress cert-manager.io/cluster-issuer certmanager.k8s.io/acme-challenge-type Ingress REMOVED certmanager.k8s.io/acme-dns01-provider Ingress REMOVED certmanager.k8s.io/alt-names Ingress, Secret cert-manager.io/alt-names certmanager.k8s.io/ip-sans Ingress, Secret cert-manager.io/ip-sans certmanager.k8s.io/common-name Ingress, Secret cert-manager.io/common-name certmanager.k8s.io/issuer-name Ingress, Secret cert-manager.io/issuer-name Ingress, Secret cert-manager.io/issuer-kind Ingress, Secret cert-manager.io/issuer-group Ingress, Secret cert-manager.io/uri-sans Certificate cert-manager.io/issue-temporary-certificate CertificateRequest cert-manager.io/private-key-secret-name certmanager.k8s.io/certificate-name CertificateRequest, Secret cert-manager.io/certificate-name","title":"Important information"},{"location":"release-notes/release-notes-0.11/#contributors","text":"This release has seen code contributions from a number of people in the community: Adam Kunicki Alpha Brian Hong Dan Farrell Dig-Doug Galo Navarro Ingo Gottwald James Munnelly JoshVanL Kevin Lefevre Lachlan Cooper Michel Blankleder Toni Menzel Wellington F Silva Woz dulltz As always, a big thank you to those opening issues, replying to issues and helping out in the Slack channel. As well as working in other projects to help users secure services running on Kubernetes.","title":"Contributors"},{"location":"release-notes/release-notes-0.11/#notable-changes","text":"","title":"Notable changes"},{"location":"release-notes/release-notes-0.11/#renamed-api-group","text":"Due to new policies in the upstream Kubernetes project, we have renamed the API group from certmanager.k8s.io to cert-manager.io . This is a breaking change to our API surface as mentioned above, but it is a long time coming. The original k8s.io suffix was used when the project first started as there was not official guidance or information on how ThirdPartyResources should be structured. Now that this area of the Kubernetes project has evolved further, we're retrospectively changing this to conform with the new requirements.","title":"Renamed API group"},{"location":"release-notes/release-notes-0.11/#moving-to-v1alpha2","text":"When cert-manager first started, we defined our APIs based on what we thought made sense for end-users. Over time, through gathering feedback and monitoring the way users are actually using cert-manager, we've identified some issues with our original API design. As part of the project moving towards v1 , we've identified certain areas of our APIs that are not fit for purpose. In order to begin the process of moving towards v1 , we first deprecated a number of fields in our v1alpha1 API. We've now dropped these API fields in v1alpha2 , in preparation for declaring this new API as v1beta1 in the coming releases.","title":"Moving to v1alpha2"},{"location":"release-notes/release-notes-0.11/#new-certificaterequest-resource-type","text":"The activation of CertificateRequest controllers are no longer behind a feature and are now instead enabled by default. This means that when requesting certificates using the Certificate resource the CertificateRequest resource will be used as the default and only way to honor the request. The addition of this resource introduces the ability for much greater extension points to cert-manager, notably out-of-tree issuers, Istio integrations, and experimental tooling such as a CSI driver. You can read more about the motivation and design of this resource in the enhancement document . This change should cause no disruption to how end users interact with cert-manager, with the exception of debugging now requiring this resource to be inspected also.","title":"New CertificateRequest resource type"},{"location":"release-notes/release-notes-0.11/#support-for-out-of-tree-issuer-types","text":"With the graduation of the CertificateRequest resource, cert-manager now supports out-of-tree issuers by default and treats them the same as any other core issuer. This process is facilitated by the addition of the group field on issuer references inside your Certificate and CertificateRequest resources. If you're interested in implementing your own out-of-tree issuer, or if there is a provider you would like see implemented, feel free to reach out either through a GitHub issue or send us a message in the #cert-manager channel on Kubernetes Slack !","title":"Support for out-of-tree issuer types"},{"location":"release-notes/release-notes-0.11/#new-fields-on-certificate-resources","text":"This release includes a new field URISANs on the Certificate resource. With this, you can specify unique resource identifier URLs as subject alternative names on your certificates. This addition unblocks development for an Istio integration where mTLS can be configured using cert-manager as the backend and in turn opens up all cert-manager issuer types as valid certificate providers in your Istio PKI.","title":"New fields on Certificate resources"},{"location":"release-notes/release-notes-0.11/#improved-acme-order-controller-design","text":"Some users may have noticed issues with the 'Order' resource not automatically detecting changes to their configure 'solvers' on their Issuer resources. In v0.11 , we've rewritten the ACME Order handling code to: 1) better handle updates to Issuers during an Order 2) improve ACME API usage - we now cache more information about the ACME Order process in the Kubernetes API, which allows us to act more reliably and without causing excessive requests to the ACME server.","title":"Improved ACME Order controller design"},{"location":"release-notes/release-notes-0.11/#no-longer-generating-temporary-certificates-by-default","text":"Previously, we have issued a temporary certificate when a Certificate resource targeting an ACME issuer has been created. This would later be overridden once the real signed certificate has been issued. The reason for this behavior was to facilitate compatibility with ingress-gce however, many users have had trouble with this in the past and has led to lots of confusion - namely where applications would need restarting to take on the signed certificate rather than the temporary. In this release, no temporary certificates will be created unless explicitly requested. This can be done using the annotation \"cert-manager.io/issue-temporary-certificate\": \"true on Certifcate resources. We've additionally changed the behavior of ingress-shim to now add this new annotation to Certificate resources if \"acme.cert-manager.io/http01-edit-in-place\" is present on the Ingress resource.","title":"No longer generating 'temporary certificates' by default"},{"location":"release-notes/release-notes-0.11/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.11/#action-required","text":"Rename certmanager.k8s.io API group to cert-manager.io ( #2096 , @munnerz ) Move Order and Challenge resources to the acme.cert-manager.io API group ( #2093 , @munnerz ) Move v1alpha1 API to v1alpha2 ( #2087 , @munnerz ) Allow controlling whether temporary certificates are issued using a new annotation certmanager.k8s.io/issue-temporary-certificate on Certificate resources. Previously, when an ACME certificate was requested, a temporary certificate would be issued in order to improve compatibility with ingress-gce . ingress-shim has been updated to automatically set this annotation on managed Certificate resources when using the 'edit-in-place' annotation, but users that have manually created their Certificate resources will need to manually add the new annotation to their Certificate resources. ( #2089 , @munnerz )","title":"Action Required"},{"location":"release-notes/release-notes-0.11/#other-notable-changes","text":"Change the default leader election namespace to kube-system instead of the same namespace as the cert-manager pod, to avoid multiple copies of cert-manager accidentally being run at once ( #2155 , @munnerz ) Adds URISANs field to Certificate.Spec resource. ( #2085 , @JoshVanL ) Move status to a CRD Subresource ( #2097 , @JoshVanL ) Enables supporting out of tree issuers with ingress annotations ( #2105 , @JoshVanL ) Bump Kubernetes dependencies to 1.16.0 ( #2095 , @munnerz ) Adds Certificate conformance suite ( #2034 , @JoshVanL ) Build using Go 1.13.1 ( #2114 , @munnerz ) Adds Kubernetes authentication type for Vault Issue ( #2040 , @JoshVanL ) Service account annotation support in Helm chart ( #2086 , @serialx ) Update AWS Go SDK to 1.24.1 to support IAM Roles for Service Accounts ( #2083 , @serialx ) Remove deprecated API fields and functionality ( #2082 , @munnerz ) Update hack/ci/run-dev-kind.sh script to use the right path of cert-manager charts. ( #2074 , @srvaroa ) Simplify, improve and rewrite the acmeorders controller ( #2041 , @munnerz )","title":"Other Notable Changes"},{"location":"release-notes/release-notes-0.12/","text":"The v0.12.0 release is finally ready! After a KubeCon-induced delay, this version focuses on usability, user experience, bug-fixes and documentation. A big notable feature in this release is the new cert-manager.io website - this has been a long time coming, but we hope that the information on this site should more clearly walk new and experienced users alike through the tool, and with it the rewrite into Markdown (with Hugo ) should make external contributions easier! The rest of the notable features below are all focused on usability, and as such, the upgrade process from v0.11 should be nice and easy :holiday:. We'll be doing an in-depth walk-through of this release and what's planned for for the next release during the next community call on Wednesday 4 th December! For more details on joining and getting involved, see the community section . Contributors \u00b6 This release has seen code contributions from a number of people in the community: Adrian Mouat Benjamin P. Jung Bouke van der Bijl Christian Groschupp Christophe Courtaut Eric Bailey Harold Drost Ingo Gottwald James Munnelly JayatiGoyal Joshua Van Leeuwen Krishna Durai Luca Berneking Matevz Mihalic Max Goltzsche Nick Parker Nils Cant Nolan Reisbeck Pierre Dorbais Sam Cogan Thomas chenjun.cj ismail BASKIN walter.goulet As always, a big thank you to those opening issues, replying to issues and helping out in the Slack channel. As well as working in other projects to help users secure services running on Kubernetes. Notable changes \u00b6 New website \u00b6 We have launched a new website to better showcase cert-manager, which can be found at cert-manager.io . With this new site, we have also significantly restructured and rewritten the documentation for the site in order to flow better, and hopefully inform users more on the inner-workings of cert-manager whilst still making on-boarding to the project easy. Whilst this is the first launch of the new website, there is still lots to do! If you have any feedback, ideas or expertise to improve the site, please open an issue or make a contribution over in the new cert-manager/website repository. Multi-architecture images \u00b6 If you run a non-homogeneous or alt-architecture cluster (i.e. arm or arm64 ) then you may have run into issues when deploying cert-manager. For almost a year now, we have published Docker images built for these architectures, but due to limitations in quay.io , using these images has required changing deployment manifests and passing additional flags to different cert-manager components. As of v0.12 , we make use of Docker Image Manifests v2.2 , which means that you will no longer have to make any changes to the deployment manifests in order to deploy cert-manager into your cluster! This is a big usability win for users of non- amd64 systems, and a big +1 for usability! Making it easier to debug failing ACME challenges \u00b6 During the ACME authorization flow, a number of issues can arise such as misconfigured DNS records or ingress controllers. This release makes it simpler to identify these issues when they occur, providing additional debugging information through the user of kubectl describe challenge <name-of-failing-challenge> . Whilst this is a small addition, it vastly improves the user experience for first time users who may have configuration issues with their DNS records or cert-manager installation, another win for usability! Simplifying the webhook component \u00b6 For those of you upgrading from older versions of cert-manager, you may already be aware of some of the deployment issues with the 'webhook' component in cert-manager. In previous releases, this component relied on the creation of an APIService resource in order for the Kubernetes apiserver to utilize the webhook and provide additional validation for our CustomResourceDefinition types. An APIService is a powerful resource, however, due to its nature, can cause certain core operations (such as garbage collection) to not function if the webhook becomes unavailable at any point, which can in turn cause cascading failures in your Kubernetes cluster in the worst of cases. In v0.12 , we have rewritten this component almost entirely, and we no longer make use of the APIService resource in order to expose it. This should mean deploying the webhook is far easier, and far less likely to cause cluster-wide issues. We have also extended the webhook to support 'API conversions' for our CRD types. Whilst we don't currently make use of this functionality, when we release the v1beta1 we will make use of it, at which point the webhook will be a required component in clusters running Kubernetes 1.15 or greater. Changelog \u00b6 Action Required \u00b6 ACTION REQUIRED Users who have previously set the Kubernetes Auth Mount Path will need to update their manifests to include the entire mount path. The /login endpoint is added for you. Changes the Vault Kubernetes Auth Path to require the entire mount path. /login is added to all mount paths when authenticating. The default auth path has now changed from kubernetes to /v1/auth/kubernetes ( #2349 , @JoshVanL ) Bug Fixes \u00b6 Fixes issues with Pod Security Policies that prevented pods from running when Pod Security Policy is enabled in Kubernetes ( #2234 , @sam-cogan ) Fix issue causing certificates not to be issued when running with OwnerReferencesPermissionEnforcement admission controller enabled ( #2325 , @CoaxVex ) Fix bug causing SIGTERM and SIGINT signals to not be respected whilst the controller is performing leader election ( #2236 , @munnerz ) Fix setting ownerReference on Challenge resources created by Orders controller ( #2324 , @CoaxVex ) Allow CloudDNS resolvers to be validated correctly without serviceAccountSecretRef to allow ambient permissions to be used. ( #2250 , @baelish ) Add missing apiVersion to Chart.yaml ( #2270 , @yurrriq ) Perform API resource validation of the 'status' subresource on cert-manager resources ( #2283 , @munnerz ) Fix outdated documentation for solver configuration in Issuers and ClusterIssuers ( #2210 , @nickbp ) Other Notable Changes \u00b6 Explicitly define containerPort protocol in helm chart ( #2405 , @bouk ) Allow permissive acceptance for matching Certificates with Secrets that are using legacy annotations to reduce non-required certificate reissue. ( #2400 , @JoshVanL ) Add API token authentication option to CloudFlare issuer ( #2170 , @matevzmihalic ) Bump Kubernetes client library dependencies to 1.16.3 ( #2290 , @munnerz ) Build using go 1.13.4 ( #2366 , @munnerz ) Mark certificaterequest.spec.csr field as required in OpenAPI schema ( #2368 , @munnerz ) Add serverAuth extended key usage to Certificates by default ( #2351 , @JoshVanL ) Surface more information about ACME authorization failures on Challenge resources ( #2261 , @munnerz ) Add documentation for the webhook ( #2252 , @cgroschupp ) Add support for API resource conversion to the webhook. NOTE: this feature is not currently utilized by cert-manager ( #2001 , @munnerz ) Remove nested cainjector sub chart and include it in main chart ( #2285 , @munnerz ) Change the default webhook listen address to 10250 for better compatibility with GKE private clusters ( #2278 , @munnerz ) Bump Helm & Tiller version used during end-to-end tests to 2.15.1 ( #2275 , @munnerz ) Make spec.csr , status.url , status.finalizeURL , status.certificate , status.authorizations , status.authorizations[].url , status.authorizations[].identifier , status.authorizations[].wildcard , status.authorizations[].challenges , status.authorizations[].challenges[].url , status.authorizations[].challenges[].type , status.authorizations[].challenges[].token fields on Order resources immutable ( #2219 , @munnerz ) No longer use architecture specific acmesolver images ( #2242 , @munnerz ) enable cert-manager using --kubeconfig to connect API Server with kubeconfig file ( #2224 , @answer1991 ) Publish multi-architecture docker manifest lists ( #2230 , @munnerz ) Make order.status.authorizations[].wildcard field a *bool ( #2225 , @munnerz ) Kubernetes APIServer dry-run is supported. ( #2206 , @ismailbaskin )","title":"Release Notes"},{"location":"release-notes/release-notes-0.12/#contributors","text":"This release has seen code contributions from a number of people in the community: Adrian Mouat Benjamin P. Jung Bouke van der Bijl Christian Groschupp Christophe Courtaut Eric Bailey Harold Drost Ingo Gottwald James Munnelly JayatiGoyal Joshua Van Leeuwen Krishna Durai Luca Berneking Matevz Mihalic Max Goltzsche Nick Parker Nils Cant Nolan Reisbeck Pierre Dorbais Sam Cogan Thomas chenjun.cj ismail BASKIN walter.goulet As always, a big thank you to those opening issues, replying to issues and helping out in the Slack channel. As well as working in other projects to help users secure services running on Kubernetes.","title":"Contributors"},{"location":"release-notes/release-notes-0.12/#notable-changes","text":"","title":"Notable changes"},{"location":"release-notes/release-notes-0.12/#new-website","text":"We have launched a new website to better showcase cert-manager, which can be found at cert-manager.io . With this new site, we have also significantly restructured and rewritten the documentation for the site in order to flow better, and hopefully inform users more on the inner-workings of cert-manager whilst still making on-boarding to the project easy. Whilst this is the first launch of the new website, there is still lots to do! If you have any feedback, ideas or expertise to improve the site, please open an issue or make a contribution over in the new cert-manager/website repository.","title":"New website"},{"location":"release-notes/release-notes-0.12/#multi-architecture-images","text":"If you run a non-homogeneous or alt-architecture cluster (i.e. arm or arm64 ) then you may have run into issues when deploying cert-manager. For almost a year now, we have published Docker images built for these architectures, but due to limitations in quay.io , using these images has required changing deployment manifests and passing additional flags to different cert-manager components. As of v0.12 , we make use of Docker Image Manifests v2.2 , which means that you will no longer have to make any changes to the deployment manifests in order to deploy cert-manager into your cluster! This is a big usability win for users of non- amd64 systems, and a big +1 for usability!","title":"Multi-architecture images"},{"location":"release-notes/release-notes-0.12/#making-it-easier-to-debug-failing-acme-challenges","text":"During the ACME authorization flow, a number of issues can arise such as misconfigured DNS records or ingress controllers. This release makes it simpler to identify these issues when they occur, providing additional debugging information through the user of kubectl describe challenge <name-of-failing-challenge> . Whilst this is a small addition, it vastly improves the user experience for first time users who may have configuration issues with their DNS records or cert-manager installation, another win for usability!","title":"Making it easier to debug failing ACME challenges"},{"location":"release-notes/release-notes-0.12/#simplifying-the-webhook-component","text":"For those of you upgrading from older versions of cert-manager, you may already be aware of some of the deployment issues with the 'webhook' component in cert-manager. In previous releases, this component relied on the creation of an APIService resource in order for the Kubernetes apiserver to utilize the webhook and provide additional validation for our CustomResourceDefinition types. An APIService is a powerful resource, however, due to its nature, can cause certain core operations (such as garbage collection) to not function if the webhook becomes unavailable at any point, which can in turn cause cascading failures in your Kubernetes cluster in the worst of cases. In v0.12 , we have rewritten this component almost entirely, and we no longer make use of the APIService resource in order to expose it. This should mean deploying the webhook is far easier, and far less likely to cause cluster-wide issues. We have also extended the webhook to support 'API conversions' for our CRD types. Whilst we don't currently make use of this functionality, when we release the v1beta1 we will make use of it, at which point the webhook will be a required component in clusters running Kubernetes 1.15 or greater.","title":"Simplifying the webhook component"},{"location":"release-notes/release-notes-0.12/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.12/#action-required","text":"ACTION REQUIRED Users who have previously set the Kubernetes Auth Mount Path will need to update their manifests to include the entire mount path. The /login endpoint is added for you. Changes the Vault Kubernetes Auth Path to require the entire mount path. /login is added to all mount paths when authenticating. The default auth path has now changed from kubernetes to /v1/auth/kubernetes ( #2349 , @JoshVanL )","title":"Action Required"},{"location":"release-notes/release-notes-0.12/#bug-fixes","text":"Fixes issues with Pod Security Policies that prevented pods from running when Pod Security Policy is enabled in Kubernetes ( #2234 , @sam-cogan ) Fix issue causing certificates not to be issued when running with OwnerReferencesPermissionEnforcement admission controller enabled ( #2325 , @CoaxVex ) Fix bug causing SIGTERM and SIGINT signals to not be respected whilst the controller is performing leader election ( #2236 , @munnerz ) Fix setting ownerReference on Challenge resources created by Orders controller ( #2324 , @CoaxVex ) Allow CloudDNS resolvers to be validated correctly without serviceAccountSecretRef to allow ambient permissions to be used. ( #2250 , @baelish ) Add missing apiVersion to Chart.yaml ( #2270 , @yurrriq ) Perform API resource validation of the 'status' subresource on cert-manager resources ( #2283 , @munnerz ) Fix outdated documentation for solver configuration in Issuers and ClusterIssuers ( #2210 , @nickbp )","title":"Bug Fixes"},{"location":"release-notes/release-notes-0.12/#other-notable-changes","text":"Explicitly define containerPort protocol in helm chart ( #2405 , @bouk ) Allow permissive acceptance for matching Certificates with Secrets that are using legacy annotations to reduce non-required certificate reissue. ( #2400 , @JoshVanL ) Add API token authentication option to CloudFlare issuer ( #2170 , @matevzmihalic ) Bump Kubernetes client library dependencies to 1.16.3 ( #2290 , @munnerz ) Build using go 1.13.4 ( #2366 , @munnerz ) Mark certificaterequest.spec.csr field as required in OpenAPI schema ( #2368 , @munnerz ) Add serverAuth extended key usage to Certificates by default ( #2351 , @JoshVanL ) Surface more information about ACME authorization failures on Challenge resources ( #2261 , @munnerz ) Add documentation for the webhook ( #2252 , @cgroschupp ) Add support for API resource conversion to the webhook. NOTE: this feature is not currently utilized by cert-manager ( #2001 , @munnerz ) Remove nested cainjector sub chart and include it in main chart ( #2285 , @munnerz ) Change the default webhook listen address to 10250 for better compatibility with GKE private clusters ( #2278 , @munnerz ) Bump Helm & Tiller version used during end-to-end tests to 2.15.1 ( #2275 , @munnerz ) Make spec.csr , status.url , status.finalizeURL , status.certificate , status.authorizations , status.authorizations[].url , status.authorizations[].identifier , status.authorizations[].wildcard , status.authorizations[].challenges , status.authorizations[].challenges[].url , status.authorizations[].challenges[].type , status.authorizations[].challenges[].token fields on Order resources immutable ( #2219 , @munnerz ) No longer use architecture specific acmesolver images ( #2242 , @munnerz ) enable cert-manager using --kubeconfig to connect API Server with kubeconfig file ( #2224 , @answer1991 ) Publish multi-architecture docker manifest lists ( #2230 , @munnerz ) Make order.status.authorizations[].wildcard field a *bool ( #2225 , @munnerz ) Kubernetes APIServer dry-run is supported. ( #2206 , @ismailbaskin )","title":"Other Notable Changes"},{"location":"release-notes/release-notes-0.13/","text":"The v0.13 contains a number of important bug-fixes and a few notable feature additions. It is a minor, incremental update over v0.12 and does not require any special upgrade steps. ACME External Account Binding support \u00b6 Users that wish to use cert-manager with ACME servers other than Let's Encrypt may have found themselves unable to register an account due to the lack of (EAB) 'External Account Binding' support. This allows an ACME server to validate that a user is somehow associated with some other entity, like an account in the CAs customer management system. With EAB support, it's now possible to specify additional parameters ( spec.acme.externalAccountBinding ) on your ACME Issuer resource and utilize cert-manager with your preferred ACME provider. Support for full set of X.509 'subject' parameters \u00b6 In this release, support for the full range of 'subject' parameters as per the X.509 specification has been added. This means you can set fields like organizationalUnit , provinces , serialNumber , country , and all other standard X.509 subject fields. A big thanks to @mathianasj for this addition! InvalidRequest status condition for CertificateRequest resources \u00b6 For the growing ecosystem of developers creating their own 'external issuer types' for cert-manager, we have added support for a new 'status condition' type InvalidRequest - this can be used to signal from your signer/issuer to cert-manager that the parameters that the user has requested on the X.509 CSR are 'invalid' and the CSR should not be retried. This prevents users expending API quotas and making requests that will never succeed. Bug Fixes \u00b6 Fix invalid service account name used in RBAC resources when manually specifying a service account name ( #2509 , @castlemilk ) fixed a bug that in certain cases could cause HTTP01 ingress serviceName fields to be incorrectly set ( #2460 , @greywolve ) Fix bug causing ever-increasing CPU usage in webhook component ( #2467 , @munnerz ) Fix bug causing temporary certificates to overwrite previously issued certificates when adding a new dnsName to an existing Certificate resource ( #2469 , @munnerz ) Fix certmanager_certificate_expiration_timestamp_seconds metric recording ( #2416 , @munnerz ) Fixes ClusterIssuers not finding the secret when the secret is in a different namespace than the certificate request using the Venafi issuer type ( #2520 , @mathianasj ) Fixes generation if invalid certificate name the the 52 nd character in a domain name is a symbol. ( #2516 , @meyskens ) Other Notable Changes \u00b6 Adds InvalidRequest condition type to CertificateRequest , signaling to not retry the request. ( #2508 , @JoshVanL ) Add volume and volume mounts field to cert-manager helm chart ( #2504 , @joshuastern ) Add support for additional X.509 'subject' fields ( #2518 , @mathianasj ) Bump k8s.io/* dependencies to Kubernetes 1.17.0 ( #2452 , @munnerz ) It is now possible to disable AppArmor when Pod Security Policies are used. ( #2489 , @czunker ) Support for arbitrary securityContext parameters ( #2455 , @nefischer ) Remove misleading 'error decoding X.509 certificate' message ( #2470 , @munnerz ) Remove IP address validation on dns01-recursive-nameservers to allow domain names ( #2428 , @haines ) Optional webhook.securityContext and cainjector.securityContext chart parameters to specify pods security context. ( #2449 , @nefischer ) webhook: register HTTP handlers for pprof debug endpoints ( #2450 , @munnerz ) Adds support for chart configurable parameters deploymentAnnotations , webhook.deploymentAnnotations and cainjector.deploymentAnnotations ( #2447 , @nefischer ) Adds ACME external account binding support ( #2392 , @JoshVanL ) Fix false-y values in helm chart to mitigate kubernetes/kubernetes#66450 ( #2383 , @colek42 ) Explicitly define containerPort protocol in helm chart ( #2405 , @bouk ) Switch to using upstream golang.org/x/crypto/acme ACME client library ( #2422 , @munnerz )","title":"Release Notes"},{"location":"release-notes/release-notes-0.13/#acme-external-account-binding-support","text":"Users that wish to use cert-manager with ACME servers other than Let's Encrypt may have found themselves unable to register an account due to the lack of (EAB) 'External Account Binding' support. This allows an ACME server to validate that a user is somehow associated with some other entity, like an account in the CAs customer management system. With EAB support, it's now possible to specify additional parameters ( spec.acme.externalAccountBinding ) on your ACME Issuer resource and utilize cert-manager with your preferred ACME provider.","title":"ACME External Account Binding support"},{"location":"release-notes/release-notes-0.13/#support-for-full-set-of-x509-subject-parameters","text":"In this release, support for the full range of 'subject' parameters as per the X.509 specification has been added. This means you can set fields like organizationalUnit , provinces , serialNumber , country , and all other standard X.509 subject fields. A big thanks to @mathianasj for this addition!","title":"Support for full set of X.509 'subject' parameters"},{"location":"release-notes/release-notes-0.13/#invalidrequest-status-condition-for-certificaterequest-resources","text":"For the growing ecosystem of developers creating their own 'external issuer types' for cert-manager, we have added support for a new 'status condition' type InvalidRequest - this can be used to signal from your signer/issuer to cert-manager that the parameters that the user has requested on the X.509 CSR are 'invalid' and the CSR should not be retried. This prevents users expending API quotas and making requests that will never succeed.","title":"InvalidRequest status condition for CertificateRequest resources"},{"location":"release-notes/release-notes-0.13/#bug-fixes","text":"Fix invalid service account name used in RBAC resources when manually specifying a service account name ( #2509 , @castlemilk ) fixed a bug that in certain cases could cause HTTP01 ingress serviceName fields to be incorrectly set ( #2460 , @greywolve ) Fix bug causing ever-increasing CPU usage in webhook component ( #2467 , @munnerz ) Fix bug causing temporary certificates to overwrite previously issued certificates when adding a new dnsName to an existing Certificate resource ( #2469 , @munnerz ) Fix certmanager_certificate_expiration_timestamp_seconds metric recording ( #2416 , @munnerz ) Fixes ClusterIssuers not finding the secret when the secret is in a different namespace than the certificate request using the Venafi issuer type ( #2520 , @mathianasj ) Fixes generation if invalid certificate name the the 52 nd character in a domain name is a symbol. ( #2516 , @meyskens )","title":"Bug Fixes"},{"location":"release-notes/release-notes-0.13/#other-notable-changes","text":"Adds InvalidRequest condition type to CertificateRequest , signaling to not retry the request. ( #2508 , @JoshVanL ) Add volume and volume mounts field to cert-manager helm chart ( #2504 , @joshuastern ) Add support for additional X.509 'subject' fields ( #2518 , @mathianasj ) Bump k8s.io/* dependencies to Kubernetes 1.17.0 ( #2452 , @munnerz ) It is now possible to disable AppArmor when Pod Security Policies are used. ( #2489 , @czunker ) Support for arbitrary securityContext parameters ( #2455 , @nefischer ) Remove misleading 'error decoding X.509 certificate' message ( #2470 , @munnerz ) Remove IP address validation on dns01-recursive-nameservers to allow domain names ( #2428 , @haines ) Optional webhook.securityContext and cainjector.securityContext chart parameters to specify pods security context. ( #2449 , @nefischer ) webhook: register HTTP handlers for pprof debug endpoints ( #2450 , @munnerz ) Adds support for chart configurable parameters deploymentAnnotations , webhook.deploymentAnnotations and cainjector.deploymentAnnotations ( #2447 , @nefischer ) Adds ACME external account binding support ( #2392 , @JoshVanL ) Fix false-y values in helm chart to mitigate kubernetes/kubernetes#66450 ( #2383 , @colek42 ) Explicitly define containerPort protocol in helm chart ( #2405 , @bouk ) Switch to using upstream golang.org/x/crypto/acme ACME client library ( #2422 , @munnerz )","title":"Other Notable Changes"},{"location":"release-notes/release-notes-0.14/","text":"The v0.14 release has a few focus areas: Improving the deployment/installation process Improving the release process CustomResourceDefinition conversion Support for older Kubernetes and OpenShift versions Experimental 'bundle' output format for Certificates As usual, please read the upgrade notes before upgrading. Webhook changes \u00b6 The webhook component is now required. The webhook will be automatically enabled by the v0.14 manifests, so no additional action is required. If you have issues running the webhook in your environment, we'd like to hear from you! We are aware of issues relating to firewall rules from the Kubernetes API server to the webhook pod(s) - we would like to gather together a corpus of configuration snippets that can be used to ensure the webhook is successfully deployed in these environments too. This change is required in order to support the upcoming changes to our API versions, as we introduce v1alpha3 , v1beta1 and v1 over the coming months! Improving our deployment and release process \u00b6 After reports of various issues installing on older Kubernetes and OpenShift versions, we've taken some time to revise our installation manifests. There are now two 'variants' to choose from, 'standard' and the 'legacy', with a simple way to know which to use: Environment Variant to use Kubernetes 1.15+ cert-manager.yaml OpenShift 4 cert-manager.yaml Kubernetes 1.11-1.14 cert-manager-legacy.yaml OpenShift 3.11 cert-manager-legacy.yaml Please be sure to read the upgrade guide for more information on how to upgrade from a previous release. CustomResourceDefinition conversion webhook + v1alpha3 API version \u00b6 As part of the effort to mature our API, we are releasing the v1alpha3 API version. This contains a number of small changes, notably moving some fields to the subject stanza on the Certificate resource to be more consistent with how certain options are specified. With this we have enabled the 'conversion webhook', which enables API clients to utilize both the v1alpha2 and v1alpha3 APIs simultaneously, similar to other core resources in Kubernetes. Thanks to this conversion webhook, this upgrade and future upgrades after it should be seamless. The ability to make these kinds of changes to our API will enable the v1beta1 API version to be released in a seamless manner in an upcoming release too. More information on the webhook can be found in the concepts section . Support for Kubernetes 1.11 and OpenShift 3.11 \u00b6 We've had a number of users who are using OpenShift 3.11 & Kubernetes 1.11 reach out requesting support with installation. In this release, we've expanded the range of Kubernetes versions we support to once again include 1.11, as well as adding support for OpenShift 3.11. A big thanks to @meyskens for putting this together! Experimental 'bundle format' support (JKS and PKCS#12 ) \u00b6 One of our top feature requests has been for support for JKS and PKCS#12 bundle files as an output from Certificate resources. In this release, we've added experimental support for both of these bundle formats. This can currently only be configured globally with flags provided to the cert-manager pod ( --experimental-issue-jks and --experimental-issue-pkcs12 ). The password used for this bundle must also be configured using the flags --experimental-jks-password and --experimental-pkcs12-keystore-password respectively. In the next release, we are aiming to provide native support for these bundle format types as part of the Certificate resource configuration. We have added these flags now in order to gather feedback on the way this feature works, and help guide how this feature should work in future. Extended support for Venafi features \u00b6 Users of the Venafi issuer often need to set custom metadata on their certificate requests in order to better associate each request with different business areas, or in order to validate & authorize whether a request should be signed. In this release, we've added support for setting custom metadata by adding the venafi.cert-manager.io/custom-fields annotation on Certificate and CertificateRequest resources. If using the Venafi TPP integration, version 19.2 or greater is required. Urgent Upgrade Notes \u00b6 (No, really, you MUST read this before you upgrade) \u00b6 Update Deployment selector to follow Helm chart best practices. This will require deleting the three cert-manager Deployment resources before upgrading. ( #2654 , @munnerz ) Changes by Kind \u00b6 Feature \u00b6 Add --experimental-issue-jks flag to enable JKS bundle generation in generated Secret resources. This flag will be replaced with native support for JKS bundles in future and is currently an experimental feature. If enabled, the --experimental-jks-password flag must also be set to the password used to encrypt JKS bundles. ( #2647 , @munnerz ) Add --experimental-issue-pkcs12 flag to enable PKCS12 bundle generation in generated Secret resources. This flag will be replaced with native support for PKCS12 bundles in future and is currently an experimental feature. If enabled, the --experimental-pkcs12-keystore-password flag must also be set to the password used to encrypt PKCS12 bundles. ( #2643 , @munnerz ) Add venafi.cert-manager.io/custom-fields annotation for Venafi custom fields ( #2573 , @meyskens ) Add emailSANs field to Certificate resource ( #2597 , @meyskens ) Added --tls-cipher-suites command line flag to the webhook binary with sensible defaults ( #2562 , @willthames ) Build OpenShift 3.11 compatible CRDs ( #2609 , @meyskens ) Enable CRD conversion webhook and begin serving v1alpha3 ( #2563 , @munnerz ) Improve startup time for webhook pod. ( #2574 , @JoshVanL ) Replace 00-crds.yaml file with a manifest file published as part of the release ( #2665 , @munnerz ) Other (Bug, Cleanup or Flake) \u00b6 Bump Venafi/vcert dependency to support custom fields in Venafi TPP 19.2 ( #2663 , @munnerz ) Fix GroupVersionKind set on OwnerReference of resources created by HTTP01 challenge solver, causing HTTP01 validations to fail on OpenShift 4 ( #2546 , @munnerz ) Fix Venafi Cloud URL field being marked required ( #2568 , @munnerz ) Fix bug in ingress-shim causing Certificate resources to be rapidly updated if multiple spec.tls[].hosts entries refer to the same Secret name but a different set of hosts ( #2611 , @munnerz ) Fix bug that could cause certificates to be incorrectly issued with an invalid public key ( #2539 , @munnerz ) Fix cainjector.enabled=False override being ignored by the Helm Chart ( #2544 , @gtaylor ) Include license header in manifests attached to GitHub releases ( #2684 , @munnerz ) Make the webhook RoleBinding the leader election namespace instead of hard-coded kube-system ( #2621 , @travisghansen ) Replace openshift and no-webhook manifest variants with a \"legacy\" variant ( #2648 , @meyskens ) Truncate message display if HTTP01 self check fails ( #2613 , @munnerz ) Upgrade to Go 1.14 ( #2656 , @munnerz ) Other Changes \u00b6 Add //build/release-tars targets for generating release artifacts ( #2556 , @munnerz ) Improve local testing and development environment setup code ( #2534 , @munnerz ) Remove isOpenShift from Helm chart ( #2642 , @meyskens ) Remove webhook.enabled variable in Helm chart as the webhook now is a required component ( #2649 , @meyskens )","title":"Release Notes"},{"location":"release-notes/release-notes-0.14/#webhook-changes","text":"The webhook component is now required. The webhook will be automatically enabled by the v0.14 manifests, so no additional action is required. If you have issues running the webhook in your environment, we'd like to hear from you! We are aware of issues relating to firewall rules from the Kubernetes API server to the webhook pod(s) - we would like to gather together a corpus of configuration snippets that can be used to ensure the webhook is successfully deployed in these environments too. This change is required in order to support the upcoming changes to our API versions, as we introduce v1alpha3 , v1beta1 and v1 over the coming months!","title":"Webhook changes"},{"location":"release-notes/release-notes-0.14/#improving-our-deployment-and-release-process","text":"After reports of various issues installing on older Kubernetes and OpenShift versions, we've taken some time to revise our installation manifests. There are now two 'variants' to choose from, 'standard' and the 'legacy', with a simple way to know which to use: Environment Variant to use Kubernetes 1.15+ cert-manager.yaml OpenShift 4 cert-manager.yaml Kubernetes 1.11-1.14 cert-manager-legacy.yaml OpenShift 3.11 cert-manager-legacy.yaml Please be sure to read the upgrade guide for more information on how to upgrade from a previous release.","title":"Improving our deployment and release process"},{"location":"release-notes/release-notes-0.14/#customresourcedefinition-conversion-webhook-v1alpha3-api-version","text":"As part of the effort to mature our API, we are releasing the v1alpha3 API version. This contains a number of small changes, notably moving some fields to the subject stanza on the Certificate resource to be more consistent with how certain options are specified. With this we have enabled the 'conversion webhook', which enables API clients to utilize both the v1alpha2 and v1alpha3 APIs simultaneously, similar to other core resources in Kubernetes. Thanks to this conversion webhook, this upgrade and future upgrades after it should be seamless. The ability to make these kinds of changes to our API will enable the v1beta1 API version to be released in a seamless manner in an upcoming release too. More information on the webhook can be found in the concepts section .","title":"CustomResourceDefinition conversion webhook + v1alpha3 API version"},{"location":"release-notes/release-notes-0.14/#support-for-kubernetes-111-and-openshift-311","text":"We've had a number of users who are using OpenShift 3.11 & Kubernetes 1.11 reach out requesting support with installation. In this release, we've expanded the range of Kubernetes versions we support to once again include 1.11, as well as adding support for OpenShift 3.11. A big thanks to @meyskens for putting this together!","title":"Support for Kubernetes 1.11 and OpenShift 3.11"},{"location":"release-notes/release-notes-0.14/#experimental-bundle-format-support-jks-and-pkcs12","text":"One of our top feature requests has been for support for JKS and PKCS#12 bundle files as an output from Certificate resources. In this release, we've added experimental support for both of these bundle formats. This can currently only be configured globally with flags provided to the cert-manager pod ( --experimental-issue-jks and --experimental-issue-pkcs12 ). The password used for this bundle must also be configured using the flags --experimental-jks-password and --experimental-pkcs12-keystore-password respectively. In the next release, we are aiming to provide native support for these bundle format types as part of the Certificate resource configuration. We have added these flags now in order to gather feedback on the way this feature works, and help guide how this feature should work in future.","title":"Experimental 'bundle format' support (JKS and PKCS#12)"},{"location":"release-notes/release-notes-0.14/#extended-support-for-venafi-features","text":"Users of the Venafi issuer often need to set custom metadata on their certificate requests in order to better associate each request with different business areas, or in order to validate & authorize whether a request should be signed. In this release, we've added support for setting custom metadata by adding the venafi.cert-manager.io/custom-fields annotation on Certificate and CertificateRequest resources. If using the Venafi TPP integration, version 19.2 or greater is required.","title":"Extended support for Venafi features"},{"location":"release-notes/release-notes-0.14/#urgent-upgrade-notes","text":"","title":"Urgent Upgrade Notes"},{"location":"release-notes/release-notes-0.14/#no-really-you-must-read-this-before-you-upgrade","text":"Update Deployment selector to follow Helm chart best practices. This will require deleting the three cert-manager Deployment resources before upgrading. ( #2654 , @munnerz )","title":"(No, really, you MUST read this before you upgrade)"},{"location":"release-notes/release-notes-0.14/#changes-by-kind","text":"","title":"Changes by Kind"},{"location":"release-notes/release-notes-0.14/#feature","text":"Add --experimental-issue-jks flag to enable JKS bundle generation in generated Secret resources. This flag will be replaced with native support for JKS bundles in future and is currently an experimental feature. If enabled, the --experimental-jks-password flag must also be set to the password used to encrypt JKS bundles. ( #2647 , @munnerz ) Add --experimental-issue-pkcs12 flag to enable PKCS12 bundle generation in generated Secret resources. This flag will be replaced with native support for PKCS12 bundles in future and is currently an experimental feature. If enabled, the --experimental-pkcs12-keystore-password flag must also be set to the password used to encrypt PKCS12 bundles. ( #2643 , @munnerz ) Add venafi.cert-manager.io/custom-fields annotation for Venafi custom fields ( #2573 , @meyskens ) Add emailSANs field to Certificate resource ( #2597 , @meyskens ) Added --tls-cipher-suites command line flag to the webhook binary with sensible defaults ( #2562 , @willthames ) Build OpenShift 3.11 compatible CRDs ( #2609 , @meyskens ) Enable CRD conversion webhook and begin serving v1alpha3 ( #2563 , @munnerz ) Improve startup time for webhook pod. ( #2574 , @JoshVanL ) Replace 00-crds.yaml file with a manifest file published as part of the release ( #2665 , @munnerz )","title":"Feature"},{"location":"release-notes/release-notes-0.14/#other-bug-cleanup-or-flake","text":"Bump Venafi/vcert dependency to support custom fields in Venafi TPP 19.2 ( #2663 , @munnerz ) Fix GroupVersionKind set on OwnerReference of resources created by HTTP01 challenge solver, causing HTTP01 validations to fail on OpenShift 4 ( #2546 , @munnerz ) Fix Venafi Cloud URL field being marked required ( #2568 , @munnerz ) Fix bug in ingress-shim causing Certificate resources to be rapidly updated if multiple spec.tls[].hosts entries refer to the same Secret name but a different set of hosts ( #2611 , @munnerz ) Fix bug that could cause certificates to be incorrectly issued with an invalid public key ( #2539 , @munnerz ) Fix cainjector.enabled=False override being ignored by the Helm Chart ( #2544 , @gtaylor ) Include license header in manifests attached to GitHub releases ( #2684 , @munnerz ) Make the webhook RoleBinding the leader election namespace instead of hard-coded kube-system ( #2621 , @travisghansen ) Replace openshift and no-webhook manifest variants with a \"legacy\" variant ( #2648 , @meyskens ) Truncate message display if HTTP01 self check fails ( #2613 , @munnerz ) Upgrade to Go 1.14 ( #2656 , @munnerz )","title":"Other (Bug, Cleanup or Flake)"},{"location":"release-notes/release-notes-0.14/#other-changes","text":"Add //build/release-tars targets for generating release artifacts ( #2556 , @munnerz ) Improve local testing and development environment setup code ( #2534 , @munnerz ) Remove isOpenShift from Helm chart ( #2642 , @meyskens ) Remove webhook.enabled variable in Helm chart as the webhook now is a required component ( #2649 , @meyskens )","title":"Other Changes"},{"location":"release-notes/release-notes-0.15/","text":"The v0.15 release has a few focus areas: Experimental new Certificate controller design New installCRDs option in the Helm chart Support for Red Hat's Operator Lifecycle Manager for easier deployment in OpenShift environments Improved deployment process for webhook component General Availability of JKS and PKCS#12 keystore support kubectl cert-manager CLI plugin allowing manual renewal and API version conversion As usual, please read the upgrade notes before upgrading. Experimental controllers \u00b6 The Certificate controller is one of the most commonly used controllers in the project. It represents the 'full lifecycle' of an X.509 private key and certificate, including private key management and renewal. As the project is maturing, more requirements around this controller are starting to become apparent in order to implement feature requests such as private key rotation, JKS/PKCS#12 keystores and manual certificate renewal triggering. This new controller aims to facilitate the above features, as well as make it easier to develop individual areas of the controller over time and continue to make improvements. For more information on this we invite you to read our design document . Using the experimental controllers \u00b6 We are looking for feedback on the use of these new controllers in different environments. If you are able to run these in your cluster and report any issues you're seeing that would be very helpful to the further development of the project. The experimental controllers are currently feature gated and disabled by default. You can enable these by the following steps, in the Helm values set: featureGates : \"ExperimentalCertificateControllers=true\" If you're using the static manifests you need to edit the cert-manager Deployment using kubectl -n cert-manager edit deploy cert-manager and edit the args to include --feature-gates=ExperimentalCertificateControllers=true : containers : - args : - --v=2 - --cluster-resource-namespace=$(POD_NAMESPACE) - --leader-election-namespace=kube-system - --feature-gates=ExperimentalCertificateControllers=true Helm chart installCRDs option \u00b6 It's been a long-standing feature request to bundle our CRD resources as part of our Helm chart, to make it easier for users installing with Helm to manage the lifecycle of the CRDs we create. To facilitate this, and to help resolve common deployment issues, we have added a new installCRDs option to the Helm chart which will mean the CRD resources will be managed by your regular Helm installation. This feature is disabled by default, and can be enabled either in your values.yaml file or as a flag with helm install --set installCRDs=true . Support for OpenShift's Operator Lifecycle Manager \u00b6 cert-manager can now be deployed as a Red Hat Certified OpenShift Operator. This is done using the cert-manager operator . More information on this can be found on the OpenShift Installation page . Improved deployment of the webhook \u00b6 In order to improve start up time of the webhook pod, as well as improved reliability and operability, cert-manager v0.15 includes a new DynamicAuthority structure in the webhook that is used to manage the CA used to secure the webhook. Instances of the webhook will keep this CA up to date and use it to generate serving certificates which are used to secure incoming connections. This means that the cert-manager-controller component is no longer required to be running in order for webhook startup to succeed. This also means that users should no longer see long start up times for this pod unless there is a genuine issue/error that needs resolving. General Availability of JKS and PKCS#12 keystores \u00b6 v0.14 added experimental 'bundle format' support for JKS and PKCS#12 . In v0.15 the keystore got added to the Certificate spec which makes cert-manager add an additional keystore in your Certificate's Secret resource. No additional feature gates need to be set anymore. apiVersion : cert-manager.io/v1alpha2 kind : Certificate metadata : name : crt spec : secretName : crt-secret dnsNames : - foo.example.com - bar.example.com issuerRef : name : letsencrypt-prod keystores : jks : create : true passwordSecretRef : # Password used to encrypt the keystore key : password-key name : jks-password-secret pkcs12 : create : true passwordSecretRef : # Password used to encrypt the keystore key : password-key name : pkcs12-password-secret For JKS this adds the files: keystore.jks and truststore.jks to the target spec.secretName . For PKCS#12 , it adds the file keystore.p12 . kubectl cert-manager tool \u00b6 kubectl cert-manager is a kubectl plugin that assists with controlling cert-manager inside your Kubernetes cluster. The kubectl cert-manager binary can be downloaded from the GitHub release page . In v0.15 the use is currently limited to the convert and renew commands. kubectl cert-manager renew can be used to manually trigger renewal of your certificates. This required the ExperimentalCertificateControllers feature gate to be set. kubectl cert-manager convert can be used to convert cert-manager config files between different API versions if your cluster does not support the conversion webhook (i.e. running the 'legacy' release) or if you want to upgrade all your local cert-manager configuration files.","title":"Release Notes"},{"location":"release-notes/release-notes-0.15/#experimental-controllers","text":"The Certificate controller is one of the most commonly used controllers in the project. It represents the 'full lifecycle' of an X.509 private key and certificate, including private key management and renewal. As the project is maturing, more requirements around this controller are starting to become apparent in order to implement feature requests such as private key rotation, JKS/PKCS#12 keystores and manual certificate renewal triggering. This new controller aims to facilitate the above features, as well as make it easier to develop individual areas of the controller over time and continue to make improvements. For more information on this we invite you to read our design document .","title":"Experimental controllers"},{"location":"release-notes/release-notes-0.15/#using-the-experimental-controllers","text":"We are looking for feedback on the use of these new controllers in different environments. If you are able to run these in your cluster and report any issues you're seeing that would be very helpful to the further development of the project. The experimental controllers are currently feature gated and disabled by default. You can enable these by the following steps, in the Helm values set: featureGates : \"ExperimentalCertificateControllers=true\" If you're using the static manifests you need to edit the cert-manager Deployment using kubectl -n cert-manager edit deploy cert-manager and edit the args to include --feature-gates=ExperimentalCertificateControllers=true : containers : - args : - --v=2 - --cluster-resource-namespace=$(POD_NAMESPACE) - --leader-election-namespace=kube-system - --feature-gates=ExperimentalCertificateControllers=true","title":"Using the experimental controllers"},{"location":"release-notes/release-notes-0.15/#helm-chart-installcrds-option","text":"It's been a long-standing feature request to bundle our CRD resources as part of our Helm chart, to make it easier for users installing with Helm to manage the lifecycle of the CRDs we create. To facilitate this, and to help resolve common deployment issues, we have added a new installCRDs option to the Helm chart which will mean the CRD resources will be managed by your regular Helm installation. This feature is disabled by default, and can be enabled either in your values.yaml file or as a flag with helm install --set installCRDs=true .","title":"Helm chart installCRDs option"},{"location":"release-notes/release-notes-0.15/#support-for-openshifts-operator-lifecycle-manager","text":"cert-manager can now be deployed as a Red Hat Certified OpenShift Operator. This is done using the cert-manager operator . More information on this can be found on the OpenShift Installation page .","title":"Support for OpenShift's Operator Lifecycle Manager"},{"location":"release-notes/release-notes-0.15/#improved-deployment-of-the-webhook","text":"In order to improve start up time of the webhook pod, as well as improved reliability and operability, cert-manager v0.15 includes a new DynamicAuthority structure in the webhook that is used to manage the CA used to secure the webhook. Instances of the webhook will keep this CA up to date and use it to generate serving certificates which are used to secure incoming connections. This means that the cert-manager-controller component is no longer required to be running in order for webhook startup to succeed. This also means that users should no longer see long start up times for this pod unless there is a genuine issue/error that needs resolving.","title":"Improved deployment of the webhook"},{"location":"release-notes/release-notes-0.15/#general-availability-of-jks-and-pkcs12-keystores","text":"v0.14 added experimental 'bundle format' support for JKS and PKCS#12 . In v0.15 the keystore got added to the Certificate spec which makes cert-manager add an additional keystore in your Certificate's Secret resource. No additional feature gates need to be set anymore. apiVersion : cert-manager.io/v1alpha2 kind : Certificate metadata : name : crt spec : secretName : crt-secret dnsNames : - foo.example.com - bar.example.com issuerRef : name : letsencrypt-prod keystores : jks : create : true passwordSecretRef : # Password used to encrypt the keystore key : password-key name : jks-password-secret pkcs12 : create : true passwordSecretRef : # Password used to encrypt the keystore key : password-key name : pkcs12-password-secret For JKS this adds the files: keystore.jks and truststore.jks to the target spec.secretName . For PKCS#12 , it adds the file keystore.p12 .","title":"General Availability of JKS and PKCS#12 keystores"},{"location":"release-notes/release-notes-0.15/#kubectl-cert-manager-tool","text":"kubectl cert-manager is a kubectl plugin that assists with controlling cert-manager inside your Kubernetes cluster. The kubectl cert-manager binary can be downloaded from the GitHub release page . In v0.15 the use is currently limited to the convert and renew commands. kubectl cert-manager renew can be used to manually trigger renewal of your certificates. This required the ExperimentalCertificateControllers feature gate to be set. kubectl cert-manager convert can be used to convert cert-manager config files between different API versions if your cluster does not support the conversion webhook (i.e. running the 'legacy' release) or if you want to upgrade all your local cert-manager configuration files.","title":"kubectl cert-manager tool"},{"location":"release-notes/release-notes-0.16/","text":"The v0.16 release has a few focus areas: Enable the new certificate controller for all users kubectl cert-manager create certificaterequest for signing local certificates v1beta1 API As usual, please read the upgrade notes before upgrading. New certificate controller \u00b6 The Certificate controller is one of the most commonly used controllers in the project. It represents the 'full lifecycle' of an X.509 private key and certificate, including private key management and renewal. In v0.15 we added the new certificate controllers under a feature gate to allow users to test these and gather feedback. Thanks to everyone testing these and reporting issues we were able to fix issues and improve the controller. In v0.16 this controller is now the default one in cert-manager. For more information on this, we invite you to read our design document . kubectl cert-manager tool for signing certificates \u00b6 cert-manager v0.15 included a kubectl plugin that allows users to interact with cert-manager. In this release we have added a new sub-command to the cert-manager CLI which allows users to sign certificates on their computer or inside a container. The kubectl cert-manager create certificaterequest command creates a new CertificateRequest resource based on the YAML manifest of a Certificate resource as specified by --from-certificate-file flag. For example this will create a CertificateRequest resource with the name \"my-cr\" based on the Certificate described in my-certificate.yaml while storing the private key and X.509 certificate in my-cr.key and my-cr.crt respectively. $ kubectl cert-manager create certificaterequest my-cr --from-certificate-file my-certificate.yaml --fetch-certificate --timeout 20m More information can be found on our kubectl plugin page . v1beta1 API \u00b6 We are soon reaching cert-manager v1.0 and the new v1beta1 API is our first step towards a stable v1 API. The biggest change users may notice is the improved API documentation. We took the time to review and update all the user-facing APIs. You can view the updated API documentation online , or use kubectl explain after installing this version of cert-manager. v1beta1 does not contain many big changes, this version is focused on streamlining field names and general clean up of the API in preparation for the release of the v1 release. These are the changes made (for reference, our conversion will take care of everything for you): Certificate: keyAlgorithm is now named algorithm under the privateKey property keyEncoding is now named encoding under the privateKey property keySize is now named size under the privateKey property Encoding values PKCS1 and PKCS8 are now uppercase CertificateRequest: The field csr is now request Issuer: DNS01 providers with DNS in their name now are uppercase DNS , these are: cloudDNS azureDNS and acmeDNS ACME Order: The field csr is now request ACME Challenge: The field authzURL is now authorizationURL Challenge types HTTP-01 and DNS-01 are now all uppercase Unsupported challenge types ( TLS-ALPN-01 , TLS-SNI-01 , TLS-SNI-02 and others) are not generated by cert-manager any longer If you're using Kubernetes 1.15 or higher, conversion webhooks will allow you seamlessly interact with v1alpha2 , v1alpha3 and v1beta1 API versions at the same time. This allows you to use the new API version without having to modify or redeploy your older resources. Users of the legacy version of cert-manager will still only have the v1alpha2 API. kubectl cert-manager convert tool \u00b6 To assist you updating your manifest files on disk (for example in your infrastructure Git repo) we offer v1beta1 support in kubectl cert-manager . The kubectl cert-manager convert command will be able to convert your manifest files to v1beta1 using: $ kubectl cert-manager convert --output-version cert-manager.io/v1beta1 cert.yaml More information can be found on our kubectl plugin page .","title":"Release Notes"},{"location":"release-notes/release-notes-0.16/#new-certificate-controller","text":"The Certificate controller is one of the most commonly used controllers in the project. It represents the 'full lifecycle' of an X.509 private key and certificate, including private key management and renewal. In v0.15 we added the new certificate controllers under a feature gate to allow users to test these and gather feedback. Thanks to everyone testing these and reporting issues we were able to fix issues and improve the controller. In v0.16 this controller is now the default one in cert-manager. For more information on this, we invite you to read our design document .","title":"New certificate controller"},{"location":"release-notes/release-notes-0.16/#kubectl-cert-manager-tool-for-signing-certificates","text":"cert-manager v0.15 included a kubectl plugin that allows users to interact with cert-manager. In this release we have added a new sub-command to the cert-manager CLI which allows users to sign certificates on their computer or inside a container. The kubectl cert-manager create certificaterequest command creates a new CertificateRequest resource based on the YAML manifest of a Certificate resource as specified by --from-certificate-file flag. For example this will create a CertificateRequest resource with the name \"my-cr\" based on the Certificate described in my-certificate.yaml while storing the private key and X.509 certificate in my-cr.key and my-cr.crt respectively. $ kubectl cert-manager create certificaterequest my-cr --from-certificate-file my-certificate.yaml --fetch-certificate --timeout 20m More information can be found on our kubectl plugin page .","title":"kubectl cert-manager tool for signing certificates"},{"location":"release-notes/release-notes-0.16/#v1beta1-api","text":"We are soon reaching cert-manager v1.0 and the new v1beta1 API is our first step towards a stable v1 API. The biggest change users may notice is the improved API documentation. We took the time to review and update all the user-facing APIs. You can view the updated API documentation online , or use kubectl explain after installing this version of cert-manager. v1beta1 does not contain many big changes, this version is focused on streamlining field names and general clean up of the API in preparation for the release of the v1 release. These are the changes made (for reference, our conversion will take care of everything for you): Certificate: keyAlgorithm is now named algorithm under the privateKey property keyEncoding is now named encoding under the privateKey property keySize is now named size under the privateKey property Encoding values PKCS1 and PKCS8 are now uppercase CertificateRequest: The field csr is now request Issuer: DNS01 providers with DNS in their name now are uppercase DNS , these are: cloudDNS azureDNS and acmeDNS ACME Order: The field csr is now request ACME Challenge: The field authzURL is now authorizationURL Challenge types HTTP-01 and DNS-01 are now all uppercase Unsupported challenge types ( TLS-ALPN-01 , TLS-SNI-01 , TLS-SNI-02 and others) are not generated by cert-manager any longer If you're using Kubernetes 1.15 or higher, conversion webhooks will allow you seamlessly interact with v1alpha2 , v1alpha3 and v1beta1 API versions at the same time. This allows you to use the new API version without having to modify or redeploy your older resources. Users of the legacy version of cert-manager will still only have the v1alpha2 API.","title":"v1beta1 API"},{"location":"release-notes/release-notes-0.16/#kubectl-cert-manager-convert-tool","text":"To assist you updating your manifest files on disk (for example in your infrastructure Git repo) we offer v1beta1 support in kubectl cert-manager . The kubectl cert-manager convert command will be able to convert your manifest files to v1beta1 using: $ kubectl cert-manager convert --output-version cert-manager.io/v1beta1 cert.yaml More information can be found on our kubectl plugin page .","title":"kubectl cert-manager convert tool"},{"location":"release-notes/release-notes-0.2/","text":"Changelog since v0.1.0 \u00b6 Action Required \u00b6 Move to jetstack organization. Action required: this will require updating your existing deployments to point to the new image repository, as new tags will not be pushed to the old jetstackexperimental/cert-manager-controller repository. A helm upgrade should take care of this. ( #145 , @munnerz ) Set the Kubernetes secret type to TLS. Action required: this will cause renewals of existing certificates to fail. You must delete certificates that have been previously produced by cert-manager else cert-manager may enter a renewal loop when saving the new certificates. Alternatively, you may specify a new secret to store your certificate in and manually update your ingress resource/applications to reference the new secret. ( #172 , @munnerz ) Other notable changes \u00b6 No longer support ClusterIssuer resources when cert-manager is running with --namespace flag set ( #179 , @munnerz ) Overcome 'registration already exists for provider key' errors in ACME provider by auto-detecting lost ACME registration URIs ( #171 , @munnerz ) Fix checking for invalid data in issuer secrets ( #170 , @munnerz ) Fix bug in ACME HTTP01 solver causing self-check to return true before paths have propagated ( #166 , @munnerz ) Fix panic if the secret named in an ACME issuer exists but contains invalid data (or no data) ( #165 , @munnerz ) Ensure 5 consecutive HTTP01 self-checks pass before issuing ACME certificate ( #156 , @munnerz ) Fix race condition in ACME HTTP01 solver when validating multiple domains ( #155 , @munnerz ) Consistently use glog throughout ( #126 , @munnerz )","title":"Release Notes"},{"location":"release-notes/release-notes-0.2/#changelog-since-v010","text":"","title":"Changelog since v0.1.0"},{"location":"release-notes/release-notes-0.2/#action-required","text":"Move to jetstack organization. Action required: this will require updating your existing deployments to point to the new image repository, as new tags will not be pushed to the old jetstackexperimental/cert-manager-controller repository. A helm upgrade should take care of this. ( #145 , @munnerz ) Set the Kubernetes secret type to TLS. Action required: this will cause renewals of existing certificates to fail. You must delete certificates that have been previously produced by cert-manager else cert-manager may enter a renewal loop when saving the new certificates. Alternatively, you may specify a new secret to store your certificate in and manually update your ingress resource/applications to reference the new secret. ( #172 , @munnerz )","title":"Action Required"},{"location":"release-notes/release-notes-0.2/#other-notable-changes","text":"No longer support ClusterIssuer resources when cert-manager is running with --namespace flag set ( #179 , @munnerz ) Overcome 'registration already exists for provider key' errors in ACME provider by auto-detecting lost ACME registration URIs ( #171 , @munnerz ) Fix checking for invalid data in issuer secrets ( #170 , @munnerz ) Fix bug in ACME HTTP01 solver causing self-check to return true before paths have propagated ( #166 , @munnerz ) Fix panic if the secret named in an ACME issuer exists but contains invalid data (or no data) ( #165 , @munnerz ) Ensure 5 consecutive HTTP01 self-checks pass before issuing ACME certificate ( #156 , @munnerz ) Fix race condition in ACME HTTP01 solver when validating multiple domains ( #155 , @munnerz ) Consistently use glog throughout ( #126 , @munnerz )","title":"Other notable changes"},{"location":"release-notes/release-notes-0.3/","text":"Highlights \u00b6 This is a big feature filled release of cert-manager, and the first since moving to a more frequent release model. There's been a huge uptick in community contributions to the project, and this release comprises the combined effort of 38 code contributors and hundreds of users reporting issues, feature requests and bug reports! There's quite a few big headline points, so we'll get straight in: ACMEv2 and Let's Encrypt wildcard certificates \u00b6 This release of cert-manager brings the long-awaited ACMEv2 support, and with it, Let's Encrypt wildcard certificates! This allows you to request certificates for wildcard domains, e.g. *.example.com , which can be used to secure many different subdomains of your domain! The introduction of ACMEv2 is a breaking change . Please read the notes below in the Action Required section for details on how to handle your existing ACME Issuers whilst upgrading from v0.2.x . Alpha support for HashiCorp Vault \u00b6 This release introduces initial support for HashiCorp Vault as an Issuer backend! Initially, this includes support for authenticating via AppRole and static token. The support for this Issuer is classed as 'alpha' - feedback is invaluable at this stage of development, so we are getting it out there in a tagged release to gather usage info. More information on configuring a Vault Issuer can be found in the Vault Issuer docs. readthedocs.io documentation site \u00b6 Whilst this note applies to the v0.2.x release series also, it is worth noting. We have now moved to readthedocs.io and reStructuredText for our documentation. This should hopefully make it easier for external collaborators to make quick edits to our documentation, and should provide more structure. We'd like to take the time to thank all those that have opened issues or opened pull requests against our documentation - it's a difficult thing to get right, but it's imperative our documentation is clear for new users adopting the project. New ACME DNS01 providers \u00b6 When cert-manager was first released, only CloudDNS and CloudFlare DNS01 providers were supported when solving ACME challenges. As new users, each using their own DNS providers, have adopted the project; there has been a flurry of contributions adding support for the variety of providers out there. With this release, we support the following DNS providers when solving ACME DNS01 challenges: Akamai FastDNS ( #322 , @twz123 ) Amazon Route53 Azure DNS ( #246 , @mwieczorek ) CloudFlare Google CloudDNS There are pull requests in flight to add support for: DNSPod ( #486 , @hemslo ) DNSimple ( #483 , @marc-sensenich ) DigitalOcean ( #345 , @dl00 ) INWX ( #336 , @steigr ) RFC2136 ( #245 , @simonfuhrer ) Changelog \u00b6 Action Required \u00b6 Please check the 'upgrading from 0.2 to 0.3' guide in the Administrative Tasks section of the docs here before upgrading. Supporting resources for ClusterIssuers (e.g. signing CA certificates, or ACME account private keys) will now be stored in the same namespace as cert-manager, instead of kube-system in previous versions ( #329 , @munnerz ): Action required : you will need to ensure to properly manually migrate these referenced resources across into the deployment namespace of cert-manager, else cert-manager may not be able to find account private keys or signing CA certificates. Use ConfigMaps for leader election ( #327 , @mikebryant ): Action required : Before upgrading, scale the cert-manager Deployment to 0, to avoid two controllers attempting to operate on the same resources Remove support for ACMEv1 in favor of ACMEv2 ( #309 , @munnerz ): Action required : As this release drops support for ACMEv1, all Issuer resources that use ACMEv1 endpoints (e.g. existing Let's Encrypt Issuers) will need updating to use equivalent ACMEv2 endpoints. (TODO: link to docs guide) Remove ingress-shim and link it into cert-manager itself ( #502 , @munnerz ) Action required : You must change your 'helm install' command to use the new --ingressShim.defaultIssuerName , --ingressShim.defaultIssuerKind options when upgrading as --ingressShim.extraArgs has been removed. Add certmanager.k8s.io/acme-http01-edit-in-place annotation and change ingress-shim to set ingressClass on ACME Certificate resources by default. ( #493 , @munnerz ) Action required : This is a potentially breaking change for users of ingress controllers that map a single IP address to a single Ingress resource, such as the GCE ingress controller. These users will need to add the following annotation to their ingress: certmanager.k8s.io/acme-http01-edit-in-place: \"true\" . Other notable changes \u00b6 ACME Issuer \u00b6 Add ACME DNS01 provider for Akamai FastDNS ( #322 , @twz123 ) Add a meaningful user agent to the ACME client to help diagnosing abusive traffic patterns ( #422 , @jsha ) Issuers using the AWS Route53 solver may attempt to find credentials using the environment, EC2 IAM Role, and other sources available to the cert-manager controller. This behavior is on by default for cluster issuers and off by default for issuers. This behavior may be enabled or disabled for all issuers or cluster issuers using the --issuer-ambient-credentials and --cluster-issuer-ambient-credentials flags on the cert-manager controller. ( #363 , @euank ) Add limits to HTTP01 validation pod ( #408 , @kragniz ) The ACME DNS01 solver now trims excess whitespace from AWS credentials ( #391 , @euank ) ACME DNS01 challenge mechanism for Azure DNS ( #246 , @mwieczorek ) Fix panic when ACME server returns an error other than HTTP Status Conflict during registration ( #237 , @munnerz ) CA Issuer \u00b6 Add the Key Encipherment purpose to CA Issuer generated certificates ( #488 , @bradleybluebean ) Bundle CA certificate with issued certificates ( #317 , @radhus ) Vault Issuer \u00b6 Add experimental support for HashiCorp Vault issuers ( #292 , @vdesjardins ) ingress-shim ingress-shim now reconfigures certificates ( #386 , @kragniz ) ingress-shim will only sync Ingress resources with kubernetes.io/tls-acme annotation if the value of that annotation is true. ( #325 , @wmedlar ) Docs \u00b6 Rewrite documentation and publish on readthedocs ( #428 , @munnerz ) Document the minimum necessary permissions for using cert-manager with Route53 ( #359 , @wmedlar ) Improve deployment documentation ( #264 , @munnerz ) Helm \u00b6 Add clusterResourceNamespace option to Helm chart ( #547 , @munnerz ) Enhance Helm chart in-line with best practices ( #229 , @unguiculus ): Add support for node affinity and tolerations in Helm chart ( #350 , @kiall ) Add podAnnotations to Helm chart ( #387 , @etiennetremel ) Add Certificate CRD short names cert and certs . This is configurable in the Helm Chart with certificateResourceShortNames . ( #312 , @Mikulas ) Remove default resource requests in Helm chart. Improve post-deployment informational messages. ( #290 , @munnerz ) End-to-end testing now covers the helm chart for cert-manager on Kubernetes 1.7-1.9 ( #216 , @munnerz ) Other \u00b6 Produce a single static manifest instead of a directory when generating deployment manifests ( #574 , @munnerz ) Use cert-manager deployment namespace by default for leader election ( #548 , @munnerz ) Removed --namespace flag ( #433 , @kragniz ) Run cert-manager container as a non root user ( #415 , @tettaji ) TLS secrets are now annotated with information about the certificate ( #388 , @kragniz ) The static deployment manifests now automatically deploy into the 'cert-manager' namespace by default ( #330 , @munnerz ) Rename Event types to be prefixed 'Err' instead of 'Error' for brevity ( #332 , @munnerz ) Clearer event logging when issuing a certificate for the first time ( #331 , @munnerz ) Provide static deployment manifests as an alternative to a Helm chart based deployment ( #276 , @munnerz ) Update existing secrets instead of replacing in order to preserve annotations/labels ( #221 , @munnerz ) Update to Go 1.9 ( #200 , @euank ) Bug fixes \u00b6 Fix a race condition in the package responsible for scheduling renewals ( #218 , @munnerz ) Fix a bug that caused ACME certificates to not be automatically renewed ( #215 , @munnerz ) Fix a bug in checking certificate validity and improve validation of dnsNames and commonName ( #183 , @munnerz ) Fix bugs when checking validity of certificate resources ( #184 , @munnerz )","title":"Release Notes"},{"location":"release-notes/release-notes-0.3/#highlights","text":"This is a big feature filled release of cert-manager, and the first since moving to a more frequent release model. There's been a huge uptick in community contributions to the project, and this release comprises the combined effort of 38 code contributors and hundreds of users reporting issues, feature requests and bug reports! There's quite a few big headline points, so we'll get straight in:","title":"Highlights"},{"location":"release-notes/release-notes-0.3/#acmev2-and-lets-encrypt-wildcard-certificates","text":"This release of cert-manager brings the long-awaited ACMEv2 support, and with it, Let's Encrypt wildcard certificates! This allows you to request certificates for wildcard domains, e.g. *.example.com , which can be used to secure many different subdomains of your domain! The introduction of ACMEv2 is a breaking change . Please read the notes below in the Action Required section for details on how to handle your existing ACME Issuers whilst upgrading from v0.2.x .","title":"ACMEv2 and Let's Encrypt wildcard certificates"},{"location":"release-notes/release-notes-0.3/#alpha-support-for-hashicorp-vault","text":"This release introduces initial support for HashiCorp Vault as an Issuer backend! Initially, this includes support for authenticating via AppRole and static token. The support for this Issuer is classed as 'alpha' - feedback is invaluable at this stage of development, so we are getting it out there in a tagged release to gather usage info. More information on configuring a Vault Issuer can be found in the Vault Issuer docs.","title":"Alpha support for HashiCorp Vault"},{"location":"release-notes/release-notes-0.3/#readthedocsio-documentation-site","text":"Whilst this note applies to the v0.2.x release series also, it is worth noting. We have now moved to readthedocs.io and reStructuredText for our documentation. This should hopefully make it easier for external collaborators to make quick edits to our documentation, and should provide more structure. We'd like to take the time to thank all those that have opened issues or opened pull requests against our documentation - it's a difficult thing to get right, but it's imperative our documentation is clear for new users adopting the project.","title":"readthedocs.io documentation site"},{"location":"release-notes/release-notes-0.3/#new-acme-dns01-providers","text":"When cert-manager was first released, only CloudDNS and CloudFlare DNS01 providers were supported when solving ACME challenges. As new users, each using their own DNS providers, have adopted the project; there has been a flurry of contributions adding support for the variety of providers out there. With this release, we support the following DNS providers when solving ACME DNS01 challenges: Akamai FastDNS ( #322 , @twz123 ) Amazon Route53 Azure DNS ( #246 , @mwieczorek ) CloudFlare Google CloudDNS There are pull requests in flight to add support for: DNSPod ( #486 , @hemslo ) DNSimple ( #483 , @marc-sensenich ) DigitalOcean ( #345 , @dl00 ) INWX ( #336 , @steigr ) RFC2136 ( #245 , @simonfuhrer )","title":"New ACME DNS01 providers"},{"location":"release-notes/release-notes-0.3/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.3/#action-required","text":"Please check the 'upgrading from 0.2 to 0.3' guide in the Administrative Tasks section of the docs here before upgrading. Supporting resources for ClusterIssuers (e.g. signing CA certificates, or ACME account private keys) will now be stored in the same namespace as cert-manager, instead of kube-system in previous versions ( #329 , @munnerz ): Action required : you will need to ensure to properly manually migrate these referenced resources across into the deployment namespace of cert-manager, else cert-manager may not be able to find account private keys or signing CA certificates. Use ConfigMaps for leader election ( #327 , @mikebryant ): Action required : Before upgrading, scale the cert-manager Deployment to 0, to avoid two controllers attempting to operate on the same resources Remove support for ACMEv1 in favor of ACMEv2 ( #309 , @munnerz ): Action required : As this release drops support for ACMEv1, all Issuer resources that use ACMEv1 endpoints (e.g. existing Let's Encrypt Issuers) will need updating to use equivalent ACMEv2 endpoints. (TODO: link to docs guide) Remove ingress-shim and link it into cert-manager itself ( #502 , @munnerz ) Action required : You must change your 'helm install' command to use the new --ingressShim.defaultIssuerName , --ingressShim.defaultIssuerKind options when upgrading as --ingressShim.extraArgs has been removed. Add certmanager.k8s.io/acme-http01-edit-in-place annotation and change ingress-shim to set ingressClass on ACME Certificate resources by default. ( #493 , @munnerz ) Action required : This is a potentially breaking change for users of ingress controllers that map a single IP address to a single Ingress resource, such as the GCE ingress controller. These users will need to add the following annotation to their ingress: certmanager.k8s.io/acme-http01-edit-in-place: \"true\" .","title":"Action Required"},{"location":"release-notes/release-notes-0.3/#other-notable-changes","text":"","title":"Other notable changes"},{"location":"release-notes/release-notes-0.3/#acme-issuer","text":"Add ACME DNS01 provider for Akamai FastDNS ( #322 , @twz123 ) Add a meaningful user agent to the ACME client to help diagnosing abusive traffic patterns ( #422 , @jsha ) Issuers using the AWS Route53 solver may attempt to find credentials using the environment, EC2 IAM Role, and other sources available to the cert-manager controller. This behavior is on by default for cluster issuers and off by default for issuers. This behavior may be enabled or disabled for all issuers or cluster issuers using the --issuer-ambient-credentials and --cluster-issuer-ambient-credentials flags on the cert-manager controller. ( #363 , @euank ) Add limits to HTTP01 validation pod ( #408 , @kragniz ) The ACME DNS01 solver now trims excess whitespace from AWS credentials ( #391 , @euank ) ACME DNS01 challenge mechanism for Azure DNS ( #246 , @mwieczorek ) Fix panic when ACME server returns an error other than HTTP Status Conflict during registration ( #237 , @munnerz )","title":"ACME Issuer"},{"location":"release-notes/release-notes-0.3/#ca-issuer","text":"Add the Key Encipherment purpose to CA Issuer generated certificates ( #488 , @bradleybluebean ) Bundle CA certificate with issued certificates ( #317 , @radhus )","title":"CA Issuer"},{"location":"release-notes/release-notes-0.3/#vault-issuer","text":"Add experimental support for HashiCorp Vault issuers ( #292 , @vdesjardins ) ingress-shim ingress-shim now reconfigures certificates ( #386 , @kragniz ) ingress-shim will only sync Ingress resources with kubernetes.io/tls-acme annotation if the value of that annotation is true. ( #325 , @wmedlar )","title":"Vault Issuer"},{"location":"release-notes/release-notes-0.3/#docs","text":"Rewrite documentation and publish on readthedocs ( #428 , @munnerz ) Document the minimum necessary permissions for using cert-manager with Route53 ( #359 , @wmedlar ) Improve deployment documentation ( #264 , @munnerz )","title":"Docs"},{"location":"release-notes/release-notes-0.3/#helm","text":"Add clusterResourceNamespace option to Helm chart ( #547 , @munnerz ) Enhance Helm chart in-line with best practices ( #229 , @unguiculus ): Add support for node affinity and tolerations in Helm chart ( #350 , @kiall ) Add podAnnotations to Helm chart ( #387 , @etiennetremel ) Add Certificate CRD short names cert and certs . This is configurable in the Helm Chart with certificateResourceShortNames . ( #312 , @Mikulas ) Remove default resource requests in Helm chart. Improve post-deployment informational messages. ( #290 , @munnerz ) End-to-end testing now covers the helm chart for cert-manager on Kubernetes 1.7-1.9 ( #216 , @munnerz )","title":"Helm"},{"location":"release-notes/release-notes-0.3/#other","text":"Produce a single static manifest instead of a directory when generating deployment manifests ( #574 , @munnerz ) Use cert-manager deployment namespace by default for leader election ( #548 , @munnerz ) Removed --namespace flag ( #433 , @kragniz ) Run cert-manager container as a non root user ( #415 , @tettaji ) TLS secrets are now annotated with information about the certificate ( #388 , @kragniz ) The static deployment manifests now automatically deploy into the 'cert-manager' namespace by default ( #330 , @munnerz ) Rename Event types to be prefixed 'Err' instead of 'Error' for brevity ( #332 , @munnerz ) Clearer event logging when issuing a certificate for the first time ( #331 , @munnerz ) Provide static deployment manifests as an alternative to a Helm chart based deployment ( #276 , @munnerz ) Update existing secrets instead of replacing in order to preserve annotations/labels ( #221 , @munnerz ) Update to Go 1.9 ( #200 , @euank )","title":"Other"},{"location":"release-notes/release-notes-0.3/#bug-fixes","text":"Fix a race condition in the package responsible for scheduling renewals ( #218 , @munnerz ) Fix a bug that caused ACME certificates to not be automatically renewed ( #215 , @munnerz ) Fix a bug in checking certificate validity and improve validation of dnsNames and commonName ( #183 , @munnerz ) Fix bugs when checking validity of certificate resources ( #184 , @munnerz )","title":"Bug fixes"},{"location":"release-notes/release-notes-0.4/","text":"This is the next feature release of cert-manager, containing a number of additions that have been in the works for a while now. As you will notice from the release notes below, we are seeing a lot more community contributions to the project which is brilliant! smile A massive thank you to everyone involved in making this release a reality. We have moved to a more regular minor-release schedule, and aim to cut new feature releases monthly. That means the next minor release ( v0.5 ) is scheduled for around the 11 th August. Highlights \u00b6 Resource validation for Issuers , ClusterIssuers and Certificates \u00b6 A common pain point for users has been around submitting invalid resources to the API, which cannot be handled or processed. Other Kubernetes API types handle this well by applying 'validation' before the resource is persisted or operated upon, and up until now we have not supported this. When submitting your resources to the Kubernetes apiserver, they will now be validated and if invalid, cert-manager will inform you of why and how they are invalid and suspend processing of that resource. In the next release, this validation will be turned into a ValidatingWebhookConfiguration which will allow us to prevent these resources being persisted into the API in the first place, similar to all other Kubernetes resource types. Due to some limitations with the current release of Helm, we have been unable to support this webhook operation mode in the v0.4 release of cert-manager. However, releasing validation this way allows us to pilot the new validation rules we have in place and it allows you to get started with it immediately! Added reference documentation for API types \u00b6 Regularly, users ask us \"what can I specify on my resources\". In the past, we have had to recommend users check out our source code (namely types.go ) in order to find out what can and cannot be specified. Digging through source code is no longer required! As part of our documentation publishing process, we now generate reference API documentation (similar to the upstream Kubernetes project!). This is available under the 'Reference documentation -> API documentation' section of our docs site! Better support for 'split horizon' DNS environments with ACME DNS01 challenges \u00b6 A number of users have noticed that when running cert-manager with DNS01 challenges in split-horizon DNS environments (using the ACME issuer), the self check stage of the validation process failed as the 'internal' DNS resolvers were used to check for challenge record propagation. We have added a new flag, --dns01-self-check-nameservers , that allows users to specify custom recursive DNS servers to use for performing DNS01 self checks. In these environments, this flag can be set to some external nameserver list that will be used for DNS01 resolution, e.g. 8.8.8.8:53,8.8.4.4:53. Self-signed Issuers \u00b6 We recently merged support for 'self signed' issuers. This allows users to create the basis for a completely cert-manager managed PKI by 'self signing' certificates. This can be useful when debugging, or once cert-manager also supports setting the isCA bit on a Certificate, for creating a self signed root CA! Read up on how to get started with this new issuer type in the documentation. Changelog \u00b6 Action Required \u00b6 Check the acme issuer has the 'HTTP01' challenge type configured if in use. ( #629 , @groner ) ACME HTTP01 validation is no longer attempted using an Issuer / ClusterIssuer with no ACME HTTP01 configuration. Note that the minimal http01: {} configuration IS sufficient. If you rely on ACME HTTP01 validation, you should check your issuers to make sure HTTP01 validation is explicitly enabled as in previous release, this was not verified! Other notable changes \u00b6 ACME Issuer \u00b6 Add --dns01-nameservers flag for setting nameservers for DNS01 check ( #710 , @kragniz ) Fix bugs affecting eTLD and CNAMEs during DNS zone resolution ( #582 , @ThatWasBrilliant ) Run acmesolver container as non-root user ( #585 , @klausenbusk ) Support for ACME HTTP01 validations when using istio-ingress with a mTLS enabled mesh ( #622 , @munnerz ) Vault Issuer \u00b6 Configurable Vault AppRole authentication path using the attribute is spec.vault.auth.authPath in the issuer. ( #612 , @vdesjardins ) Self-signed Issuer \u00b6 Add 'self signed' Issuer type ( #637 , @munnerz ) Docs \u00b6 Add reference documentation for API types ( #644 , @munnerz ) Helm \u00b6 Added configuration variables to set http_proxy , https_proxy and no_proxy environment variables in Helm chart. ( #680 , @fllaca ) added option to set additional environment variable values to the Helm chart ( #556 , @nazarewk ) Other \u00b6 Add certmanager.k8s.io/certificate-name label to secrets. ( #719 , @kragniz ) Add resource validation at start of sync loops, and mark resources as not Ready when invalid ( #682 , @munnerz ) To disable ingress-shim , you can now set this flag: --controllers=issuers,clusterissuers,certificates ( #717 , @kragniz )","title":"Release Notes"},{"location":"release-notes/release-notes-0.4/#highlights","text":"","title":"Highlights"},{"location":"release-notes/release-notes-0.4/#resource-validation-for-issuers-clusterissuers-and-certificates","text":"A common pain point for users has been around submitting invalid resources to the API, which cannot be handled or processed. Other Kubernetes API types handle this well by applying 'validation' before the resource is persisted or operated upon, and up until now we have not supported this. When submitting your resources to the Kubernetes apiserver, they will now be validated and if invalid, cert-manager will inform you of why and how they are invalid and suspend processing of that resource. In the next release, this validation will be turned into a ValidatingWebhookConfiguration which will allow us to prevent these resources being persisted into the API in the first place, similar to all other Kubernetes resource types. Due to some limitations with the current release of Helm, we have been unable to support this webhook operation mode in the v0.4 release of cert-manager. However, releasing validation this way allows us to pilot the new validation rules we have in place and it allows you to get started with it immediately!","title":"Resource validation for Issuers, ClusterIssuers and Certificates"},{"location":"release-notes/release-notes-0.4/#added-reference-documentation-for-api-types","text":"Regularly, users ask us \"what can I specify on my resources\". In the past, we have had to recommend users check out our source code (namely types.go ) in order to find out what can and cannot be specified. Digging through source code is no longer required! As part of our documentation publishing process, we now generate reference API documentation (similar to the upstream Kubernetes project!). This is available under the 'Reference documentation -> API documentation' section of our docs site!","title":"Added reference documentation for API types"},{"location":"release-notes/release-notes-0.4/#better-support-for-split-horizon-dns-environments-with-acme-dns01-challenges","text":"A number of users have noticed that when running cert-manager with DNS01 challenges in split-horizon DNS environments (using the ACME issuer), the self check stage of the validation process failed as the 'internal' DNS resolvers were used to check for challenge record propagation. We have added a new flag, --dns01-self-check-nameservers , that allows users to specify custom recursive DNS servers to use for performing DNS01 self checks. In these environments, this flag can be set to some external nameserver list that will be used for DNS01 resolution, e.g. 8.8.8.8:53,8.8.4.4:53.","title":"Better support for 'split horizon' DNS environments with ACME DNS01 challenges"},{"location":"release-notes/release-notes-0.4/#self-signed-issuers","text":"We recently merged support for 'self signed' issuers. This allows users to create the basis for a completely cert-manager managed PKI by 'self signing' certificates. This can be useful when debugging, or once cert-manager also supports setting the isCA bit on a Certificate, for creating a self signed root CA! Read up on how to get started with this new issuer type in the documentation.","title":"Self-signed Issuers"},{"location":"release-notes/release-notes-0.4/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.4/#action-required","text":"Check the acme issuer has the 'HTTP01' challenge type configured if in use. ( #629 , @groner ) ACME HTTP01 validation is no longer attempted using an Issuer / ClusterIssuer with no ACME HTTP01 configuration. Note that the minimal http01: {} configuration IS sufficient. If you rely on ACME HTTP01 validation, you should check your issuers to make sure HTTP01 validation is explicitly enabled as in previous release, this was not verified!","title":"Action Required"},{"location":"release-notes/release-notes-0.4/#other-notable-changes","text":"","title":"Other notable changes"},{"location":"release-notes/release-notes-0.4/#acme-issuer","text":"Add --dns01-nameservers flag for setting nameservers for DNS01 check ( #710 , @kragniz ) Fix bugs affecting eTLD and CNAMEs during DNS zone resolution ( #582 , @ThatWasBrilliant ) Run acmesolver container as non-root user ( #585 , @klausenbusk ) Support for ACME HTTP01 validations when using istio-ingress with a mTLS enabled mesh ( #622 , @munnerz )","title":"ACME Issuer"},{"location":"release-notes/release-notes-0.4/#vault-issuer","text":"Configurable Vault AppRole authentication path using the attribute is spec.vault.auth.authPath in the issuer. ( #612 , @vdesjardins )","title":"Vault Issuer"},{"location":"release-notes/release-notes-0.4/#self-signed-issuer","text":"Add 'self signed' Issuer type ( #637 , @munnerz )","title":"Self-signed Issuer"},{"location":"release-notes/release-notes-0.4/#docs","text":"Add reference documentation for API types ( #644 , @munnerz )","title":"Docs"},{"location":"release-notes/release-notes-0.4/#helm","text":"Added configuration variables to set http_proxy , https_proxy and no_proxy environment variables in Helm chart. ( #680 , @fllaca ) added option to set additional environment variable values to the Helm chart ( #556 , @nazarewk )","title":"Helm"},{"location":"release-notes/release-notes-0.4/#other","text":"Add certmanager.k8s.io/certificate-name label to secrets. ( #719 , @kragniz ) Add resource validation at start of sync loops, and mark resources as not Ready when invalid ( #682 , @munnerz ) To disable ingress-shim , you can now set this flag: --controllers=issuers,clusterissuers,certificates ( #717 , @kragniz )","title":"Other"},{"location":"release-notes/release-notes-0.5/","text":"Highlights \u00b6 Resource validation webhook \u00b6 Following the v0.4.0 release, we have now added a 'validating webhook' for our API resources. This will help prevent invalid configurations being submitted to the API server. This feature is disabled by default. Information on enabling the new webhook component can be found in the Resource Validation Webhook document. New Certificate options \u00b6 A number of new fields have been added to the Certificate resource type: keyAlgorithm - support alternative private key algorithms (e.g. RSA or ECDSA) for generated certificates. keySize - allow specifying an alternative key bit size isCA - allows generating certificates with the 'signing' usage set organization - allows specifying values for the 'O' field of Certificates (for supported providers) New fields like this make cert-manager more useful for applications beyond just securing Ingress, as well as allowing users to continue meeting their security requirements for X.509 certificates. New ACME DNS providers \u00b6 This release includes two new DNS provides for the ACME Issuer: ACMEDNS RFC2136 These additions should help more users begin using cert-manager with their chosen DNS provider, without having to delegate to an alternate provider that is supported Changelog \u00b6 General \u00b6 Add renew-before-expiry-duration option to configure how long before expiration a certificate should be attempted to be renewed ( #801 , @munnerz ) Add validation webhooks for API types ( #478 , @munnerz ) Add extended issuer specific validation to certificates at runtime ( #761 , @kragniz ) API changes \u00b6 Adds new fields: keyAlgorithm , keySize onto CertificateSpec to allow specifying algorithm (RSA, ECDSA) and key size to use when generating TLS keys ( #722 , @badie ) Add isCA field to Certificates ( #658 , @munnerz ) Add \"organization\" field to certificate objects ( #838 , @Queuecumber ) CA Issuer \u00b6 Don't bundle the CA certificate when using the self signed issuer ( #811 , @munnerz ) ACME \u00b6 Fix issue that could cause Certificates to fail renewal ( #800 , @munnerz ) Add ACMEDNS as a DNS01 provider ( #787 , @Queuecumber ) Fix panic from acmedns.go constructor failure ( #858 , @jjo ) Fix CloudFlare provider failing on cleanup if no record is found ( #849 , @frankh ) Fixed Route53 cleanup errors for already deleted records. ( #746 , @euank ) Add support for delegating DNS01 challenges using CNAME records. ( #670 , @gurvindersingh ) Fix a race that could cause ACME orders to fail despite them being in a 'valid' state ( #764 , @munnerz ) Fix cleanup of Google Cloud DNS hosted zone for DNS01 challenge records ( #754 , @kragniz ) Fix issue causing existing Ingresses to not be cleaned up properly after HTTP01 challenges in some cases ( #831 , @munnerz ) Allow metadata server authentication for Google Cloud DNS ( #664 , @rpahli ) Add RFC2136 DNS Provider ( #661 , @splashx )","title":"Release Notes"},{"location":"release-notes/release-notes-0.5/#highlights","text":"","title":"Highlights"},{"location":"release-notes/release-notes-0.5/#resource-validation-webhook","text":"Following the v0.4.0 release, we have now added a 'validating webhook' for our API resources. This will help prevent invalid configurations being submitted to the API server. This feature is disabled by default. Information on enabling the new webhook component can be found in the Resource Validation Webhook document.","title":"Resource validation webhook"},{"location":"release-notes/release-notes-0.5/#new-certificate-options","text":"A number of new fields have been added to the Certificate resource type: keyAlgorithm - support alternative private key algorithms (e.g. RSA or ECDSA) for generated certificates. keySize - allow specifying an alternative key bit size isCA - allows generating certificates with the 'signing' usage set organization - allows specifying values for the 'O' field of Certificates (for supported providers) New fields like this make cert-manager more useful for applications beyond just securing Ingress, as well as allowing users to continue meeting their security requirements for X.509 certificates.","title":"New Certificate options"},{"location":"release-notes/release-notes-0.5/#new-acme-dns-providers","text":"This release includes two new DNS provides for the ACME Issuer: ACMEDNS RFC2136 These additions should help more users begin using cert-manager with their chosen DNS provider, without having to delegate to an alternate provider that is supported","title":"New ACME DNS providers"},{"location":"release-notes/release-notes-0.5/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.5/#general","text":"Add renew-before-expiry-duration option to configure how long before expiration a certificate should be attempted to be renewed ( #801 , @munnerz ) Add validation webhooks for API types ( #478 , @munnerz ) Add extended issuer specific validation to certificates at runtime ( #761 , @kragniz )","title":"General"},{"location":"release-notes/release-notes-0.5/#api-changes","text":"Adds new fields: keyAlgorithm , keySize onto CertificateSpec to allow specifying algorithm (RSA, ECDSA) and key size to use when generating TLS keys ( #722 , @badie ) Add isCA field to Certificates ( #658 , @munnerz ) Add \"organization\" field to certificate objects ( #838 , @Queuecumber )","title":"API changes"},{"location":"release-notes/release-notes-0.5/#ca-issuer","text":"Don't bundle the CA certificate when using the self signed issuer ( #811 , @munnerz )","title":"CA Issuer"},{"location":"release-notes/release-notes-0.5/#acme","text":"Fix issue that could cause Certificates to fail renewal ( #800 , @munnerz ) Add ACMEDNS as a DNS01 provider ( #787 , @Queuecumber ) Fix panic from acmedns.go constructor failure ( #858 , @jjo ) Fix CloudFlare provider failing on cleanup if no record is found ( #849 , @frankh ) Fixed Route53 cleanup errors for already deleted records. ( #746 , @euank ) Add support for delegating DNS01 challenges using CNAME records. ( #670 , @gurvindersingh ) Fix a race that could cause ACME orders to fail despite them being in a 'valid' state ( #764 , @munnerz ) Fix cleanup of Google Cloud DNS hosted zone for DNS01 challenge records ( #754 , @kragniz ) Fix issue causing existing Ingresses to not be cleaned up properly after HTTP01 challenges in some cases ( #831 , @munnerz ) Allow metadata server authentication for Google Cloud DNS ( #664 , @rpahli ) Add RFC2136 DNS Provider ( #661 , @splashx )","title":"ACME"},{"location":"release-notes/release-notes-0.6/","text":"The long-awaited v0.6 release is here! This release includes a huge number of improvements, bug fixes and new features. We've made a big focus on the ACME implementation, as well as improving the general user-experience when requesting certificates. We've exposed new X.509 certificate fields via the Certificate resource type, as well as improving support for these options across all Issuer types. As of the v0.6 release being cut, we've also reached a huge 99 code contributors! This is incredible to see, and we're thankful to all those who have contributed in all forms over the last couple of years! Read on to get some of the highlights, as well as the full list of note-worthy changes below! Highlights \u00b6 Introducing ACME 'Order' and 'Challenge' CRDs \u00b6 This release of cert-manager refactors how ACME certificates are handled significantly. This should result in: Fewer API calls to ACME servers - information about orders and challenges is now stored within the Kubernetes API Better behavior with regards to rate limits A cleaner surface for debugging issues - we can now provide more context and information through the Events API as well as the 'status' field on our API types This is largely an internal change, but with far reaching benefits. For more details, check out the details in the pull request ( #788 ). We are keen to hear feedback on this new design, so please create issues including the /area provider-acme text in order to report feedback/problems. Improved handling of ACME rate limits \u00b6 After extensive testing, we've found in the most extreme cases a 100 times reduction in ACME API client calls. This is a massive difference, and helps reduce the load that instances of cert-manager put on services like Let's Encrypt. As a result, we strongly recommend all users upgrade to the v0.6 release as soon as possible! Prometheus metrics for the ACME client \u00b6 In order to support the API client testing above, we've also added support for Prometheus metrics into our ACME client. This means you can now start instrumenting cert-manager's own usage of ACME APIs, in order to detect issues and understand behavior before it becomes a problem. The metrics are broken down by path, status code and a number of other labels. Validating resource webhook enabled by default \u00b6 In order to provide a better experience out of the box, we've now enabled the validating webhook component by default. This means that when you submit resources to the API server, they will be checked for misconfiguration before they are persisted to the API, meaning configuration errors are surfaced immediately, and in some cases alongside steps that can be taken to remediate the errors. ECDSA keys supported for ACME certificates \u00b6 It's now possible to create ECDSA private keys when issuing certificates from ACME servers. You can configure the key type and key size using certificate.spec.keyAlgorithm and certificate.spec.keySize respectively. Scalability improvements \u00b6 As part of our validation for this release, we've been able to test cert-manager in larger deployment configurations. This includes running with an ACME issuer with 6,000+ domain names, showing that our client usage remains sensible and cert-manager itself does not begin to strain. Off the back of this scale testing, we've also got numerous scale-related improvements lined up for the next minor release, v0.7 . Action Required \u00b6 There is only one PR that changes previous behavior in this release. Between v0.4.0 and v0.5.0 , we introduced support for following CNAME records when presenting DNS01 challenges. This inadvertently broke DNS01 challenge solving when a user used a CNAME record at the route of their DNS zone (i.e. on Route53 when using an Amazon ELB). This change reverts the default behavior to support this kind of setup without additional changes, and instead introduces a new cnameStrategy field on ACME Issuer resources. You can set this field to Follow to restore the behavior introduced in v0.5.0 . This note only affects the ACME Issuer type. Changelog \u00b6 General \u00b6 Bump Go version to 1.11 ( #1050 , @munnerz ) Removed the Git commit hash from the version string in non canary builds ( #997 ) ( #1021 , @Nalum ) Include ca.crt in created secrets for Issuers that support it (Vault, CA and SelfSigned ) ( #848 , @Queuecumber ) Added RBAC permissions for user facing roles to access Certificates and Issuers. ( #902 , @fuel-wlightning ) Add global.priorityClassName option to Helm chart ( #1190 , @Art3mK ) Add --namespace option to limit scope to a single namespace ( #1188 , @kragniz ) Print more useful information about Certificate, Order and Challenge resources when running kubectl get ( #1194 , @munnerz ) ACME Issuer \u00b6 Introduce ACME 'Order' and 'Challenge' resource types & re-implement ACME Issuer to be completely driven by CRDs ( #788 , @munnerz ) ACTION REQUIRED: Fix ACME issues relating to wildcard CNAME records and add a cnameStrategy field to the ACME Issuer DNS01 provider configuration ( #1136 , @munnerz ) Added certmanager.k8s.io/acme-http01-ingress-class annotation to ingress-shim ( #1006 , @kinolaev ) Make HTTP01 solver serviceType configurable, so one can use ClusterIP instead of the previously hard coded type NodePort . NodePort still remains as default. ( #924 , @arnisoph ) Revised Cert Issuer Docs for DNS01 challenge and added a doc for AzureDNS ( #915 , @damienwebdev ) Make HTTP01 solver pod resource request/limits configurable ( #923 , @arnisoph ) Allow ECDSA keys for ACME certificates ( #937 , @acoshift ) RFC2136 provider: fixes a minor bug where DNS01 nameserver key has value with no port ( #908 , @splashx ) Add ACME HTTP client Prometheus metrics ( #1226 , @munnerz ) Reduce usage of ACME new-acct endpoint ( #1227 , @munnerz ) Disable TLS verification when self-checking ( #1221 , @DanielMorsing ) Adds new flag --dns01-recursive-nameservers-only=[true|false] that defaults to false. When true, cert-manager will only ever query the configured DNS resolvers to perform the ACME DNS01 self check. This is useful in DNS constrained environments, where access to authoritative nameservers is restricted. Enabling this option could cause the DNS01 self check to take longer due to caching performed by the recursive nameservers. ( #1184 , @tlmiller ) Retain Challenge resources when an Order has entered a failed state to make debugging easier ( #1197 , @munnerz ) Increase back-off time between ACME order attempts on failure from 5 minutes to 1 hour ( #1195 , @munnerz ) Add 'reason' field when an order/challenge gets marked invalid ( #1192 , @DanielMorsing ) Add DigitalOcean DNS Provider ( #972 , @aslafy-z ) CA Issuer \u00b6 Update CA Issuer status condition usage ( #961 , @munnerz ) It is now possible to include a certificate chain in the secret for the CA Issuer. This will then be propagated to generated certificates. ( #1077 , @mikebryant ) Vault Issuer \u00b6 A new field caBundle added to the Vault Issuer configures a CA certificate used to validate the connection to the Vault Server. ( #911 , @vdesjardins ) Bug fixes \u00b6 Increase time between retries for failing Issuers and ClusterIssuers ( #981 , @munnerz ) Fix concurrent map write race condition in ACME solver ( #1033 , @munnerz ) Fix bug when updating ACME server URL on an existing Issuer resource ( #1230 , @munnerz ) Fix issuing a certificate into a preexisting secret resource ( #1217 , @munnerz ) Fix affinity and tolerations declaration ( #1209 , @GuillaumeSmaha )","title":"Release Notes"},{"location":"release-notes/release-notes-0.6/#highlights","text":"","title":"Highlights"},{"location":"release-notes/release-notes-0.6/#introducing-acme-order-and-challenge-crds","text":"This release of cert-manager refactors how ACME certificates are handled significantly. This should result in: Fewer API calls to ACME servers - information about orders and challenges is now stored within the Kubernetes API Better behavior with regards to rate limits A cleaner surface for debugging issues - we can now provide more context and information through the Events API as well as the 'status' field on our API types This is largely an internal change, but with far reaching benefits. For more details, check out the details in the pull request ( #788 ). We are keen to hear feedback on this new design, so please create issues including the /area provider-acme text in order to report feedback/problems.","title":"Introducing ACME 'Order' and 'Challenge' CRDs"},{"location":"release-notes/release-notes-0.6/#improved-handling-of-acme-rate-limits","text":"After extensive testing, we've found in the most extreme cases a 100 times reduction in ACME API client calls. This is a massive difference, and helps reduce the load that instances of cert-manager put on services like Let's Encrypt. As a result, we strongly recommend all users upgrade to the v0.6 release as soon as possible!","title":"Improved handling of ACME rate limits"},{"location":"release-notes/release-notes-0.6/#prometheus-metrics-for-the-acme-client","text":"In order to support the API client testing above, we've also added support for Prometheus metrics into our ACME client. This means you can now start instrumenting cert-manager's own usage of ACME APIs, in order to detect issues and understand behavior before it becomes a problem. The metrics are broken down by path, status code and a number of other labels.","title":"Prometheus metrics for the ACME client"},{"location":"release-notes/release-notes-0.6/#validating-resource-webhook-enabled-by-default","text":"In order to provide a better experience out of the box, we've now enabled the validating webhook component by default. This means that when you submit resources to the API server, they will be checked for misconfiguration before they are persisted to the API, meaning configuration errors are surfaced immediately, and in some cases alongside steps that can be taken to remediate the errors.","title":"Validating resource webhook enabled by default"},{"location":"release-notes/release-notes-0.6/#ecdsa-keys-supported-for-acme-certificates","text":"It's now possible to create ECDSA private keys when issuing certificates from ACME servers. You can configure the key type and key size using certificate.spec.keyAlgorithm and certificate.spec.keySize respectively.","title":"ECDSA keys supported for ACME certificates"},{"location":"release-notes/release-notes-0.6/#scalability-improvements","text":"As part of our validation for this release, we've been able to test cert-manager in larger deployment configurations. This includes running with an ACME issuer with 6,000+ domain names, showing that our client usage remains sensible and cert-manager itself does not begin to strain. Off the back of this scale testing, we've also got numerous scale-related improvements lined up for the next minor release, v0.7 .","title":"Scalability improvements"},{"location":"release-notes/release-notes-0.6/#action-required","text":"There is only one PR that changes previous behavior in this release. Between v0.4.0 and v0.5.0 , we introduced support for following CNAME records when presenting DNS01 challenges. This inadvertently broke DNS01 challenge solving when a user used a CNAME record at the route of their DNS zone (i.e. on Route53 when using an Amazon ELB). This change reverts the default behavior to support this kind of setup without additional changes, and instead introduces a new cnameStrategy field on ACME Issuer resources. You can set this field to Follow to restore the behavior introduced in v0.5.0 . This note only affects the ACME Issuer type.","title":"Action Required"},{"location":"release-notes/release-notes-0.6/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.6/#general","text":"Bump Go version to 1.11 ( #1050 , @munnerz ) Removed the Git commit hash from the version string in non canary builds ( #997 ) ( #1021 , @Nalum ) Include ca.crt in created secrets for Issuers that support it (Vault, CA and SelfSigned ) ( #848 , @Queuecumber ) Added RBAC permissions for user facing roles to access Certificates and Issuers. ( #902 , @fuel-wlightning ) Add global.priorityClassName option to Helm chart ( #1190 , @Art3mK ) Add --namespace option to limit scope to a single namespace ( #1188 , @kragniz ) Print more useful information about Certificate, Order and Challenge resources when running kubectl get ( #1194 , @munnerz )","title":"General"},{"location":"release-notes/release-notes-0.6/#acme-issuer","text":"Introduce ACME 'Order' and 'Challenge' resource types & re-implement ACME Issuer to be completely driven by CRDs ( #788 , @munnerz ) ACTION REQUIRED: Fix ACME issues relating to wildcard CNAME records and add a cnameStrategy field to the ACME Issuer DNS01 provider configuration ( #1136 , @munnerz ) Added certmanager.k8s.io/acme-http01-ingress-class annotation to ingress-shim ( #1006 , @kinolaev ) Make HTTP01 solver serviceType configurable, so one can use ClusterIP instead of the previously hard coded type NodePort . NodePort still remains as default. ( #924 , @arnisoph ) Revised Cert Issuer Docs for DNS01 challenge and added a doc for AzureDNS ( #915 , @damienwebdev ) Make HTTP01 solver pod resource request/limits configurable ( #923 , @arnisoph ) Allow ECDSA keys for ACME certificates ( #937 , @acoshift ) RFC2136 provider: fixes a minor bug where DNS01 nameserver key has value with no port ( #908 , @splashx ) Add ACME HTTP client Prometheus metrics ( #1226 , @munnerz ) Reduce usage of ACME new-acct endpoint ( #1227 , @munnerz ) Disable TLS verification when self-checking ( #1221 , @DanielMorsing ) Adds new flag --dns01-recursive-nameservers-only=[true|false] that defaults to false. When true, cert-manager will only ever query the configured DNS resolvers to perform the ACME DNS01 self check. This is useful in DNS constrained environments, where access to authoritative nameservers is restricted. Enabling this option could cause the DNS01 self check to take longer due to caching performed by the recursive nameservers. ( #1184 , @tlmiller ) Retain Challenge resources when an Order has entered a failed state to make debugging easier ( #1197 , @munnerz ) Increase back-off time between ACME order attempts on failure from 5 minutes to 1 hour ( #1195 , @munnerz ) Add 'reason' field when an order/challenge gets marked invalid ( #1192 , @DanielMorsing ) Add DigitalOcean DNS Provider ( #972 , @aslafy-z )","title":"ACME Issuer"},{"location":"release-notes/release-notes-0.6/#ca-issuer","text":"Update CA Issuer status condition usage ( #961 , @munnerz ) It is now possible to include a certificate chain in the secret for the CA Issuer. This will then be propagated to generated certificates. ( #1077 , @mikebryant )","title":"CA Issuer"},{"location":"release-notes/release-notes-0.6/#vault-issuer","text":"A new field caBundle added to the Vault Issuer configures a CA certificate used to validate the connection to the Vault Server. ( #911 , @vdesjardins )","title":"Vault Issuer"},{"location":"release-notes/release-notes-0.6/#bug-fixes","text":"Increase time between retries for failing Issuers and ClusterIssuers ( #981 , @munnerz ) Fix concurrent map write race condition in ACME solver ( #1033 , @munnerz ) Fix bug when updating ACME server URL on an existing Issuer resource ( #1230 , @munnerz ) Fix issuing a certificate into a preexisting secret resource ( #1217 , @munnerz ) Fix affinity and tolerations declaration ( #1209 , @GuillaumeSmaha )","title":"Bug fixes"},{"location":"release-notes/release-notes-0.7/","text":"Action Required \u00b6 The Helm chart rbac.create option has moved to be global.rbac.create . Users of the Helm chart will need to update their install overrides to use the new format. The Helm chart has now moved to be hosted on charts.jetstack.io , and exposed via the Helm Hub. This allows us to make and test changes to the Helm chart more easily, and better manage versions. Highlights \u00b6 Venafi Issuer type \u00b6 This release introduces a new issuer type for Venafi Cloud and Venafi Trust Protection Platform. The Venafi adapter will be built out over the coming months to improve the integration and expose more of the Venafi platform's advanced functionality. New cainjector controller \u00b6 This release introduces support for injecting CA bundles into Kubernetes {Validating,Mutating}WebhookConfiguration & APIService resources. You can utilize the new controller by adding the certmanager.k8s.io/inject-ca-from annotation to your webhook and APIService resources. This was needed in order to improve our own deployment of the 'webhook' component as part of this release. Improved webhook deployment \u00b6 The v0.6 release utilized an additional ca-sync CronJob resource that allowed us to secure the webhook component automatically using cert-manager itself. Thanks to the new cainjector controller described above, we have now removed this CronJob altogether in favor of using the far more reliable controller. Experimental ARM support \u00b6 Support for ARM was adding as part of this release ( #1212 ). We do not currently have automated testing using ARM platforms, so this feature is still marked experimental. To utilize the new ARM support, you'll need to update your manifests and append the architecture to the image name (i.e. quay.io/jetstack/cert-manager-controller-arm64:v0.7.0 ). Easier debugging of failing ACME challenges \u00b6 The introduction of the Challenge resource in the last release has allowed us to provide better means for debugging failures. In the v0.7.0 release , if a self check or ACME validation is failing for some reason, this information will be displayed when running kubectl get and kubectl describe . Changelog since v0.6.0 \u00b6 Add Venafi Cloud & TPP issuer type ( #1250 , @munnerz ) cainjector : add support for injecting apiserver CA ( #1420 , @munnerz ) Generate temporary self signed certificate whilst waiting for issuer to issue certificate ( #1392 , @munnerz ) Added kubeprod as an alternative way to deploy cert-manager to the documentation ( #1421 , @arapulido ) Use new cainjector controller for webhook APIService resource ( #1415 , @munnerz ) Adds a controller for injecting CA data into webhooks and APIServices ( #1398 , @DirectXMan12 ) Bump Kubernetes dependencies to v1.13 ( #1268 , @munnerz ) Use charts.jetstack.io instead of the helm/charts repository to publish Helm chart ( #1377 , @munnerz ) Recreate dead solver pods during self-check ( #1388 , @DanielMorsing ) Improve RFC2136 DNS01 provider documentation ( #944 , @briantopping ) Add more information to Google CloudDNS guide ( #1295 , @wwwil ) Add validation schema to CRD resources ( #1322 , @munnerz ) Fire additional events when syncing ACME certificates fails ( #1327 , @munnerz ) Publish ARM32 and ARM64 images for all cert-manager components ( #1212 , @munnerz ) Extend ACME self check to check CAA records ( #1325 , @DanielMorsing ) Bump Kubernetes apimachinery dependencies to v1.10.12 ( #1344 , @munnerz ) Increase acmesolver default CPU resource limit to 100m ( #1335 , @munnerz ) Fix potential race when updating secret resource ( #1318 , @munnerz ) Fix bug causing certificates to be re-issued endlessly in certain edge cases ( #1280 , @munnerz ) Fix bug when specify certificate keyAlgorithm without an explicit keySize ( #1309 , @munnerz ) Bump Go version to 1.11.5 ( #1304 , @munnerz ) Fix typo in SelfSigned Issuer in webhook deployment manifests ( #1294 , @munnerz ) Add IP Address in CSR ( #1128 , @lrolaz ) Allow to use PKCS#8 encoded private keys in CA issuers. ( #1191 , @chr-fritz ) Add webhook troubleshooting guide ( #1288 , @munnerz ) Overhaul documentation and add additional content ( #1279 , @munnerz ) Increase X.509 certificate duration from 90 days to 1 year for webhook component certificates ( #1276 , @munnerz ) Fix bug where --dns01-recursive-nameservers flag was not respected when looking up the zone to update for a DNS01 challenge ( #1266 , @munnerz ) Reuse acme clients to limit use of nonce/directory/accounts endpoints ( #1265 , @DanielMorsing ) Surface self-check errors in challenge resource ( #1244 , @DanielMorsing )","title":"Release Notes"},{"location":"release-notes/release-notes-0.7/#action-required","text":"The Helm chart rbac.create option has moved to be global.rbac.create . Users of the Helm chart will need to update their install overrides to use the new format. The Helm chart has now moved to be hosted on charts.jetstack.io , and exposed via the Helm Hub. This allows us to make and test changes to the Helm chart more easily, and better manage versions.","title":"Action Required"},{"location":"release-notes/release-notes-0.7/#highlights","text":"","title":"Highlights"},{"location":"release-notes/release-notes-0.7/#venafi-issuer-type","text":"This release introduces a new issuer type for Venafi Cloud and Venafi Trust Protection Platform. The Venafi adapter will be built out over the coming months to improve the integration and expose more of the Venafi platform's advanced functionality.","title":"Venafi Issuer type"},{"location":"release-notes/release-notes-0.7/#new-cainjector-controller","text":"This release introduces support for injecting CA bundles into Kubernetes {Validating,Mutating}WebhookConfiguration & APIService resources. You can utilize the new controller by adding the certmanager.k8s.io/inject-ca-from annotation to your webhook and APIService resources. This was needed in order to improve our own deployment of the 'webhook' component as part of this release.","title":"New cainjector controller"},{"location":"release-notes/release-notes-0.7/#improved-webhook-deployment","text":"The v0.6 release utilized an additional ca-sync CronJob resource that allowed us to secure the webhook component automatically using cert-manager itself. Thanks to the new cainjector controller described above, we have now removed this CronJob altogether in favor of using the far more reliable controller.","title":"Improved webhook deployment"},{"location":"release-notes/release-notes-0.7/#experimental-arm-support","text":"Support for ARM was adding as part of this release ( #1212 ). We do not currently have automated testing using ARM platforms, so this feature is still marked experimental. To utilize the new ARM support, you'll need to update your manifests and append the architecture to the image name (i.e. quay.io/jetstack/cert-manager-controller-arm64:v0.7.0 ).","title":"Experimental ARM support"},{"location":"release-notes/release-notes-0.7/#easier-debugging-of-failing-acme-challenges","text":"The introduction of the Challenge resource in the last release has allowed us to provide better means for debugging failures. In the v0.7.0 release , if a self check or ACME validation is failing for some reason, this information will be displayed when running kubectl get and kubectl describe .","title":"Easier debugging of failing ACME challenges"},{"location":"release-notes/release-notes-0.7/#changelog-since-v060","text":"Add Venafi Cloud & TPP issuer type ( #1250 , @munnerz ) cainjector : add support for injecting apiserver CA ( #1420 , @munnerz ) Generate temporary self signed certificate whilst waiting for issuer to issue certificate ( #1392 , @munnerz ) Added kubeprod as an alternative way to deploy cert-manager to the documentation ( #1421 , @arapulido ) Use new cainjector controller for webhook APIService resource ( #1415 , @munnerz ) Adds a controller for injecting CA data into webhooks and APIServices ( #1398 , @DirectXMan12 ) Bump Kubernetes dependencies to v1.13 ( #1268 , @munnerz ) Use charts.jetstack.io instead of the helm/charts repository to publish Helm chart ( #1377 , @munnerz ) Recreate dead solver pods during self-check ( #1388 , @DanielMorsing ) Improve RFC2136 DNS01 provider documentation ( #944 , @briantopping ) Add more information to Google CloudDNS guide ( #1295 , @wwwil ) Add validation schema to CRD resources ( #1322 , @munnerz ) Fire additional events when syncing ACME certificates fails ( #1327 , @munnerz ) Publish ARM32 and ARM64 images for all cert-manager components ( #1212 , @munnerz ) Extend ACME self check to check CAA records ( #1325 , @DanielMorsing ) Bump Kubernetes apimachinery dependencies to v1.10.12 ( #1344 , @munnerz ) Increase acmesolver default CPU resource limit to 100m ( #1335 , @munnerz ) Fix potential race when updating secret resource ( #1318 , @munnerz ) Fix bug causing certificates to be re-issued endlessly in certain edge cases ( #1280 , @munnerz ) Fix bug when specify certificate keyAlgorithm without an explicit keySize ( #1309 , @munnerz ) Bump Go version to 1.11.5 ( #1304 , @munnerz ) Fix typo in SelfSigned Issuer in webhook deployment manifests ( #1294 , @munnerz ) Add IP Address in CSR ( #1128 , @lrolaz ) Allow to use PKCS#8 encoded private keys in CA issuers. ( #1191 , @chr-fritz ) Add webhook troubleshooting guide ( #1288 , @munnerz ) Overhaul documentation and add additional content ( #1279 , @munnerz ) Increase X.509 certificate duration from 90 days to 1 year for webhook component certificates ( #1276 , @munnerz ) Fix bug where --dns01-recursive-nameservers flag was not respected when looking up the zone to update for a DNS01 challenge ( #1266 , @munnerz ) Reuse acme clients to limit use of nonce/directory/accounts endpoints ( #1265 , @DanielMorsing ) Surface self-check errors in challenge resource ( #1244 , @DanielMorsing )","title":"Changelog since v0.6.0"},{"location":"release-notes/release-notes-0.8/","text":"Following on from the v0.7.x releases and a series of prerelease candidates, cert-manager v0.8.0 is available at last! This release packs in a tonne of stability improvements, as well as a whole load of new features grinning As part of this release, we're updating our API format in order to better support the 1.0 release, which we hope to reach within the next few months. This has been accomplished in a backwards-compatible for now, to make the upgrade process easier, especially for users that manage large numbers of certificate resources. As well as the new release, we've also finally created a project logo! For those of you who are attending KubeCon EU, we'll be handing out stickers at the Jetstack booth from tomorrow onward! Action required \u00b6 The deployment manifests have now moved from being a part of our GitHub repository and are now published alongside each image tag. Please double check the installation guide for more information on where the manifests can now be found. This change does not affect the Helm chart! New ACME configuration format \u00b6 As part of stabilizing our API surface, we've made a change to the way you configure your ACME based certificates. Instead of Certificate resources containing an extra certificate.spec.acme field, which is only relevant for ACME certificates, the configuration has now moved over to the Issuer resource instead. More details on this change can be found in the upgrade notes. OpenShift installation instructions \u00b6 In order to make it easier for users to run cert-manager on platforms other than Kubernetes, we've improved our OpenShift support, including an official installation guide for users of OpenShift. If you use OpenShift in your organization, check out the getting started section for more information on how to get up and running! Webhook based ACME DNS01 solver \u00b6 Over the last year and a half, we've had more than 15 pull requests to add new ACME DNS01 providers to our codebase. It's been brilliant to see such vibrant community involvement, however it's become infeasible for us to continue to accept, test and maintain such a rapidly growing matrix of providers. As a result, we've put together a new 'webhook' DNS01 solver type. This allows you to create and install your own DNS01 providers without having to make changes in cert-manager itself. You can see an example repository to get started building your own over in the cert-manager-webhook-example repo on GitHub. This is a new and experimental feature, however we're excited to see the community move to this new model of extending cert-manager. Switch to structured logging \u00b6 As the project has grown, we've also increased the verbosity and frequency of our log messages. Over time, this has become difficult to manage and work with, and so with the v0.8 release we have begun the process of switching over our code base to structured logging. This should make it far easier to index, search and grep through log messages that cert-manager emits. Your feedback here is really valuable, so please open issues and comment on Slack if you have any issues! Changelog \u00b6 make email address an optional field in ACME issuers ( #1483 , @DanielMorsing ) Fix bug when handling resources that have lastTransitionTime set to null ( #1628 , @munnerz ) Allow OpenShift to install cert-manager chart ( #1395 , @JGodin-C2C ) Update documentation for new 'solvers' field ( #1623 , @munnerz ) Fix issue where ingress-shim would not clear old configuration when migrating to the new 'solvers' field ( #1620 , @munnerz ) Add new issuer.spec.acme.solvers field that replaces certificate.spec.acme in order to make all certificate resources portable between issuer types. The previously syntax is still supported to allow easy migration to the new configuration format. ( #1450 , @munnerz ) Fixes additionalPrinterColumn formatting for Certificate resources ( #1616 , @munnerz ) Fix update loop in certificates controller and add additional debug logging ( #1602 , @munnerz ) Automatically retry expired Challenge resources ( #1603 , @munnerz ) Build under MacOS. ( #1601 , @michaelfig ) Disable the CAA check by default, and introduce a new --feature-gates=ValidateCAA=true option to enable it ( #1585 , @munnerz ) Improve error handling when ACME challenges fail to Present or CleanUp ( #1597 , @munnerz ) Add static label for solver identification to allow usage of custom service ( #1575 , @christianhuening ) Fix issues running the cainjector controller on Kubernetes 1.9 ( #1579 , @munnerz ) Fix upgrade bug where lastTransitionTime may be set to nil, rendering cert-manager inoperable without manual intervention ( #1576 , @munnerz ) Add webhook based DNS01 provider ( #1563 , @munnerz ) Add DNS01 provider conformance test suite ( #1562 , @munnerz ) fix typo in the deployment template ( #1546 , @cpanato ) Automatically generate LICENSES file ( #1549 , @munnerz ) Switch to go modules for dependency management ( #1523 , @munnerz ) Bump to use Go 1.12 ( #1429 , @munnerz ) use authoritative nameservers for CAA checks ( #1521 , @DanielMorsing ) Update certificate if issuer changes ( #1512 , @lentzi90 ) also whitelist IPv6 ( #1497 , @mdonoughe ) Set default acmesolver image based on arch ( #1494 , @lentzi90 ) Improve logging in ACME HTTP01 solver ( #1474 , @munnerz ) Run metrics server on cert-manager instances that have not been elected as leader ( #1482 , @kragniz ) Switch to structured logging using logr ( #1409 , @munnerz ) fixing the quick-start documentation to use the new helm chart repo charts.jetstack.io ( #1468 , @BradErz ) Removes need for hostedZoneName to be specified. Uses discovered DNS zone name instead. ( #1466 , @logicfox )","title":"Release Notes"},{"location":"release-notes/release-notes-0.8/#action-required","text":"The deployment manifests have now moved from being a part of our GitHub repository and are now published alongside each image tag. Please double check the installation guide for more information on where the manifests can now be found. This change does not affect the Helm chart!","title":"Action required"},{"location":"release-notes/release-notes-0.8/#new-acme-configuration-format","text":"As part of stabilizing our API surface, we've made a change to the way you configure your ACME based certificates. Instead of Certificate resources containing an extra certificate.spec.acme field, which is only relevant for ACME certificates, the configuration has now moved over to the Issuer resource instead. More details on this change can be found in the upgrade notes.","title":"New ACME configuration format"},{"location":"release-notes/release-notes-0.8/#openshift-installation-instructions","text":"In order to make it easier for users to run cert-manager on platforms other than Kubernetes, we've improved our OpenShift support, including an official installation guide for users of OpenShift. If you use OpenShift in your organization, check out the getting started section for more information on how to get up and running!","title":"OpenShift installation instructions"},{"location":"release-notes/release-notes-0.8/#webhook-based-acme-dns01-solver","text":"Over the last year and a half, we've had more than 15 pull requests to add new ACME DNS01 providers to our codebase. It's been brilliant to see such vibrant community involvement, however it's become infeasible for us to continue to accept, test and maintain such a rapidly growing matrix of providers. As a result, we've put together a new 'webhook' DNS01 solver type. This allows you to create and install your own DNS01 providers without having to make changes in cert-manager itself. You can see an example repository to get started building your own over in the cert-manager-webhook-example repo on GitHub. This is a new and experimental feature, however we're excited to see the community move to this new model of extending cert-manager.","title":"Webhook based ACME DNS01 solver"},{"location":"release-notes/release-notes-0.8/#switch-to-structured-logging","text":"As the project has grown, we've also increased the verbosity and frequency of our log messages. Over time, this has become difficult to manage and work with, and so with the v0.8 release we have begun the process of switching over our code base to structured logging. This should make it far easier to index, search and grep through log messages that cert-manager emits. Your feedback here is really valuable, so please open issues and comment on Slack if you have any issues!","title":"Switch to structured logging"},{"location":"release-notes/release-notes-0.8/#changelog","text":"make email address an optional field in ACME issuers ( #1483 , @DanielMorsing ) Fix bug when handling resources that have lastTransitionTime set to null ( #1628 , @munnerz ) Allow OpenShift to install cert-manager chart ( #1395 , @JGodin-C2C ) Update documentation for new 'solvers' field ( #1623 , @munnerz ) Fix issue where ingress-shim would not clear old configuration when migrating to the new 'solvers' field ( #1620 , @munnerz ) Add new issuer.spec.acme.solvers field that replaces certificate.spec.acme in order to make all certificate resources portable between issuer types. The previously syntax is still supported to allow easy migration to the new configuration format. ( #1450 , @munnerz ) Fixes additionalPrinterColumn formatting for Certificate resources ( #1616 , @munnerz ) Fix update loop in certificates controller and add additional debug logging ( #1602 , @munnerz ) Automatically retry expired Challenge resources ( #1603 , @munnerz ) Build under MacOS. ( #1601 , @michaelfig ) Disable the CAA check by default, and introduce a new --feature-gates=ValidateCAA=true option to enable it ( #1585 , @munnerz ) Improve error handling when ACME challenges fail to Present or CleanUp ( #1597 , @munnerz ) Add static label for solver identification to allow usage of custom service ( #1575 , @christianhuening ) Fix issues running the cainjector controller on Kubernetes 1.9 ( #1579 , @munnerz ) Fix upgrade bug where lastTransitionTime may be set to nil, rendering cert-manager inoperable without manual intervention ( #1576 , @munnerz ) Add webhook based DNS01 provider ( #1563 , @munnerz ) Add DNS01 provider conformance test suite ( #1562 , @munnerz ) fix typo in the deployment template ( #1546 , @cpanato ) Automatically generate LICENSES file ( #1549 , @munnerz ) Switch to go modules for dependency management ( #1523 , @munnerz ) Bump to use Go 1.12 ( #1429 , @munnerz ) use authoritative nameservers for CAA checks ( #1521 , @DanielMorsing ) Update certificate if issuer changes ( #1512 , @lentzi90 ) also whitelist IPv6 ( #1497 , @mdonoughe ) Set default acmesolver image based on arch ( #1494 , @lentzi90 ) Improve logging in ACME HTTP01 solver ( #1474 , @munnerz ) Run metrics server on cert-manager instances that have not been elected as leader ( #1482 , @kragniz ) Switch to structured logging using logr ( #1409 , @munnerz ) fixing the quick-start documentation to use the new helm chart repo charts.jetstack.io ( #1468 , @BradErz ) Removes need for hostedZoneName to be specified. Uses discovered DNS zone name instead. ( #1466 , @logicfox )","title":"Changelog"},{"location":"release-notes/release-notes-0.9/","text":"The v0.9 release is one of our biggest yet, packed with new features and bug fixes! The introduction of the new CertificateRequest resource type is significant as it is a step towards where we want to be for 1.0, defining an API specification for Certificates and allowing anyone to implement their own issuers and CAs as first class citizens. This release includes changes from: Aaron Gershman Aled James Artem Yarmoluk Carlos Panato Chris Abiad Christopher Abiad Crystal-Chun Dan Dobes Vandermeer Hans Kristian Flaatten Hays Clark Ivan Wallis James Munnelly Joshua Van Leeuwen Kevin Woo Lachlan Cooper Louis Taylor Michael Cristina Michael Tsang PirateBread Qiu Yu Sergej Nikolaev Solly Ross Stefan Kolb Steven Tobias Stuart Hu Till Wiese kfoozminus Notable Items \u00b6 New CertificateRequest Resource \u00b6 A new resource has been introduced - CertificateRequest - that is used to request certificates using a raw X.509 certificate signing request. This resource is not typically used by humans but rather by other controllers or services. For example, the Certificate controller will now create a CertificateRequest resource to resolve its own Spec. Controllers to resolve CertificateRequest s are currently disabled by default and enabled via the feature gate CertificateRequestControllers . This feature is currently in Alpha and only the CA issuer has been implemented. This resource is going to enable out of tree, external issuer controllers to resolve requests. Other issuer implementations and details on how to develop an out of tree issuer will follow in later releases. You can read more on the motivations and road map in the enhancement proposal or how this resource is used in the docs . DNS Zones support for ACME challenge solver selector \u00b6 A list of DNS zones can now be added to the ACME challenge solver selector. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com . If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected. Certificate Readiness Prometheus Metrics \u00b6 Cert-manager now exposes Prometheus metrics on Certificate ready statuses as certmanager_certificate_ready_status . This is useful for monitoring Certificate resources to ensure they have a Ready=True status. Prometheus Operator ServiceMonitor \u00b6 Support has been added to include a Prometheus ServiceMonitor for cert-manager in the helm chart. This enables monitoring of cert-manager when in conjunction with the Prometheus Operator . This is disabled by default but can be enabled via the helm configuration. ACMEv2 POST-as-GET \u00b6 We have now switched to use the new POST-as-GET feature that was introduced into the latest version of the ACME spec a few months ago. If you are running your own ACME server, please ensure it supports POST-as-GET as we no longer supported the old behavior. ACME Issuer Solver Pod Template \u00b6 The ACME Solver Pod Spec now exposes a template that can be used to change metadata about that pod. Currently, a template will expose labels, annotations, node selector, tolerations, and affinity. This is useful when running cert-manager in multi-arch clusters, or when you run workloads across different types of nodes and need to restrict where the acmesolver pod runs. Action Required \u00b6 Length limit for Common Names \u00b6 Common names with a character length of over 63 will be rejected during validation. This is due to the upper limit being detailed in RFC 5280. Distroless Cert-Manager Base Images \u00b6 For each container, cert-manager ships with the base image gcr.io/distroless/static which is a minimal image that includes no binaries. Users who want to debug from within the cert-manager pod will need to attach an additional container with their debug utilities to the pod's namespace. CSRs in Order Resources now PEM Encoded \u00b6 CSRs in Order resources have previously been incorrectly DER encoded due to an error in implementation. This has now been corrected to PEM encoding. Current orders that were created with a previous version of cert-manager will fail to validate and so will be recreated. This should resume the order normally. Changelog \u00b6 General \u00b6 Reduce cert-manager's RBAC permissions ( #1658 , @munnerz ) commented-out extraArg for enable-certificate-owner-ref ( #1828 , @aegershman ) Validate that Certificates in a namespace have unique secretName ( #1689 , @cheukwing ) Feature addition: Support for PKCS#8 keys. ( #1308 , @Crystal-Chun ) Add the removal of certificates when no longer required by the owner ingress ( #1705 , @cheukwing ) Fix bug causing ECDSA certificates to be issued using 2048 bit RSA private keys ( #1757 , @munnerz ) Updated the labels in the helm charts to use the newer ones. ( #1769 , @cpanato ) Allow disabling issuing temporary certificates with feature flag --feature-gates=IssueTemporaryCertificate=false ( #1764 , @gordonbondon ) Switch to using Distroless for base images ( #1663 , @munnerz ) Limit length for CommonName to 63 bytes ( #1818 , @cheukwing ) ACME Issuer \u00b6 Properly encode the CSR field on Order resources as PEM data instead of DER ( #1884 , @munnerz ) Fire informational Event if an ACME solver cannot be chosen for a domain on an Order ( #1856 , @munnerz ) Fix bug with auto-generated Order names being longer than 63 characters ( #1765 , @cheukwing ) Fix a panic when a misconfigured Issuer is used for HTTP01 challenge solving ( #1758 , @munnerz ) Fix a bug where the logic to select a solver would always return the last solver and may return the wrong kind of solver for the challenge that it returned. ( #1717 , @dobesv ) Fix indentation on ACME setup examples ( #1785 , @lachlancooper ) Fix a the logic to select the most specific solver from an issuer if multiple matched ( #1715 , @dobesv ) Adds support for nodeSelector and tolerations in podTemplate.spec ( #1803 , @cheukwing ) support azure non-public regions ( #1830 , @stuarthu ) Fix issue causing challenge controller to attempt to list Secrets across all namespaces even when --namespace is specified ( #1849 , @munnerz ) Adds the handling of updates to the spec.acme.email field in Issuers ( #1763 , @cheukwing ) Fix issue with private managed-zone being picked in CloudDNS ( #1704 , @cheukwing ) Expose pod template for the ACME issuer solver pod ( #1749 , @JoshVanL ) Ingress skips updating Certificate resource if already exists and not owned ( #1670 , @cheukwing ) Add support for ACMEv2 POST-as-GET ( #1648 , @munnerz ) Fix incorrect handling of issuewild tag when verifying CAA ( #1777 , @cheukwing ) Add support for selecting ACME challenge solver to use by specifying dnsZones in the selector ( #1806 , @munnerz ) Use proxy environment variables in self-check request ( #1850 , @kinolaev ) Venafi Issuer \u00b6 Venafi: use vCert v4.1.0 ( #1827 , @munnerz ) Bump Venafi vCert dependency to latest version ( #1754 , @munnerz ) Webhook \u00b6 cert-manager-webhook secret exists in cert-manager namespace ( #1791 , @jetstack-bot ) Support CRD conversion webhooks in the CA injector controller. ( #1505 , @DirectXMan12 ) CA Issuer \u00b6 Adds CSR signing to CA issuer ( #1835 , @JoshVanL ) CertificateRequest \u00b6 Adds CertificateRequest resource ( #1789 , @JoshVanL ) Adds CA issuer controller to resolve CertificateRequests where CA is the issuer reference ( #1836 , @JoshVanL ) Adds Sign interface to Issuers ( #1807 , @JoshVanL ) Adds group to issuerRef in CertificateRequest resources to distinguish resource ownership of incoming CertificateRequests so enabling full external issuer support. ( #1860 , @JoshVanL ) Documentation \u00b6 Adds Design and Proposals page to website docs ( #1876 , @JoshVanL ) Adds CertificateRequest proposal ( #1866 , @JoshVanL ) Monitoring \u00b6 Prometheus metrics for deleted Certificates are cleaned up ( #1681 , @cheukwing ) Adds ControllerSyncCallCount Prometheus metric to count sync calls from each controller ( #1692 , @cheukwing ) Add support for Prometheus Operator ServiceMonitor object in Helm Chart ( #1761 , @Starefossen ) Add Prometheus metrics for tracking Certificate readiness ( #1811 , @cheukwing )","title":"Release Notes"},{"location":"release-notes/release-notes-0.9/#notable-items","text":"","title":"Notable Items"},{"location":"release-notes/release-notes-0.9/#new-certificaterequest-resource","text":"A new resource has been introduced - CertificateRequest - that is used to request certificates using a raw X.509 certificate signing request. This resource is not typically used by humans but rather by other controllers or services. For example, the Certificate controller will now create a CertificateRequest resource to resolve its own Spec. Controllers to resolve CertificateRequest s are currently disabled by default and enabled via the feature gate CertificateRequestControllers . This feature is currently in Alpha and only the CA issuer has been implemented. This resource is going to enable out of tree, external issuer controllers to resolve requests. Other issuer implementations and details on how to develop an out of tree issuer will follow in later releases. You can read more on the motivations and road map in the enhancement proposal or how this resource is used in the docs .","title":"New CertificateRequest Resource"},{"location":"release-notes/release-notes-0.9/#dns-zones-support-for-acme-challenge-solver-selector","text":"A list of DNS zones can now be added to the ACME challenge solver selector. The most specific DNS zone match specified here will take precedence over other DNS zone matches, so a solver specifying sys.example.com will be selected over one specifying example.com for the domain www.sys.example.com . If multiple solvers match with the same dnsZones value, the solver with the most matching labels in matchLabels will be selected. If neither has more matches, the solver defined earlier in the list will be selected.","title":"DNS Zones support for ACME challenge solver selector"},{"location":"release-notes/release-notes-0.9/#certificate-readiness-prometheus-metrics","text":"Cert-manager now exposes Prometheus metrics on Certificate ready statuses as certmanager_certificate_ready_status . This is useful for monitoring Certificate resources to ensure they have a Ready=True status.","title":"Certificate Readiness Prometheus Metrics"},{"location":"release-notes/release-notes-0.9/#prometheus-operator-servicemonitor","text":"Support has been added to include a Prometheus ServiceMonitor for cert-manager in the helm chart. This enables monitoring of cert-manager when in conjunction with the Prometheus Operator . This is disabled by default but can be enabled via the helm configuration.","title":"Prometheus Operator ServiceMonitor"},{"location":"release-notes/release-notes-0.9/#acmev2-post-as-get","text":"We have now switched to use the new POST-as-GET feature that was introduced into the latest version of the ACME spec a few months ago. If you are running your own ACME server, please ensure it supports POST-as-GET as we no longer supported the old behavior.","title":"ACMEv2 POST-as-GET"},{"location":"release-notes/release-notes-0.9/#acme-issuer-solver-pod-template","text":"The ACME Solver Pod Spec now exposes a template that can be used to change metadata about that pod. Currently, a template will expose labels, annotations, node selector, tolerations, and affinity. This is useful when running cert-manager in multi-arch clusters, or when you run workloads across different types of nodes and need to restrict where the acmesolver pod runs.","title":"ACME Issuer Solver Pod Template"},{"location":"release-notes/release-notes-0.9/#action-required","text":"","title":"Action Required"},{"location":"release-notes/release-notes-0.9/#length-limit-for-common-names","text":"Common names with a character length of over 63 will be rejected during validation. This is due to the upper limit being detailed in RFC 5280.","title":"Length limit for Common Names"},{"location":"release-notes/release-notes-0.9/#distroless-cert-manager-base-images","text":"For each container, cert-manager ships with the base image gcr.io/distroless/static which is a minimal image that includes no binaries. Users who want to debug from within the cert-manager pod will need to attach an additional container with their debug utilities to the pod's namespace.","title":"Distroless Cert-Manager Base Images"},{"location":"release-notes/release-notes-0.9/#csrs-in-order-resources-now-pem-encoded","text":"CSRs in Order resources have previously been incorrectly DER encoded due to an error in implementation. This has now been corrected to PEM encoding. Current orders that were created with a previous version of cert-manager will fail to validate and so will be recreated. This should resume the order normally.","title":"CSRs in Order Resources now PEM Encoded"},{"location":"release-notes/release-notes-0.9/#changelog","text":"","title":"Changelog"},{"location":"release-notes/release-notes-0.9/#general","text":"Reduce cert-manager's RBAC permissions ( #1658 , @munnerz ) commented-out extraArg for enable-certificate-owner-ref ( #1828 , @aegershman ) Validate that Certificates in a namespace have unique secretName ( #1689 , @cheukwing ) Feature addition: Support for PKCS#8 keys. ( #1308 , @Crystal-Chun ) Add the removal of certificates when no longer required by the owner ingress ( #1705 , @cheukwing ) Fix bug causing ECDSA certificates to be issued using 2048 bit RSA private keys ( #1757 , @munnerz ) Updated the labels in the helm charts to use the newer ones. ( #1769 , @cpanato ) Allow disabling issuing temporary certificates with feature flag --feature-gates=IssueTemporaryCertificate=false ( #1764 , @gordonbondon ) Switch to using Distroless for base images ( #1663 , @munnerz ) Limit length for CommonName to 63 bytes ( #1818 , @cheukwing )","title":"General"},{"location":"release-notes/release-notes-0.9/#acme-issuer","text":"Properly encode the CSR field on Order resources as PEM data instead of DER ( #1884 , @munnerz ) Fire informational Event if an ACME solver cannot be chosen for a domain on an Order ( #1856 , @munnerz ) Fix bug with auto-generated Order names being longer than 63 characters ( #1765 , @cheukwing ) Fix a panic when a misconfigured Issuer is used for HTTP01 challenge solving ( #1758 , @munnerz ) Fix a bug where the logic to select a solver would always return the last solver and may return the wrong kind of solver for the challenge that it returned. ( #1717 , @dobesv ) Fix indentation on ACME setup examples ( #1785 , @lachlancooper ) Fix a the logic to select the most specific solver from an issuer if multiple matched ( #1715 , @dobesv ) Adds support for nodeSelector and tolerations in podTemplate.spec ( #1803 , @cheukwing ) support azure non-public regions ( #1830 , @stuarthu ) Fix issue causing challenge controller to attempt to list Secrets across all namespaces even when --namespace is specified ( #1849 , @munnerz ) Adds the handling of updates to the spec.acme.email field in Issuers ( #1763 , @cheukwing ) Fix issue with private managed-zone being picked in CloudDNS ( #1704 , @cheukwing ) Expose pod template for the ACME issuer solver pod ( #1749 , @JoshVanL ) Ingress skips updating Certificate resource if already exists and not owned ( #1670 , @cheukwing ) Add support for ACMEv2 POST-as-GET ( #1648 , @munnerz ) Fix incorrect handling of issuewild tag when verifying CAA ( #1777 , @cheukwing ) Add support for selecting ACME challenge solver to use by specifying dnsZones in the selector ( #1806 , @munnerz ) Use proxy environment variables in self-check request ( #1850 , @kinolaev )","title":"ACME Issuer"},{"location":"release-notes/release-notes-0.9/#venafi-issuer","text":"Venafi: use vCert v4.1.0 ( #1827 , @munnerz ) Bump Venafi vCert dependency to latest version ( #1754 , @munnerz )","title":"Venafi Issuer"},{"location":"release-notes/release-notes-0.9/#webhook","text":"cert-manager-webhook secret exists in cert-manager namespace ( #1791 , @jetstack-bot ) Support CRD conversion webhooks in the CA injector controller. ( #1505 , @DirectXMan12 )","title":"Webhook"},{"location":"release-notes/release-notes-0.9/#ca-issuer","text":"Adds CSR signing to CA issuer ( #1835 , @JoshVanL )","title":"CA Issuer"},{"location":"release-notes/release-notes-0.9/#certificaterequest","text":"Adds CertificateRequest resource ( #1789 , @JoshVanL ) Adds CA issuer controller to resolve CertificateRequests where CA is the issuer reference ( #1836 , @JoshVanL ) Adds Sign interface to Issuers ( #1807 , @JoshVanL ) Adds group to issuerRef in CertificateRequest resources to distinguish resource ownership of incoming CertificateRequests so enabling full external issuer support. ( #1860 , @JoshVanL )","title":"CertificateRequest"},{"location":"release-notes/release-notes-0.9/#documentation","text":"Adds Design and Proposals page to website docs ( #1876 , @JoshVanL ) Adds CertificateRequest proposal ( #1866 , @JoshVanL )","title":"Documentation"},{"location":"release-notes/release-notes-0.9/#monitoring","text":"Prometheus metrics for deleted Certificates are cleaned up ( #1681 , @cheukwing ) Adds ControllerSyncCallCount Prometheus metric to count sync calls from each controller ( #1692 , @cheukwing ) Add support for Prometheus Operator ServiceMonitor object in Helm Chart ( #1761 , @Starefossen ) Add Prometheus metrics for tracking Certificate readiness ( #1811 , @cheukwing )","title":"Monitoring"},{"location":"release-notes/release-notes-1.0/","text":"With cert-manager v1.0 we're putting a seal of trust on 3 years of development on the cert-manager project. In these 3 years cert-manager has grown in functionality and stability, but mostly in the community. Today we see many people using cert-manager to secure their Kubernetes clusters, as well as cert-manager being integrated into many other parts in the ecosystem. In the past 16 releases many bugs got fixed, and things that needed to be broken were broken. Several iterations on the API improved the user experience. We solved 1500 GitHub Issues with even more PRs by 253 contributors. With releasing v1.0 we're officially making a statement that cert-manager is a mature project now. We will also be making a compatibility promise with our v1 API. A big thank you to everyone who helped to build cert-manager in the past 3 years! Let v1.0 be the first of many big achievements! The v1.0 release is a stability release with a few focus areas: v1 API kubectl cert-manager status command to help with investigating issues Using new and stable Kubernetes APIs Improved logging ACME improvements As usual, please read the upgrade notes before upgrading. v1 API \u00b6 In v0.16 we introduced the v1beta1 API. This brought some structural changes as well as better documentation of the API fields. In v1.0 we build on this with the v1 API. This API is our first \"stable\" API version, while our others were well used we had to already provide some compatibility guarantees with the v1 API we promise compatibility for the API for years to come. These are the changes made (for reference, our conversion will take care of everything for you): Certificate: emailSANs is now named emailAddresses uriSANs is now named uris This change makes these 2 SANs consistent with the other SANs as well as the Go API. Dropping the term SAN from our API. Upgrading \u00b6 If you're using Kubernetes 1.16 or higher, conversion webhooks will allow you seamlessly interact with v1alpha2 , v1alpha3 , v1beta1 and v1 API versions at the same time. This allows you to use the new API version without having to modify or redeploy your older resources. We highly recommend upgrading your manifests to the v1 API as older versions will soon be deprecated. Users of the legacy version of cert-manager will still only have the v1 API, migration steps can be found in the upgrade notes . kubectl cert-manager status command \u00b6 With the new improvements to our kubectl plugin it is easier to investigate issues with certificates not being issued. kubectl cert-manager status now displays a lot more information about what has been going on with your certificate and in which stage of issuance it currently is in. Once the plugin is installed, you can run kubectl cert-manager status certificate <name-of-cert> . That will then look for the Certificate with the name <name-of-cert> and any related resources like CertificateRequest, Secret, Issuer, as well as Order and Challenges if it is a ACME Certificate. The command outputs information about the resources, including Conditions, Events and resource specific fields like Key Usages and Extended Key Usages of the Secret or Authorizations of the Order. For example while debugging a not ready certificate: $ kubectl cert-manager status certificate acme-certificate Name: acme-certificate Namespace: default Created at: 2020-08-21T16:44:13+02:00 Conditions: Ready: False, Reason: DoesNotExist, Message: Issuing certificate as Secret does not exist Issuing: True, Reason: DoesNotExist, Message: Issuing certificate as Secret does not exist DNS Names: - example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 18m cert-manager Issuing certificate as Secret does not exist Normal Generated 18m cert-manager Stored new private key in temporary Secret resource \"acme-certificate-tr8b2\" Normal Requested 18m cert-manager Created new CertificateRequest resource \"acme-certificate-qp5dm\" Issuer: Name: acme-issuer Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server error when finding Secret \"acme-tls\": secrets \"acme-tls\" not found Not Before: <none> Not After: <none> Renewal Time: <none> CertificateRequest: Name: acme-certificate-qp5dm Namespace: default Conditions: Ready: False, Reason: Pending, Message: Waiting on certificate issuance from order default/acme-certificate-qp5dm-1319513028: \"pending\" Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 18m cert-manager Created Order resource default/acme-certificate-qp5dm-1319513028 Order: Name: acme-certificate-qp5dm-1319513028 State: pending, Reason: Authorizations: URL: https://acme-staging-v02.api.letsencrypt.org/acme/authz-v3/97777571, Identifier: example.com, Initial State: pending, Wildcard: false Challenges: - Name: acme-certificate-qp5dm-1319513028-1825664779, Type: DNS-01, Token: J-lOZ39yNDQLZTtP_ZyrYojDqjutMAJOxCL1AkOEZWw, Key: U_W3gGV2KWgIUonlO2me3rvvEOTrfTb-L5s0V1TJMCw, State: pending, Reason: error getting clouddns service account: secret \"clouddns-accoun\" not found, Processing: true, Presented: false The command also can help looking into what is inside an issued certificate. This example looks at an issuer Let's Encrypt certificate in detail: $ kubectl cert-manager status certificate example Name: example [...] Secret: Name: example Issuer Country: US Issuer Organisation: Let's Encrypt Issuer Common Name: Let's Encrypt Authority X3 Key Usage: Digital Signature, Key Encipherment Extended Key Usages: Server Authentication, Client Authentication Public Key Algorithm: RSA Signature Algorithm: SHA256-RSA Subject Key ID: 65081d98a9870764590829b88c53240571997862 Authority Key ID: a84a6a63047dddbae6d139b7a64565eff3a8eca1 Serial Number: 0462ffaa887ea17797e0057ca81d7ba2a6fb Events: <none> Not Before: 2020-06-02T04:29:56+02:00 Not After: 2020-08-31T04:29:56+02:00 Renewal Time: 2020-08-01T04:29:56+02:00 [...] Using new and stable Kubernetes APIs \u00b6 cert-manager has been an early adopter of the Kubernetes CRDs. That and us supporting Kubernetes versions as for back as v1.11 made us use the now deprecated apiextensions.k8s.io/v1beta1 for our CRDs and admissionregistration.k8s.io/v1beta1 for our webhooks. These are now deprecated and to be removed in Kubernetes v1.22 . In v1.0 we now offer full support for apiextensions.k8s.io/v1 and admissionregistration.k8s.io/v1 for Kubernetes v1.16 (where this got added) and above. For users of Kubernetes v1.15 we keep offering support for the v1beta1 Kubernetes APIs in our legacy version. Improved logging \u00b6 For this release we upgraded our logging library to klog/v2 analog to Kubernetes v1.19 . We also reviewed every log we write to assign it an appropriate log level. We followed the (Kubernetes logging guidelines)[ https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md ]. To come up with 5 log levels ranging from Error (level 0) which only prints important errors to Trace (level 5) which can help you to know exactly what is gong on. With this change we reduced the number of logs when you don't need to have a debugging trace while running cert-manager. Tip: My default cert-manager runs on level 2 (Info), you can set this using global.logLevel in the Helm chart. Note : Looking at the logs while troubleshooting cert-manager should be last resort behavior, for more info check out our troubleshooting guide ACME improvements \u00b6 The most used use case of cert-manager is probably to issue certificates from Let's Encrypt using ACME. In v1.0 we took took feedback from the community to add two small but important improvements to our ACME issuer. Disable Account Key Generation \u00b6 If you deploy ACME issuer certs on a large scale you probably want to re-use your ACME account across multiple clusters so your rate limit exceptions get applied everywhere. While this was already possible in cert-manager by copying over the secret referenced in privateKeySecretRef . However this process was quite error prone as cert-manager was trying to be helpful and was happy to create a new account key for you if one was not found. This is why we added disableAccountKeyGeneration to safe guard you against this behavior, if set to true it will not create a key and warn you if no account key was given to it. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : privateKeySecretRef : name : example-issuer-account-key disableAccountKeyGeneration : false Preferred Chain \u00b6 On September 29 th Let's Encrypt will change over to using its own ISRG Root CA. This will replace the cross-signed certificates by Identrust . This change over needs no changes to your cert-manager configuration, any renewed or new certificates issued after this date will use the new CA root. Let's encrypt currently already signs certificates using this CA and offers them as \"alternative certificate chain\" via ACME. In this release cert-manager adds support for accessing these alternative chains in the issuer config. The new preferredChain option will allow you to specify a CA's common name for the certificate to be issued by. If there is a certificate available matching that request it will present you that certificate. Note that this is a Preferred option, if none is found matching the request it will give you the default certificate as before. This makes sure you still get your certificate renewed once the alternative chain gets removed on the ACME issuer side. You can already today get certificates from the ISRG Root by using: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"ISRG Root X1\" If you prefer to keep the IdenTrust chain you can do that by setting the option to DST Root CA X3 : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"DST Root CA X3\" Note that this Root CA is expiring soon, Let's Encrypt will keep this certificate chain active until September 29 2021.","title":"Release Notes"},{"location":"release-notes/release-notes-1.0/#v1-api","text":"In v0.16 we introduced the v1beta1 API. This brought some structural changes as well as better documentation of the API fields. In v1.0 we build on this with the v1 API. This API is our first \"stable\" API version, while our others were well used we had to already provide some compatibility guarantees with the v1 API we promise compatibility for the API for years to come. These are the changes made (for reference, our conversion will take care of everything for you): Certificate: emailSANs is now named emailAddresses uriSANs is now named uris This change makes these 2 SANs consistent with the other SANs as well as the Go API. Dropping the term SAN from our API.","title":"v1 API"},{"location":"release-notes/release-notes-1.0/#upgrading","text":"If you're using Kubernetes 1.16 or higher, conversion webhooks will allow you seamlessly interact with v1alpha2 , v1alpha3 , v1beta1 and v1 API versions at the same time. This allows you to use the new API version without having to modify or redeploy your older resources. We highly recommend upgrading your manifests to the v1 API as older versions will soon be deprecated. Users of the legacy version of cert-manager will still only have the v1 API, migration steps can be found in the upgrade notes .","title":"Upgrading"},{"location":"release-notes/release-notes-1.0/#kubectl-cert-manager-status-command","text":"With the new improvements to our kubectl plugin it is easier to investigate issues with certificates not being issued. kubectl cert-manager status now displays a lot more information about what has been going on with your certificate and in which stage of issuance it currently is in. Once the plugin is installed, you can run kubectl cert-manager status certificate <name-of-cert> . That will then look for the Certificate with the name <name-of-cert> and any related resources like CertificateRequest, Secret, Issuer, as well as Order and Challenges if it is a ACME Certificate. The command outputs information about the resources, including Conditions, Events and resource specific fields like Key Usages and Extended Key Usages of the Secret or Authorizations of the Order. For example while debugging a not ready certificate: $ kubectl cert-manager status certificate acme-certificate Name: acme-certificate Namespace: default Created at: 2020-08-21T16:44:13+02:00 Conditions: Ready: False, Reason: DoesNotExist, Message: Issuing certificate as Secret does not exist Issuing: True, Reason: DoesNotExist, Message: Issuing certificate as Secret does not exist DNS Names: - example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 18m cert-manager Issuing certificate as Secret does not exist Normal Generated 18m cert-manager Stored new private key in temporary Secret resource \"acme-certificate-tr8b2\" Normal Requested 18m cert-manager Created new CertificateRequest resource \"acme-certificate-qp5dm\" Issuer: Name: acme-issuer Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server error when finding Secret \"acme-tls\": secrets \"acme-tls\" not found Not Before: <none> Not After: <none> Renewal Time: <none> CertificateRequest: Name: acme-certificate-qp5dm Namespace: default Conditions: Ready: False, Reason: Pending, Message: Waiting on certificate issuance from order default/acme-certificate-qp5dm-1319513028: \"pending\" Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 18m cert-manager Created Order resource default/acme-certificate-qp5dm-1319513028 Order: Name: acme-certificate-qp5dm-1319513028 State: pending, Reason: Authorizations: URL: https://acme-staging-v02.api.letsencrypt.org/acme/authz-v3/97777571, Identifier: example.com, Initial State: pending, Wildcard: false Challenges: - Name: acme-certificate-qp5dm-1319513028-1825664779, Type: DNS-01, Token: J-lOZ39yNDQLZTtP_ZyrYojDqjutMAJOxCL1AkOEZWw, Key: U_W3gGV2KWgIUonlO2me3rvvEOTrfTb-L5s0V1TJMCw, State: pending, Reason: error getting clouddns service account: secret \"clouddns-accoun\" not found, Processing: true, Presented: false The command also can help looking into what is inside an issued certificate. This example looks at an issuer Let's Encrypt certificate in detail: $ kubectl cert-manager status certificate example Name: example [...] Secret: Name: example Issuer Country: US Issuer Organisation: Let's Encrypt Issuer Common Name: Let's Encrypt Authority X3 Key Usage: Digital Signature, Key Encipherment Extended Key Usages: Server Authentication, Client Authentication Public Key Algorithm: RSA Signature Algorithm: SHA256-RSA Subject Key ID: 65081d98a9870764590829b88c53240571997862 Authority Key ID: a84a6a63047dddbae6d139b7a64565eff3a8eca1 Serial Number: 0462ffaa887ea17797e0057ca81d7ba2a6fb Events: <none> Not Before: 2020-06-02T04:29:56+02:00 Not After: 2020-08-31T04:29:56+02:00 Renewal Time: 2020-08-01T04:29:56+02:00 [...]","title":"kubectl cert-manager status command"},{"location":"release-notes/release-notes-1.0/#using-new-and-stable-kubernetes-apis","text":"cert-manager has been an early adopter of the Kubernetes CRDs. That and us supporting Kubernetes versions as for back as v1.11 made us use the now deprecated apiextensions.k8s.io/v1beta1 for our CRDs and admissionregistration.k8s.io/v1beta1 for our webhooks. These are now deprecated and to be removed in Kubernetes v1.22 . In v1.0 we now offer full support for apiextensions.k8s.io/v1 and admissionregistration.k8s.io/v1 for Kubernetes v1.16 (where this got added) and above. For users of Kubernetes v1.15 we keep offering support for the v1beta1 Kubernetes APIs in our legacy version.","title":"Using new and stable Kubernetes APIs"},{"location":"release-notes/release-notes-1.0/#improved-logging","text":"For this release we upgraded our logging library to klog/v2 analog to Kubernetes v1.19 . We also reviewed every log we write to assign it an appropriate log level. We followed the (Kubernetes logging guidelines)[ https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md ]. To come up with 5 log levels ranging from Error (level 0) which only prints important errors to Trace (level 5) which can help you to know exactly what is gong on. With this change we reduced the number of logs when you don't need to have a debugging trace while running cert-manager. Tip: My default cert-manager runs on level 2 (Info), you can set this using global.logLevel in the Helm chart. Note : Looking at the logs while troubleshooting cert-manager should be last resort behavior, for more info check out our troubleshooting guide","title":"Improved logging"},{"location":"release-notes/release-notes-1.0/#acme-improvements","text":"The most used use case of cert-manager is probably to issue certificates from Let's Encrypt using ACME. In v1.0 we took took feedback from the community to add two small but important improvements to our ACME issuer.","title":"ACME improvements"},{"location":"release-notes/release-notes-1.0/#disable-account-key-generation","text":"If you deploy ACME issuer certs on a large scale you probably want to re-use your ACME account across multiple clusters so your rate limit exceptions get applied everywhere. While this was already possible in cert-manager by copying over the secret referenced in privateKeySecretRef . However this process was quite error prone as cert-manager was trying to be helpful and was happy to create a new account key for you if one was not found. This is why we added disableAccountKeyGeneration to safe guard you against this behavior, if set to true it will not create a key and warn you if no account key was given to it. apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : privateKeySecretRef : name : example-issuer-account-key disableAccountKeyGeneration : false","title":"Disable Account Key Generation"},{"location":"release-notes/release-notes-1.0/#preferred-chain","text":"On September 29 th Let's Encrypt will change over to using its own ISRG Root CA. This will replace the cross-signed certificates by Identrust . This change over needs no changes to your cert-manager configuration, any renewed or new certificates issued after this date will use the new CA root. Let's encrypt currently already signs certificates using this CA and offers them as \"alternative certificate chain\" via ACME. In this release cert-manager adds support for accessing these alternative chains in the issuer config. The new preferredChain option will allow you to specify a CA's common name for the certificate to be issued by. If there is a certificate available matching that request it will present you that certificate. Note that this is a Preferred option, if none is found matching the request it will give you the default certificate as before. This makes sure you still get your certificate renewed once the alternative chain gets removed on the ACME issuer side. You can already today get certificates from the ISRG Root by using: apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"ISRG Root X1\" If you prefer to keep the IdenTrust chain you can do that by setting the option to DST Root CA X3 : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt spec : acme : server : https://acme-v02.api.letsencrypt.org/directory preferredChain : \"DST Root CA X3\" Note that this Root CA is expiring soon, Let's Encrypt will keep this certificate chain active until September 29 2021.","title":"Preferred Chain"},{"location":"release-notes/release-notes-1.1/","text":"The v1.1 release is our first release in the v1 series with a few focus areas: New features and fixes in the ACME Issuer Improved Venafi TPP Authentication We also want to thank several new contributors to the project for their PRs! alrs raphink renan sharmaansh21 supriya-premkumar All help is very appreciated and very welcome! Interested in knowing what will happen in the next releases of cert-manager? Go check out our road map ! As usual, please read the upgrade notes before upgrading. ACME Improvements \u00b6 The ACME issuer is the most used cert-manager issuer. While most use it to talk to Let's Encrypt we are seeing a growing number of new ACME endpoints by certificate authorities, PKI software exposing ACME endpoints and even ACME proxies to allow ACME being used to talk to other APIs. In this release we focused on adding new features into the ACME issuer to make even more possible! IP Addresses \u00b6 In RFC8738 the support for IP Address validation was added to the ACME spec. This allows cert-manager to use HTTP-01 validation to get certificates for the IP(s) of your ingress controller. This can be done using the ipAddresses field of the Certificate resource. Note: Let's Encrypt has announced plans to support this soon! Duration \u00b6 cert-manager now allows you to request certificates with a certain validity period from an ACME issuer. This allows you to get shorter or longer lived certificates from ACME solutions such as Step-CA . You can enable this by setting enableDurationFeature to true in the ACME Issuer configuration. Be careful, if your ACME issuer does not support this feature it is allowed by the ACME spec to hard fail the Order causing your certificate renewal or creation to stop. Note: Let's Encrypt has announced intention to look into the possibilities of implementing this. Error handling \u00b6 We improved the recognition and handling of errors given by the ACME server. We are now able to quickly retry transient errors and surface any fatal errors faster in the Kubernetes events and logs. This allows you to get more insight into any rate limiting or other errors your ACME issuer provides us. Improvements for Venafi TPP Authentication \u00b6 It is now possible to use a long lived access-token for authentication when configuring Venafi TPP Issuer and ClusterIssuer types . This authentication mechanism is supported by Venafi TPP >= 19.2 .","title":"Release Notes"},{"location":"release-notes/release-notes-1.1/#acme-improvements","text":"The ACME issuer is the most used cert-manager issuer. While most use it to talk to Let's Encrypt we are seeing a growing number of new ACME endpoints by certificate authorities, PKI software exposing ACME endpoints and even ACME proxies to allow ACME being used to talk to other APIs. In this release we focused on adding new features into the ACME issuer to make even more possible!","title":"ACME Improvements"},{"location":"release-notes/release-notes-1.1/#ip-addresses","text":"In RFC8738 the support for IP Address validation was added to the ACME spec. This allows cert-manager to use HTTP-01 validation to get certificates for the IP(s) of your ingress controller. This can be done using the ipAddresses field of the Certificate resource. Note: Let's Encrypt has announced plans to support this soon!","title":"IP Addresses"},{"location":"release-notes/release-notes-1.1/#duration","text":"cert-manager now allows you to request certificates with a certain validity period from an ACME issuer. This allows you to get shorter or longer lived certificates from ACME solutions such as Step-CA . You can enable this by setting enableDurationFeature to true in the ACME Issuer configuration. Be careful, if your ACME issuer does not support this feature it is allowed by the ACME spec to hard fail the Order causing your certificate renewal or creation to stop. Note: Let's Encrypt has announced intention to look into the possibilities of implementing this.","title":"Duration"},{"location":"release-notes/release-notes-1.1/#error-handling","text":"We improved the recognition and handling of errors given by the ACME server. We are now able to quickly retry transient errors and surface any fatal errors faster in the Kubernetes events and logs. This allows you to get more insight into any rate limiting or other errors your ACME issuer provides us.","title":"Error handling"},{"location":"release-notes/release-notes-1.1/#improvements-for-venafi-tpp-authentication","text":"It is now possible to use a long lived access-token for authentication when configuring Venafi TPP Issuer and ClusterIssuer types . This authentication mechanism is supported by Venafi TPP >= 19.2 .","title":"Improvements for Venafi TPP Authentication"},{"location":"release-notes/release-notes-1.10/","text":"Release 1.10 adds a variety of quality-of-life fixes and features including improvements to the test suite. The latest version is v1.10.1 . Breaking Changes (You MUST read this before you upgrade!) \u00b6 Container Name Changes \u00b6 This change is only relevant if you install cert-manager using Helm or the static manifest files. v1.10.0 changes the names of containers in pods created by cert-manager. The names are changed to better reflect what they do; for example, the container in the controller pod had its name changed from cert-manager to cert-manager-controller , and the webhook pod had its container name changed from cert-manager to cert-manager-webhook . This change could cause a break if you: Use Helm or the static manifests, and Have scripts, tools or tasks which rely on the names of the cert-manager containers being static If both of these are true, you may need to update your automation before you upgrade. On OpenShift the cert-manager Pods may fail until you modify Security Context Constraints \u00b6 In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . (See cert-manager pull request 5259 .) The securityContext fields of the Pod are set as follows: ... # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ securityContext : seccompProfile : type : RuntimeDefault ... On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook . On OpenShift v4.7 , v4.8 , v4.9 and v4.10 you may need to modify Security Context Constraints to allow cert-manager Pods to be deployed \u00b6 In OpenShift v4.7 , v4.8 , v4.9 and v4.10 , the default SecurityContextConstraint is called \"restricted\", and it forbids Pods that have the RuntimeDefault seccomp profile. If you deploy cert-manager on these versions of OpenShift you may see the following error condition on the cert-manager Deployments: apiVersion : apps/v1 kind : Deployment # ... status : conditions : # ... - lastTransitionTime : \"2022-11-01T09:41:41Z\" lastUpdateTime : \"2022-11-01T09:41:41Z\" message : 'pods \"cert-manager-84bc577876-qzbnf\" is forbidden: unable to validate against any security context constraint: [pod.metadata.annotations.seccomp.security.alpha.kubernetes.io/pod: Forbidden: seccomp may not be set pod.metadata.annotations.container.seccomp.security.alpha.kubernetes.io/cert-manager-controller: Forbidden: seccomp may not be set provider \"anyuid\": Forbidden: not usable by user or serviceaccount provider \"nonroot\": Forbidden: not usable by user or serviceaccount provider \"hostmount-anyuid\": Forbidden: not usable by user or serviceaccount provider \"machine-api-termination-handler\": Forbidden: not usable by user or serviceaccount provider \"hostnetwork\": Forbidden: not usable by user or serviceaccount provider \"hostaccess\": Forbidden: not usable by user or serviceaccount provider \"privileged\": Forbidden: not usable by user or serviceaccount]' reason : FailedCreate status : \"True\" type : ReplicaFailure # ... The work around is to copy the \"restricted\" SecurityContextConstraint resource and then modify it to allow Pods with RuntimeDefault seccomp profile. Then use oc adm policy add-scc-to-user to create a Role and a RoleBinding that allows all the cert-manager ServiceAccounts to use that SecurityContextConstraint. \ud83d\udcd6 Read Enabling the default seccomp profile for all pods to learn more about this process. On OpenShift v4.11 you may need to modify Security Context Constraints to allow cert-manager Pods to be deployed \u00b6 In OpenShift v4.11 , there is a new SecurityContextConstraint called restricted-v2 , which permits Pods that have the RuntimeDefault seccomp profile and this will used for the cert-manager Pods by default, allowing the Pods to be created. But if you have upgraded OpenShift from a previous version, the old restricted SecurityContextConstraint may still be used and you will have to make changes to the RoleBindings in order to make it the default for all Pods. \ud83d\udcd6 Read Pod security admission in the OpenShift v4.11 release notes to learn more about the changes to the default security context constraints in v4.11 . \ud83d\udcd6 Read Default security context constraints in the OpenShift v4.11 documentation to learn about the characteristics of the default Security Context Constraints in OpenShift. When using the OLM packages for OperatorHub on OpenShift >= v4.7 , you may need to modify Security Context Constraints to allow the cert-manager ACME HTTP01 Pod to be deployed \u00b6 In the cert-manager OLM packages for RedHat OpenShift OperatorHub, the seccompProfile field in the Deployment resource has been removed, and this should allow you to install it on OpenShift v4.7 , v4.8 , v4.9 , v4.10 , and v4.11 without any extra configuration. But if you are using the ACME Issuer with the HTTP01 solver, cert-manager will deploy a short lived Pod that uses the RuntimDefault seccomp profile which may be denied because of the existing Security Context Constraints. \ud83d\udcd6 Read Enabling the default seccomp profile for all pods to learn how to configure your system to allow Pods that use the RuntimeDefault seccomp profile. v1.10.1 : Changes since v1.10.0 \u00b6 Bug or Regression \u00b6 The Venafi Issuer now supports TLS 1.2 renegotiation, so that it can connect to TPP servers where the vedauth API endpoints are configured to accept client certificates. (Note: This does not mean that the Venafi Issuer supports client certificate authentication). ( #5576 , @wallrj ) Upgrade to latest go patch release ( #5560 , @SgtCoDFish ) v1.10.0 : Changes since v1.9.1 \u00b6 Feature \u00b6 Add issuer_name , issuer_kind and issuer_group labels to certificate_expiration_timestamp_seconds , certmanager_certificate_renewal_timestamp_seconds and certmanager_certificate_ready_status metrics ( #5461 , @dkulchinsky ) Add make targets for running scans with trivy against locally built containers ( #5358 , @SgtCoDFish ) CertificateRequests: requests that use the SelfSigned Issuer will be re-reconciled when the target private key Secret has been informed cert-manager.io/private-key-secret-name . This resolves an issue whereby a request would never be signed when the target Secret was not created or was misconfigured before the request. ( #5336 , @JoshVanL ) CertificateSigningRequests: requests that use the SelfSigned Issuer will be re-reconciled when the target private key Secret has been informed experimental.cert-manager.io/private-key-secret-name . This resolves an issue whereby a request would never be signed when the target Secret was not created or was misconfigured before the request. CertificateSigningRequests will also now no-longer be marked as failed when the target private key Secret is malformed- now only firing an event. When the Secret data is resolved, the request will attempt issuance. ( #5379 , @JoshVanL ) Upgraded Gateway API to v0.5.0 ( #5376 , @inteon ) Add caBundleSecretRef to the Vault Issuer to allow referencing the Vault CA Bundle with a Secret. Cannot be used in conjunction with the in-line caBundle field. ( #5387 , @Tolsto ) The feature to create certificate requests with the name being a function of certificate name and revision has been introduced under the feature flag \"StableCertificateRequestName\" and it is disabled by default. This helps to prevent the error \"multiple CertificateRequests were found for the 'next' revision...\". ( #5487 , @sathyanarays ) Helm: Added a new parameter commonLabels which gives you the capability to add the same label on all the resource deployed by the chart. ( #5208 , @thib-mary ) Bug or Regression \u00b6 CertificateSigningRequest: no longer mark a request as failed when using the SelfSigned issuer, and the Secret referenced in experimental.cert-manager.io/private-key-secret-name doesn't exist. ( #5323 , @JoshVanL ) DNS Route53: Remove incorrect validation which rejects solvers that don't define either a accessKeyID or secretAccessKeyID . ( #5339 , @JoshVanL ) Enhanced securityContext for PSS/restricted compliance. ( #5259 , @joebowbeer ) Fix issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests ( #5366 , @munnerz ) cmctl and kubectl cert-manager now report their actual versions instead of \"canary\", fixing issue #5020 ( #5022 , @maelvls ) Other \u00b6 Avoid hard-coding release namespace in helm chart ( #5163 , @james-callahan ) Bump cert-manager's version of Go to 1.19 ( #5466 , @lucacome ) Remove .bazel and .bzl files from cert-manager now that bazel has been fully replaced ( #5340 , @SgtCoDFish ) Updates Kubernetes libraries to v0.25.2 . ( #5456 , @lucacome ) Add annotations for ServiceMonitor in helm chart ( #5401 , @sathieu ) Helm: Add NetworkPolicy support ( #5417 , @mjudeikis ) To help troubleshooting, make the container names unique. BREAKING: this change will break scripts/ CI that depend on cert-manager being the container name. ( #5410 , @rgl )","title":"Release 1.10"},{"location":"release-notes/release-notes-1.10/#breaking-changes-you-must-read-this-before-you-upgrade","text":"","title":"Breaking Changes (You MUST read this before you upgrade!)"},{"location":"release-notes/release-notes-1.10/#container-name-changes","text":"This change is only relevant if you install cert-manager using Helm or the static manifest files. v1.10.0 changes the names of containers in pods created by cert-manager. The names are changed to better reflect what they do; for example, the container in the controller pod had its name changed from cert-manager to cert-manager-controller , and the webhook pod had its container name changed from cert-manager to cert-manager-webhook . This change could cause a break if you: Use Helm or the static manifests, and Have scripts, tools or tasks which rely on the names of the cert-manager containers being static If both of these are true, you may need to update your automation before you upgrade.","title":"Container Name Changes"},{"location":"release-notes/release-notes-1.10/#on-openshift-the-cert-manager-pods-may-fail-until-you-modify-security-context-constraints","text":"In cert-manager 1.10 the secure computing (seccomp) profile for all the Pods is set to RuntimeDefault . (See cert-manager pull request 5259 .) The securityContext fields of the Pod are set as follows: ... # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/ securityContext : seccompProfile : type : RuntimeDefault ... On some versions and configurations of OpenShift this can cause the Pod to be rejected by the Security Context Constraints admission webhook .","title":"On OpenShift the cert-manager Pods may fail until you modify Security Context Constraints"},{"location":"release-notes/release-notes-1.10/#on-openshift-v47-v48-v49-and-v410-you-may-need-to-modify-security-context-constraints-to-allow-cert-manager-pods-to-be-deployed","text":"In OpenShift v4.7 , v4.8 , v4.9 and v4.10 , the default SecurityContextConstraint is called \"restricted\", and it forbids Pods that have the RuntimeDefault seccomp profile. If you deploy cert-manager on these versions of OpenShift you may see the following error condition on the cert-manager Deployments: apiVersion : apps/v1 kind : Deployment # ... status : conditions : # ... - lastTransitionTime : \"2022-11-01T09:41:41Z\" lastUpdateTime : \"2022-11-01T09:41:41Z\" message : 'pods \"cert-manager-84bc577876-qzbnf\" is forbidden: unable to validate against any security context constraint: [pod.metadata.annotations.seccomp.security.alpha.kubernetes.io/pod: Forbidden: seccomp may not be set pod.metadata.annotations.container.seccomp.security.alpha.kubernetes.io/cert-manager-controller: Forbidden: seccomp may not be set provider \"anyuid\": Forbidden: not usable by user or serviceaccount provider \"nonroot\": Forbidden: not usable by user or serviceaccount provider \"hostmount-anyuid\": Forbidden: not usable by user or serviceaccount provider \"machine-api-termination-handler\": Forbidden: not usable by user or serviceaccount provider \"hostnetwork\": Forbidden: not usable by user or serviceaccount provider \"hostaccess\": Forbidden: not usable by user or serviceaccount provider \"privileged\": Forbidden: not usable by user or serviceaccount]' reason : FailedCreate status : \"True\" type : ReplicaFailure # ... The work around is to copy the \"restricted\" SecurityContextConstraint resource and then modify it to allow Pods with RuntimeDefault seccomp profile. Then use oc adm policy add-scc-to-user to create a Role and a RoleBinding that allows all the cert-manager ServiceAccounts to use that SecurityContextConstraint. \ud83d\udcd6 Read Enabling the default seccomp profile for all pods to learn more about this process.","title":"On OpenShift v4.7, v4.8, v4.9 and v4.10 you may need to modify Security Context Constraints to allow cert-manager Pods to be deployed"},{"location":"release-notes/release-notes-1.10/#on-openshift-v411-you-may-need-to-modify-security-context-constraints-to-allow-cert-manager-pods-to-be-deployed","text":"In OpenShift v4.11 , there is a new SecurityContextConstraint called restricted-v2 , which permits Pods that have the RuntimeDefault seccomp profile and this will used for the cert-manager Pods by default, allowing the Pods to be created. But if you have upgraded OpenShift from a previous version, the old restricted SecurityContextConstraint may still be used and you will have to make changes to the RoleBindings in order to make it the default for all Pods. \ud83d\udcd6 Read Pod security admission in the OpenShift v4.11 release notes to learn more about the changes to the default security context constraints in v4.11 . \ud83d\udcd6 Read Default security context constraints in the OpenShift v4.11 documentation to learn about the characteristics of the default Security Context Constraints in OpenShift.","title":"On OpenShift v4.11 you may need to modify Security Context Constraints to allow cert-manager Pods to be deployed"},{"location":"release-notes/release-notes-1.10/#when-using-the-olm-packages-for-operatorhub-on-openshift-v47-you-may-need-to-modify-security-context-constraints-to-allow-the-cert-manager-acme-http01-pod-to-be-deployed","text":"In the cert-manager OLM packages for RedHat OpenShift OperatorHub, the seccompProfile field in the Deployment resource has been removed, and this should allow you to install it on OpenShift v4.7 , v4.8 , v4.9 , v4.10 , and v4.11 without any extra configuration. But if you are using the ACME Issuer with the HTTP01 solver, cert-manager will deploy a short lived Pod that uses the RuntimDefault seccomp profile which may be denied because of the existing Security Context Constraints. \ud83d\udcd6 Read Enabling the default seccomp profile for all pods to learn how to configure your system to allow Pods that use the RuntimeDefault seccomp profile.","title":"When using the OLM packages for OperatorHub on OpenShift &gt;= v4.7, you may need to modify Security Context Constraints to allow the cert-manager ACME HTTP01 Pod to be deployed"},{"location":"release-notes/release-notes-1.10/#v1101-changes-since-v1100","text":"","title":"v1.10.1: Changes since v1.10.0"},{"location":"release-notes/release-notes-1.10/#bug-or-regression","text":"The Venafi Issuer now supports TLS 1.2 renegotiation, so that it can connect to TPP servers where the vedauth API endpoints are configured to accept client certificates. (Note: This does not mean that the Venafi Issuer supports client certificate authentication). ( #5576 , @wallrj ) Upgrade to latest go patch release ( #5560 , @SgtCoDFish )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.10/#v1100-changes-since-v191","text":"","title":"v1.10.0: Changes since v1.9.1"},{"location":"release-notes/release-notes-1.10/#feature","text":"Add issuer_name , issuer_kind and issuer_group labels to certificate_expiration_timestamp_seconds , certmanager_certificate_renewal_timestamp_seconds and certmanager_certificate_ready_status metrics ( #5461 , @dkulchinsky ) Add make targets for running scans with trivy against locally built containers ( #5358 , @SgtCoDFish ) CertificateRequests: requests that use the SelfSigned Issuer will be re-reconciled when the target private key Secret has been informed cert-manager.io/private-key-secret-name . This resolves an issue whereby a request would never be signed when the target Secret was not created or was misconfigured before the request. ( #5336 , @JoshVanL ) CertificateSigningRequests: requests that use the SelfSigned Issuer will be re-reconciled when the target private key Secret has been informed experimental.cert-manager.io/private-key-secret-name . This resolves an issue whereby a request would never be signed when the target Secret was not created or was misconfigured before the request. CertificateSigningRequests will also now no-longer be marked as failed when the target private key Secret is malformed- now only firing an event. When the Secret data is resolved, the request will attempt issuance. ( #5379 , @JoshVanL ) Upgraded Gateway API to v0.5.0 ( #5376 , @inteon ) Add caBundleSecretRef to the Vault Issuer to allow referencing the Vault CA Bundle with a Secret. Cannot be used in conjunction with the in-line caBundle field. ( #5387 , @Tolsto ) The feature to create certificate requests with the name being a function of certificate name and revision has been introduced under the feature flag \"StableCertificateRequestName\" and it is disabled by default. This helps to prevent the error \"multiple CertificateRequests were found for the 'next' revision...\". ( #5487 , @sathyanarays ) Helm: Added a new parameter commonLabels which gives you the capability to add the same label on all the resource deployed by the chart. ( #5208 , @thib-mary )","title":"Feature"},{"location":"release-notes/release-notes-1.10/#bug-or-regression_1","text":"CertificateSigningRequest: no longer mark a request as failed when using the SelfSigned issuer, and the Secret referenced in experimental.cert-manager.io/private-key-secret-name doesn't exist. ( #5323 , @JoshVanL ) DNS Route53: Remove incorrect validation which rejects solvers that don't define either a accessKeyID or secretAccessKeyID . ( #5339 , @JoshVanL ) Enhanced securityContext for PSS/restricted compliance. ( #5259 , @joebowbeer ) Fix issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests ( #5366 , @munnerz ) cmctl and kubectl cert-manager now report their actual versions instead of \"canary\", fixing issue #5020 ( #5022 , @maelvls )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.10/#other","text":"Avoid hard-coding release namespace in helm chart ( #5163 , @james-callahan ) Bump cert-manager's version of Go to 1.19 ( #5466 , @lucacome ) Remove .bazel and .bzl files from cert-manager now that bazel has been fully replaced ( #5340 , @SgtCoDFish ) Updates Kubernetes libraries to v0.25.2 . ( #5456 , @lucacome ) Add annotations for ServiceMonitor in helm chart ( #5401 , @sathieu ) Helm: Add NetworkPolicy support ( #5417 , @mjudeikis ) To help troubleshooting, make the container names unique. BREAKING: this change will break scripts/ CI that depend on cert-manager being the container name. ( #5410 , @rgl )","title":"Other"},{"location":"release-notes/release-notes-1.2/","text":"\u26a0\ufe0f cert-manager v1.2 release drops support for Kubernetes versions below v1.16 . This allows new features to be introduced whilst keeping the project maintainable. \u26a0\ufe0f This release adds new features for several issuers and fixes several bugs. Please read the upgrade notes before upgrading. Aside from that, there have been numerous bug fixes and features summarized below. Deprecated Features and Breaking Changes \u00b6 The --renew-before-expiration-duration flag of the cert-manager controller-manager has been deprecated. Please set the Certificate.Spec.RenewBefore field instead. This flag will be removed in the next release. As Kubernetes v1.16 is now the earliest supported version, The legacy manifests have now been removed. You can read more here . The User-Agent request header has been changed from jetstack-cert-manager/<version> to cert-manager/<version> . This may affect functionality if you rely on an a User-Agent allowlist in a corporate environment. Copyright and Ownership \u00b6 As this is the first release prepared after the acceptance of cert-manager into the CNCF sandbox , the copyright strings have been changed to remove references to Jetstack. The User-Agent request header has changed from jetstack-cert-manager/<version> to cert-manager/<version> . New Features \u00b6 Additional options for cert-manager controllers \u00b6 The cert-manager controller can now be configured to expose profiling information using the new --enable-profiling flag. cainjector leader election leases are now customizable using the new flags --leader-election-lease-duration , --leader-election-renew-deadline and --leader-election-retry-period . Usability improvements \u00b6 cert-manager can now create Java KeyStores that are compatible with Java 8 or greater. A file named keystore.jks will be added to the secret specified in the Certificate.spec.secretName encrypted with the password specified in the Certificate.spec.jks.passwordSecretRef secret. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : jks-example spec : secretName : jks-keystore jks : create : true passwordSecretRef : name : supersecret key : password ingress-shim now supports the new cert-manager.io/usages annotation for specifying custom key usages. If this isn't set, it defaults to digital signature,key encipherment , but a comma separated list of any valid usages can be specified. ingress-shim now also checks for cert-manager.io/duration and cert-manager.io/renew-before annotations and uses those values to set the Certificate.Spec.Duration and Certificate.Spec.RenewBefore fields. Issuer Improvements \u00b6 The Vault issuer now stores the root CA in ca.crt rather than the issuing CA, moving the chain into tls.crt . The Venafi issuer now sets the ca.crt field of the secret. A list of OCSP server URLs can now be set on certificates issued by the CA issuer using the Issuer.spec.ca.ocspServers field. CLI User Experience \u00b6 The cert-manager kubectl plugin can now show you information about certificates in your cluster: kubectl cert-manager inspect secret my-crt --namespace my-namespace cert-manager CRDs have been given categories so now they appear in kubectl get cert-manager and kubectl get cert-manager-acme . ACME \u00b6 The ACME spec allows for a NotAfter date, which is supported by Step CA but not Let's Encrypt. This is gated behind a boolean on Issuer.spec.acme.enableDurationFeature . When enabled, cert-manager will pass through the requested Duration to the ACME server. Bug Fixes \u00b6 The AWS Route53 DNS01 challenge now uses exponential backoff on failure. Ingress validation rules have been relaxed to allow for Certificates to be created/updated for valid Ingress TLS entries even if the same Ingress contains some invalid TLS entries. OpenAPI validation has relaxed in the helm chart to work around a type conversion bug that prevented users from upgrading cert-manager with helm upgrade","title":"Release Notes"},{"location":"release-notes/release-notes-1.2/#deprecated-features-and-breaking-changes","text":"The --renew-before-expiration-duration flag of the cert-manager controller-manager has been deprecated. Please set the Certificate.Spec.RenewBefore field instead. This flag will be removed in the next release. As Kubernetes v1.16 is now the earliest supported version, The legacy manifests have now been removed. You can read more here . The User-Agent request header has been changed from jetstack-cert-manager/<version> to cert-manager/<version> . This may affect functionality if you rely on an a User-Agent allowlist in a corporate environment.","title":"Deprecated Features and Breaking Changes"},{"location":"release-notes/release-notes-1.2/#copyright-and-ownership","text":"As this is the first release prepared after the acceptance of cert-manager into the CNCF sandbox , the copyright strings have been changed to remove references to Jetstack. The User-Agent request header has changed from jetstack-cert-manager/<version> to cert-manager/<version> .","title":"Copyright and Ownership"},{"location":"release-notes/release-notes-1.2/#new-features","text":"","title":"New Features"},{"location":"release-notes/release-notes-1.2/#additional-options-for-cert-manager-controllers","text":"The cert-manager controller can now be configured to expose profiling information using the new --enable-profiling flag. cainjector leader election leases are now customizable using the new flags --leader-election-lease-duration , --leader-election-renew-deadline and --leader-election-retry-period .","title":"Additional options for cert-manager controllers"},{"location":"release-notes/release-notes-1.2/#usability-improvements","text":"cert-manager can now create Java KeyStores that are compatible with Java 8 or greater. A file named keystore.jks will be added to the secret specified in the Certificate.spec.secretName encrypted with the password specified in the Certificate.spec.jks.passwordSecretRef secret. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : jks-example spec : secretName : jks-keystore jks : create : true passwordSecretRef : name : supersecret key : password ingress-shim now supports the new cert-manager.io/usages annotation for specifying custom key usages. If this isn't set, it defaults to digital signature,key encipherment , but a comma separated list of any valid usages can be specified. ingress-shim now also checks for cert-manager.io/duration and cert-manager.io/renew-before annotations and uses those values to set the Certificate.Spec.Duration and Certificate.Spec.RenewBefore fields.","title":"Usability improvements"},{"location":"release-notes/release-notes-1.2/#issuer-improvements","text":"The Vault issuer now stores the root CA in ca.crt rather than the issuing CA, moving the chain into tls.crt . The Venafi issuer now sets the ca.crt field of the secret. A list of OCSP server URLs can now be set on certificates issued by the CA issuer using the Issuer.spec.ca.ocspServers field.","title":"Issuer Improvements"},{"location":"release-notes/release-notes-1.2/#cli-user-experience","text":"The cert-manager kubectl plugin can now show you information about certificates in your cluster: kubectl cert-manager inspect secret my-crt --namespace my-namespace cert-manager CRDs have been given categories so now they appear in kubectl get cert-manager and kubectl get cert-manager-acme .","title":"CLI User Experience"},{"location":"release-notes/release-notes-1.2/#acme","text":"The ACME spec allows for a NotAfter date, which is supported by Step CA but not Let's Encrypt. This is gated behind a boolean on Issuer.spec.acme.enableDurationFeature . When enabled, cert-manager will pass through the requested Duration to the ACME server.","title":"ACME"},{"location":"release-notes/release-notes-1.2/#bug-fixes","text":"The AWS Route53 DNS01 challenge now uses exponential backoff on failure. Ingress validation rules have been relaxed to allow for Certificates to be created/updated for valid Ingress TLS entries even if the same Ingress contains some invalid TLS entries. OpenAPI validation has relaxed in the helm chart to work around a type conversion bug that prevented users from upgrading cert-manager with helm upgrade","title":"Bug Fixes"},{"location":"release-notes/release-notes-1.3/","text":"Patch Release v1.3.1 \u00b6 Bug and Security Fixes \u00b6 A Helm upgrade bug was fixed , you should now able to upgrade from cert-manager 1.2 to 1.3 when --set installCRDs=true is used. This issue was due to a Helm bug with the minimum field on the CRDs. Final Release v1.3.0 \u00b6 The 1.3 release prepares for the implementation of certificate issuance policies and adoption of the upstream Kubernetes CSR API. It also improves interoperability with HashiCorp Vault Enterprise . A slew of bugs have also been squashed. Special thanks to the external contributors who contributed to this release: @teejaded @7opf @yann-soubeyrand @Kirill-Garbar @joshuastern @lalitadithya @johejo @alrs @jsoref @RinkiyaKeDad @jonathansp @OmairK @justinkillen Please read the upgrade notes before upgrading. As always, the full change log is available on the GitHub release . Deprecated Features and Breaking Changes \u00b6 Venafi Cloud Issuer \u00b6 This release updates the Venafi Cloud Issuer to use OutagePREDICT instead of DevOpsACCELERATE . The only impact to Venafi Cloud users is the change in zone syntax. The zone is now <Application Name>\\<Issuing Template Alias> (e.g. My Application\\My CIT ). cert-manager controller \u00b6 The --renew-before-expiration-duration flag has been removed from the cert-manager controller, having been deprecated in the previous release. cert-manager CRDs \u00b6 CertificateRequests are now immutable - the spec and metadata.annotations fields cannot be changed after creation. They were always designed to be immutable but this behavior is now enforced by the cert-manager webhook. New Features \u00b6 Policy Support Preparation \u00b6 The design documentation for Certificate Identity is now available. CertificateRequests now have identity fields mirroring the upstream Kubernetes CSR object. CertificateRequests are now immutable. CertificateRequests now have an Approval condition type, with Approved and Denied reasons. The cert-manager controller currently always approves any CertificateRequest . Added kubectl cert-manager [approve|deny] commands to the kubectl plugin. cert-manager CRDs \u00b6 CertificateRequests now support the revisionHistoryLimit field to limit the amount of retained history. The default is unlimited ( nil ). Vault Enterprise \u00b6 cert-manager now sends the X-VAULT-NAMESPACE header for the requestTokenWithAppRoleRef API call. Bug Fixes \u00b6 cert-manager Controller \u00b6 Fixed an issue which could cause multiple CertificateRequests to be created in a short time for a single Certificate resource. Certificate Readiness controller only updates a certificate's status if something has changed. SelfSigned Issuer \u00b6 The issuer now warns if you request a certificate with an empty subject DN - creating a certificate that is in violation of RFC 5280. Some applications will reject such certificates as invalid, such as Java's keytool . Helm Chart \u00b6 The targetPort used by the Prometheus service monitor is now correctly set from helm values. The correct permissions are added to the aggregate edit role. Other Changes \u00b6 Repository Hygiene \u00b6 SECURITY.md now contains information on how to report security issues. The language of CONTRIBUTING.md has been updated to match existing copyright notices. Tooling \u00b6 cert-manager now can be built with go 1.16 on Apple Silicon. Docker images targets have been added to the Makefile. Bazel v3.5.0 is required to build locally and to run tests.","title":"Release Notes"},{"location":"release-notes/release-notes-1.3/#patch-release-v131","text":"","title":"Patch Release v1.3.1"},{"location":"release-notes/release-notes-1.3/#bug-and-security-fixes","text":"A Helm upgrade bug was fixed , you should now able to upgrade from cert-manager 1.2 to 1.3 when --set installCRDs=true is used. This issue was due to a Helm bug with the minimum field on the CRDs.","title":"Bug and Security Fixes"},{"location":"release-notes/release-notes-1.3/#final-release-v130","text":"The 1.3 release prepares for the implementation of certificate issuance policies and adoption of the upstream Kubernetes CSR API. It also improves interoperability with HashiCorp Vault Enterprise . A slew of bugs have also been squashed. Special thanks to the external contributors who contributed to this release: @teejaded @7opf @yann-soubeyrand @Kirill-Garbar @joshuastern @lalitadithya @johejo @alrs @jsoref @RinkiyaKeDad @jonathansp @OmairK @justinkillen Please read the upgrade notes before upgrading. As always, the full change log is available on the GitHub release .","title":"Final Release v1.3.0"},{"location":"release-notes/release-notes-1.3/#deprecated-features-and-breaking-changes","text":"","title":"Deprecated Features and Breaking Changes"},{"location":"release-notes/release-notes-1.3/#venafi-cloud-issuer","text":"This release updates the Venafi Cloud Issuer to use OutagePREDICT instead of DevOpsACCELERATE . The only impact to Venafi Cloud users is the change in zone syntax. The zone is now <Application Name>\\<Issuing Template Alias> (e.g. My Application\\My CIT ).","title":"Venafi Cloud Issuer"},{"location":"release-notes/release-notes-1.3/#cert-manager-controller","text":"The --renew-before-expiration-duration flag has been removed from the cert-manager controller, having been deprecated in the previous release.","title":"cert-manager controller"},{"location":"release-notes/release-notes-1.3/#cert-manager-crds","text":"CertificateRequests are now immutable - the spec and metadata.annotations fields cannot be changed after creation. They were always designed to be immutable but this behavior is now enforced by the cert-manager webhook.","title":"cert-manager CRDs"},{"location":"release-notes/release-notes-1.3/#new-features","text":"","title":"New Features"},{"location":"release-notes/release-notes-1.3/#policy-support-preparation","text":"The design documentation for Certificate Identity is now available. CertificateRequests now have identity fields mirroring the upstream Kubernetes CSR object. CertificateRequests are now immutable. CertificateRequests now have an Approval condition type, with Approved and Denied reasons. The cert-manager controller currently always approves any CertificateRequest . Added kubectl cert-manager [approve|deny] commands to the kubectl plugin.","title":"Policy Support Preparation"},{"location":"release-notes/release-notes-1.3/#cert-manager-crds_1","text":"CertificateRequests now support the revisionHistoryLimit field to limit the amount of retained history. The default is unlimited ( nil ).","title":"cert-manager CRDs"},{"location":"release-notes/release-notes-1.3/#vault-enterprise","text":"cert-manager now sends the X-VAULT-NAMESPACE header for the requestTokenWithAppRoleRef API call.","title":"Vault Enterprise"},{"location":"release-notes/release-notes-1.3/#bug-fixes","text":"","title":"Bug Fixes"},{"location":"release-notes/release-notes-1.3/#cert-manager-controller_1","text":"Fixed an issue which could cause multiple CertificateRequests to be created in a short time for a single Certificate resource. Certificate Readiness controller only updates a certificate's status if something has changed.","title":"cert-manager Controller"},{"location":"release-notes/release-notes-1.3/#selfsigned-issuer","text":"The issuer now warns if you request a certificate with an empty subject DN - creating a certificate that is in violation of RFC 5280. Some applications will reject such certificates as invalid, such as Java's keytool .","title":"SelfSigned Issuer"},{"location":"release-notes/release-notes-1.3/#helm-chart","text":"The targetPort used by the Prometheus service monitor is now correctly set from helm values. The correct permissions are added to the aggregate edit role.","title":"Helm Chart"},{"location":"release-notes/release-notes-1.3/#other-changes","text":"","title":"Other Changes"},{"location":"release-notes/release-notes-1.3/#repository-hygiene","text":"SECURITY.md now contains information on how to report security issues. The language of CONTRIBUTING.md has been updated to match existing copyright notices.","title":"Repository Hygiene"},{"location":"release-notes/release-notes-1.3/#tooling","text":"cert-manager now can be built with go 1.16 on Apple Silicon. Docker images targets have been added to the Makefile. Bazel v3.5.0 is required to build locally and to run tests.","title":"Tooling"},{"location":"release-notes/release-notes-1.4/","text":"Final Release v1.4.0 \u00b6 Special thanks to the external contributors who contributed to this release: @andreas-p @erikgb @eddiehoffman @inteon @anton-johansson @edglynes @jandersen-plaid @foosinn @jsoref @clatour @tamalsaha Deprecated Features and Breaking Changes \u00b6 Removal of the cert-manager operator package on Red Hat Marketplace \u00b6 Since cert-manager v0.15 there has been a package for cert-manager on Red Hat Marketplace , but this has now been removed because it was not maintained and was found to be unreliable: #4055 #3732 #436 It is replaced by a new package which is generated via the Community Operators Repository , and which is therefore available on OperatorHub.io , OpenShift Container Platform and OKD . Please uninstall the existing cert-manager package and re-install by following the OLM Installation Documentation . Upgrading cert-manager CRDs and stored versions of cert-manager custom resources \u00b6 We have deprecated the following cert-manager APIs: cert-manager.io/v1alpha2 cert-manager.io/v1alpha3 cert-manager.io/v1beta1 acme.cert-manager.io/v1alpha2 acme.cert-manager.io/v1alpha3 acme.cert-manager.io/v1beta1 These APIs will be removed in cert-manager 1.6. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **by the time you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](../installation/upgrading/remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page. This change was made in the cert-manager PR #4021 . Helm chart: securityContext defaults to non-root \u00b6 The Helm chart now follows the current Pod hardening best practices as defined by the Kyverno pod-security restricted policy. To pass the validation, the controller, webhook, and cainjector Pods are now running as non-root: apiVersion : v1 kind : Pod spec : securityContext : runAsNonRoot : true \u26d4\ufe0f If you are using custom containers that run as root with the Helm chart, you will need to set this back to `false`. Implemented in the cert-manager PR #4036 . CA, Vault and Venafi issuer handling of ca.crt and tls.crt \u00b6 The CA, Vault, and Venafi issuer now produce a tls.crt that is de-duplicated, in the correct order (leaf at the top, issuing certificate at the bottom) and verified (i.e. each signature can be verified). The CA issuer now produces a ca.crt that contains the \"most\" root CA that cert-manager is aware of. ca.crt may thus not be the actual self-signed root CA, since cert-manager may not be aware of it. Fixed in the cert-manager PRs #3982 , #3983 , and #3985 . \u26d4\ufe0f You may need to adjust systems that consume the `ca.crt` from Secrets managed by cert-manager with the CA issuer. Vault renewal bug \u00b6 The renewal behavior has changed when a Certificate has a duration value of more than 90 days and renewBefore has not been set. Previously, the Certificate was renewed 30 days before expiry; now, the renewal happens \u2154 through the duration. This change was necessary to fix a bug where users of the Vault issuer would see a clash between the default renewal duration of 30 days and the duration of certificates issued by the Vault PKI. \u26d4\ufe0f If you were relying on the default renewal happening 30 days before expiry, we would advise setting `renewBefore` to 30 days (`720h`) to keep the old behavior. Fixed in the cert-manager PR #4092 . New Features \u00b6 Experimental Support for Kubernetes CertificateSigningRequests \u00b6 It is now possible to use the built-in Kubernetes CertificateSigningRequest resources with cert-manager. The CA Issuer is currently the only supported issuer. The feature is experimental and can be enabled by adding a flag to the cert-manager controller. For example, with Helm: helm install cert-manager jetstack/cert-manager \\ --set extraArgs = \"{--feature-gates=ExperimentalCertificateSigningRequestControllers=true}\" Note that you will still need to manually approve the CSR object before cert-manager can sign the CSR. The documentation is available on the the Kubernetes CSR usage page . Implemented in cert-manager PR #4064 . Helm chart: webhook externally accessible for bare-metal \u00b6 In some Kubernetes setups, the apiserver is not able to talk to kube-dns (i.e., when Kubernetes is running on bare-metal with no special resolv.conf ). To work around that, the cert-manager webhook can now be configured to be accessible from outside of the cluster. For example, in values.yaml : # values.yaml webhook : serviceType : LoadBalancer loadBalancerIP : 198.51.100.20 url : host : 198.51.100.20 Implemented in cert-manager PRs #3876 , #3932 . Helm chart: Service labels \u00b6 The cert-manager controller Service now supports custom labels using the top-level field in values.yaml : # values.yaml serviceLabels : app : armada-api This may be useful in conjunction with Prometheus' labelmap . For example, with the following sample Prometheus configuration: # prometheus.yaml - action : labelmap regex : __meta_kubernetes_service_label_(.+) With the above example, the source label __meta_kubernetes_service_label_app='armada-api' becomes the new label app='armada-api' when metrics related to this Service are scraped. Implemented in the cert-manager PR #4009 . Akamai DNS01 solver \u00b6 The Akamai DNS01 solver has been [updated][4007] to use the v2 of the OPEN EdgeGrid Go package. Bug Fixes \u00b6 The RFC2136 issuer is now able to handle DNS01 challenges that map to multiple TXT records. This lets you create Let's Encrypt certificates using RFC2136 with multiple DNS names. Fixed in the cert-manager PR #3622 . The comparison function PublicKeysEqual is now correct for public keys. Fixed in PR #3914 . The ACME issuer now works correctly with Certificates that have a long name (52 characters or more). These Certificates would not get renewed due to non-unique Order names being generated. Fixed in the cert-manager PR #3866 . Orders that are used with a misbehaving ACME server should not get stuck anymore. By misbehaving, we mean an ACME server that would validate the authorizations before having set the status of the order to \"ready\". Fixed in the cert-manager PR #3805 . The internal issuers now set the condition Ready=False with the reason RequestDenied when a CertificateRequest has been Denied . This is to keep the same behavior where a terminal state of a CertificateRequest should have a Ready condition. Fixed in the cert-manager PR #3878 . Other Changes \u00b6 The cert-manager controller now uses the configmapsleases resource instead of the configmaps one for leader election. The only noticeable difference is that a new Lease object is now being created in the leader election namespace. Implemented in the cert-manager PR #4016 . The keyAlgorithm for the ACME Issuer is now deprecated, and the EAB MAC algorithm is now hard-coded to HS256 . apiVersion : cert-manager.io/v1 kind : Issuer spec : acme : externalAccountBinding : keyAlgorithm : HS256 # DEPRECATED. Previously, we used to have a fork of golang/crypto which allowed us to set the EAB MAC algorithm. We now use the upstream version of golang/crypto where the EAB MAC algorithm is hard-coded to HS256. This change were implemented in the cert-manager PRs #3877 and #3936 . If you happen to look at the cert-manager controller logs, you may see this new message about optimistic locking: I0419 controller.go:158] msg=\"re-queuing item due to optimistic locking on resource\" error=\"Operation cannot be fulfilled on certificates.cert-manager.io sauron-adverts-evo-app-tls: the object has been modified; please apply your changes to the latest version and try again\" This message, shown at the info level, replaces the error level message that showed previously: E0419 controller.go:158] msg=\"re-queuing item due to error processing\" error=\"Operation cannot be fulfilled on certificates.cert-manager.io sauron-adverts-evo-app-tls: the object has been modified; please apply your changes to the latest version and try again\" The goal is to prevent users from thinking that the optimistic locking mechanism has to do with their issues, when in reality it mostly isn't and is the normal operation mode for Kubernetes controllers. Fixed in the cert-manager PR #3794 . The util.UsageContentCommittment (which contained a spelling mistake) was deprecated in favor of util.UsageContentCommitment . The only people impacted by this deprecation are the the people importing the Go package github.com/jetstack/cert-manager/pkg/api/util . The webhook now panics when it is not able to register the API schemes. Previously, the webhook would silently skip the error and start. A couple of legacy functions in test/e2e/util package have been removed. These functions can be found in the test/unit/gen package. The Kubernetes Go dependencies have been updated from v0.19.0 to v0.21.0 . When waiting for DNS propagating, the ACME DNS01 self-check now returns a better message when an unexpected DNS response code is received, such as SERVFAIL . Before: Could not find the start of authority After: Could not find the SOA record in the DNS tree for the domain '_acme-challenge.foo.example.com' using nameservers [8.8.8.8, 8.8.4.4] In addition to the above, you will get a new message when the DNS returns an unexpected response code: When querying the SOA record for the domain '_acme-challenge.foo.example.com' using nameservers [8.8.8.8, 8.8.4.4], rcode was expected to be 'NOERROR' or 'NXDOMAIN', but got 'SERVFAIL' Fixed in the cert-manager PR #3906 . The distroless/static base image was updated to the latest version as of 2021-05-20. Honorable mentions \u00b6 Tim Ramlot ( @inteon ) has done a fantastic job at adding the Istio VirtualService support for HTTP01 challenges in #3724 . It took an immense effort to have this PR ready and merged for the 1.4 release. After a lot of thinking, we have decided that trying to support every custom resource for every proxy could not be done in-tree due to the Go dependency weight that each integration adds. Jake Sanders proposed an out-of-tree approach that will be worked on as part of cert-manager 1.5.","title":"Release Notes"},{"location":"release-notes/release-notes-1.4/#final-release-v140","text":"Special thanks to the external contributors who contributed to this release: @andreas-p @erikgb @eddiehoffman @inteon @anton-johansson @edglynes @jandersen-plaid @foosinn @jsoref @clatour @tamalsaha","title":"Final Release v1.4.0"},{"location":"release-notes/release-notes-1.4/#deprecated-features-and-breaking-changes","text":"","title":"Deprecated Features and Breaking Changes"},{"location":"release-notes/release-notes-1.4/#removal-of-the-cert-manager-operator-package-on-red-hat-marketplace","text":"Since cert-manager v0.15 there has been a package for cert-manager on Red Hat Marketplace , but this has now been removed because it was not maintained and was found to be unreliable: #4055 #3732 #436 It is replaced by a new package which is generated via the Community Operators Repository , and which is therefore available on OperatorHub.io , OpenShift Container Platform and OKD . Please uninstall the existing cert-manager package and re-install by following the OLM Installation Documentation .","title":"Removal of the cert-manager operator package on Red Hat Marketplace"},{"location":"release-notes/release-notes-1.4/#upgrading-cert-manager-crds-and-stored-versions-of-cert-manager-custom-resources","text":"We have deprecated the following cert-manager APIs: cert-manager.io/v1alpha2 cert-manager.io/v1alpha3 cert-manager.io/v1beta1 acme.cert-manager.io/v1alpha2 acme.cert-manager.io/v1alpha3 acme.cert-manager.io/v1beta1 These APIs will be removed in cert-manager 1.6. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **by the time you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](../installation/upgrading/remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page. This change was made in the cert-manager PR #4021 .","title":"Upgrading cert-manager CRDs and stored versions of cert-manager custom resources"},{"location":"release-notes/release-notes-1.4/#helm-chart-securitycontext-defaults-to-non-root","text":"The Helm chart now follows the current Pod hardening best practices as defined by the Kyverno pod-security restricted policy. To pass the validation, the controller, webhook, and cainjector Pods are now running as non-root: apiVersion : v1 kind : Pod spec : securityContext : runAsNonRoot : true \u26d4\ufe0f If you are using custom containers that run as root with the Helm chart, you will need to set this back to `false`. Implemented in the cert-manager PR #4036 .","title":"Helm chart: securityContext defaults to non-root"},{"location":"release-notes/release-notes-1.4/#ca-vault-and-venafi-issuer-handling-of-cacrt-and-tlscrt","text":"The CA, Vault, and Venafi issuer now produce a tls.crt that is de-duplicated, in the correct order (leaf at the top, issuing certificate at the bottom) and verified (i.e. each signature can be verified). The CA issuer now produces a ca.crt that contains the \"most\" root CA that cert-manager is aware of. ca.crt may thus not be the actual self-signed root CA, since cert-manager may not be aware of it. Fixed in the cert-manager PRs #3982 , #3983 , and #3985 . \u26d4\ufe0f You may need to adjust systems that consume the `ca.crt` from Secrets managed by cert-manager with the CA issuer.","title":"CA, Vault and Venafi issuer handling of ca.crt and tls.crt"},{"location":"release-notes/release-notes-1.4/#vault-renewal-bug","text":"The renewal behavior has changed when a Certificate has a duration value of more than 90 days and renewBefore has not been set. Previously, the Certificate was renewed 30 days before expiry; now, the renewal happens \u2154 through the duration. This change was necessary to fix a bug where users of the Vault issuer would see a clash between the default renewal duration of 30 days and the duration of certificates issued by the Vault PKI. \u26d4\ufe0f If you were relying on the default renewal happening 30 days before expiry, we would advise setting `renewBefore` to 30 days (`720h`) to keep the old behavior. Fixed in the cert-manager PR #4092 .","title":"Vault renewal bug"},{"location":"release-notes/release-notes-1.4/#new-features","text":"","title":"New Features"},{"location":"release-notes/release-notes-1.4/#experimental-support-for-kubernetes-certificatesigningrequests","text":"It is now possible to use the built-in Kubernetes CertificateSigningRequest resources with cert-manager. The CA Issuer is currently the only supported issuer. The feature is experimental and can be enabled by adding a flag to the cert-manager controller. For example, with Helm: helm install cert-manager jetstack/cert-manager \\ --set extraArgs = \"{--feature-gates=ExperimentalCertificateSigningRequestControllers=true}\" Note that you will still need to manually approve the CSR object before cert-manager can sign the CSR. The documentation is available on the the Kubernetes CSR usage page . Implemented in cert-manager PR #4064 .","title":"Experimental Support for Kubernetes CertificateSigningRequests"},{"location":"release-notes/release-notes-1.4/#helm-chart-webhook-externally-accessible-for-bare-metal","text":"In some Kubernetes setups, the apiserver is not able to talk to kube-dns (i.e., when Kubernetes is running on bare-metal with no special resolv.conf ). To work around that, the cert-manager webhook can now be configured to be accessible from outside of the cluster. For example, in values.yaml : # values.yaml webhook : serviceType : LoadBalancer loadBalancerIP : 198.51.100.20 url : host : 198.51.100.20 Implemented in cert-manager PRs #3876 , #3932 .","title":"Helm chart: webhook externally accessible for bare-metal"},{"location":"release-notes/release-notes-1.4/#helm-chart-service-labels","text":"The cert-manager controller Service now supports custom labels using the top-level field in values.yaml : # values.yaml serviceLabels : app : armada-api This may be useful in conjunction with Prometheus' labelmap . For example, with the following sample Prometheus configuration: # prometheus.yaml - action : labelmap regex : __meta_kubernetes_service_label_(.+) With the above example, the source label __meta_kubernetes_service_label_app='armada-api' becomes the new label app='armada-api' when metrics related to this Service are scraped. Implemented in the cert-manager PR #4009 .","title":"Helm chart: Service labels"},{"location":"release-notes/release-notes-1.4/#akamai-dns01-solver","text":"The Akamai DNS01 solver has been [updated][4007] to use the v2 of the OPEN EdgeGrid Go package.","title":"Akamai DNS01 solver"},{"location":"release-notes/release-notes-1.4/#bug-fixes","text":"The RFC2136 issuer is now able to handle DNS01 challenges that map to multiple TXT records. This lets you create Let's Encrypt certificates using RFC2136 with multiple DNS names. Fixed in the cert-manager PR #3622 . The comparison function PublicKeysEqual is now correct for public keys. Fixed in PR #3914 . The ACME issuer now works correctly with Certificates that have a long name (52 characters or more). These Certificates would not get renewed due to non-unique Order names being generated. Fixed in the cert-manager PR #3866 . Orders that are used with a misbehaving ACME server should not get stuck anymore. By misbehaving, we mean an ACME server that would validate the authorizations before having set the status of the order to \"ready\". Fixed in the cert-manager PR #3805 . The internal issuers now set the condition Ready=False with the reason RequestDenied when a CertificateRequest has been Denied . This is to keep the same behavior where a terminal state of a CertificateRequest should have a Ready condition. Fixed in the cert-manager PR #3878 .","title":"Bug Fixes"},{"location":"release-notes/release-notes-1.4/#other-changes","text":"The cert-manager controller now uses the configmapsleases resource instead of the configmaps one for leader election. The only noticeable difference is that a new Lease object is now being created in the leader election namespace. Implemented in the cert-manager PR #4016 . The keyAlgorithm for the ACME Issuer is now deprecated, and the EAB MAC algorithm is now hard-coded to HS256 . apiVersion : cert-manager.io/v1 kind : Issuer spec : acme : externalAccountBinding : keyAlgorithm : HS256 # DEPRECATED. Previously, we used to have a fork of golang/crypto which allowed us to set the EAB MAC algorithm. We now use the upstream version of golang/crypto where the EAB MAC algorithm is hard-coded to HS256. This change were implemented in the cert-manager PRs #3877 and #3936 . If you happen to look at the cert-manager controller logs, you may see this new message about optimistic locking: I0419 controller.go:158] msg=\"re-queuing item due to optimistic locking on resource\" error=\"Operation cannot be fulfilled on certificates.cert-manager.io sauron-adverts-evo-app-tls: the object has been modified; please apply your changes to the latest version and try again\" This message, shown at the info level, replaces the error level message that showed previously: E0419 controller.go:158] msg=\"re-queuing item due to error processing\" error=\"Operation cannot be fulfilled on certificates.cert-manager.io sauron-adverts-evo-app-tls: the object has been modified; please apply your changes to the latest version and try again\" The goal is to prevent users from thinking that the optimistic locking mechanism has to do with their issues, when in reality it mostly isn't and is the normal operation mode for Kubernetes controllers. Fixed in the cert-manager PR #3794 . The util.UsageContentCommittment (which contained a spelling mistake) was deprecated in favor of util.UsageContentCommitment . The only people impacted by this deprecation are the the people importing the Go package github.com/jetstack/cert-manager/pkg/api/util . The webhook now panics when it is not able to register the API schemes. Previously, the webhook would silently skip the error and start. A couple of legacy functions in test/e2e/util package have been removed. These functions can be found in the test/unit/gen package. The Kubernetes Go dependencies have been updated from v0.19.0 to v0.21.0 . When waiting for DNS propagating, the ACME DNS01 self-check now returns a better message when an unexpected DNS response code is received, such as SERVFAIL . Before: Could not find the start of authority After: Could not find the SOA record in the DNS tree for the domain '_acme-challenge.foo.example.com' using nameservers [8.8.8.8, 8.8.4.4] In addition to the above, you will get a new message when the DNS returns an unexpected response code: When querying the SOA record for the domain '_acme-challenge.foo.example.com' using nameservers [8.8.8.8, 8.8.4.4], rcode was expected to be 'NOERROR' or 'NXDOMAIN', but got 'SERVFAIL' Fixed in the cert-manager PR #3906 . The distroless/static base image was updated to the latest version as of 2021-05-20.","title":"Other Changes"},{"location":"release-notes/release-notes-1.4/#honorable-mentions","text":"Tim Ramlot ( @inteon ) has done a fantastic job at adding the Istio VirtualService support for HTTP01 challenges in #3724 . It took an immense effort to have this PR ready and merged for the 1.4 release. After a lot of thinking, we have decided that trying to support every custom resource for every proxy could not be done in-tree due to the Go dependency weight that each integration adds. Jake Sanders proposed an out-of-tree approach that will be worked on as part of cert-manager 1.5.","title":"Honorable mentions"},{"location":"release-notes/release-notes-1.5/","text":"v1.5.5 \u00b6 Changelog since v1.5.4 \u00b6 In 1.5.5, we have reverted a change that caused a regression in the ACME Issuer. Before 1.5.4, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1beta1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. In 1.5.4, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager 1.5.4, 1.6.0, 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.5.5, we have restored the original behavior which is to use the annotation. We will also backport this fix to 1.5.5 and 1.6.2, allowing people to upgrade safely. Most people won't have any trouble upgrading from a version that contains the regression to 1.7.0, 1.6.2 or 1.5.5. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility . Bug or Regression \u00b6 Fixed a regression where cert-manager was creating Ingresses using the field ingressClassName instead of the annotation kubernetes.io/ingress.class . More details about this regression are available in the 1.7 release notes . ( #4783 , @maelvls ) Other (Cleanup or Flake) \u00b6 cert-manager now does one call to the ACME API instead of two when an Order fails. This belongs to the effort towards mitigating the high load that cert-manager deployments have on the Let's Encrypt API ( #4618 , @irbekrm ) v1.5.4 \u00b6 Changelog since v1.5.3 \u00b6 Bug or Regression \u00b6 Fixed a bug that caused cert-manager to panic when the Vault Issuer failed to reach the health endpoint. ( #4476 , @JoshVanL ) Helm chart: the post-install hook startupapicheck is now compatible with the PodSecurityPolicy resource. ( #4432 , @ndegory ) Helm chart: the post-install hook startupapicheck now deletes any post-install hook resources left after a previous failed install allowing helm install to be re-run after a failed attempt. ( #4435 , @wallrj ) Other (Cleanup or Flake) \u00b6 Update cert-manager base image versions ( #4479 , @SgtCoDFish ) v1.5.3 \u00b6 Changelog since v1.5.2 \u00b6 Bug or Regression \u00b6 Fix a bug where a Certificate may not get renewed when the issued Certificate has a one-second skew between notBefore and notAfter and spec.duration is not used. This one-second skew can be observed on certificates issued with Let's Encrypt and caused a mismatch in time precision between the time stored in status.renewalTime and the time internally computed by cert-manager. ( #4403 , @irbekrm ). Thanks to @mfmbarros for help with debugging the issue! v1.5.2 \u00b6 Changelog since v1.5.1 \u00b6 Bug or Regression \u00b6 Fix a regression introduced in v1.5.0 where the Ingress created for solving HTTP-01 challenges was created with pathType: Exact instead of pathType: ImplementationSpecific . ( #4385 , @jakexks ) Fixed the HTTP-01 solver creating ClusterIP instead of NodePort services by default. ( #4394 , @jakexks ) Helm chart and static manifest: the pointless status field is now stripped from the CRD manifests. ( #4387 , @irbekrm ) v1.5.1 \u00b6 The CRDs for the cert-manager v1beta1 API were mistakenly changed in cert-manager v1.5.0. If you installed the CRDs for v1.5.0, you should upgrade your CRDs to v1.5.1. The only affected API version is v1beta1, so if you're using the latest version - v1 - you won't be affected by the CRD changes. It's worth upgrading to v1 in any case, since v1alpha2, v1alpha3 and v1beta1 are all deprecated and will be removed in a future release. Changelog since v1.5.0 \u00b6 Bug or Regression \u00b6 Fix v1beta1 CRDs which were accidentally changed in cert-manager v1.5.0 ( #4355 , @SgtCoDFish ) v1.5.0 \u00b6 Major Themes \u00b6 API Deprecation \u00b6 The recent Kubernetes 1.22 release has removed a number of deprecated APIs. You can read the official blog post Kubernetes API and Feature Removals In 1.22 to learn more about it. If you intend to upgrade to Kubernetes 1.22, you must upgrade to cert-manager 1.5. To keep compatibility with older Kubernetes versions (down to 1.16), cert-manager 1.5 is now compatible with both Ingress v1 and v1beta1 . cert-manager will default to using v1 Ingress, and fall back to v1beta1 when v1 is not available. Please read the Ingress class compatibility notes to see if your Ingress controller has any known issues. Additionally, the cert-manager API versions v1alpha2 , v1alpha3 and v1beta1 are now deprecated, and will be removed in cert-manager 1.7. Please change all your YAML manifests that use a deprecated API version to use cert-manager.io/v1 instead, and re-apply them. These deprecation changes have been implemented in the cert-manager PRs #4225 and #4172 . Experimental Features \u00b6 Features that we are currently working on are included in cert-manager releases but disabled by default, as they are likely to change in future. If any of them look interesting to you, please try them out and report bugs or quirks in a GitHub Issue. Gateway API \u00b6 We have seen many requests from users to support different ways of routing HTTP traffic into their clusters for solving ACME HTTP-01 challenges. As the cloud-native ecosystem has so many different ingress implementations, we searched for a solution that would avoid having to add individual support for every kind of virtual service to the cert-manager API, and settled on the sig-network Gateway API . The Gateway API project aims to provide a universal API for modeling service networking in Kubernetes, and while it is still in its alpha stages is already gaining wide adoption . By supporting the Gateway API HTTPRoute resource, we hope that anyone using Ambassador, Contour, Gloo, HAProxy, Istio, Kong or Traefik will be able to solve HTTP-01 challenges, with more implementations coming in future. To go along with the HTTPRoute resource support, we have also added a gateway-shim controller that will allow users to annotate their Gateway resources to get a cert-manager Certificate automatically created, similar to the current ingress-shim functionality. Implemented in the cert-manager PRs #4276 and #4158 . CertificateSigningRequests \u00b6 CertificateSigningRequest is a built-in Kubernetes resource that was originally aimed at requesting X.509 client certificates and serving certificates for Kubernetes components such as kubelet. We have seen a rising interest in using the CertificateSigningRequest (CSR) resource as a way to provision workload certificates in service meshes such as Istio and its Istio Custom CA Integration using Kubernetes CSR . For that purpose, the CSR resource needs to be integrated with existing signers such as HashiCorp Vault or Venafi TPP. Back in cert-manager 1.4, the CA Issuer became the first built-in cert-manager issuer to support signing CertificateSigningRequest resources. In 1.5, we extended the support to all existing Issuers. The support for signing CSR resources is still experimental and requires to be explicitly enabled. If you are interested, please take a look at the Kubernetes CertificateSigningRequest documentation on the cert-manager website. To help you try the CSR support, you may want to try a new command that was added to the kubectl plugin. It allows you to create a CSR resource out of a cert-manager Certificate manifest: kubectl cert-manager x create certificatesigningrequest example-csr certificate.yaml Finally, we decided to remove the annotation experimental.cert-manager.io/ca that was added to the CertificateSigningRequest resource after being signed by cert-manager. This annotation was introduced in cert-manager 1.4 and will no longer be set on CertificateSigningRequest resources. We removed this annotation due to a technical limitation related to the fact that Kubernetes resources have a status subresource that is separate from the main resource. The above features were implemented in the cert-manager PRs #4112 , #4100 , #4103 , #4108 , #4106 , and #4143 User Experience \u00b6 kubectl plugin \u00b6 cert-manager comes with a kubectl plugin, kubectl cert-manager , that comes in handy for checking the status of your cert-manager Certificate resources. In 1.5, a new experimental command for installing cert-manager has been added. Under the hood, it uses the cert-manager Helm chart. This means that all helm templating options are also supported by this install command: kubectl cert-manager x install \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4s # Example: changing the wehbook timeout using a Helm parameter An interesting feature that comes when using with this new install command is that it installs the CRDs in a way that prevents helm uninstall from deleting the CRDs while uninstalling cert-manager. The plugin is now capable of determining when your cert-manager deployment is ready to be used: kubectl cert-manager check api The plugin also learned how to discover the version of cert-manager running on your cluster, similar to kubectl version : kubectl cert-manager version To install the plugin, check out the Kubectl plugin page on the cert-manager website. These features were implemented by Tim in the cert-manager PRs #4226 , #4205 , and #4138 . Helm chart \u00b6 While installing cert-manager using Helm, you might have noticed that the --wait flag does not wait until cert-manager is fully functional. With 1.5, the --wait flag now works as you would expect. The Helm chart now comes with a small startup job that waits until the cert-manager API becomes ready. Implemented in the cert-manager PR #4234 by Tim. Labels and annotations on generated Secret and CertificateRequest resources \u00b6 cert-manager now allows you to add custom annotations and labels to the Secret containing the TLS key pair using the new Certificate field secretTemplate . This is useful when using third-party solutions such as kubed to copy Secret resources to multiple namespaces. The secretTemplate is synced to the Secret when the Certificate is created or renewed. Here is an example of Certificate using the secretTemplate field: apiVersion : cert-manager.io/v1 kind : Certificate spec : secretTemplate : annotations : my-secret-annotation : \"foo\" labels : my-secret-label : bar Note that labels and annotations can only be added or replaced, but not removed. Removing any labels or annotations from the template or removing the template itself will have no effect. Along with the ability to set your own annotations and labels on Secret resources created by cert-manager, you can also tell cert-manager which annotations should be copied from Certificate resources to the generated CertificateRequest resources. By default, cert-manager will skip copying the annotations with the following prefixes: kubectl.kubernetes.io/ , fluxcd.io , argocd.argoproj.io . If you wish to keep the old behavior and allow all annotations to be copied, you can pass the flag --copied-annotations=* to the cert-manager controller. Implemented in the cert-manager PRs #3828 and #4251 . Community \u00b6 This is the first time that cert-manager participated in Google Summer of Code. Congratulations to Arsh and Tim for completing their GSoC projects! We hope you both continue to contribute in future. Thanks again to all open-source contributors with commits in this release: alrs annerajb Dean-Coakley francescsanjuanmrf inteon jonathansp kit837 longkai mozz-lx RinkiyaKeDad tamalsaha thiscantbeserious ulrichgi wpjunior Also thanks to coderanger for helping people out on the Slack #cert-manager channel; it's a huge help and much appreciated. New Features \u00b6 cert-manager now supports using Ed25519 private keys and signatures for Certificates. Implemented in the cert-manager PR #4079 . cert-manager now emits an event when a CertificateSigningRequest resource has not yet been approved. Without this event, the user would never know that cert-manager is waiting for the approval of the CertificateSigningRequest resource. Implemented in the cert-manager PR #4229 . cert-manager now only supports the version v1 of the AdmissionReviewVersion and ConversionReviewVersion resources, both available since Kubernetes 1.16. The v1beta1 version is no longer supported by cert-manager. This change was implemented in the cert-manager PRs #4254 and #4253 . cert-manager now restarts more quickly by clearing the leader election before shutting down. Also, upon shutdown, the controller loops now cleanly stop, which allows all in-flight reconciliation functions to finish before exiting. Implemented in the cert-manager PR #4243 . Metrics: a new metric, named clock_time_seconds was added; this metric allows for monitoring systems that do not have a built-in time function (e.g. DataDog) to calculate the number of seconds until a certificate expires by subtracting this metric from the existing certificate_expiration_timestamp metrics. Implemented in the cert-manager PR #4105 . Helm chart: the Prometheus scraping service port now has a name. Implemented in the cert-manager PR #4072 . Helm chart: you can now configure the labels for the cert-manager-webhook service using the Helm value webhook.serviceLabels . Implemented in the cert-manager PR #4260 . Bug or Regression \u00b6 Security: cert-manager now times out after 10 second when performing the self-check while solving HTTP-01 challenges. Fixed in the cert-manager PR #4311 . Cloudflare: Refactored DNS01 challenge to use API for finding the nearest Zone (fixing potential DNS issues) ( #4147 , @thiscantbeserious ) Fix a bug where failed CertificateRequest resources were not retried ( #4130 , @irbekrm ) Fix a regression that would lead to a Certificate becoming \"Failed\" when the issued X.509 certificate's subject DN would be equal to the issuer's subject DN. Fixed in the cert-manager PR #4237 . Fix a regression where the tls.crt certificate chain would unexpectedly not contain an intermediate CA certificate when no root CA is available in the CA chain returned by the issuer. This bug affected the Vault Issuer, Venafi Issuer and CA Issuer. This bug was fixed in the cert-manager PR #4261 . Fix a goroutine leak that was causing the controller's memory usage to grow with time. Fixed in the cert-manager PR #4233 . Fix a race condition introduced in cert-manager 0.15 that would crash cert-manager for clusters with a large number of certificates. Fixed in the cert-manager PR #4231 . Fix a bug where the default renewal duration of certificate, set to 30 days, would clash with the duration of certificates issued by the Vault Issuer. All Certificate resources are now renewed \u2154 through the duration unless a custom renew period is specified by setting renewBefore on the Certificate. Fixed in the cert-manager PR #4092 . The cert-manager binaries, including the kubectl plugin, now exit with the correct exit code on SIGINT (Ctrl+C) and SIGTERM events. More specifically, when one of these events is caught, cert-manager will exit with the code 128 + signal number. Fixed in #4230 . The static manifests available on the GitHub Releases page now contain a version label app.kubernetes.io/version: v1.5.0 . We also removed the Helm-specific labels from the static manifests. Fixed in the cert-manager PR #4190 . Other (Cleanup or Flake) \u00b6 A conformance end-to-end testing suite was added for the CertificateSigningRequest resources ( #4101 ). Reduce binary sizes from 74MB down to 49MB by adding the Go ldflag -w ( #4181 ).","title":"Release 1.5"},{"location":"release-notes/release-notes-1.5/#v155","text":"","title":"v1.5.5"},{"location":"release-notes/release-notes-1.5/#changelog-since-v154","text":"In 1.5.5, we have reverted a change that caused a regression in the ACME Issuer. Before 1.5.4, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1beta1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. In 1.5.4, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager 1.5.4, 1.6.0, 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.5.5, we have restored the original behavior which is to use the annotation. We will also backport this fix to 1.5.5 and 1.6.2, allowing people to upgrade safely. Most people won't have any trouble upgrading from a version that contains the regression to 1.7.0, 1.6.2 or 1.5.5. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility .","title":"Changelog since v1.5.4"},{"location":"release-notes/release-notes-1.5/#bug-or-regression","text":"Fixed a regression where cert-manager was creating Ingresses using the field ingressClassName instead of the annotation kubernetes.io/ingress.class . More details about this regression are available in the 1.7 release notes . ( #4783 , @maelvls )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#other-cleanup-or-flake","text":"cert-manager now does one call to the ACME API instead of two when an Order fails. This belongs to the effort towards mitigating the high load that cert-manager deployments have on the Let's Encrypt API ( #4618 , @irbekrm )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.5/#v154","text":"","title":"v1.5.4"},{"location":"release-notes/release-notes-1.5/#changelog-since-v153","text":"","title":"Changelog since v1.5.3"},{"location":"release-notes/release-notes-1.5/#bug-or-regression_1","text":"Fixed a bug that caused cert-manager to panic when the Vault Issuer failed to reach the health endpoint. ( #4476 , @JoshVanL ) Helm chart: the post-install hook startupapicheck is now compatible with the PodSecurityPolicy resource. ( #4432 , @ndegory ) Helm chart: the post-install hook startupapicheck now deletes any post-install hook resources left after a previous failed install allowing helm install to be re-run after a failed attempt. ( #4435 , @wallrj )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#other-cleanup-or-flake_1","text":"Update cert-manager base image versions ( #4479 , @SgtCoDFish )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.5/#v153","text":"","title":"v1.5.3"},{"location":"release-notes/release-notes-1.5/#changelog-since-v152","text":"","title":"Changelog since v1.5.2"},{"location":"release-notes/release-notes-1.5/#bug-or-regression_2","text":"Fix a bug where a Certificate may not get renewed when the issued Certificate has a one-second skew between notBefore and notAfter and spec.duration is not used. This one-second skew can be observed on certificates issued with Let's Encrypt and caused a mismatch in time precision between the time stored in status.renewalTime and the time internally computed by cert-manager. ( #4403 , @irbekrm ). Thanks to @mfmbarros for help with debugging the issue!","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#v152","text":"","title":"v1.5.2"},{"location":"release-notes/release-notes-1.5/#changelog-since-v151","text":"","title":"Changelog since v1.5.1"},{"location":"release-notes/release-notes-1.5/#bug-or-regression_3","text":"Fix a regression introduced in v1.5.0 where the Ingress created for solving HTTP-01 challenges was created with pathType: Exact instead of pathType: ImplementationSpecific . ( #4385 , @jakexks ) Fixed the HTTP-01 solver creating ClusterIP instead of NodePort services by default. ( #4394 , @jakexks ) Helm chart and static manifest: the pointless status field is now stripped from the CRD manifests. ( #4387 , @irbekrm )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#v151","text":"The CRDs for the cert-manager v1beta1 API were mistakenly changed in cert-manager v1.5.0. If you installed the CRDs for v1.5.0, you should upgrade your CRDs to v1.5.1. The only affected API version is v1beta1, so if you're using the latest version - v1 - you won't be affected by the CRD changes. It's worth upgrading to v1 in any case, since v1alpha2, v1alpha3 and v1beta1 are all deprecated and will be removed in a future release.","title":"v1.5.1"},{"location":"release-notes/release-notes-1.5/#changelog-since-v150","text":"","title":"Changelog since v1.5.0"},{"location":"release-notes/release-notes-1.5/#bug-or-regression_4","text":"Fix v1beta1 CRDs which were accidentally changed in cert-manager v1.5.0 ( #4355 , @SgtCoDFish )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#v150","text":"","title":"v1.5.0"},{"location":"release-notes/release-notes-1.5/#major-themes","text":"","title":"Major Themes"},{"location":"release-notes/release-notes-1.5/#api-deprecation","text":"The recent Kubernetes 1.22 release has removed a number of deprecated APIs. You can read the official blog post Kubernetes API and Feature Removals In 1.22 to learn more about it. If you intend to upgrade to Kubernetes 1.22, you must upgrade to cert-manager 1.5. To keep compatibility with older Kubernetes versions (down to 1.16), cert-manager 1.5 is now compatible with both Ingress v1 and v1beta1 . cert-manager will default to using v1 Ingress, and fall back to v1beta1 when v1 is not available. Please read the Ingress class compatibility notes to see if your Ingress controller has any known issues. Additionally, the cert-manager API versions v1alpha2 , v1alpha3 and v1beta1 are now deprecated, and will be removed in cert-manager 1.7. Please change all your YAML manifests that use a deprecated API version to use cert-manager.io/v1 instead, and re-apply them. These deprecation changes have been implemented in the cert-manager PRs #4225 and #4172 .","title":"API Deprecation"},{"location":"release-notes/release-notes-1.5/#experimental-features","text":"Features that we are currently working on are included in cert-manager releases but disabled by default, as they are likely to change in future. If any of them look interesting to you, please try them out and report bugs or quirks in a GitHub Issue.","title":"Experimental Features"},{"location":"release-notes/release-notes-1.5/#gateway-api","text":"We have seen many requests from users to support different ways of routing HTTP traffic into their clusters for solving ACME HTTP-01 challenges. As the cloud-native ecosystem has so many different ingress implementations, we searched for a solution that would avoid having to add individual support for every kind of virtual service to the cert-manager API, and settled on the sig-network Gateway API . The Gateway API project aims to provide a universal API for modeling service networking in Kubernetes, and while it is still in its alpha stages is already gaining wide adoption . By supporting the Gateway API HTTPRoute resource, we hope that anyone using Ambassador, Contour, Gloo, HAProxy, Istio, Kong or Traefik will be able to solve HTTP-01 challenges, with more implementations coming in future. To go along with the HTTPRoute resource support, we have also added a gateway-shim controller that will allow users to annotate their Gateway resources to get a cert-manager Certificate automatically created, similar to the current ingress-shim functionality. Implemented in the cert-manager PRs #4276 and #4158 .","title":"Gateway API"},{"location":"release-notes/release-notes-1.5/#certificatesigningrequests","text":"CertificateSigningRequest is a built-in Kubernetes resource that was originally aimed at requesting X.509 client certificates and serving certificates for Kubernetes components such as kubelet. We have seen a rising interest in using the CertificateSigningRequest (CSR) resource as a way to provision workload certificates in service meshes such as Istio and its Istio Custom CA Integration using Kubernetes CSR . For that purpose, the CSR resource needs to be integrated with existing signers such as HashiCorp Vault or Venafi TPP. Back in cert-manager 1.4, the CA Issuer became the first built-in cert-manager issuer to support signing CertificateSigningRequest resources. In 1.5, we extended the support to all existing Issuers. The support for signing CSR resources is still experimental and requires to be explicitly enabled. If you are interested, please take a look at the Kubernetes CertificateSigningRequest documentation on the cert-manager website. To help you try the CSR support, you may want to try a new command that was added to the kubectl plugin. It allows you to create a CSR resource out of a cert-manager Certificate manifest: kubectl cert-manager x create certificatesigningrequest example-csr certificate.yaml Finally, we decided to remove the annotation experimental.cert-manager.io/ca that was added to the CertificateSigningRequest resource after being signed by cert-manager. This annotation was introduced in cert-manager 1.4 and will no longer be set on CertificateSigningRequest resources. We removed this annotation due to a technical limitation related to the fact that Kubernetes resources have a status subresource that is separate from the main resource. The above features were implemented in the cert-manager PRs #4112 , #4100 , #4103 , #4108 , #4106 , and #4143","title":"CertificateSigningRequests"},{"location":"release-notes/release-notes-1.5/#user-experience","text":"","title":"User Experience"},{"location":"release-notes/release-notes-1.5/#kubectl-plugin","text":"cert-manager comes with a kubectl plugin, kubectl cert-manager , that comes in handy for checking the status of your cert-manager Certificate resources. In 1.5, a new experimental command for installing cert-manager has been added. Under the hood, it uses the cert-manager Helm chart. This means that all helm templating options are also supported by this install command: kubectl cert-manager x install \\ --set prometheus.enabled = false \\ # Example: disabling prometheus using a Helm parameter --set webhook.timeoutSeconds = 4s # Example: changing the wehbook timeout using a Helm parameter An interesting feature that comes when using with this new install command is that it installs the CRDs in a way that prevents helm uninstall from deleting the CRDs while uninstalling cert-manager. The plugin is now capable of determining when your cert-manager deployment is ready to be used: kubectl cert-manager check api The plugin also learned how to discover the version of cert-manager running on your cluster, similar to kubectl version : kubectl cert-manager version To install the plugin, check out the Kubectl plugin page on the cert-manager website. These features were implemented by Tim in the cert-manager PRs #4226 , #4205 , and #4138 .","title":"kubectl plugin"},{"location":"release-notes/release-notes-1.5/#helm-chart","text":"While installing cert-manager using Helm, you might have noticed that the --wait flag does not wait until cert-manager is fully functional. With 1.5, the --wait flag now works as you would expect. The Helm chart now comes with a small startup job that waits until the cert-manager API becomes ready. Implemented in the cert-manager PR #4234 by Tim.","title":"Helm chart"},{"location":"release-notes/release-notes-1.5/#labels-and-annotations-on-generated-secret-and-certificaterequest-resources","text":"cert-manager now allows you to add custom annotations and labels to the Secret containing the TLS key pair using the new Certificate field secretTemplate . This is useful when using third-party solutions such as kubed to copy Secret resources to multiple namespaces. The secretTemplate is synced to the Secret when the Certificate is created or renewed. Here is an example of Certificate using the secretTemplate field: apiVersion : cert-manager.io/v1 kind : Certificate spec : secretTemplate : annotations : my-secret-annotation : \"foo\" labels : my-secret-label : bar Note that labels and annotations can only be added or replaced, but not removed. Removing any labels or annotations from the template or removing the template itself will have no effect. Along with the ability to set your own annotations and labels on Secret resources created by cert-manager, you can also tell cert-manager which annotations should be copied from Certificate resources to the generated CertificateRequest resources. By default, cert-manager will skip copying the annotations with the following prefixes: kubectl.kubernetes.io/ , fluxcd.io , argocd.argoproj.io . If you wish to keep the old behavior and allow all annotations to be copied, you can pass the flag --copied-annotations=* to the cert-manager controller. Implemented in the cert-manager PRs #3828 and #4251 .","title":"Labels and annotations on generated Secret and CertificateRequest resources"},{"location":"release-notes/release-notes-1.5/#community","text":"This is the first time that cert-manager participated in Google Summer of Code. Congratulations to Arsh and Tim for completing their GSoC projects! We hope you both continue to contribute in future. Thanks again to all open-source contributors with commits in this release: alrs annerajb Dean-Coakley francescsanjuanmrf inteon jonathansp kit837 longkai mozz-lx RinkiyaKeDad tamalsaha thiscantbeserious ulrichgi wpjunior Also thanks to coderanger for helping people out on the Slack #cert-manager channel; it's a huge help and much appreciated.","title":"Community"},{"location":"release-notes/release-notes-1.5/#new-features","text":"cert-manager now supports using Ed25519 private keys and signatures for Certificates. Implemented in the cert-manager PR #4079 . cert-manager now emits an event when a CertificateSigningRequest resource has not yet been approved. Without this event, the user would never know that cert-manager is waiting for the approval of the CertificateSigningRequest resource. Implemented in the cert-manager PR #4229 . cert-manager now only supports the version v1 of the AdmissionReviewVersion and ConversionReviewVersion resources, both available since Kubernetes 1.16. The v1beta1 version is no longer supported by cert-manager. This change was implemented in the cert-manager PRs #4254 and #4253 . cert-manager now restarts more quickly by clearing the leader election before shutting down. Also, upon shutdown, the controller loops now cleanly stop, which allows all in-flight reconciliation functions to finish before exiting. Implemented in the cert-manager PR #4243 . Metrics: a new metric, named clock_time_seconds was added; this metric allows for monitoring systems that do not have a built-in time function (e.g. DataDog) to calculate the number of seconds until a certificate expires by subtracting this metric from the existing certificate_expiration_timestamp metrics. Implemented in the cert-manager PR #4105 . Helm chart: the Prometheus scraping service port now has a name. Implemented in the cert-manager PR #4072 . Helm chart: you can now configure the labels for the cert-manager-webhook service using the Helm value webhook.serviceLabels . Implemented in the cert-manager PR #4260 .","title":"New Features"},{"location":"release-notes/release-notes-1.5/#bug-or-regression_5","text":"Security: cert-manager now times out after 10 second when performing the self-check while solving HTTP-01 challenges. Fixed in the cert-manager PR #4311 . Cloudflare: Refactored DNS01 challenge to use API for finding the nearest Zone (fixing potential DNS issues) ( #4147 , @thiscantbeserious ) Fix a bug where failed CertificateRequest resources were not retried ( #4130 , @irbekrm ) Fix a regression that would lead to a Certificate becoming \"Failed\" when the issued X.509 certificate's subject DN would be equal to the issuer's subject DN. Fixed in the cert-manager PR #4237 . Fix a regression where the tls.crt certificate chain would unexpectedly not contain an intermediate CA certificate when no root CA is available in the CA chain returned by the issuer. This bug affected the Vault Issuer, Venafi Issuer and CA Issuer. This bug was fixed in the cert-manager PR #4261 . Fix a goroutine leak that was causing the controller's memory usage to grow with time. Fixed in the cert-manager PR #4233 . Fix a race condition introduced in cert-manager 0.15 that would crash cert-manager for clusters with a large number of certificates. Fixed in the cert-manager PR #4231 . Fix a bug where the default renewal duration of certificate, set to 30 days, would clash with the duration of certificates issued by the Vault Issuer. All Certificate resources are now renewed \u2154 through the duration unless a custom renew period is specified by setting renewBefore on the Certificate. Fixed in the cert-manager PR #4092 . The cert-manager binaries, including the kubectl plugin, now exit with the correct exit code on SIGINT (Ctrl+C) and SIGTERM events. More specifically, when one of these events is caught, cert-manager will exit with the code 128 + signal number. Fixed in #4230 . The static manifests available on the GitHub Releases page now contain a version label app.kubernetes.io/version: v1.5.0 . We also removed the Helm-specific labels from the static manifests. Fixed in the cert-manager PR #4190 .","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.5/#other-cleanup-or-flake_2","text":"A conformance end-to-end testing suite was added for the CertificateSigningRequest resources ( #4101 ). Reduce binary sizes from 74MB down to 49MB by adding the Go ldflag -w ( #4181 ).","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.6/","text":"v1.6.3 \u00b6 Changes since 1.6.2 \u00b6 Bug or Regression \u00b6 Bumps the version of Go used to build the cert-manager binaries to 1.17.8, to fix a slew of CVEs (none of which were likely to be exploited) ( #4975 , @vhosakot ) Fixes an expired hardcoded certificate which broke unit tests ( #4977 , @SgtCoDFish , @jakexks ) v1.6.2 \u00b6 In 1.6.2, we reverted a change that caused a regression in the ACME Issuer. In 1.6.0 and 1.6.1, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1beta1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. After 1.5, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager 1.5.4, 1.6.0, and 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.6.2, we restored the original behavior which is to use the annotation. This patch is also available in 1.5.5 and in 1.7.0. Most people won't have any trouble upgrading from 1.6.0 or 1.6.1 to 1.6.2. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility . Changelog since v1.6.1 \u00b6 Bug or Regression \u00b6 The HTTP-01 ACME solver now uses the kubernetes.io/ingress.class annotation instead of the spec.ingressClassName in created Ingress resources. ( #4785 , @maelvls ) Other (Cleanup or Flake) \u00b6 cert-manager now does one call to the ACME API instead of two when an Order fails. This fix is part of the effort towards mitigating the high load that cert-manager deployments have on the Let's Encrypt API ( #4619 , @irbekrm ) Bump base images to latest versions ( #4707 , @SgtCoDFish ) v1.6.1 \u00b6 Changelog since v1.6.0 \u00b6 Bug or Regression \u00b6 Fixes an issue in cmctl that prevented displaying the Order resource with cert-manager 1.6 when running cmctl status certificate . ( #4572 , @maelvls ) Update to latest version of keystore-go to address a backwards incompatible change introduced in v1.6.0 ( #4564 , @SgtCoDFish ) v1.6.0 \u00b6 Breaking Changes (You MUST read this before you upgrade!) \u00b6 Legacy cert-manager API versions are no-longer served \u00b6 Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 are no longer served. This means if your deployment manifests contain any of these API versions, you will not be able to deploy them after upgrading. Our new cmctl utility or old kubectl cert-manager plugin can convert old manifests to v1 for you. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **before you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](../installation/upgrading/remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page. JKS Keystore Minimum Password Length \u00b6 \u2139\ufe0f This no longer applies as it was fixed in v1.6.1 , but will remain here for informational purposes. If you haven't upgraded cert-manager to v1.6.0 from any v1.5 release, we recommend upgrading straight to the latest version, skipping v1.6.0 . In cert-manager v1.6.0 JKS Keystores had a minimum password length of 6 characters, as an unintended side effect of upgrading keystore-go from v2 to v4 . If you are using a shorter password, certificates would have failed to renew, and the only observable error was in the cert-manager logs. This was fixed in cert-manager v1.6.1 . Major Themes \u00b6 Command-line tool User Experience \u00b6 The cert-manager kubectl plugin has been redesigned as a standalone utility: cmctl While the kubectl plugin functionality remains intact, using cmctl allows for full tab completion. Supply Chain Security \u00b6 As part of the wider ecosystem's push for greater supply chain security we are aiming to achieve SLSA 3 by the 1.7 release date. cert-manager 1.6 has achieved the requirements for SLSA 2 when installed via helm. Our helm chart's signature can be verified with the cert-manager maintainers' public key published on our website . Our container images will be signed using sigstore's cosign as soon as our OCI registry supports it. Tool Chain Updates \u00b6 cert-manager is now built with go 1.17 ( #4478 , @irbekrm ) and can now be compiled on Apple Silicon ( #4485 , @munnerz ). Changelog since v1.5.0 \u00b6 Feature \u00b6 Add Certificate RenewBefore Prometheus metrics ( #4419 , @artificial-aidan ) Add option to specify managed identity id when using Azure DNS DNS01 solver ( #4332 , @tomasfreund ) Add support for building & developing on M1 macs ( #4485 , @munnerz ) Adds release targets for both cmctl as well as kubectl-cert_manager ( #4523 , @JoshVanL ) Allow setting Helm chart service annotations ( #3639 , @treydock ) CLI: Adds cmctl completion command for generating shell completion scripts for Bash, ZSH, Fish, and PowerShell ( #4408 , @JoshVanL ) CLI: Adds support for auto-completion on runtime objects (Namespaces, CertificateRequests, Certificates etc.) ( #4409 , @JoshVanL ) CLI: Only expose Kubernetes related flags on commands that use them ( #4407 , @JoshVanL ) Enable configuring CLI command name and registering completion sub-command at build time. ( #4522 , @JoshVanL ) Bug or Regression \u00b6 Fix a bug in the Vault client that led to a panic after a request to Vault health endpoint failed. ( #4456 , @JoshVanL ) Fix CRDs which were accidentally changed in cert-manager v1.5.0 ( #4353 , @SgtCoDFish ) Fix a regression in Ingress PathType introduced in v1.5.0 ( #4373 , @jakexks ) Fixed the HTTP-01 solver creating ClusterIP instead of NodePort services by default. ( #4393 , @jakexks ) Fix a bug where a Certificate may not get renewed when the issued Certificate has a one-second skew between notBefore and notAfter and spec.duration is not used. This one-second skew can be observed on certificates issued with Let's Encrypt and caused a mismatch in time precision between the time stored in status.renewalTime and the time internally computed by cert-manager. ( #4399 , @irbekrm ) Helm chart: the post-install hook startupapicheck is now compatible with PodSecurityPolicy. ( #4364 , @ndegory ) Helm chart: the post-install hook startupapicheck now deletes any post-install hook resources left after a previous failed install allowing helm install to be re-run after a failed attempt. ( #4433 , @wallrj ) The defaults for leader election parameters are now consistent across cert-manager and cainjector. ( #4359 , @johanfleury ) Use GetAuthorization instead of GetChallenge when querying the current state of an ACME challenge. ( #4430 , @JoshVanL ) Other (Cleanup or Flake) \u00b6 Adds middleware logging back to ACME client for debugging ( #4429 , @JoshVanL ) Deprecation: The API versions: v1alpha2 , v1alpha3 , and v1beta1 , are no longer served in cert-manager 1.6 and will be removed in cert-manager 1.7. ( #4482 , @wallrj ) Expose error messages (e.g., invalid access token) from the Cloudflare API to users; allow live testing using Cloudflare API token (not just key). ( #4465 , @andrewmwhite ) Fix manually specified PKCS#10 CSR and X.509 Certificate version numbers (although these were ignored in practice) ( #4392 , @SgtCoDFish ) Improves logging for 'owner not found' errors for CertificateRequest s owning Order s. ( #4369 , @irbekrm ) Refactor: move from io/ioutil to io and os package ( #4402 , @Juneezee ) Helm chart and static manifest: the pointless status field is now stripped from the CRD manifests. ( #4379 , @irbekrm ) Update cert-manager base image versions ( #4474 , @SgtCoDFish ) cert-manager now uses Go 1.17. ( #4478 , @irbekrm )","title":"Release 1.6"},{"location":"release-notes/release-notes-1.6/#v163","text":"","title":"v1.6.3"},{"location":"release-notes/release-notes-1.6/#changes-since-162","text":"","title":"Changes since 1.6.2"},{"location":"release-notes/release-notes-1.6/#bug-or-regression","text":"Bumps the version of Go used to build the cert-manager binaries to 1.17.8, to fix a slew of CVEs (none of which were likely to be exploited) ( #4975 , @vhosakot ) Fixes an expired hardcoded certificate which broke unit tests ( #4977 , @SgtCoDFish , @jakexks )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.6/#v162","text":"In 1.6.2, we reverted a change that caused a regression in the ACME Issuer. In 1.6.0 and 1.6.1, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1beta1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. After 1.5, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager 1.5.4, 1.6.0, and 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.6.2, we restored the original behavior which is to use the annotation. This patch is also available in 1.5.5 and in 1.7.0. Most people won't have any trouble upgrading from 1.6.0 or 1.6.1 to 1.6.2. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility .","title":"v1.6.2"},{"location":"release-notes/release-notes-1.6/#changelog-since-v161","text":"","title":"Changelog since v1.6.1"},{"location":"release-notes/release-notes-1.6/#bug-or-regression_1","text":"The HTTP-01 ACME solver now uses the kubernetes.io/ingress.class annotation instead of the spec.ingressClassName in created Ingress resources. ( #4785 , @maelvls )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.6/#other-cleanup-or-flake","text":"cert-manager now does one call to the ACME API instead of two when an Order fails. This fix is part of the effort towards mitigating the high load that cert-manager deployments have on the Let's Encrypt API ( #4619 , @irbekrm ) Bump base images to latest versions ( #4707 , @SgtCoDFish )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.6/#v161","text":"","title":"v1.6.1"},{"location":"release-notes/release-notes-1.6/#changelog-since-v160","text":"","title":"Changelog since v1.6.0"},{"location":"release-notes/release-notes-1.6/#bug-or-regression_2","text":"Fixes an issue in cmctl that prevented displaying the Order resource with cert-manager 1.6 when running cmctl status certificate . ( #4572 , @maelvls ) Update to latest version of keystore-go to address a backwards incompatible change introduced in v1.6.0 ( #4564 , @SgtCoDFish )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.6/#v160","text":"","title":"v1.6.0"},{"location":"release-notes/release-notes-1.6/#breaking-changes-you-must-read-this-before-you-upgrade","text":"","title":"Breaking Changes (You MUST read this before you upgrade!)"},{"location":"release-notes/release-notes-1.6/#legacy-cert-manager-api-versions-are-no-longer-served","text":"Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 are no longer served. This means if your deployment manifests contain any of these API versions, you will not be able to deploy them after upgrading. Our new cmctl utility or old kubectl cert-manager plugin can convert old manifests to v1 for you. \u26d4\ufe0f If you are upgrading cert-manager on a cluster which has previously had cert-manager < `v1.0.0`, you will need to ensure that all cert-manager custom resources are stored in `etcd` at `v1` version and that cert-manager CRDs do not reference the deprecated APIs **before you upgrade to `v1.6`**. This is explained in more detail in the [Upgrading existing cert-manager resources](../installation/upgrading/remove-deprecated-apis.md#upgrading-existing-cert-manager-resources) page.","title":"Legacy cert-manager API versions are no-longer served"},{"location":"release-notes/release-notes-1.6/#jks-keystore-minimum-password-length","text":"\u2139\ufe0f This no longer applies as it was fixed in v1.6.1 , but will remain here for informational purposes. If you haven't upgraded cert-manager to v1.6.0 from any v1.5 release, we recommend upgrading straight to the latest version, skipping v1.6.0 . In cert-manager v1.6.0 JKS Keystores had a minimum password length of 6 characters, as an unintended side effect of upgrading keystore-go from v2 to v4 . If you are using a shorter password, certificates would have failed to renew, and the only observable error was in the cert-manager logs. This was fixed in cert-manager v1.6.1 .","title":"JKS Keystore Minimum Password Length"},{"location":"release-notes/release-notes-1.6/#major-themes","text":"","title":"Major Themes"},{"location":"release-notes/release-notes-1.6/#command-line-tool-user-experience","text":"The cert-manager kubectl plugin has been redesigned as a standalone utility: cmctl While the kubectl plugin functionality remains intact, using cmctl allows for full tab completion.","title":"Command-line tool User Experience"},{"location":"release-notes/release-notes-1.6/#supply-chain-security","text":"As part of the wider ecosystem's push for greater supply chain security we are aiming to achieve SLSA 3 by the 1.7 release date. cert-manager 1.6 has achieved the requirements for SLSA 2 when installed via helm. Our helm chart's signature can be verified with the cert-manager maintainers' public key published on our website . Our container images will be signed using sigstore's cosign as soon as our OCI registry supports it.","title":"Supply Chain Security"},{"location":"release-notes/release-notes-1.6/#tool-chain-updates","text":"cert-manager is now built with go 1.17 ( #4478 , @irbekrm ) and can now be compiled on Apple Silicon ( #4485 , @munnerz ).","title":"Tool Chain Updates"},{"location":"release-notes/release-notes-1.6/#changelog-since-v150","text":"","title":"Changelog since v1.5.0"},{"location":"release-notes/release-notes-1.6/#feature","text":"Add Certificate RenewBefore Prometheus metrics ( #4419 , @artificial-aidan ) Add option to specify managed identity id when using Azure DNS DNS01 solver ( #4332 , @tomasfreund ) Add support for building & developing on M1 macs ( #4485 , @munnerz ) Adds release targets for both cmctl as well as kubectl-cert_manager ( #4523 , @JoshVanL ) Allow setting Helm chart service annotations ( #3639 , @treydock ) CLI: Adds cmctl completion command for generating shell completion scripts for Bash, ZSH, Fish, and PowerShell ( #4408 , @JoshVanL ) CLI: Adds support for auto-completion on runtime objects (Namespaces, CertificateRequests, Certificates etc.) ( #4409 , @JoshVanL ) CLI: Only expose Kubernetes related flags on commands that use them ( #4407 , @JoshVanL ) Enable configuring CLI command name and registering completion sub-command at build time. ( #4522 , @JoshVanL )","title":"Feature"},{"location":"release-notes/release-notes-1.6/#bug-or-regression_3","text":"Fix a bug in the Vault client that led to a panic after a request to Vault health endpoint failed. ( #4456 , @JoshVanL ) Fix CRDs which were accidentally changed in cert-manager v1.5.0 ( #4353 , @SgtCoDFish ) Fix a regression in Ingress PathType introduced in v1.5.0 ( #4373 , @jakexks ) Fixed the HTTP-01 solver creating ClusterIP instead of NodePort services by default. ( #4393 , @jakexks ) Fix a bug where a Certificate may not get renewed when the issued Certificate has a one-second skew between notBefore and notAfter and spec.duration is not used. This one-second skew can be observed on certificates issued with Let's Encrypt and caused a mismatch in time precision between the time stored in status.renewalTime and the time internally computed by cert-manager. ( #4399 , @irbekrm ) Helm chart: the post-install hook startupapicheck is now compatible with PodSecurityPolicy. ( #4364 , @ndegory ) Helm chart: the post-install hook startupapicheck now deletes any post-install hook resources left after a previous failed install allowing helm install to be re-run after a failed attempt. ( #4433 , @wallrj ) The defaults for leader election parameters are now consistent across cert-manager and cainjector. ( #4359 , @johanfleury ) Use GetAuthorization instead of GetChallenge when querying the current state of an ACME challenge. ( #4430 , @JoshVanL )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.6/#other-cleanup-or-flake_1","text":"Adds middleware logging back to ACME client for debugging ( #4429 , @JoshVanL ) Deprecation: The API versions: v1alpha2 , v1alpha3 , and v1beta1 , are no longer served in cert-manager 1.6 and will be removed in cert-manager 1.7. ( #4482 , @wallrj ) Expose error messages (e.g., invalid access token) from the Cloudflare API to users; allow live testing using Cloudflare API token (not just key). ( #4465 , @andrewmwhite ) Fix manually specified PKCS#10 CSR and X.509 Certificate version numbers (although these were ignored in practice) ( #4392 , @SgtCoDFish ) Improves logging for 'owner not found' errors for CertificateRequest s owning Order s. ( #4369 , @irbekrm ) Refactor: move from io/ioutil to io and os package ( #4402 , @Juneezee ) Helm chart and static manifest: the pointless status field is now stripped from the CRD manifests. ( #4379 , @irbekrm ) Update cert-manager base image versions ( #4474 , @SgtCoDFish ) cert-manager now uses Go 1.17. ( #4478 , @irbekrm )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.7/","text":"v1.7.3 \u00b6 v1.7.3 is in effect a bug fix release which increases some hard-coded timeouts which were preventing the use of certain ACME issuers which sometimes had slower response times. This is known to include ZeroSSL and Sectigo. These issues were reported by many users, who we listed and thanked on the GitHub release . Changes since v1.7.2 \u00b6 Bug \u00b6 Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5232 , @JoooostB @SgtCoDFish ) Other (Cleanup) \u00b6 Bumps go to 1.17.11 and bumps base images to latest distroless images ( #5234 , @SgtCoDFish ) v1.7.2 \u00b6 Changes since 1.7.1 \u00b6 Bug or Regression \u00b6 Bumps the version of Go used to build the cert-manager binaries to 1.17.8, to fix a slew of CVEs (none of which were likely to be exploited) ( #4976 , @vhosakot ) Fixes an expired hardcoded certificate which broke unit tests ( #4978 , @SgtCoDFish , @jakexks ) v1.7.1 \u00b6 Changes since v1.7.0 \u00b6 Bug or Regression \u00b6 Fix: The alpha feature Certificate's additionalOutputFormats is now correctly validated at admission time, and no longer only validated if the privateKey field of the Certificate is set. The Webhook component now contains a separate feature set. AdditionalCertificateOutputFormats feature gate (disabled by default) has been added to the webhook. This gate is required to be enabled on both the controller and webhook components in order to make use of the Certificate's additionalOutputFormat feature. ( #4816 , @JoshVanL ) v1.7.0 \u00b6 Breaking Changes (You MUST read this before you upgrade!) \u00b6 Removal of Deprecated APIs \u00b6 \u26a0 Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 have been removed. You must ensure that all cert-manager custom resources are stored in etcd at version v1 and that all cert-manager CustomResourceDefinition s have only v1 as the stored version before upgrading. Since release 1.7, cmctl can automatically migrate any deprecated API resources. Please [download cmctl-v1.7.1 ] and read Migrating Deprecated API Resources for full instructions. Ingress Class Semantics \u00b6 In 1.7, we have reverted a change that caused a regression in the ACME Issuer. Before v1.5.4, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. Since v1.5.4, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager v1.5.4, 1.6.0, and 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.7, we have restored the original behavior which is to use the annotation. We also backported this fix to 1.5.5 and 1.6.2, allowing people to upgrade safely. Most people won't have any trouble upgrading from a version that contains the regression to 1.7.0, 1.6.2 or 1.5.5. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility . Upgrading with Server Side Apply \u00b6 As part of the work to remove deprecated APIs cert-manager CustomResourceDefinition s no longer require a conversion webhook. The related change in cert-manager CustomResourceDefinition specs results in invalid CustomResourceDefinition configurations for users who are upgrading to cert-manager 1.7 using kubectl apply --server-side=true -f <manifests> . This can be solved either by performing the upgrade with client side apply or by manually patching the managed fields of cert-manager CustomResourceDefinitions : crds =( \"certificaterequests.cert-manager.io\" \"certificates.cert-manager.io\" \"challenges.acme.cert-manager.io\" \"clusterissuers.cert-manager.io\" \"issuers.cert-manager.io\" \"orders.acme.cert-manager.io\" ) for crd in \" ${ crds [@] } \" ; do manager_index = \" $( kubectl get crd \" ${ crd } \" --show-managed-fields --output json | jq -r '.metadata.managedFields | map(.manager == \"cainjector\") | index(true)' ) \" kubectl patch crd \" ${ crd } \" --type = json -p = \"[{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/metadata/managedFields/ ${ manager_index } \\\"}]\" done Thanks to @stevehipwell for the above patch commands. See the original GitHub issue cert-manager#4831 Major Themes \u00b6 Removal of Deprecated APIs \u00b6 In 1.7 the cert-manager API versions v1alpha2, v1alpha3, and v1beta1, that were deprecated in 1.4, have been removed from the custom resource definitions (CRDs). As a result, you will notice that the YAML manifest files are much smaller. In this release we have added a new sub-command to the cert-manager CLI ( cmctl upgrade migrate-api-version ), which you SHOULD run BEFORE upgrading cert-manager to 1.7. Please read [Removing Deprecated API Resources] for full instructions. Additional Certificate Output Formats \u00b6 additionalOutputFormats is a field on the Certificate spec that allows specifying additional supplementary formats of issued certificates and their private key. There are currently two supported additional output formats: CombinedPEM (the PEM-encoded private key followed by the certificate chain) and DER (the DER-encoded private key only). Any combination of output formats can be requested for the same certificate. Read Additional Certificate Output Formats for more details and thanks to @seuf for getting this across the line! Server-Side Apply \u00b6 This is the first version of cert-manager which relies on Server-Side Apply . We use it to properly manage the annotations and labels on TLS secrets. For this reason cert-manager 1.7 requires at least Kubernetes 1.18 (see Supported Releases for further compatibility details). Configuration Files \u00b6 In this release we introduce a new configuration file for the cert-manager-webhook. Instead of configuring the webhook using command line flags, you can now modify the webhook Deployment to mount a ConfigMap containing a configuration file. Read the WebhookConfiguration Schema for more information. In future releases we will introduce configuration files for the other cert-manager components: the controller and the cainjector. Developing cert-manager Without Bazel \u00b6 In a future release, we'll remove the use of bazel for building and testing cert-manager, with the aim of making it as easy as possible for anyone to contribute and to get involved with the cert-manager project. The work is ongoing , but for now we've ensured that cert-manager 1.7 can be built with go build , and that all unit tests can be run with go test ./cmd/... ./internal/... ./pkg/... . Community \u00b6 Thanks again to all open-source contributors with commits in this release, including: @Adphi @devholic @johnwchadwick @jsoref @jwenz723 @seuf @thirdeyenick And thanks as usual to coderanger for helping people out on the [ #cert-manager Slack channel]; it's a huge help and much appreciated. Changelog since v1.6.0 \u00b6 Feature \u00b6 Add --acme-http01-solver-nameservers flag to enable custom nameservers usage for ACME HTT01 challenges propagation checks. ( #4287 , @Adphi ) Add cmctl upgrade migrate-api-version to ensure all CRD resources are stored at 'v1' prior to upgrading to v1.7 onwards ( #4711 , @munnerz ) Add goimports verification step for CI ( #4710 , @SgtCoDFish ) Add support for loading webhook flags/options from a WebhookConfiguration file on disk ( #4546 , @munnerz ) Added additionalOutputFormats parameter to allow DER (binary) and CombinedPEM (key + cert bundle) formats. ( #4598 , @seuf ) Added a makefile based build workflow which doesn't depend on bazel ( #4554 , @SgtCoDFish ) Added a new Helm chart parameter prometheus.servicemonitor.honorLabels , which sets the honor_labels field of the Prometheus scrape config. ( #4608 , @thirdeyenick ) Breaking change: pprof now runs by default on localhost:6060 on the webhook and the controller, but only if explicitly enabled. Pprof can now be enabled also for cainjector. All three components have --enable-profiling , --profiler-address CLI flags to configure profiling. Thanks to @bitscuit for help with this! ( #4550 , @irbekrm ) Certificate Secrets are now managed by the APPLY API call, rather than UPDATE/CREATE. The issuing controller actively reconciles Certificate SecretTemplate's against corresponding Secrets, garbage collecting and correcting key/value changes. ( #4638 , @JoshVanL ) Bug or Regression \u00b6 Ensures 1 hour backoff between errored calls for new ACME Orders. ( #4616 , @irbekrm ) Fix unexpected exit when multiple DNS providers are passed to RunWebhookServer ( #4702 , @devholic ) Fixed a bug that can cause cmctl version to erroneously display the wrong webhook pod versions when older failed pods are present. ( #4615 , @johnwchadwick ) Fixes a bug where a previous failed CertificateRequest was picked up during the next issuance. Thanks to @MattiasGees for raising the issue and help with debugging! ( #4688 , @irbekrm ) Fixes an issue in cmctl that prevented displaying the Order resource with cert-manager 1.6 when running cmctl status certificate . ( #4569 , @maelvls ) Improve checksum validation in makefile based tool installation ( #4680 , @SgtCoDFish ) The HTTP-01 ACME solver now uses the kubernetes.io/ingress.class annotation instead of the spec.ingressClassName in created Ingress resources. ( #4762 , @jakexks ) The cmctl experimental install command now uses the cert-manager namespace. This fixes a bug which was introduced in release 1.6 that caused cert-manager to be installed in the default namespace. ( #4763 , @wallrj ) Fixed a bug in the way the Helm chart handles service annotations on the controller and webhook services. ( #4329 , @jwenz723 ) Update to latest version of keystore-go to address a backwards incompatible change introduced in v1.6.0 ( #4563 , @SgtCoDFish ) Other (Cleanup or Flake) \u00b6 Adds clock_time_seconds_gauge metric which returns the current clock time, based on seconds since 1970/01/01 UTC ( #4640 , @JoshVanL ) Adds an automated script for cert-manager developers to update versions of kind used for development and testing. ( #4574 , @SgtCoDFish ) Breaking change: removes the deprecated dns01-self-check-nameservers flag. Use --dns01-recursive-nameservers instead. ( #4551 , @irbekrm ) Bump kind image versions ( #4593 , @SgtCoDFish ) Clean up: Remove v1beta1 form the webhook's admissionReviewVersions as cert-manager no longer supports v1.16 ( #4639 , @JoshVanL ) Cleanup: Pipe feature gate flag to the e2e binary. Test against shared Feature Gate map for feature enabled and whether they should be tested against. ( #4703 , @JoshVanL ) Ensures that in cases where an attempt to finalize an already finalized order is made, the originally issued certificate is used (instead of erroring and creating a new ACME order) ( #4697 , @irbekrm ) No longer log an error when a Certificate is deleted during normal operation. ( #4637 , @JoshVanL ) Removed deprecated API versions from the cert-manager CRDs ( #4635 , @wallrj ) Update distroless base images for cert-manager ( #4706 , @SgtCoDFish ) Upgrade Kubernetes dependencies to v0.23.1 ( #4675 , @munnerz )","title":"Release 1.7"},{"location":"release-notes/release-notes-1.7/#v173","text":"v1.7.3 is in effect a bug fix release which increases some hard-coded timeouts which were preventing the use of certain ACME issuers which sometimes had slower response times. This is known to include ZeroSSL and Sectigo. These issues were reported by many users, who we listed and thanked on the GitHub release .","title":"v1.7.3"},{"location":"release-notes/release-notes-1.7/#changes-since-v172","text":"","title":"Changes since v1.7.2"},{"location":"release-notes/release-notes-1.7/#bug","text":"Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5232 , @JoooostB @SgtCoDFish )","title":"Bug"},{"location":"release-notes/release-notes-1.7/#other-cleanup","text":"Bumps go to 1.17.11 and bumps base images to latest distroless images ( #5234 , @SgtCoDFish )","title":"Other (Cleanup)"},{"location":"release-notes/release-notes-1.7/#v172","text":"","title":"v1.7.2"},{"location":"release-notes/release-notes-1.7/#changes-since-171","text":"","title":"Changes since 1.7.1"},{"location":"release-notes/release-notes-1.7/#bug-or-regression","text":"Bumps the version of Go used to build the cert-manager binaries to 1.17.8, to fix a slew of CVEs (none of which were likely to be exploited) ( #4976 , @vhosakot ) Fixes an expired hardcoded certificate which broke unit tests ( #4978 , @SgtCoDFish , @jakexks )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.7/#v171","text":"","title":"v1.7.1"},{"location":"release-notes/release-notes-1.7/#changes-since-v170","text":"","title":"Changes since v1.7.0"},{"location":"release-notes/release-notes-1.7/#bug-or-regression_1","text":"Fix: The alpha feature Certificate's additionalOutputFormats is now correctly validated at admission time, and no longer only validated if the privateKey field of the Certificate is set. The Webhook component now contains a separate feature set. AdditionalCertificateOutputFormats feature gate (disabled by default) has been added to the webhook. This gate is required to be enabled on both the controller and webhook components in order to make use of the Certificate's additionalOutputFormat feature. ( #4816 , @JoshVanL )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.7/#v170","text":"","title":"v1.7.0"},{"location":"release-notes/release-notes-1.7/#breaking-changes-you-must-read-this-before-you-upgrade","text":"","title":"Breaking Changes (You MUST read this before you upgrade!)"},{"location":"release-notes/release-notes-1.7/#removal-of-deprecated-apis","text":"\u26a0 Following their deprecation in version 1.4, the cert-manager API versions v1alpha2, v1alpha3, and v1beta1 have been removed. You must ensure that all cert-manager custom resources are stored in etcd at version v1 and that all cert-manager CustomResourceDefinition s have only v1 as the stored version before upgrading. Since release 1.7, cmctl can automatically migrate any deprecated API resources. Please [download cmctl-v1.7.1 ] and read Migrating Deprecated API Resources for full instructions.","title":"Removal of Deprecated APIs"},{"location":"release-notes/release-notes-1.7/#ingress-class-semantics","text":"In 1.7, we have reverted a change that caused a regression in the ACME Issuer. Before v1.5.4, the Ingress created by cert-manager while solving an HTTP-01 challenge contained the kubernetes.io/ingress.class annotation: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : kubernetes.io/ingress.class : istio # The `class` present on the Issuer. Since v1.5.4, the Ingress does not contain the annotation anymore. Instead, cert-manager uses the ingressClassName field: apiVersion : networking.k8s.io/v1 kind : Ingress spec : ingressClassName : istio # \ud83d\udd25 Breaking change! This broke many users that either don't use an Ingress controller that supports the field (such as ingress-gce and Azure AGIC), as well as people who did not need to create an IngressClass previously (such as with Istio and Traefik). The regression is present in cert-manager v1.5.4, 1.6.0, and 1.6.1. It is only present on Kubernetes 1.19+ and only appears when using an Issuer or ClusterIssuer with an ACME HTTP-01 solver configured. In 1.7, we have restored the original behavior which is to use the annotation. We also backported this fix to 1.5.5 and 1.6.2, allowing people to upgrade safely. Most people won't have any trouble upgrading from a version that contains the regression to 1.7.0, 1.6.2 or 1.5.5. If you are using Gloo, Contour, Skipper, or kube-ingress-aws-controller, you shouldn't have any issues. If you use the default \"class\" (e.g., istio for Istio) for Traefik, Istio, Ambassador, or ingress-nginx, then these should also continue to work without issue. If you are using Traefik, Istio, Ambassador, or ingress-nginx and you are using a non-default value for the class (e.g., istio-internal ), or if you experience any issues with your HTTP-01 challenges please read the notes on Ingress v1 compatibility .","title":"Ingress Class Semantics"},{"location":"release-notes/release-notes-1.7/#upgrading-with-server-side-apply","text":"As part of the work to remove deprecated APIs cert-manager CustomResourceDefinition s no longer require a conversion webhook. The related change in cert-manager CustomResourceDefinition specs results in invalid CustomResourceDefinition configurations for users who are upgrading to cert-manager 1.7 using kubectl apply --server-side=true -f <manifests> . This can be solved either by performing the upgrade with client side apply or by manually patching the managed fields of cert-manager CustomResourceDefinitions : crds =( \"certificaterequests.cert-manager.io\" \"certificates.cert-manager.io\" \"challenges.acme.cert-manager.io\" \"clusterissuers.cert-manager.io\" \"issuers.cert-manager.io\" \"orders.acme.cert-manager.io\" ) for crd in \" ${ crds [@] } \" ; do manager_index = \" $( kubectl get crd \" ${ crd } \" --show-managed-fields --output json | jq -r '.metadata.managedFields | map(.manager == \"cainjector\") | index(true)' ) \" kubectl patch crd \" ${ crd } \" --type = json -p = \"[{\\\"op\\\": \\\"remove\\\", \\\"path\\\": \\\"/metadata/managedFields/ ${ manager_index } \\\"}]\" done Thanks to @stevehipwell for the above patch commands. See the original GitHub issue cert-manager#4831","title":"Upgrading with Server Side Apply"},{"location":"release-notes/release-notes-1.7/#major-themes","text":"","title":"Major Themes"},{"location":"release-notes/release-notes-1.7/#removal-of-deprecated-apis_1","text":"In 1.7 the cert-manager API versions v1alpha2, v1alpha3, and v1beta1, that were deprecated in 1.4, have been removed from the custom resource definitions (CRDs). As a result, you will notice that the YAML manifest files are much smaller. In this release we have added a new sub-command to the cert-manager CLI ( cmctl upgrade migrate-api-version ), which you SHOULD run BEFORE upgrading cert-manager to 1.7. Please read [Removing Deprecated API Resources] for full instructions.","title":"Removal of Deprecated APIs"},{"location":"release-notes/release-notes-1.7/#additional-certificate-output-formats","text":"additionalOutputFormats is a field on the Certificate spec that allows specifying additional supplementary formats of issued certificates and their private key. There are currently two supported additional output formats: CombinedPEM (the PEM-encoded private key followed by the certificate chain) and DER (the DER-encoded private key only). Any combination of output formats can be requested for the same certificate. Read Additional Certificate Output Formats for more details and thanks to @seuf for getting this across the line!","title":"Additional Certificate Output Formats"},{"location":"release-notes/release-notes-1.7/#server-side-apply","text":"This is the first version of cert-manager which relies on Server-Side Apply . We use it to properly manage the annotations and labels on TLS secrets. For this reason cert-manager 1.7 requires at least Kubernetes 1.18 (see Supported Releases for further compatibility details).","title":"Server-Side Apply"},{"location":"release-notes/release-notes-1.7/#configuration-files","text":"In this release we introduce a new configuration file for the cert-manager-webhook. Instead of configuring the webhook using command line flags, you can now modify the webhook Deployment to mount a ConfigMap containing a configuration file. Read the WebhookConfiguration Schema for more information. In future releases we will introduce configuration files for the other cert-manager components: the controller and the cainjector.","title":"Configuration Files"},{"location":"release-notes/release-notes-1.7/#developing-cert-manager-without-bazel","text":"In a future release, we'll remove the use of bazel for building and testing cert-manager, with the aim of making it as easy as possible for anyone to contribute and to get involved with the cert-manager project. The work is ongoing , but for now we've ensured that cert-manager 1.7 can be built with go build , and that all unit tests can be run with go test ./cmd/... ./internal/... ./pkg/... .","title":"Developing cert-manager Without Bazel"},{"location":"release-notes/release-notes-1.7/#community","text":"Thanks again to all open-source contributors with commits in this release, including: @Adphi @devholic @johnwchadwick @jsoref @jwenz723 @seuf @thirdeyenick And thanks as usual to coderanger for helping people out on the [ #cert-manager Slack channel]; it's a huge help and much appreciated.","title":"Community"},{"location":"release-notes/release-notes-1.7/#changelog-since-v160","text":"","title":"Changelog since v1.6.0"},{"location":"release-notes/release-notes-1.7/#feature","text":"Add --acme-http01-solver-nameservers flag to enable custom nameservers usage for ACME HTT01 challenges propagation checks. ( #4287 , @Adphi ) Add cmctl upgrade migrate-api-version to ensure all CRD resources are stored at 'v1' prior to upgrading to v1.7 onwards ( #4711 , @munnerz ) Add goimports verification step for CI ( #4710 , @SgtCoDFish ) Add support for loading webhook flags/options from a WebhookConfiguration file on disk ( #4546 , @munnerz ) Added additionalOutputFormats parameter to allow DER (binary) and CombinedPEM (key + cert bundle) formats. ( #4598 , @seuf ) Added a makefile based build workflow which doesn't depend on bazel ( #4554 , @SgtCoDFish ) Added a new Helm chart parameter prometheus.servicemonitor.honorLabels , which sets the honor_labels field of the Prometheus scrape config. ( #4608 , @thirdeyenick ) Breaking change: pprof now runs by default on localhost:6060 on the webhook and the controller, but only if explicitly enabled. Pprof can now be enabled also for cainjector. All three components have --enable-profiling , --profiler-address CLI flags to configure profiling. Thanks to @bitscuit for help with this! ( #4550 , @irbekrm ) Certificate Secrets are now managed by the APPLY API call, rather than UPDATE/CREATE. The issuing controller actively reconciles Certificate SecretTemplate's against corresponding Secrets, garbage collecting and correcting key/value changes. ( #4638 , @JoshVanL )","title":"Feature"},{"location":"release-notes/release-notes-1.7/#bug-or-regression_2","text":"Ensures 1 hour backoff between errored calls for new ACME Orders. ( #4616 , @irbekrm ) Fix unexpected exit when multiple DNS providers are passed to RunWebhookServer ( #4702 , @devholic ) Fixed a bug that can cause cmctl version to erroneously display the wrong webhook pod versions when older failed pods are present. ( #4615 , @johnwchadwick ) Fixes a bug where a previous failed CertificateRequest was picked up during the next issuance. Thanks to @MattiasGees for raising the issue and help with debugging! ( #4688 , @irbekrm ) Fixes an issue in cmctl that prevented displaying the Order resource with cert-manager 1.6 when running cmctl status certificate . ( #4569 , @maelvls ) Improve checksum validation in makefile based tool installation ( #4680 , @SgtCoDFish ) The HTTP-01 ACME solver now uses the kubernetes.io/ingress.class annotation instead of the spec.ingressClassName in created Ingress resources. ( #4762 , @jakexks ) The cmctl experimental install command now uses the cert-manager namespace. This fixes a bug which was introduced in release 1.6 that caused cert-manager to be installed in the default namespace. ( #4763 , @wallrj ) Fixed a bug in the way the Helm chart handles service annotations on the controller and webhook services. ( #4329 , @jwenz723 ) Update to latest version of keystore-go to address a backwards incompatible change introduced in v1.6.0 ( #4563 , @SgtCoDFish )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.7/#other-cleanup-or-flake","text":"Adds clock_time_seconds_gauge metric which returns the current clock time, based on seconds since 1970/01/01 UTC ( #4640 , @JoshVanL ) Adds an automated script for cert-manager developers to update versions of kind used for development and testing. ( #4574 , @SgtCoDFish ) Breaking change: removes the deprecated dns01-self-check-nameservers flag. Use --dns01-recursive-nameservers instead. ( #4551 , @irbekrm ) Bump kind image versions ( #4593 , @SgtCoDFish ) Clean up: Remove v1beta1 form the webhook's admissionReviewVersions as cert-manager no longer supports v1.16 ( #4639 , @JoshVanL ) Cleanup: Pipe feature gate flag to the e2e binary. Test against shared Feature Gate map for feature enabled and whether they should be tested against. ( #4703 , @JoshVanL ) Ensures that in cases where an attempt to finalize an already finalized order is made, the originally issued certificate is used (instead of erroring and creating a new ACME order) ( #4697 , @irbekrm ) No longer log an error when a Certificate is deleted during normal operation. ( #4637 , @JoshVanL ) Removed deprecated API versions from the cert-manager CRDs ( #4635 , @wallrj ) Update distroless base images for cert-manager ( #4706 , @SgtCoDFish ) Upgrade Kubernetes dependencies to v0.23.1 ( #4675 , @munnerz )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.8/","text":"v1.8.2 \u00b6 v1.8.2 is in effect a bug fix release which increases some hard-coded timeouts which were preventing the use of certain ACME issuers which sometimes had slower response times. This is known to include ZeroSSL and Sectigo. These issues were reported by many users, who we listed and thanked on the GitHub release . Changes since v1.8.1 \u00b6 Bug \u00b6 Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5231 , @JoooostB @SgtCoDFish ) Other (Cleanup or Flake) \u00b6 Bump distroless base images to latest versions ( #5235 , @SgtCoDFish ) v1.8.1 \u00b6 v1.8.1 is a patch release rebuilding cert-manager 1.8 using the latest version of Go, and reverting a previous commit which had negatively affected some GitOps workflows. Changes since v1.8.0 \u00b6 Bug \u00b6 Reverts a check for Prometheus APIs before creating cert-manager ServiceMonitor s which broke users' GitOps flows ( #5204 ) Cleanup \u00b6 Bumps the version of Go used to build the cert-manager binaries to 1.17.11 which fixes a few CVEs (although we don't think that any of those CVEs were likely to be exploited in cert-manager) ( #5203 , @irbekrm ) v1.8.0 \u00b6 cert-manager 1.8 includes wider support for Kubernetes server-side-apply, a new build and development experience based around Makefile s rather than Bazel, and a range of other improvements, tweaks and bug fixes. Version 1.8 also marks our first release in which the Go import path for cert-manager is that of the repo's new home: github.com/cert-manager/cert-manager Breaking Changes (You MUST read this before you upgrade!) \u00b6 Validation of the rotationPolicy field \u00b6 The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. If you are using a GitOps flow and one of your YAML manifests contains a Certificate with an invalid value, you will need to update it with a valid value to prevent your GitOps tool from failing on the new validation. Please follow the instructions listed on the page Upgrading from v1.7 to v1.8 . ( #4913 , @jahrlin ) What happens if I upgrade to 1.8.0 without doing the above steps? \u00b6 After upgrading to 1.8.0, when updating existing Certificate objects that have an incorrect value for rotationPolicy , Kubernetes clients such as kubectl, Helm, or ArgoCD will start showing the following message: Certificate.cert-manager.io \"my-cert\" is invalid: spec.privateKey.rotationPolicy: Unsupported value: \"Foo\": supported values: \"Never\", \"Always\". Why was this change necessary? \u00b6 Previously, when the value of the rotationPolicy field was set to an incorrect value, you would not know since no event or condition would be visible on the Certificate itself. The only way to know that something was wrong was to dig into the cert-manager-controller logs and see the message \"Certificate with unknown certificate.spec.privateKey.rotationPolicy value\": I0329 12:43:13.325771 1 keymanager_controller.go:176] cert-manager/certificates-key-manager \"msg\"=\"Certificate with unknown certificate.spec.privateKey.rotationPolicy value\" \"key\"=\"default/my-cert\" \"rotation_policy\"=\"Foo\" This change was implemented in #4913 . Changed Container Layouts \u00b6 This only affects you if you're modifying cert-manager containers in some way, such as adding init scripts or otherwise changing how the binaries inside the containers are called. Bazel has a unique way of creating containers, which places the actual binary at a long unusual path. For the v1.7.0 cert-manager-webhook container for example, the binary is placed at /app/cmd/webhook/webhook.runfiles/com_github_jetstack_cert_manager/cmd/webhook/webhook_/webhook and /app/cmd/webhook/webhook is provided as a symlink to the binary. This is simplified in our new build system; we only place a single binary at /app/cmd/webhook/webhook and the old path disappears. This applies to all cert-manager containers. We also removed the \"LICENSES\" file from the containers and replaced it with a link to the cert-manager repo. .exe Extension on Windows \u00b6 We package cmctl and kubectl_cert-manager for Windows on amd64 platforms, but previously the binaries had the same names as the binaries on other platforms, e.g. cmctl with no file extension. In 1.8.0 and later, the binaries now have a .exe extension since this is standard practice on Windows. This could affect you if you're calling the binary in a Powershell script, for example. We've also now added zip-compressed versions of the cmctl and kubectl_cert-manager binaries on Windows, since .tar.gz is less common on Windows. Changed Import Path \u00b6 This will only affect you if you're writing code in Go which imports cert-manager as a module, which we generally recommend against doing in most cases. All versions of cert-manager prior to v1.8.0 used a Go import path corresponding to the old cert-manager repository, github.com/jetstack/cert-manager . v1.8.0 marks the first release in which the import path changes to the new location, github.com/cert-manager/cert-manager . We have a guide for Importing cert-manager in Go on cert-manager.io with all the details, including details on why we don't recommend importing cert-manager as a module if that's avoidable. Major Themes \u00b6 Server-Side Apply \u00b6 cert-manager v1.8.0 adds initial support for Kubernetes Server-Side Apply , which became stable in Kubernetes 1.22. This support is behind a feature gate for now, and is only supported by cert-manager on Kubernetes 1.22 and later. Server-Side Apply helps to ensure that changes to resources are made in a managed way, and aims to prevent certain classes of bugs. Notably, it should eliminate conflicts when multiple controllers try to apply status changes to a single resource. You'll likely have seen messages relating to this kind of conflict in logs before, e.g.: I0119 12:34:56.000000 1 controller.go:161] cert-manager/controller/certificaterequests-issuer-acme \"msg\"=\"re-queuing item due to optimistic locking on resource\" \"key\"=\"my-namespace/my-cr\" \"error\"=\"Operation cannot be fulfilled on certificaterequests.cert-manager.io \\\"my-cr\\\": the object has been modified; please apply your changes to the latest version and try again\" These conflicts aren't usually actually a problem which will block the issuance of a certificate, but they can delay things as they cause extra reconcile loops. Server-side apply cleans things up, which should mean less noise in logs and fewer pointless reconcile loops. If you want to test it out, you can enable alpha-level cert-manager Server-Side Apply support through the --feature-gates controller flag . From Bazel to Make \u00b6 A common theme when someone tries to make a change to cert-manager for the first time is that they ask for help with navigating Bazel, which cert-manager used as its build tool. Helping people with Bazel isn't easy; it's an incredibly powerful tool, but that power also brings a lot of complications which can seriously get in the way of being able to make even simple changes to the code base. Even developers who are familiar with contributing to open source projects in Go can find it daunting to make changes thanks to Bazel. The problem isn't limited to open-source contributors; many of cert-manager's maintainers also struggle with configuring and changing Bazel, too. cert-manager 1.8 is the first release which is built and tested using a newly written make -based build system. We believe that this new build system should make it much simpler to understand and change the commands which are being run behind the scenes to build and test cert-manager. In time, we'll fully document the new build system, ensure it's at full feature-parity with Bazel and then remove all references to Bazel across the codebase. A neat side effect of this change is that our build times have significantly improved. Bazel took around 14 minutes to build every cert-manager artifact for every platform during a release, while the new make build system can do the same (and more) in under 5 minutes. Exponential backoff after a failed issuance \u00b6 cert-manager v1.8.0 introduces exponential backoff after failed certificate issuance . Previously, a failed issuance was retried every hour which \u2014 especially in larger cert-manager installations \u2014 could cause rate limits to be hit as well as overwhelm external services. Failed attempts are now retried with a binary exponential backoff starting with 1h then 2h , 4h up to a maximum of 32h . As part of the new backoff behavior, a new failedIssuanceAttempts field was added to the Certificate spec to track the number of currently failed issuances. The cmctl renew command command can still be used to force Certificate renewal immediately. We're also considering reducing the initial backoff from 1 hour. If you have a use case where this would be useful please do comment on our tracking issue . Changelog since v1.7.0 \u00b6 Feature \u00b6 ACTION REQUIRED: The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. If you are using a GitOps flow and one of your YAML manifests contains a Certificate with an invalid value, you will need to update it with a valid value to prevent your GitOps tool from failing on the new validation. ( #4913 , @jahrlin ) Build: add make targets for running unit and integration tests, as part of the Bazel replacement. ( #4865 , @SgtCoDFish ) Build: add make targets for running the end-to-end tests, as part of the Bazel replacement. ( #4914 , @maelvls ) cert-manager now supports the field spec.expirationSeconds on Kubernetes CertificateSigningRequest resources. Using this field requires Kubernetes 1.22. You can still use the annotation experimental.cert-manager.io/request-duration to request a duration. ( #4957 , @enj ) cert-manager now properly updates the content of the data keys tls-combined.pem and key.der on Secret resources that are associated to Certificate resources that use the field additionalOutputFormats . The field additionalOutputFormat is an alpha feature and can be enabled by passing the flag --feature-gates=AdditionalCertificateOutputFormats=true to the cert-manager controller. ( #4813 , @JoshVanL ) ClusterRoles aggregation to user-facing admin/edit/view ClusterRoles can be optionally turned off ( #4937 , @illrill ) ACTION REQUIRED: Server-Side Apply: the feature gate ServerSideApply=true now configures the ingress-shim and gateway-shim controllers to use Kubernetes Server-Side Apply on Certificate resources. When upgrading to cert-manager 1.8 with ServerSideApply=true , do make sure there are no Challenge resources currently in the cluster. If there are some, you will need to manually delete them once they are in 'valid' state as cert-manager post-1.8 with the Server-Side Apply feature is not able to clean up Challenge resources created pre-1.8. ( #4811 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the certificaterequests-* controllers to use Kubernetes Server-Side Apply on CertificateRequest resources. ( #4792 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the certificates-* controllers to use Kubernetes Server-Side Apply on Certificate resources. ( #4777 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the CertificateSigningRequest controllers to use Kubernetes Server-Side Apply on CertificateSigningRequest resources. ( #4798 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the issuers and clusterissuers controllers to use Kubernetes Server-Side Apply on Issuer and ClusterIssuer resources. ( #4794 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the orders controller to use Kubernetes Server-Side Apply on Order resources. ( #4799 , @JoshVanL ) The annotation experimental.cert-manager.io/request-duration now has a minimum value of 600 seconds. This annotation This change ensures compatibility with the Kubernetes resource CertificateSigningRequest, which requires a minimum of 600 seconds on the field spec.expirationSeconds . ( #4973 , @irbekrm ) The annotation ingress.kubernetes.io/whitelist-source-range used by the Ingress shim when creating Ingress resources can now be overridden by setting the field ingressTemplate on the Issuer and ClusterIssuer. ( #4789 , @tasharnvb ) The experimental Gateway API support now uses the v1alpha2 CRDs. ( #4791 , @jakexks ) The user-agent used by cert-manager in its Kubernetes API clients and ACME clients now takes the form cert-manager-<component name>/<version> (<os>/<arch>) cert-manager/<git commit> . Another change is the addition of specific field managers strings; previously, all the controllers had the same field manager cert-manager . Now, each controller has its own field manager string of the form cert-manager-<controller name> . ( #4773 , @JoshVanL ) You can now uninstall cert-manager using the command cmctl experimental uninstall . ( #4897 , @jahrlin ) You can now use an external issuer resource as the default issuer when using the Ingress shim feature. The default issuer can be set using the flags --default-issuer-group , --default-issuer-kind , and --default-issuer-name . ( #4833 , @jakexks ) Design \u00b6 ACTION REQUIRED: The import path for cert-manager has been updated to github.com/cert-manager/cert-manager . If you import cert-manager as a go module (which isn't currently recommended), you'll need to update the module import path in your code to import cert-manager 1.8 or later. ( #4587 , @SgtCoDFish ) Bug or Regression \u00b6 ACTION REQUIRED: The field additionalOutputFormats , which is available as an alpha feature on Certificate resources, is now correctly validated. Previously, it would only get validated when the privateKey field was set on the Certificate. If you are using the additionalOutputFormats field, you will want to add the feature gate AdditionalCertificateOutputFormats to both the webhook and the controller. Previously, you only needed to set AdditionalCertificateOutputFormats on the controller. If the feature gate is missing on either the controller or the webhook, you won't be able to use the additionalOutputFormat field. ( #4814 , @JoshVanL ) The Go version used to build the cert-manager binaries has been bumped to 1.17.8 to fix a slew of CVEs (none of which were likely to be exploited). ( #4970 , @vhosakot ) Helm: the default nodeSelector is now kubernetes.io/os: linux . If this label isn't present on any nodes in the cluster, the nodeSelector will need to be overwritten, or that label added to some nodes. ( #3605 , @mikebryant ) Use multivalue records instead of simple records for the AWS Route53 ACME DNS challenge solver, to allow for multiple challenges for the same domain at the same time ( #4793 , @fvlaicu ) Other (Cleanup or Flake) \u00b6 Aggregated admin and edit roles will now include permissions to update certificates' status, which will allow namespace admins and editors to run the cmctl renew command in their namespaces. ( #4955 , @andreadecorte ) Cleanup: No longer log an error when cert-manager encounters a conflict in the secrets manager, in favor of always force applying. ( #4815 , @JoshVanL ) Failed certificate issuances are now retried with an exponential backoff where the backoff periods are 1h , 2h , 4h , 8h , 16h , 32h . A new field failedIssuanceAttempts is now set by cert-manager on the Certificate status. This field keeps track of consecutive failed issuances. The backoff period gets reset after a successful issuance. Like before, updating a field on a failed Certificate (such as spec.dnsNames ) or running the command cmctl renew continues to trigger a re-issuance. ( #4772 , @irbekrm ) When starting up, cert-manager now solely relies on Lease objects to perform the leader election. Previously, cert-manager supported both ConfigMap and Lease objects for leader election. Existing ConfigMap resources used for leader election will remain and will need deleting manually. A side effect of this is that you cannot upgrade to v1.8.0 from cert-manager 1.3 (although upgrading multiple versions at a time was never supported). ( #4935 , @davidsbond ) Helm: you can now set custom labels on the ServiceAccount resources using the values serviceAccount.labels , cainjector.serviceAccount.labels , webhook.serviceAccount.labels , and startupapicheck.serviceAccount.labels . ( #4932 , @4molybdenum2 ) Uncategorized \u00b6 Introducing a new metric controller_sync_error_count counting the number of errors during sync() of a controller. ( #4987 , @jayme-github ) When creating an acmesolver pod, cert-manager now sets allowPrivilegeEscalation to false by default. The Helm chart now also sets securityContext.allowPrivilegeEscalation to false by default for the controller, cainjector, and webhook pods as well as for the startupapicheck job. ( #4953 , @ajvn )","title":"Release 1.8"},{"location":"release-notes/release-notes-1.8/#v182","text":"v1.8.2 is in effect a bug fix release which increases some hard-coded timeouts which were preventing the use of certain ACME issuers which sometimes had slower response times. This is known to include ZeroSSL and Sectigo. These issues were reported by many users, who we listed and thanked on the GitHub release .","title":"v1.8.2"},{"location":"release-notes/release-notes-1.8/#changes-since-v181","text":"","title":"Changes since v1.8.1"},{"location":"release-notes/release-notes-1.8/#bug","text":"Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5231 , @JoooostB @SgtCoDFish )","title":"Bug"},{"location":"release-notes/release-notes-1.8/#other-cleanup-or-flake","text":"Bump distroless base images to latest versions ( #5235 , @SgtCoDFish )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.8/#v181","text":"v1.8.1 is a patch release rebuilding cert-manager 1.8 using the latest version of Go, and reverting a previous commit which had negatively affected some GitOps workflows.","title":"v1.8.1"},{"location":"release-notes/release-notes-1.8/#changes-since-v180","text":"","title":"Changes since v1.8.0"},{"location":"release-notes/release-notes-1.8/#bug_1","text":"Reverts a check for Prometheus APIs before creating cert-manager ServiceMonitor s which broke users' GitOps flows ( #5204 )","title":"Bug"},{"location":"release-notes/release-notes-1.8/#cleanup","text":"Bumps the version of Go used to build the cert-manager binaries to 1.17.11 which fixes a few CVEs (although we don't think that any of those CVEs were likely to be exploited in cert-manager) ( #5203 , @irbekrm )","title":"Cleanup"},{"location":"release-notes/release-notes-1.8/#v180","text":"cert-manager 1.8 includes wider support for Kubernetes server-side-apply, a new build and development experience based around Makefile s rather than Bazel, and a range of other improvements, tweaks and bug fixes. Version 1.8 also marks our first release in which the Go import path for cert-manager is that of the repo's new home: github.com/cert-manager/cert-manager","title":"v1.8.0"},{"location":"release-notes/release-notes-1.8/#breaking-changes-you-must-read-this-before-you-upgrade","text":"","title":"Breaking Changes (You MUST read this before you upgrade!)"},{"location":"release-notes/release-notes-1.8/#validation-of-the-rotationpolicy-field","text":"The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. If you are using a GitOps flow and one of your YAML manifests contains a Certificate with an invalid value, you will need to update it with a valid value to prevent your GitOps tool from failing on the new validation. Please follow the instructions listed on the page Upgrading from v1.7 to v1.8 . ( #4913 , @jahrlin )","title":"Validation of the rotationPolicy field"},{"location":"release-notes/release-notes-1.8/#what-happens-if-i-upgrade-to-180-without-doing-the-above-steps","text":"After upgrading to 1.8.0, when updating existing Certificate objects that have an incorrect value for rotationPolicy , Kubernetes clients such as kubectl, Helm, or ArgoCD will start showing the following message: Certificate.cert-manager.io \"my-cert\" is invalid: spec.privateKey.rotationPolicy: Unsupported value: \"Foo\": supported values: \"Never\", \"Always\".","title":"What happens if I upgrade to 1.8.0 without doing the above steps?"},{"location":"release-notes/release-notes-1.8/#why-was-this-change-necessary","text":"Previously, when the value of the rotationPolicy field was set to an incorrect value, you would not know since no event or condition would be visible on the Certificate itself. The only way to know that something was wrong was to dig into the cert-manager-controller logs and see the message \"Certificate with unknown certificate.spec.privateKey.rotationPolicy value\": I0329 12:43:13.325771 1 keymanager_controller.go:176] cert-manager/certificates-key-manager \"msg\"=\"Certificate with unknown certificate.spec.privateKey.rotationPolicy value\" \"key\"=\"default/my-cert\" \"rotation_policy\"=\"Foo\" This change was implemented in #4913 .","title":"Why was this change necessary?"},{"location":"release-notes/release-notes-1.8/#changed-container-layouts","text":"This only affects you if you're modifying cert-manager containers in some way, such as adding init scripts or otherwise changing how the binaries inside the containers are called. Bazel has a unique way of creating containers, which places the actual binary at a long unusual path. For the v1.7.0 cert-manager-webhook container for example, the binary is placed at /app/cmd/webhook/webhook.runfiles/com_github_jetstack_cert_manager/cmd/webhook/webhook_/webhook and /app/cmd/webhook/webhook is provided as a symlink to the binary. This is simplified in our new build system; we only place a single binary at /app/cmd/webhook/webhook and the old path disappears. This applies to all cert-manager containers. We also removed the \"LICENSES\" file from the containers and replaced it with a link to the cert-manager repo.","title":"Changed Container Layouts"},{"location":"release-notes/release-notes-1.8/#exe-extension-on-windows","text":"We package cmctl and kubectl_cert-manager for Windows on amd64 platforms, but previously the binaries had the same names as the binaries on other platforms, e.g. cmctl with no file extension. In 1.8.0 and later, the binaries now have a .exe extension since this is standard practice on Windows. This could affect you if you're calling the binary in a Powershell script, for example. We've also now added zip-compressed versions of the cmctl and kubectl_cert-manager binaries on Windows, since .tar.gz is less common on Windows.","title":".exe Extension on Windows"},{"location":"release-notes/release-notes-1.8/#changed-import-path","text":"This will only affect you if you're writing code in Go which imports cert-manager as a module, which we generally recommend against doing in most cases. All versions of cert-manager prior to v1.8.0 used a Go import path corresponding to the old cert-manager repository, github.com/jetstack/cert-manager . v1.8.0 marks the first release in which the import path changes to the new location, github.com/cert-manager/cert-manager . We have a guide for Importing cert-manager in Go on cert-manager.io with all the details, including details on why we don't recommend importing cert-manager as a module if that's avoidable.","title":"Changed Import Path"},{"location":"release-notes/release-notes-1.8/#major-themes","text":"","title":"Major Themes"},{"location":"release-notes/release-notes-1.8/#server-side-apply","text":"cert-manager v1.8.0 adds initial support for Kubernetes Server-Side Apply , which became stable in Kubernetes 1.22. This support is behind a feature gate for now, and is only supported by cert-manager on Kubernetes 1.22 and later. Server-Side Apply helps to ensure that changes to resources are made in a managed way, and aims to prevent certain classes of bugs. Notably, it should eliminate conflicts when multiple controllers try to apply status changes to a single resource. You'll likely have seen messages relating to this kind of conflict in logs before, e.g.: I0119 12:34:56.000000 1 controller.go:161] cert-manager/controller/certificaterequests-issuer-acme \"msg\"=\"re-queuing item due to optimistic locking on resource\" \"key\"=\"my-namespace/my-cr\" \"error\"=\"Operation cannot be fulfilled on certificaterequests.cert-manager.io \\\"my-cr\\\": the object has been modified; please apply your changes to the latest version and try again\" These conflicts aren't usually actually a problem which will block the issuance of a certificate, but they can delay things as they cause extra reconcile loops. Server-side apply cleans things up, which should mean less noise in logs and fewer pointless reconcile loops. If you want to test it out, you can enable alpha-level cert-manager Server-Side Apply support through the --feature-gates controller flag .","title":"Server-Side Apply"},{"location":"release-notes/release-notes-1.8/#from-bazel-to-make","text":"A common theme when someone tries to make a change to cert-manager for the first time is that they ask for help with navigating Bazel, which cert-manager used as its build tool. Helping people with Bazel isn't easy; it's an incredibly powerful tool, but that power also brings a lot of complications which can seriously get in the way of being able to make even simple changes to the code base. Even developers who are familiar with contributing to open source projects in Go can find it daunting to make changes thanks to Bazel. The problem isn't limited to open-source contributors; many of cert-manager's maintainers also struggle with configuring and changing Bazel, too. cert-manager 1.8 is the first release which is built and tested using a newly written make -based build system. We believe that this new build system should make it much simpler to understand and change the commands which are being run behind the scenes to build and test cert-manager. In time, we'll fully document the new build system, ensure it's at full feature-parity with Bazel and then remove all references to Bazel across the codebase. A neat side effect of this change is that our build times have significantly improved. Bazel took around 14 minutes to build every cert-manager artifact for every platform during a release, while the new make build system can do the same (and more) in under 5 minutes.","title":"From Bazel to Make"},{"location":"release-notes/release-notes-1.8/#exponential-backoff-after-a-failed-issuance","text":"cert-manager v1.8.0 introduces exponential backoff after failed certificate issuance . Previously, a failed issuance was retried every hour which \u2014 especially in larger cert-manager installations \u2014 could cause rate limits to be hit as well as overwhelm external services. Failed attempts are now retried with a binary exponential backoff starting with 1h then 2h , 4h up to a maximum of 32h . As part of the new backoff behavior, a new failedIssuanceAttempts field was added to the Certificate spec to track the number of currently failed issuances. The cmctl renew command command can still be used to force Certificate renewal immediately. We're also considering reducing the initial backoff from 1 hour. If you have a use case where this would be useful please do comment on our tracking issue .","title":"Exponential backoff after a failed issuance"},{"location":"release-notes/release-notes-1.8/#changelog-since-v170","text":"","title":"Changelog since v1.7.0"},{"location":"release-notes/release-notes-1.8/#feature","text":"ACTION REQUIRED: The field spec.privateKey.rotationPolicy on Certificate resources is now validated. Valid options are Never and Always. If you are using a GitOps flow and one of your YAML manifests contains a Certificate with an invalid value, you will need to update it with a valid value to prevent your GitOps tool from failing on the new validation. ( #4913 , @jahrlin ) Build: add make targets for running unit and integration tests, as part of the Bazel replacement. ( #4865 , @SgtCoDFish ) Build: add make targets for running the end-to-end tests, as part of the Bazel replacement. ( #4914 , @maelvls ) cert-manager now supports the field spec.expirationSeconds on Kubernetes CertificateSigningRequest resources. Using this field requires Kubernetes 1.22. You can still use the annotation experimental.cert-manager.io/request-duration to request a duration. ( #4957 , @enj ) cert-manager now properly updates the content of the data keys tls-combined.pem and key.der on Secret resources that are associated to Certificate resources that use the field additionalOutputFormats . The field additionalOutputFormat is an alpha feature and can be enabled by passing the flag --feature-gates=AdditionalCertificateOutputFormats=true to the cert-manager controller. ( #4813 , @JoshVanL ) ClusterRoles aggregation to user-facing admin/edit/view ClusterRoles can be optionally turned off ( #4937 , @illrill ) ACTION REQUIRED: Server-Side Apply: the feature gate ServerSideApply=true now configures the ingress-shim and gateway-shim controllers to use Kubernetes Server-Side Apply on Certificate resources. When upgrading to cert-manager 1.8 with ServerSideApply=true , do make sure there are no Challenge resources currently in the cluster. If there are some, you will need to manually delete them once they are in 'valid' state as cert-manager post-1.8 with the Server-Side Apply feature is not able to clean up Challenge resources created pre-1.8. ( #4811 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the certificaterequests-* controllers to use Kubernetes Server-Side Apply on CertificateRequest resources. ( #4792 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the certificates-* controllers to use Kubernetes Server-Side Apply on Certificate resources. ( #4777 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the CertificateSigningRequest controllers to use Kubernetes Server-Side Apply on CertificateSigningRequest resources. ( #4798 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the issuers and clusterissuers controllers to use Kubernetes Server-Side Apply on Issuer and ClusterIssuer resources. ( #4794 , @JoshVanL ) Server-Side Apply: the feature gate ServerSideApply=true configures the orders controller to use Kubernetes Server-Side Apply on Order resources. ( #4799 , @JoshVanL ) The annotation experimental.cert-manager.io/request-duration now has a minimum value of 600 seconds. This annotation This change ensures compatibility with the Kubernetes resource CertificateSigningRequest, which requires a minimum of 600 seconds on the field spec.expirationSeconds . ( #4973 , @irbekrm ) The annotation ingress.kubernetes.io/whitelist-source-range used by the Ingress shim when creating Ingress resources can now be overridden by setting the field ingressTemplate on the Issuer and ClusterIssuer. ( #4789 , @tasharnvb ) The experimental Gateway API support now uses the v1alpha2 CRDs. ( #4791 , @jakexks ) The user-agent used by cert-manager in its Kubernetes API clients and ACME clients now takes the form cert-manager-<component name>/<version> (<os>/<arch>) cert-manager/<git commit> . Another change is the addition of specific field managers strings; previously, all the controllers had the same field manager cert-manager . Now, each controller has its own field manager string of the form cert-manager-<controller name> . ( #4773 , @JoshVanL ) You can now uninstall cert-manager using the command cmctl experimental uninstall . ( #4897 , @jahrlin ) You can now use an external issuer resource as the default issuer when using the Ingress shim feature. The default issuer can be set using the flags --default-issuer-group , --default-issuer-kind , and --default-issuer-name . ( #4833 , @jakexks )","title":"Feature"},{"location":"release-notes/release-notes-1.8/#design","text":"ACTION REQUIRED: The import path for cert-manager has been updated to github.com/cert-manager/cert-manager . If you import cert-manager as a go module (which isn't currently recommended), you'll need to update the module import path in your code to import cert-manager 1.8 or later. ( #4587 , @SgtCoDFish )","title":"Design"},{"location":"release-notes/release-notes-1.8/#bug-or-regression","text":"ACTION REQUIRED: The field additionalOutputFormats , which is available as an alpha feature on Certificate resources, is now correctly validated. Previously, it would only get validated when the privateKey field was set on the Certificate. If you are using the additionalOutputFormats field, you will want to add the feature gate AdditionalCertificateOutputFormats to both the webhook and the controller. Previously, you only needed to set AdditionalCertificateOutputFormats on the controller. If the feature gate is missing on either the controller or the webhook, you won't be able to use the additionalOutputFormat field. ( #4814 , @JoshVanL ) The Go version used to build the cert-manager binaries has been bumped to 1.17.8 to fix a slew of CVEs (none of which were likely to be exploited). ( #4970 , @vhosakot ) Helm: the default nodeSelector is now kubernetes.io/os: linux . If this label isn't present on any nodes in the cluster, the nodeSelector will need to be overwritten, or that label added to some nodes. ( #3605 , @mikebryant ) Use multivalue records instead of simple records for the AWS Route53 ACME DNS challenge solver, to allow for multiple challenges for the same domain at the same time ( #4793 , @fvlaicu )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.8/#other-cleanup-or-flake_1","text":"Aggregated admin and edit roles will now include permissions to update certificates' status, which will allow namespace admins and editors to run the cmctl renew command in their namespaces. ( #4955 , @andreadecorte ) Cleanup: No longer log an error when cert-manager encounters a conflict in the secrets manager, in favor of always force applying. ( #4815 , @JoshVanL ) Failed certificate issuances are now retried with an exponential backoff where the backoff periods are 1h , 2h , 4h , 8h , 16h , 32h . A new field failedIssuanceAttempts is now set by cert-manager on the Certificate status. This field keeps track of consecutive failed issuances. The backoff period gets reset after a successful issuance. Like before, updating a field on a failed Certificate (such as spec.dnsNames ) or running the command cmctl renew continues to trigger a re-issuance. ( #4772 , @irbekrm ) When starting up, cert-manager now solely relies on Lease objects to perform the leader election. Previously, cert-manager supported both ConfigMap and Lease objects for leader election. Existing ConfigMap resources used for leader election will remain and will need deleting manually. A side effect of this is that you cannot upgrade to v1.8.0 from cert-manager 1.3 (although upgrading multiple versions at a time was never supported). ( #4935 , @davidsbond ) Helm: you can now set custom labels on the ServiceAccount resources using the values serviceAccount.labels , cainjector.serviceAccount.labels , webhook.serviceAccount.labels , and startupapicheck.serviceAccount.labels . ( #4932 , @4molybdenum2 )","title":"Other (Cleanup or Flake)"},{"location":"release-notes/release-notes-1.8/#uncategorized","text":"Introducing a new metric controller_sync_error_count counting the number of errors during sync() of a controller. ( #4987 , @jayme-github ) When creating an acmesolver pod, cert-manager now sets allowPrivilegeEscalation to false by default. The Helm chart now also sets securityContext.allowPrivilegeEscalation to false by default for the controller, cainjector, and webhook pods as well as for the startupapicheck job. ( #4953 , @ajvn )","title":"Uncategorized"},{"location":"release-notes/release-notes-1.9/","text":"v1.9.2 \u00b6 cert-manager v1.9.2 is a bug fix release which fixes an issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests, and a problem which prevented the Venafi Issuer from connecting to TPP servers where the vedauth API endpoints were configured to accept client certificates. It is also compiled with a newer version of Go 1.18 ( v1.18.8 ) which fixes some vulnerabilities in the Go standard library. Changes since v1.9.1 \u00b6 Bug or Regression \u00b6 Fix issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests. ( #5371 , @munnerz ) The Venafi Issuer now supports TLS 1.2 renegotiation, so that it can connect to TPP servers where the vedauth API endpoints are configured to accept client certificates. (Note: This does not mean that the Venafi Issuer supports client certificate authentication). ( #5577 , @wallrj ) Upgrade to latest go patch release. ( #5561 , @SgtCoDFish ) v1.9.1 \u00b6 cert-manager v1.9.1 is a bug fix release which removes an incorrect check in the Route53 DNS solver. This accidental change prevented the use of credentials derived from instance metadata or AWS pod metadata. Changes since v1.9.0 \u00b6 Bug or Regression \u00b6 DNS Route53: Remove incorrect validation which rejects solvers that don't define either a accessKeyID or secretAccessKeyID . ( #5341 , @jetstack-bot ) v1.9.0 \u00b6 cert-manager v1.9.0 adds alpha support for using cert-manager Certificate s in scenarios where the ordering of the Relative Distinguished Names (RDN) sequence that constitutes an X.509 certificate's subject needs to be preserved; improves the ability to configure the Certificate created via ingress-shim using annotations on the Ingress resource; introduces various changes/improvements in contributor flow; and finishes the new make-based contributor workflow. Major Themes \u00b6 Literal Certificate Subjects \u00b6 cert-manager's Certificate allows users to configure the subject fields of the X.509 certificate via spec.subject and spec.commonName fields. The X.509 spec states that the subject is an (ordered) sequence of Relative Distinguished Names (RDN). cert-manager does not strictly abide by this spec when encoding the subject fields from the Certificate spec. For example, the order of the RDN sequence may not be preserved. This is because cert-manager uses Go's libraries for X.509 certificates, and the Go libraries don't preserve ordering. For the vast majority of users this does not matter, but there are specific cases that require defining the exact ordered RDN sequence. For example, if the certificate is used for LDAP authentication and the RDN sequence represents a location in LDAP directory tree . See cert-manager#3203 . For these use cases, a new alpha LiteralSubject field has been added to the Certificate spec where users can pass a literal RDN sequence: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : test spec : secretName : test literalSubject : \"C=US,O=myOrg,CN=someName\" To use this field, the alpha feature gate LiteralCertificateSubject needs to be enabled on both the cert-manager controller and webhook. Bear in mind that spec.literalSubject is mutually exclusive with spec.commonName and spec.subject . This feature is aimed at the specific scenario where an exact RDN sequence needs to be defined. We do not intend to deprecate the existing spec.subject and spec.commonName fields and we recommend that folks keep using those fields in all other cases; they're simpler, have better validation and are more obvious to read and change. ingress-shim Certificate Configuration \u00b6 cert-manager 1.9 adds the ability to configure an ingress-shim Certificate 's spec.revisionHistoryLimit and spec.privateKey via annotations on the Ingress resource . This should allow folks to configure ingress-shim Certificate s according to best practices (i.e by setting Certificate 's spec.privateKey.rotationPolicy to Always ). In the future we would like to design a better mechanism to configure these Certificate s. We advise caution when using Ingress annotations as there is no validation of the annotations at Ingress creation time. Contribution Workflow \u00b6 Over the past couple of months there have been a number of discussions in regards to contributor experience and project health, partially triggered by the awesome community discussions in cert-manager's KubeCon booth and also by the work done to move cert-manager to CNCF's incubating stage. For example, we've clarified our feature policy and discussed the process of building cert-manager's roadmap . If you're interested in these topics, we're happy to chat about them! make Workflow \u00b6 cert-manager 1.8 introduced a new make based workflow alongside the existing Bazel workflow. The work to improve the make workflow was continued in 1.9 and our contributor documentation has been redefined to use make commands. This should make building and testing cert-manager easier with faster build and test times, easier debugging and less complexity. As part of this, Bazel has now been fully deprecated for building and testing cert-manager. As usual, we welcome any feedback in regards to further improving contributor experience. Changes since v1.8.0 \u00b6 Feature \u00b6 Added support for pulling both AWS access key IDs and secret keys from Kubernetes secrets ( #5194 , @Compy ) Adds make clean-all for starting a fresh development environment and make which-go for getting go version information when developing cert-manager ( #5118 , @SgtCoDFish ) Adds make upload-release target for publishing cert-manager releases to GCS, simplifying the cert-manager release process simpler and making it easier to change ( #5205 , @SgtCoDFish ) Adds a new alpha Prometheus summary vector metric certmanager_http_venafi_client_request_duration_seconds which allows tracking the latency of Venafi API calls. The metric is labelled by the type of API call. Example PromQL query: certmanager_http_venafi_client_request_duration_seconds{api_call=\"request_certificate\"} will show the average latency of calls to the Venafi certificate request endpoint ( #5053 , @irbekrm ) Adds more verbose logging info for certificate renewal in the DynamicSource webhook to include DNSNames ( #5142 , @AcidLeroy ) Adds new LICENSES format and ability to verify and update licenses through make ( #5243 , @SgtCoDFish ) Adds private key Ingress annotations to set private key properties for Certificate ( #5239 , @oGi4i ) Adds the cert-manager.io/revision-history-limit annotation for Ingress resources, to limit the number of CertificateRequests which are kept for a Certificate ( #5221 , @oGi4i ) Adds the literalSubject field for Certificate resources. This is an alpha feature, enabled by passing the flag --feature-gates=LiteralCertificateSubject=true to the cert-manager controller and webhook. literalSubject allows fine-grained control of the subject a certificate should have when issued and is intended for power-users with specific use cases in mind ( #5002 , @spockz ) Change default build dir from bin to _bin , which plays better with certain tools which might treat bin as just another source directory ( #5130 , @SgtCoDFish ) Helm: Adds a new namespace parameter which allows users to override the namespace in which resources will be created. This also allows users to set the namespace of the chart when using cert-manager as a sub chart. ( #5141 , @andrewgkew ) Helm: Allow for users to not auto-mount service account tokens see also k/k#57601 ( #5016 , @sveba ) Use multiple retries when provisioning tools using curl , to reduce flakes in tests and development environments ( #5272 , @SgtCoDFish ) Bug or Regression \u00b6 CertificateRequests controllers must wait for the core secrets informer to be synced ( #5224 , @rodrigorfk ) Ensure that make release-artifacts only builds unsigned artifacts as intended ( #5181 , @SgtCoDFish ) Ensure the startupapicheck is only scheduled on Linux nodes in the helm chart ( #5136 , @craigminihan ) Fixed a bug where the Venafi Issuer would not verify its access token (TPP) or API key (Cloud) before becoming ready. Venafi Issuers now remotely verify the access token or API key ( #5212 , @jahrlin ) Fixed release artifact archives generated by Make so that a leading ./ is stripped from paths. This ensures that behavior is the same as v1.7 and earlier ( #5050 , @jahrlin ) Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5226 , @SgtCoDFish ) Increases Venafi Issuer timeout for retrieving a certificate increased to 60 seconds, up from 10. This gives TPP instances longer to complete their workflows and make the certificate available before cert-manager times out and re-queues the request. ( #5247 , @hawksight ) Remove pkg/util/coverage which broke compatibility with go 1.18; thanks @davidsbond for finding the issue! ( #5032 , @SgtCoDFish ) cmctl and kubectl cert-manager now report their actual versions instead of \"canary\", fixing issue #5020 ( #5286 , @jetstack-bot ) Other (Cleanup or Flake) \u00b6 Adds make update-all as a convenience target to run before raising a PR ( #5251 , @SgtCoDFish ) Adds make targets for updating and verifying CRDs and codegen ( #5242 , @SgtCoDFish ) Bump cert-manager's version of Go to 1.18 ( #5152 , @lucacome ) Bumps distroless base images to their latest versions ( #5222 , @irbekrm ) CertificateSigningRequest: no longer mark a request as failed when using the SelfSigned issuer, and the Secret referenced in experimental.cert-manager.io/private-key-secret-name doesn't exist. ( #5332 , @jetstack-bot ) Only require python for the one test we have which needs it, rather than requiring it globally ( #5245 , @SgtCoDFish ) Remove deprecated field securityContext.enabled from helm chart ( #4721 , @Dean-Coakley ) Removes support for networking/v1beta Ingresses in ingress-shim. ( #5250 , @irbekrm ) Reverts additional check for ServiceMonitor ( #5202 , @irbekrm ) Updates Kubernetes libraries to v0.24.2 . ( #5097 , @lucacome ) Updates warning message that is thrown if issuance fails because private key does not match spec, but private key regeneration is disabled. See https://github.com/cert-manager/cert-manager/pull/5199 . ( #5199 , @irbekrm )","title":"Release 1.9"},{"location":"release-notes/release-notes-1.9/#v192","text":"cert-manager v1.9.2 is a bug fix release which fixes an issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests, and a problem which prevented the Venafi Issuer from connecting to TPP servers where the vedauth API endpoints were configured to accept client certificates. It is also compiled with a newer version of Go 1.18 ( v1.18.8 ) which fixes some vulnerabilities in the Go standard library.","title":"v1.9.2"},{"location":"release-notes/release-notes-1.9/#changes-since-v191","text":"","title":"Changes since v1.9.1"},{"location":"release-notes/release-notes-1.9/#bug-or-regression","text":"Fix issue where CertificateRequests marked as InvalidRequest did not properly trigger issuance failure handling leading to 'stuck' requests. ( #5371 , @munnerz ) The Venafi Issuer now supports TLS 1.2 renegotiation, so that it can connect to TPP servers where the vedauth API endpoints are configured to accept client certificates. (Note: This does not mean that the Venafi Issuer supports client certificate authentication). ( #5577 , @wallrj ) Upgrade to latest go patch release. ( #5561 , @SgtCoDFish )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.9/#v191","text":"cert-manager v1.9.1 is a bug fix release which removes an incorrect check in the Route53 DNS solver. This accidental change prevented the use of credentials derived from instance metadata or AWS pod metadata.","title":"v1.9.1"},{"location":"release-notes/release-notes-1.9/#changes-since-v190","text":"","title":"Changes since v1.9.0"},{"location":"release-notes/release-notes-1.9/#bug-or-regression_1","text":"DNS Route53: Remove incorrect validation which rejects solvers that don't define either a accessKeyID or secretAccessKeyID . ( #5341 , @jetstack-bot )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.9/#v190","text":"cert-manager v1.9.0 adds alpha support for using cert-manager Certificate s in scenarios where the ordering of the Relative Distinguished Names (RDN) sequence that constitutes an X.509 certificate's subject needs to be preserved; improves the ability to configure the Certificate created via ingress-shim using annotations on the Ingress resource; introduces various changes/improvements in contributor flow; and finishes the new make-based contributor workflow.","title":"v1.9.0"},{"location":"release-notes/release-notes-1.9/#major-themes","text":"","title":"Major Themes"},{"location":"release-notes/release-notes-1.9/#literal-certificate-subjects","text":"cert-manager's Certificate allows users to configure the subject fields of the X.509 certificate via spec.subject and spec.commonName fields. The X.509 spec states that the subject is an (ordered) sequence of Relative Distinguished Names (RDN). cert-manager does not strictly abide by this spec when encoding the subject fields from the Certificate spec. For example, the order of the RDN sequence may not be preserved. This is because cert-manager uses Go's libraries for X.509 certificates, and the Go libraries don't preserve ordering. For the vast majority of users this does not matter, but there are specific cases that require defining the exact ordered RDN sequence. For example, if the certificate is used for LDAP authentication and the RDN sequence represents a location in LDAP directory tree . See cert-manager#3203 . For these use cases, a new alpha LiteralSubject field has been added to the Certificate spec where users can pass a literal RDN sequence: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : test spec : secretName : test literalSubject : \"C=US,O=myOrg,CN=someName\" To use this field, the alpha feature gate LiteralCertificateSubject needs to be enabled on both the cert-manager controller and webhook. Bear in mind that spec.literalSubject is mutually exclusive with spec.commonName and spec.subject . This feature is aimed at the specific scenario where an exact RDN sequence needs to be defined. We do not intend to deprecate the existing spec.subject and spec.commonName fields and we recommend that folks keep using those fields in all other cases; they're simpler, have better validation and are more obvious to read and change.","title":"Literal Certificate Subjects"},{"location":"release-notes/release-notes-1.9/#ingress-shim-certificate-configuration","text":"cert-manager 1.9 adds the ability to configure an ingress-shim Certificate 's spec.revisionHistoryLimit and spec.privateKey via annotations on the Ingress resource . This should allow folks to configure ingress-shim Certificate s according to best practices (i.e by setting Certificate 's spec.privateKey.rotationPolicy to Always ). In the future we would like to design a better mechanism to configure these Certificate s. We advise caution when using Ingress annotations as there is no validation of the annotations at Ingress creation time.","title":"ingress-shim Certificate Configuration"},{"location":"release-notes/release-notes-1.9/#contribution-workflow","text":"Over the past couple of months there have been a number of discussions in regards to contributor experience and project health, partially triggered by the awesome community discussions in cert-manager's KubeCon booth and also by the work done to move cert-manager to CNCF's incubating stage. For example, we've clarified our feature policy and discussed the process of building cert-manager's roadmap . If you're interested in these topics, we're happy to chat about them!","title":"Contribution Workflow"},{"location":"release-notes/release-notes-1.9/#make-workflow","text":"cert-manager 1.8 introduced a new make based workflow alongside the existing Bazel workflow. The work to improve the make workflow was continued in 1.9 and our contributor documentation has been redefined to use make commands. This should make building and testing cert-manager easier with faster build and test times, easier debugging and less complexity. As part of this, Bazel has now been fully deprecated for building and testing cert-manager. As usual, we welcome any feedback in regards to further improving contributor experience.","title":"make Workflow"},{"location":"release-notes/release-notes-1.9/#changes-since-v180","text":"","title":"Changes since v1.8.0"},{"location":"release-notes/release-notes-1.9/#feature","text":"Added support for pulling both AWS access key IDs and secret keys from Kubernetes secrets ( #5194 , @Compy ) Adds make clean-all for starting a fresh development environment and make which-go for getting go version information when developing cert-manager ( #5118 , @SgtCoDFish ) Adds make upload-release target for publishing cert-manager releases to GCS, simplifying the cert-manager release process simpler and making it easier to change ( #5205 , @SgtCoDFish ) Adds a new alpha Prometheus summary vector metric certmanager_http_venafi_client_request_duration_seconds which allows tracking the latency of Venafi API calls. The metric is labelled by the type of API call. Example PromQL query: certmanager_http_venafi_client_request_duration_seconds{api_call=\"request_certificate\"} will show the average latency of calls to the Venafi certificate request endpoint ( #5053 , @irbekrm ) Adds more verbose logging info for certificate renewal in the DynamicSource webhook to include DNSNames ( #5142 , @AcidLeroy ) Adds new LICENSES format and ability to verify and update licenses through make ( #5243 , @SgtCoDFish ) Adds private key Ingress annotations to set private key properties for Certificate ( #5239 , @oGi4i ) Adds the cert-manager.io/revision-history-limit annotation for Ingress resources, to limit the number of CertificateRequests which are kept for a Certificate ( #5221 , @oGi4i ) Adds the literalSubject field for Certificate resources. This is an alpha feature, enabled by passing the flag --feature-gates=LiteralCertificateSubject=true to the cert-manager controller and webhook. literalSubject allows fine-grained control of the subject a certificate should have when issued and is intended for power-users with specific use cases in mind ( #5002 , @spockz ) Change default build dir from bin to _bin , which plays better with certain tools which might treat bin as just another source directory ( #5130 , @SgtCoDFish ) Helm: Adds a new namespace parameter which allows users to override the namespace in which resources will be created. This also allows users to set the namespace of the chart when using cert-manager as a sub chart. ( #5141 , @andrewgkew ) Helm: Allow for users to not auto-mount service account tokens see also k/k#57601 ( #5016 , @sveba ) Use multiple retries when provisioning tools using curl , to reduce flakes in tests and development environments ( #5272 , @SgtCoDFish )","title":"Feature"},{"location":"release-notes/release-notes-1.9/#bug-or-regression_2","text":"CertificateRequests controllers must wait for the core secrets informer to be synced ( #5224 , @rodrigorfk ) Ensure that make release-artifacts only builds unsigned artifacts as intended ( #5181 , @SgtCoDFish ) Ensure the startupapicheck is only scheduled on Linux nodes in the helm chart ( #5136 , @craigminihan ) Fixed a bug where the Venafi Issuer would not verify its access token (TPP) or API key (Cloud) before becoming ready. Venafi Issuers now remotely verify the access token or API key ( #5212 , @jahrlin ) Fixed release artifact archives generated by Make so that a leading ./ is stripped from paths. This ensures that behavior is the same as v1.7 and earlier ( #5050 , @jahrlin ) Increase timeouts for Issuer and ClusterIssuer controllers to 2 minutes and increase ACME client HTTP timeouts to 90 seconds, in order to enable the use of slower ACME issuers which take a long time to process certain requests. ( #5226 , @SgtCoDFish ) Increases Venafi Issuer timeout for retrieving a certificate increased to 60 seconds, up from 10. This gives TPP instances longer to complete their workflows and make the certificate available before cert-manager times out and re-queues the request. ( #5247 , @hawksight ) Remove pkg/util/coverage which broke compatibility with go 1.18; thanks @davidsbond for finding the issue! ( #5032 , @SgtCoDFish ) cmctl and kubectl cert-manager now report their actual versions instead of \"canary\", fixing issue #5020 ( #5286 , @jetstack-bot )","title":"Bug or Regression"},{"location":"release-notes/release-notes-1.9/#other-cleanup-or-flake","text":"Adds make update-all as a convenience target to run before raising a PR ( #5251 , @SgtCoDFish ) Adds make targets for updating and verifying CRDs and codegen ( #5242 , @SgtCoDFish ) Bump cert-manager's version of Go to 1.18 ( #5152 , @lucacome ) Bumps distroless base images to their latest versions ( #5222 , @irbekrm ) CertificateSigningRequest: no longer mark a request as failed when using the SelfSigned issuer, and the Secret referenced in experimental.cert-manager.io/private-key-secret-name doesn't exist. ( #5332 , @jetstack-bot ) Only require python for the one test we have which needs it, rather than requiring it globally ( #5245 , @SgtCoDFish ) Remove deprecated field securityContext.enabled from helm chart ( #4721 , @Dean-Coakley ) Removes support for networking/v1beta Ingresses in ingress-shim. ( #5250 , @irbekrm ) Reverts additional check for ServiceMonitor ( #5202 , @irbekrm ) Updates Kubernetes libraries to v0.24.2 . ( #5097 , @lucacome ) Updates warning message that is thrown if issuance fails because private key does not match spec, but private key regeneration is disabled. See https://github.com/cert-manager/cert-manager/pull/5199 . ( #5199 , @irbekrm )","title":"Other (Cleanup or Flake)"},{"location":"troubleshooting/","text":"In this section, you will learn troubleshooting techniques that will help you find the root cause if your Certificate fails to be issued or renewed. This section also includes the following guides: Troubleshooting Problems with ACME / Let's Encrypt Certificates : Learn more about how the ACME issuer works and how to diagnose problems with it. Troubleshooting Problems with the Webhook : Learn how to diagnose problems with the cert-manager webhook. Overview \u00b6 When troubleshooting cert-manager your best friend is kubectl describe , this will give you information on the resources as well as recent events. It is not advised to use the logs as these are quite verbose and only should be looked at if the following steps do not provide help. cert-manager consists of multiple custom resources that live inside your Kubernetes cluster, these resources are linked together and are often created by one another. When such an event happens it will be reflected in a Kubernetes event, you can see these per-namespace using kubectl get event , or in the output of kubectl describe when looking at a single resource. Troubleshooting a failed certificate request \u00b6 There are several resources that are involved in requesting a certificate. ( +---------+ ) ( | Ingress | ) Optional ACME Only! ( +---------+ ) | | | +-------------+ +--------------------+ | +-------+ +-----------+ |-> | Certificate |----> | CertificateRequest | ----> | | Order | ----> | Challenge | +-------------+ +--------------------+ | +-------+ +-----------+ | The cert-manager flow all starts at a Certificate resource, you can create this yourself or your Ingress resource will do this for you if you have the correct annotations set. 1. Checking the Certificate resource \u00b6 First we have to check if we have a Certificate resource created in our namespace. We can get these using kubectl get certificate . $ kubectl get certificate NAME READY AGE example-com-tls False 1h If none is present and you plan to use the ingress-shim : check the ingress annotations more about that is in the ingress troubleshooting guide . If you are not using the ingress-shim: check the output of the command you used to create the certificate. If you see one with ready status False you can get more info using kubectl describe certificate , if the status is True that means that cert-manager has successfully issued a certificate. $ kubectl describe certificate <certificate-name> [...] Status: Conditions: Last Transition Time: 2020-05-15T21:45:22Z Message: Issuing certificate as Secret does not exist Reason: DoesNotExist Status: False Type: Ready Next Private Key Secret Name: example-tls-wtlww Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 105s cert-manager Issuing certificate as Secret does not exist Normal Generated 105s cert-manager Stored new private key in temporary Secret resource \"example-tls-wtlww\" Normal Requested 104s cert-manager Created new CertificateRequest resource \"example-tls-bw5t9\" Here you will find more info about the current certificate status under Status as well as detailed information about what happened to it under Events . Both will help you determine the current state of the certificate. The last status is Created new CertificateRequest resource , it is worth taking a look at in which state CertificateRequest is to get more info on why our Certificate isn't getting issued. 2. Checking the CertificateRequest \u00b6 The CertificateRequest resource represents a CSR in cert-manager and passes this CSR on onto the issuer. You can find the name of the CertificateRequest in the Certificate event log or using kubectl get certificaterequest To get more info we again run kubectl describe : $ kubectl describe certificaterequest <CertificateRequest name> API Version: cert-manager.io/v1 Kind: CertificateRequest Spec: Request: [...] Issuer Ref: Group: cert-manager.io Kind: ClusterIssuer Name: letencrypt-production Status: Conditions: Last Transition Time: 2020-05-15T21:45:36Z Message: Waiting on certificate issuance from order example-tls-fqtfg-1165244518: \"pending\" Reason: Pending Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 8m20s cert-manager Created Order resource example-tls-fqtfg-1165244518 Here we will see any issue regarding the Issuer configuration as well as Issuer responses. 3. Check the issuer state \u00b6 If in the above steps you saw an issuer not ready error you can do the same steps again for (cluster)issuer resources: $ kubectl describe issuer <Issuer name> $ kubectl describe clusterissuer <ClusterIssuer name> These will allow you to get any error messages regarding accounts or network issues with your issuer. Troubleshooting ACME issuers is described in more detail in Troubleshooting Issuing ACME Certificates . 4. ACME Troubleshooting \u00b6 ACME (e.g. Let's Encrypt) issuers have 2 additional resources inside cert-manager: Orders and Challenges . Troubleshooting these is described in Troubleshooting Issuing ACME Certificates .","title":"\u4ecb\u7ecd"},{"location":"troubleshooting/#overview","text":"When troubleshooting cert-manager your best friend is kubectl describe , this will give you information on the resources as well as recent events. It is not advised to use the logs as these are quite verbose and only should be looked at if the following steps do not provide help. cert-manager consists of multiple custom resources that live inside your Kubernetes cluster, these resources are linked together and are often created by one another. When such an event happens it will be reflected in a Kubernetes event, you can see these per-namespace using kubectl get event , or in the output of kubectl describe when looking at a single resource.","title":"Overview"},{"location":"troubleshooting/#troubleshooting-a-failed-certificate-request","text":"There are several resources that are involved in requesting a certificate. ( +---------+ ) ( | Ingress | ) Optional ACME Only! ( +---------+ ) | | | +-------------+ +--------------------+ | +-------+ +-----------+ |-> | Certificate |----> | CertificateRequest | ----> | | Order | ----> | Challenge | +-------------+ +--------------------+ | +-------+ +-----------+ | The cert-manager flow all starts at a Certificate resource, you can create this yourself or your Ingress resource will do this for you if you have the correct annotations set.","title":"Troubleshooting a failed certificate request"},{"location":"troubleshooting/#1-checking-the-certificate-resource","text":"First we have to check if we have a Certificate resource created in our namespace. We can get these using kubectl get certificate . $ kubectl get certificate NAME READY AGE example-com-tls False 1h If none is present and you plan to use the ingress-shim : check the ingress annotations more about that is in the ingress troubleshooting guide . If you are not using the ingress-shim: check the output of the command you used to create the certificate. If you see one with ready status False you can get more info using kubectl describe certificate , if the status is True that means that cert-manager has successfully issued a certificate. $ kubectl describe certificate <certificate-name> [...] Status: Conditions: Last Transition Time: 2020-05-15T21:45:22Z Message: Issuing certificate as Secret does not exist Reason: DoesNotExist Status: False Type: Ready Next Private Key Secret Name: example-tls-wtlww Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 105s cert-manager Issuing certificate as Secret does not exist Normal Generated 105s cert-manager Stored new private key in temporary Secret resource \"example-tls-wtlww\" Normal Requested 104s cert-manager Created new CertificateRequest resource \"example-tls-bw5t9\" Here you will find more info about the current certificate status under Status as well as detailed information about what happened to it under Events . Both will help you determine the current state of the certificate. The last status is Created new CertificateRequest resource , it is worth taking a look at in which state CertificateRequest is to get more info on why our Certificate isn't getting issued.","title":"1. Checking the Certificate resource"},{"location":"troubleshooting/#2-checking-the-certificaterequest","text":"The CertificateRequest resource represents a CSR in cert-manager and passes this CSR on onto the issuer. You can find the name of the CertificateRequest in the Certificate event log or using kubectl get certificaterequest To get more info we again run kubectl describe : $ kubectl describe certificaterequest <CertificateRequest name> API Version: cert-manager.io/v1 Kind: CertificateRequest Spec: Request: [...] Issuer Ref: Group: cert-manager.io Kind: ClusterIssuer Name: letencrypt-production Status: Conditions: Last Transition Time: 2020-05-15T21:45:36Z Message: Waiting on certificate issuance from order example-tls-fqtfg-1165244518: \"pending\" Reason: Pending Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 8m20s cert-manager Created Order resource example-tls-fqtfg-1165244518 Here we will see any issue regarding the Issuer configuration as well as Issuer responses.","title":"2. Checking the CertificateRequest"},{"location":"troubleshooting/#3-check-the-issuer-state","text":"If in the above steps you saw an issuer not ready error you can do the same steps again for (cluster)issuer resources: $ kubectl describe issuer <Issuer name> $ kubectl describe clusterissuer <ClusterIssuer name> These will allow you to get any error messages regarding accounts or network issues with your issuer. Troubleshooting ACME issuers is described in more detail in Troubleshooting Issuing ACME Certificates .","title":"3. Check the issuer state"},{"location":"troubleshooting/#4-acme-troubleshooting","text":"ACME (e.g. Let's Encrypt) issuers have 2 additional resources inside cert-manager: Orders and Challenges . Troubleshooting these is described in Troubleshooting Issuing ACME Certificates .","title":"4. ACME Troubleshooting"},{"location":"troubleshooting/acme/","text":"Learn how to diagnose problems if cert-manager fails to renew ACME / Let's Encrypt Certificates. Overview \u00b6 When requesting ACME certificates, cert-manager will create Order and Challenges to complete the request. As such, there are more resources to investigate and debug if there is a problem during the process. You can read more about these resources in the concepts pages . Before you start here you should probably take a look at our general troubleshooting guide 1. Troubleshooting (Cluster)Issuers \u00b6 First of all check if the (Cluster)Issuer you're using is in a ready state: $ kubectl get issuer $ kubectl get clusterissuer NAME READY AGE letsencrypt True 38m letsencrypt-http False 32m If you see False check the status using kubectl describe . For example: $ kubectl describe issuer letsencrypt-http $ kubectl describe clusterissuer letsencrypt-http Name: letsencrypt API Version: cert-manager.io/v1 Kind: Issuer Spec: Acme: Email: cert-manager@example.com Private Key Secret Ref: Name: letsencrypt Server: https://acme-staging-v02.api.letsencrypt.org/directory Status: Acme: Conditions: Message: Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail: Unable to update account :: invalid contact domain. Contact emails @example.com are forbidden Reason: ErrUpdateACMEAccount Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning ErrUpdateACMEAccount 101s ( x3 over 106s ) cert-manager Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail: Unable to update account :: invalid contact domain. Contact emails @example.com are forbidden Common errors \u00b6 Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail : the email you specified in the Issuer configuration isn't valid. Error initializing issuer: Failed to register ACME account: secrets \"acme-key\" already exists : there might be a leftover account from a previous issuer that is no longer valid, you should remove the secret so it can be recreated. Error accepting challenge: 400 urn:ietf:params:acme:error:malformed: Unable to update challenge :: authorization must be pending : this suggests that the authorization was not in 'pending' state at a time when cert-manager sent a request to the ACME server to accept the challenge. This may be because the domain validation has already failed and the authorization has been marked as 'invalid'. Check the authorization URL on the status of the Order or Challenge to see the status of the authorization and any additional information. 2. Troubleshooting Orders \u00b6 When we run a describe on the CertificateRequest resource we see that an Order that has been created: $ kubectl describe certificaterequest example-com-2745722290 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 5s cert-manager Created Order resource default/example-com-2745722290-439160286 Orders are a request to an ACME instance to issue a certificate. By running kubectl describe order on a particular order, information can be gleaned about failures in the process: $ kubectl describe order example-com-2745722290-439160286 ... Reason: State: pending URL: https://acme-v02.api.letsencrypt.org/acme/order/41123272/265506123 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 1m cert-manager Created Challenge resource \"example-com-2745722290-439160286-0\" for domain \"test1.example.com\" Normal Created 1m cert-manager Created Challenge resource \"example-com-2745722290-439160286-1\" for domain \"test2.example.com\" Here we can see that cert-manager has created two Challenge resources to verify we control specific domains, a requirements of the ACME order to obtain a signed certificate. You can then go on to run kubectl describe challenge example-com-2745722290-439160286-0 to further debug the progress of the Order. Once an Order is successful, you should see an event like the following: $ kubectl describe order example-com-2745722290-439160286 ... Reason: State: valid URL: https://acme-v02.api.letsencrypt.org/acme/order/41123272/265506123 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 72s cert-manager Created Challenge resource \"example-com-2745722290-439160286-0\" for domain \"test1.example.com\" Normal Created 72s cert-manager Created Challenge resource \"example-com-2745722290-439160286-1\" for domain \"test2.example.com\" Normal OrderValid 4s cert-manager Order completed successfully You can see some additional information about the state of the ACME authorization that needs to be validated as part of this order using the authorization URL from the status of the Order : $ kubectl get order <order-name> -ojsonpath = '{.status.authorizations[x].url}' If the Order is not completing successfully, you can debug the challenges for the Order by running kubectl describe on the Challenge resource which is described in the following steps. 3. Troubleshooting Challenges \u00b6 In order to determine why an ACME Order is not being finished, we can debug using the Challenge resources that cert-manager has created. In order to determine which Challenge is failing, you can run kubectl get challenges : $ kubectl get challenges ... NAME STATE DOMAIN REASON AGE example-com-2745722290-4391602865-0 pending example.com Waiting for dns-01 challenge propagation 22s This shows that the challenge has been presented using the DNS01 solver successfully and now cert-manager is waiting for the 'self check' to pass. You can get more information about the challenge and it's lifecycle by using kubectl describe : $ kubectl describe challenge example-com-2745722290-4391602865-0 ... Status: Presented: true Processing: true Reason: Waiting for dns-01 challenge propagation State: pending Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 19s cert-manager Challenge scheduled for processing Normal Presented 16s cert-manager Presented challenge using dns-01 challenge mechanism Progress about the state of each challenge will be recorded either as Events or on the Challenge's status block (as shown above). In case of DNS01 you will find any errors from your DNS provider here. Both HTTP01 and DNS01 go through a \"self-check\" first before cert-manager presents the challenge to the ACME provider. This is done not to overload the ACME provider with failed challenges due to DNS or loadbalancer propagations. The status of this can be found in the Status block of the describe: $ kubectl describe challenge [...] Status: Presented: true Processing: true Reason: Waiting for http-01 challenge propagation: failed to perform self check GET request 'http://example.com/.well-known/acme-challenge/_fgdLz0i3TFiZW4LBjuhjgd5nTOkaMBhxYmTY': Get \"http://example.com/.well-known/acme-challenge/_fgdLz0i3TFiZW4LBjuhjgd5nTOkaMBhxYmTY: remote error: tls: handshake failure State: pending [...] In this example our HTTP01 check fails due a network issue. You will also see any errors coming from your DNS provider here. You can also see some additional information about the state of the ACME authorization that the challenge should validate using the authorization URL on from the status of the Challenge : $ kubectl get challenge <challenge-name> -ojsonpath = '{.spec.authorizationURL}' HTTP01 troubleshooting \u00b6 First of all check if you can see the challenge URL from the public internet, if this does not work check your Ingress and firewall configuration as well as the service and pod cert-manager created to solve the ACME challenge. If this does work check if your cluster can see it too. It is important to test this from inside a Pod. If you get a connection error it is suggested to check the cluster's network configuration. If you receive a tls: handshake failure , try setting the annotation cert-manager.io/issue-temporary-certificate: \"true\" on the Ingress or Certificate resource. This will issue a temporary self signed certificate for the ingress controller to use before the actual certificate is issued. If you still are having issues, there may be an issue with your ingress controller handling multiple resources for the same hostname, in this case, the annotation acme.cert-manager.io/http01-edit-in-place: \"true\" is likely required. For example when using GKE with the Google Cloud Loadbalancer it is recommended to set: cert-manager.io/issue-temporary-certificate: \"true\" acme.cert-manager.io/http01-edit-in-place: \"true\" This will allow the Google Cloud Loadbalancer to propagate a HTTPS endpoint correctly with a temporary certificate, the http01-edit-in-place part will prevent GKE from assigning a 2 nd IP address for the challenge endpoint. Got 404 status code \u00b6 If your challenge self-check fails with a 404 not found error. Make sure to check the following: you can access the URL from the public internet the ACME solver pod is up and running use kubectl describe ingress to check the status of the HTTP01 solver ingress. (unless you use acme.cert-manager.io/http01-edit-in-place , then check the same ingress as your domain) DNS01 troubleshooting \u00b6 If you see no error events about your DNS provider you can check the following Check if you can see the _acme_challenge.domain TXT DNS record from the public internet, or in your DNS provider's interface. cert-manager will check if a DNS record has been propagated by querying the cluster's DNS solver. If you are able to see it from the public internet but not from inside the cluster you might want to change the DNS server for self-check as some cloud providers overwrite DNS internally. cert-manager identifies the wrong zone for your domain name \u00b6 cert-manager by default uses SOA (Start of Authority) records to determine which zone name to use at your DNS provider. Some DNS resolvers will filter this information, if this is the case cert-manager cannot determine the zone and it is advised to change the DNS server for DNS01 self-checks . If you use dnsmasq as your DNS server, this may occur if you use the --filterwin2k flag . In OpenWRT there is a filterwin2k configuration option . And in LuCI there is a \"Filter useless\" option . By enabling this flag, dnsmasq drops all SOA records. March 2020 Let's Encrypt CAA Rechecking Bug \u00b6 Following the announcement on March 4 Let's Encrypt will be revoking a number of certificates due to a bug in the way they validate CAA records, we have created a tool to analyse your existing cert-manager managed certificates and compare their serial numbers to the publicised list of revoked certificates. It's advised that all users of Let's Encrypt & cert-manager run a check using this tool to ensure they do not experience any invalid certificate errors in clusters. You can find a copy of the checker tool here: https://github.com/jetstack/letsencrypt-caa-bug-checker .","title":"Troubleshooting Problems with ACME / Let's Encrypt Certificates"},{"location":"troubleshooting/acme/#overview","text":"When requesting ACME certificates, cert-manager will create Order and Challenges to complete the request. As such, there are more resources to investigate and debug if there is a problem during the process. You can read more about these resources in the concepts pages . Before you start here you should probably take a look at our general troubleshooting guide","title":"Overview"},{"location":"troubleshooting/acme/#1-troubleshooting-clusterissuers","text":"First of all check if the (Cluster)Issuer you're using is in a ready state: $ kubectl get issuer $ kubectl get clusterissuer NAME READY AGE letsencrypt True 38m letsencrypt-http False 32m If you see False check the status using kubectl describe . For example: $ kubectl describe issuer letsencrypt-http $ kubectl describe clusterissuer letsencrypt-http Name: letsencrypt API Version: cert-manager.io/v1 Kind: Issuer Spec: Acme: Email: cert-manager@example.com Private Key Secret Ref: Name: letsencrypt Server: https://acme-staging-v02.api.letsencrypt.org/directory Status: Acme: Conditions: Message: Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail: Unable to update account :: invalid contact domain. Contact emails @example.com are forbidden Reason: ErrUpdateACMEAccount Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning ErrUpdateACMEAccount 101s ( x3 over 106s ) cert-manager Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail: Unable to update account :: invalid contact domain. Contact emails @example.com are forbidden","title":"1. Troubleshooting (Cluster)Issuers"},{"location":"troubleshooting/acme/#common-errors","text":"Failed to update ACME account:400 urn:ietf:params:acme:error:invalidEmail : the email you specified in the Issuer configuration isn't valid. Error initializing issuer: Failed to register ACME account: secrets \"acme-key\" already exists : there might be a leftover account from a previous issuer that is no longer valid, you should remove the secret so it can be recreated. Error accepting challenge: 400 urn:ietf:params:acme:error:malformed: Unable to update challenge :: authorization must be pending : this suggests that the authorization was not in 'pending' state at a time when cert-manager sent a request to the ACME server to accept the challenge. This may be because the domain validation has already failed and the authorization has been marked as 'invalid'. Check the authorization URL on the status of the Order or Challenge to see the status of the authorization and any additional information.","title":"Common errors"},{"location":"troubleshooting/acme/#2-troubleshooting-orders","text":"When we run a describe on the CertificateRequest resource we see that an Order that has been created: $ kubectl describe certificaterequest example-com-2745722290 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal OrderCreated 5s cert-manager Created Order resource default/example-com-2745722290-439160286 Orders are a request to an ACME instance to issue a certificate. By running kubectl describe order on a particular order, information can be gleaned about failures in the process: $ kubectl describe order example-com-2745722290-439160286 ... Reason: State: pending URL: https://acme-v02.api.letsencrypt.org/acme/order/41123272/265506123 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 1m cert-manager Created Challenge resource \"example-com-2745722290-439160286-0\" for domain \"test1.example.com\" Normal Created 1m cert-manager Created Challenge resource \"example-com-2745722290-439160286-1\" for domain \"test2.example.com\" Here we can see that cert-manager has created two Challenge resources to verify we control specific domains, a requirements of the ACME order to obtain a signed certificate. You can then go on to run kubectl describe challenge example-com-2745722290-439160286-0 to further debug the progress of the Order. Once an Order is successful, you should see an event like the following: $ kubectl describe order example-com-2745722290-439160286 ... Reason: State: valid URL: https://acme-v02.api.letsencrypt.org/acme/order/41123272/265506123 Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 72s cert-manager Created Challenge resource \"example-com-2745722290-439160286-0\" for domain \"test1.example.com\" Normal Created 72s cert-manager Created Challenge resource \"example-com-2745722290-439160286-1\" for domain \"test2.example.com\" Normal OrderValid 4s cert-manager Order completed successfully You can see some additional information about the state of the ACME authorization that needs to be validated as part of this order using the authorization URL from the status of the Order : $ kubectl get order <order-name> -ojsonpath = '{.status.authorizations[x].url}' If the Order is not completing successfully, you can debug the challenges for the Order by running kubectl describe on the Challenge resource which is described in the following steps.","title":"2. Troubleshooting Orders"},{"location":"troubleshooting/acme/#3-troubleshooting-challenges","text":"In order to determine why an ACME Order is not being finished, we can debug using the Challenge resources that cert-manager has created. In order to determine which Challenge is failing, you can run kubectl get challenges : $ kubectl get challenges ... NAME STATE DOMAIN REASON AGE example-com-2745722290-4391602865-0 pending example.com Waiting for dns-01 challenge propagation 22s This shows that the challenge has been presented using the DNS01 solver successfully and now cert-manager is waiting for the 'self check' to pass. You can get more information about the challenge and it's lifecycle by using kubectl describe : $ kubectl describe challenge example-com-2745722290-4391602865-0 ... Status: Presented: true Processing: true Reason: Waiting for dns-01 challenge propagation State: pending Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 19s cert-manager Challenge scheduled for processing Normal Presented 16s cert-manager Presented challenge using dns-01 challenge mechanism Progress about the state of each challenge will be recorded either as Events or on the Challenge's status block (as shown above). In case of DNS01 you will find any errors from your DNS provider here. Both HTTP01 and DNS01 go through a \"self-check\" first before cert-manager presents the challenge to the ACME provider. This is done not to overload the ACME provider with failed challenges due to DNS or loadbalancer propagations. The status of this can be found in the Status block of the describe: $ kubectl describe challenge [...] Status: Presented: true Processing: true Reason: Waiting for http-01 challenge propagation: failed to perform self check GET request 'http://example.com/.well-known/acme-challenge/_fgdLz0i3TFiZW4LBjuhjgd5nTOkaMBhxYmTY': Get \"http://example.com/.well-known/acme-challenge/_fgdLz0i3TFiZW4LBjuhjgd5nTOkaMBhxYmTY: remote error: tls: handshake failure State: pending [...] In this example our HTTP01 check fails due a network issue. You will also see any errors coming from your DNS provider here. You can also see some additional information about the state of the ACME authorization that the challenge should validate using the authorization URL on from the status of the Challenge : $ kubectl get challenge <challenge-name> -ojsonpath = '{.spec.authorizationURL}'","title":"3. Troubleshooting Challenges"},{"location":"troubleshooting/acme/#http01-troubleshooting","text":"First of all check if you can see the challenge URL from the public internet, if this does not work check your Ingress and firewall configuration as well as the service and pod cert-manager created to solve the ACME challenge. If this does work check if your cluster can see it too. It is important to test this from inside a Pod. If you get a connection error it is suggested to check the cluster's network configuration. If you receive a tls: handshake failure , try setting the annotation cert-manager.io/issue-temporary-certificate: \"true\" on the Ingress or Certificate resource. This will issue a temporary self signed certificate for the ingress controller to use before the actual certificate is issued. If you still are having issues, there may be an issue with your ingress controller handling multiple resources for the same hostname, in this case, the annotation acme.cert-manager.io/http01-edit-in-place: \"true\" is likely required. For example when using GKE with the Google Cloud Loadbalancer it is recommended to set: cert-manager.io/issue-temporary-certificate: \"true\" acme.cert-manager.io/http01-edit-in-place: \"true\" This will allow the Google Cloud Loadbalancer to propagate a HTTPS endpoint correctly with a temporary certificate, the http01-edit-in-place part will prevent GKE from assigning a 2 nd IP address for the challenge endpoint.","title":"HTTP01 troubleshooting"},{"location":"troubleshooting/acme/#got-404-status-code","text":"If your challenge self-check fails with a 404 not found error. Make sure to check the following: you can access the URL from the public internet the ACME solver pod is up and running use kubectl describe ingress to check the status of the HTTP01 solver ingress. (unless you use acme.cert-manager.io/http01-edit-in-place , then check the same ingress as your domain)","title":"Got 404 status code"},{"location":"troubleshooting/acme/#dns01-troubleshooting","text":"If you see no error events about your DNS provider you can check the following Check if you can see the _acme_challenge.domain TXT DNS record from the public internet, or in your DNS provider's interface. cert-manager will check if a DNS record has been propagated by querying the cluster's DNS solver. If you are able to see it from the public internet but not from inside the cluster you might want to change the DNS server for self-check as some cloud providers overwrite DNS internally.","title":"DNS01 troubleshooting"},{"location":"troubleshooting/acme/#cert-manager-identifies-the-wrong-zone-for-your-domain-name","text":"cert-manager by default uses SOA (Start of Authority) records to determine which zone name to use at your DNS provider. Some DNS resolvers will filter this information, if this is the case cert-manager cannot determine the zone and it is advised to change the DNS server for DNS01 self-checks . If you use dnsmasq as your DNS server, this may occur if you use the --filterwin2k flag . In OpenWRT there is a filterwin2k configuration option . And in LuCI there is a \"Filter useless\" option . By enabling this flag, dnsmasq drops all SOA records.","title":"cert-manager identifies the wrong zone for your domain name"},{"location":"troubleshooting/acme/#march-2020-lets-encrypt-caa-rechecking-bug","text":"Following the announcement on March 4 Let's Encrypt will be revoking a number of certificates due to a bug in the way they validate CAA records, we have created a tool to analyse your existing cert-manager managed certificates and compare their serial numbers to the publicised list of revoked certificates. It's advised that all users of Let's Encrypt & cert-manager run a check using this tool to ensure they do not experience any invalid certificate errors in clusters. You can find a copy of the checker tool here: https://github.com/jetstack/letsencrypt-caa-bug-checker .","title":"March 2020 Let's Encrypt CAA Rechecking Bug"},{"location":"troubleshooting/webhook/","text":"Last verified: 8 Sept 2022 The cert-manager webhook is a pod that runs as part of your cert-manager installation. When applying a manifest with kubectl , the Kubernetes API server calls the cert-manager webhook over TLS to validate your manifests. This guide helps you debug communication issues between the Kubernetes API server and the cert-manager webhook pod. The error messages listed in this page are encountered while installing or upgrading cert-manager, or shortly after installing or upgrading cert-manager when trying to create a Certificate, Issuer, or any other cert-manager custom resource. In the below diagram, we show the common pattern when debugging an issue with the cert-manager webhook: when creating a cert-manager custom resource, the API server connects over TLS to the cert-manager webhook pod. The red cross indicates that the API server fails talking to the webhook. The rest of this document presents error messages you may encounter. Error: connect: connection refused \u00b6 This issue was reported in 4 GitHub issues ( #2736 , #3133 , #3445 , #4425 ), was reported in 1 GitHub issue in an external project ( aws-load-balancer-controller#1563 ), on Stack Overflow ( serverfault#1076563 ), and was mentioned in 13 Slack messages that can be listed with the search in:#cert-manager in:#cert-manager-dev \":443: connect: connection refused\" . This error message can also be found in other projects that are building webhooks ( kubewarden-controller#110 ). Shortly after installing or upgrading cert-manager, you may hit this error when creating a Certificate, Issuer, or any other cert-manager custom resource. For example, creating an Issuer resource with the following command: kubectl apply -f- <<EOF apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: example spec: selfSigned: {} EOF shows the following error message: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.96.20.99:443: connect: connection refused When installing or upgrading cert-manager 1.5.0 and above with Helm, a very similar error message may appear when running helm install or helm upgrade : Error: INSTALLATION FAILED: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.96.20.99:443: connect: connection refused The message \"connection refused\" happens when the API server tries to establish a TCP connection with the cert-manager-webhook. In TCP terms, the API server sent the SYN packet to start the TCP handshake, and received an RST packet in return. If we were to use tcpdump inside the control plane node where the API server is running, we would see a packet returned to the API server: 192.168.1.43 (apiserver) -> 10.96.20.99 (webhook pod) TCP 59466 \u2192 443 [SYN] 10.96.20.99 (webhook pod) -> 192.168.1.43 (apiserver) TCP 443 \u2192 59466 [RST, ACK] The RST packet is sent by the Linux kernel when nothing is listening to the requested port. The RST packet can also be returned by one of the TCP hops, e.g., a firewall, as detailed in the Stack Overflow page What can be the reasons of connection refused errors? Note that firewalls usually don't return an RST packet; they usually drop the SYN packet entirely, and you end up with the error message i/o timeout or context deadline exceeded . If that is the case, continue your investigation with the section Error: i/o timeout (connectivity issue) and Error: context deadline exceeded respectively. Let's eliminate the possible causes from the closest to the source of the TCP connection (the API server) to its destination (the pod cert-manager-webhook ). Let's imagine that the name cert-manager-webhook.cert-manager.svc was resolved to 10.43.183.232. This is a cluster IP. The control plane node, in which the API server process runs, uses its iptables to rewrite the IP destination using the pod IP. That might be the first problem: sometimes, no pod IP is associated with a given cluster IP because the kubelet doesn't fill in the Endpoint resource with pod IPs as long as the readiness probe doesn't work. Let us first check whether it is a problem with the Endpoint resource: kubectl get endpoints -n cert-manager cert-manager-webhook A valid output would look like this: NAME ENDPOINTS AGE cert-manager-webhook 10.244.0.2:10250 27d \u2705 If you have this valid output and have the connect: connection refused , then the issue is deeper in the networking stack. We won't dig into this case, but you might want to use tcpdump and Wireshark to see whether traffic properly flows from the API server to the node's host namespace. The traffic from the host namespace to the pod's namespace already works fine since the kubelet was already able to reach the readiness endpoint. Common issues include firewall dropping traffic from the control plane to workers; for example, the API server on GKE is only allowed to talk to worker nodes (which is where the cert-manager webhook is running) over port 10250 . In EKS, your security groups might deny traffic from your control plane VPC towards your workers VPC over TCP 10250 . If you see <none> , it indicates that the cert-manager webhook is properly running but its readiness endpoint can't be reached: NAME ENDPOINTS AGE cert-manager-webhook <none> 236d \u274c To fix <none> , you will have to check whether the cert-manager-webhook deployment is healthy. The endpoints stays at <none> while the cert-manager-webhook isn't marked as healthy . kubectl get pod -n cert-manager -l app.kubernetes.io/name = webhook You should see that the pod is Running , and that the number of containers that are ready is 0/1 : NAME READY STATUS RESTARTS AGE cert-manager-76578c9687-24kmr 0/1 Running 7 (8h ago) 28d \u274c We won't be detailing the case where you get 1/1 and Running , since it would indicate an inconsistent state in Kubernetes. Continuing with 0/1 , that means the readiness endpoint isn't answering. When that happens, no endpoint is created. The next step is to figure out why the readiness endpoint isn't answering. Let us see which port the kubelet is using when hitting the readiness endpoint: kubectl -n cert-manager get deploy cert-manager-webhook -oyaml | grep -A5 readiness In our example, the port that the kubelet will try to hit is 6080: readinessProbe : failureThreshold : 3 httpGet : path : /healthz port : 6080 # \u2728 scheme : HTTP Now, let us port-forward to that port and see if /healthz works. In a shell session, run: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 6080 In another shell session, run: curl -sS --dump-header - 127 .0.0.1:6080/healthz The happy output is: HTTP / 1.1 200 OK \u2705 Date : Tue, 07 Jun 2022 17:16:56 GMT Content-Length : 0 If the readiness endpoint doesn't work, you will see: curl: (7) Failed to connect to 127.0.0.1 port 6080 after 0 ms: Connection refused \u274c At this point, verify that the readiness endpoint is configured on that same port. Let us see the logs to check that our webhook is listening on 6080 for its readiness endpoint: $ kubectl logs -n cert-manager -l app.kubernetes.io/name = webhook | head -10 I0607 webhook.go:129] \"msg\"=\"using dynamic certificate generating using CA stored in Secret resource\" I0607 server.go:133] \"msg\"=\"listening for insecure healthz connections\" \"address\"=\":6081\" \u274c I0607 server.go:197] \"msg\"=\"listening for secure connections\" \"address\"=\":10250\" I0607 dynamic_source.go:267] \"msg\"=\"Updated serving TLS certificate\" ... In the above example, the issue was a misconfiguration of the readiness port. In the webhook deployment, the argument --healthz-port=6081 was mismatched with the readiness configuration. Error: i/o timeout (connectivity issue) \u00b6 This error message was reported 26 times on Slack. To list these messages, do a search with in:#cert-manager in:#cert-manager-dev \"443: i/o timeout\" . The error message was reported in 2 GitHub issues ( #2811 , #4073 ) Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.0.0.69:443: i/o timeout When the API server tries to talk to the cert-manager webhook, the SYN packet is never answered, and the connection times out. If we were to run tcpdump inside the webhook's net namespace, we would see: 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] This issue is caused by the SYN packet being dropped somewhere. Cause 1: GKE Private Cluster \u00b6 The default Helm configuration should work with GKE private clusters, but changing securePort might break it. For context, unlike public GKE clusters where the control plane can freely talk to pods over any TCP port, the control plane in private GKE clusters can only talk to the pods in worker nodes over TCP port 10250 and 443 . These two open ports refer to the containerPort inside the pod, not the port called port in the Service resource. For it to work, the containerPort inside the Deployment must match either 10250 or 443 ; containerPort is configured by the Helm value webhook.securePort . By default, webhook.securePort is set to 10250 . To see if something is off with the containerPort , let us start looking at the Service resource: kubectl get svc -n cert-manager cert-manager-webhook -oyaml Looking at the output, we see that the targetPort is set to \"https\" : apiVersion : v1 kind : Service metadata : name : cert-manager-webhook spec : ports : - name : https port : 443 # \u274c This port is not the cause. protocol : TCP targetPort : \"https\" # \ud83c\udf1f This port might be the cause. The reason the above port: 443 can't be the cause is because kube-proxy, which also runs on the control plane node, translates the webhook's cluster IP to a pod IP, and also translates the above port: 443 to the value in containerPort . To see how what is behind the target port \"https\" , we look at the Deployment resource: kubectl get deploy -n cert-manager cert-manager-webhook -oyaml | grep -A3 ports: The output shows that the containerPort is not set to 10250 , meaning that a new firewall rule will have to be added in Google Cloud. ports : - containerPort : 12345 # \ud83c\udf1f This port matches neither 10250 nor 443. name : https protocol : TCP To recap, if the above containerPort is something other than 443 or 10250 and you prefer not changing containerPort to 10250 , you will have to add a new firewall rule. You can read the section Adding a firewall rule in a GKE private cluster in the Google documentation. For context, the reason we did not default securePort to 443 is because binding to 443 requires one additional Linux capability ( NET_BIND_SERVICE ); on the other side, 10250 doesn't require any additional capability. Cause 2: EKS on a custom CNI \u00b6 If you are on EKS and you are using a custom CNI such as Weave or Calico, the Kubernetes API server (which is in its own node) might not be able to reach the webhook pod. This happens because the control plane cannot be configured to run on a custom CNI on EKS, meaning that the CNIs cannot enable connectivity between the API server and the pods running in the worker nodes. Supposing that you are using Helm, the workaround is to add the following value in your values.yaml file: webhook : hostNetwork : true securePort : 10260 Or if you are using Helm from the command-line, use the following flag: --set webhook.hostNetwork = true --set webhook.securePort = 10260 By setting hostNetwork to true , the webhook pod will be run in the host's network namespace. By running in the host's network namespace, the webhook pod becomes accessible over the node's IP, which means you will work around the fact that kube-apiserver can't reach any pod IPs nor cluster IPs. By setting securePort to 10260 instead of relying on the default value (which is 10250 ), you will prevent a conflict between the webhook and the kubelet. The kubelet, which is an agent that runs on every Kubernetes worker node and runs directly on the host, uses the port 10250 to expose its internal API to kube-apiserver. To understand how hostnetwork and securePort interact, we have to look at how the TCP connection is established. When the kube-apiserver process tries to connect to the webhook pod, kube-proxy (which also runs on control plane nodes, even without a CNI) kicks in and translates the webhook's cluster IP to the webhook's host IP: https://cert-manager-webhook.cert-manager.svc:443/validate | |Step 1: resolve to the cluster IP v https://10.43.103.211:443/validate | |Step 2: send TCP packet v src: 172.28.0.1:43021 dst: 10.43.103.211:443 | |Step 3: kube-proxy rewrite (cluster IP to host IP) v src: 172.28.0.1:43021 dst: 172.28.0.2:10260 | | control-plane node | (host IP: 172.28.0.1) ------------|-------------------------------------------------- | (host IP: 172.28.0.2) v worker node +-------------------+ | webhook pod | | listens on | | 172.28.0.2:10260 | +-------------------+ The reason 10250 is used as the default securePort is because it works around another limitation with GKE Private Clusters, as detailed in the above section GKE Private Cluster . Cause 3: Network Policies, Calico \u00b6 Assuming that you are using the Helm chart and that you are using the default value of webhook.securePort (which is 10250 ), and that you are using a network policy controller such as Calico, check that there exists a policy allowing traffic from the API server to the webhook pod over TCP port 10250 . Cause 4: EKS and Security Groups \u00b6 Assuming that you are using the Helm chart and that you are using the default value of webhook.securePort (which is 10250 ), you might want to check that your AWS Security Groups allow TCP traffic over 10250 from the control plane's VPC to the workers VPC. Other causes \u00b6 If none of the above causes apply, you will need to figure out why the webhook is unreachable. To debug reachability issues (i.e., packets being dropped), we advise to use tcpdump along with Wireshark at every TCP hop. You can follow the article Debugging Kubernetes Networking: my kube-dns is not working! to learn how to use tcpdump with Wireshark to debug networking issues. Error: x509: certificate is valid for xxx.internal, not cert-manager-webhook.cert-manager.svc (EKS with Fargate pods) \u00b6 Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: x509: certificate is valid for ip-192-168-xxx-xxx.xxx.compute.internal, not cert-manager-webhook.cert-manager.svc This issue was first reported in #3237 . This is probably because you are running on EKS with Fargate enabled. Fargate creates a microVM per pod, and the VM's kernel is used to run the container in its own namespace. The problem is that each microVM gets its own kubelet. As for any Kubernetes node, the VM's port 10250 is listened to by a kubelet process. And 10250 is also the port that the cert-manager webhook listens on. But that's not a problem: the kubelet process and the cert-manager webhook process are running in two separate network namespaces, and ports don't clash. That's the case both in traditional Kubernetes nodes, as well as inside a Fargate microVM. The problem arises when the API server tries hitting the Fargate pod: the microVM's host net namespace is configured to port-forward every possible port for maximum compatibility with traditional pods, as demonstrated in the Stack Overflow page EKS Fargate connect to local kubelet . But the port 10250 is already used by the microVM's kubelet, so anything hitting this port won't be port-forwarded and will hit the kubelet instead. To sum up, the cert-manager webhook looks healthy and is able to listen to port 10250 as per its logs, but the microVM's host does not port-forward 10250 to the webhook's net namespace. That's the reason you see a message about an unexpected domain showing up when doing the TLS handshake: although the cert-manager webhook is properly running, the kubelet is the one responding to the API server. This is a limitation of Fargate's microVMs: the IP of the pod and the IP of the node are the same. It gives you the same experience as traditional pods, but it poses networking challenges. To fix the issue, the trick is to change the port the cert-manager webhook is listening on. Using Helm, we can use the parameter webhook.securePort : helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.8.0 \\ --set webhook.securePort = 10260 Error: service \"cert-managercert-manager-webhook\" not found \u00b6 Error from server (InternalError): error when creating \"test-resources.yaml\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-managercert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": service \"cert-managercert-manager-webhook\" not found This error was reported in 2 GitHub issues ( #3195 , #4999 ). We do not know the cause of this error, please comment on one of the GitHub issues above if you happen to come across it. Error: no endpoints available for service \"cert-manager-webhook\" (OVHCloud) \u00b6 Error: INSTALLATION FAILED: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: no endpoints available for service \"cert-manager-webhook\" This issue was first reported once in Slack ( 1 ). This error is rare and was only seen in OVHcloud managed Kubernetes clusters, where the etcd resource quota is quite low. etcd is the database where your Kubernetes resources (such as pods and deployments) are stored. OVHCloud limits the disk space used by your resources in etcd. When the limit is reached, the whole cluster starts behaving erratically and one symptom is that Endpoint resources aren't created by the kubelet. To verify that it is in fact a problem of quota, you should be able to see the following messages in your kube-apiserver logs: rpc error: code = Unknown desc = ETCD storage quota exceeded rpc error: code = Unknown desc = quota computation: etcdserver: not capable rpc error: code = Unknown desc = The OVHcloud storage quota has been reached The workaround is to remove some resources such as CertificateRequest resources to get under the limit, as explained in OVHCloud's ETCD Quotas error, troubleshooting page. Error: x509: certificate has expired or is not yet valid \u00b6 This error message was reported once in Slack ( 1 ). When using kubectl apply : Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://kubernetes.default.svc:443/apis/webhook.cert-manager.io/v1beta1/mutations?timeout=30s: x509: certificate has expired or is not yet valid This error message was reported once in Slack ( 1 ). Please answer to the above Slack message since we are still unsure as to what may cause this issue; to get access to the Kubernetes Slack, visit https://slack.k8s.io/ . Error: net/http: request canceled while waiting for connection \u00b6 Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) This error message was reported once in Slack ( 1 ). Error: context deadline exceeded \u00b6 This error message was reported in GitHub issues ( 2319 , 2706 5189 , 5004 ), and once on Stack Overflow . This error appears with cert-manager 0.12 and above when trying to apply an Issuer or any other cert-manager custom resource after having installed or upgraded cert-manager: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: context deadline exceeded \u2139\ufe0f In older releases of cert-manager (0.11 and below), the webhook relied on the APIService mechanism , and the message looked a bit different but the cause was the same: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.certmanager.k8s.io\": Post https://kubernetes.default.svc:443/apis/webhook.certmanager.k8s.io/v1beta1/mutations?timeout=30s: context deadline exceeded \u2139\ufe0f The message context deadline exceeded also appears when using cmctl check api . The cause is identical, you can continue reading this section to debug it. Not ready: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": context deadline exceeded The trouble with the message context deadline exceeded is that it obfuscates the part of the HTTP connection that timed out. When this message appears, we can't tell which part of the HTTP interaction timed out. It might be the DNS resolution, the TCP handshake, the TLS handshake, sending the HTTP request or receiving the HTTP response. \u2139\ufe0f For context, the query parameter ?timeout=30s that you can see in the above error messages is a timeout that the API server decides when calling the webhook. It is often set to 10 or 30 seconds. The following diagram shows what are the three errors that may be hidden behind the all-catching \"context deadline exceeded\" error message, represented by the outer box, that is usually thrown after 30 seconds: context deadline exceeded | 30 seconds | timeout v +-------------------------------------------------------------------------+ | | | i/o timeout | | | net/http: TLS handshake timeout | | 10 seconds | | | | timeout v | | |------------+ 30 seconds | net/http: request canceled | |TCP | timeout v while awaiting headers | |handshake +---------------------+ | | |------------| TLS | | | | | handshake +------------+ 10 seconds | | | +---------------------| sending | timeout v | | | request +------------+ | | +------------|receiving |------+ | | |resp. header| recv.| | | +------------+ resp.| | | | body +-----+ | +------|other| | |logic| | +-----+ +-------------------------------------------------------------------------+ <----------> <----------------------------------------------> connectivity webhook-side issue issue In the rest of the section, we will be trying to trigger one of the three \"more specific\" errors: i/o timeout is the TCP handshake timeout and comes from DialTimeout in the Kubernetes apiserver. The name resolution may be the cause, but usually, this message appears after the API server sent the SYN packet and waited for 10 seconds for the SYN-ACK packet to be received from the cert-manager webhook. net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) is the HTTP response timeout and comes from here and is configured to 30 seconds . The Kubernetes API server already sent the HTTP request is is waiting for the HTTP response headers (e.g., HTTP/1.1 200 OK ). net/http: TLS handshake timeout is when the TCP handshake is done, and the Kubernetes API server sent the initial TLS handshake packet ( ClientHello ) and waited for 10 seconds for the cert-manager webhook to answer with the ServerHello packet. We can sort these three messages in two categories: either it is a connectivity issue ( SYN is dropped), or it is a webhook issue (i.e., the TLS certificate is wrong, or the webhook is not returning any HTTP response): Timeout message Category i/o timeout connectivity issue net/http: TLS handshake timeout webhook-side issue net/http: request canceled while awaiting headers webhook-side issue The first step is to rule out a webhook-side issue. In your shell session, run the following: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 10250 In another shell session, check that you can reach the webhook: curl -vsS --resolve cert-manager-webhook.cert-manager.svc:10250:127.0.0.1 \\ --service-name cert-manager-webhook-ca \\ --cacert < ( kubectl -n cert-manager get secret cert-manager-webhook-ca -ojsonpath = '{.data.ca\\.crt}' | base64 -d ) \\ https://cert-manager-webhook.cert-manager.svc:10250/validate 2 > & 1 -d@- <<'EOF' | sed '/^* /d; /bytes data]$/d; s/> //; s/< //' {\"kind\":\"AdmissionReview\",\"apiVersion\":\"admission.k8s.io/v1\",\"request\":{\"requestKind\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"kind\":\"Certificate\"},\"requestResource\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"resource\":\"certificates\"},\"name\":\"foo\",\"namespace\":\"default\",\"operation\":\"CREATE\",\"object\":{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"spec\":{\"dnsNames\":[\"foo\"],\"issuerRef\":{\"group\":\"cert-manager.io\",\"kind\":\"Issuer\",\"name\":\"letsencrypt\"},\"secretName\":\"foo\",\"usages\":[\"digital signature\"]}}}} EOF The happy output looks like this: POST /validate HTTP / 1.1 Host : cert-manager-webhook.cert-manager.svc:10250 User-Agent : curl/7.83.0 Accept : */* Content-Length : 1299 Content-Type : application/x-www-form-urlencoded HTTP/1.1 200 OK Date: Wed, 08 Jun 2022 14:52:21 GMT Content-Length: 2029 Content-Type: text/plain; charset=utf-8 ... \"response\": { \"uid\": \"\", \"allowed\": true } If the response shows 200 OK , we can rule out a webhook-side issue. Since the initial error message was context deadline exceeded and not an apiserver-side issue such as x509: certificate signed by unknown authority or x509: certificate has expired or is not yet valid , we can conclude that the problem is a connectivity issue: the Kubernetes API server isn't able to establish a TCP connection to the cert-manager webhook. Please follow the instructions in the section Error: i/o timeout (connectivity issue) above to continue debugging. Error: net/http: TLS handshake timeout \u00b6 This error message was reported in 1 GitHub issue ( #2602 ). Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: net/http: TLS handshake timeout Looking at the above diagram , this error message indicates that the Kubernetes API server successfully established a TCP connection to the pod IP associated with the cert-manager webhook. The TLS handshake timeout means that the cert-manager webhook process isn't the one ending the TCP connection: there is some HTTP proxy in between that is probably waiting for a plain HTTP request instead a ClientHello packet. We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error. Error: HTTP probe failed with statuscode: 500 \u00b6 This error message was reported in 2 GitHub issue ( #3185 , #4557 ). The error message is visible as an event on the cert-manager webhook: Warning Unhealthy <invalid> (x13 over 15s) kubelet, node83 Readiness probe failed: HTTP probe failed with statuscode: 500 We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error. Error: Service Unavailable \u00b6 This error was reported in 1 GitHub issue ( #4281 ) Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post \"https://my-cert-manager-webhook.default.svc:443/mutate?timeout=10s\": Service Unavailable The above message appears in Kubernetes clusters using the Weave CNI. We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error. Error: failed calling admission webhook: the server is currently unable to handle the request \u00b6 This issue was reported in 4 GitHub issues ( 1369 , 1425 3542 , 4852 ) Error from server (InternalError): error when creating \"test-resources.yaml\": Internal error occurred: failed calling admission webhook \"issuers.admission.certmanager.k8s.io\": the server is currently unable to handle the request We do not know the cause of this error. Please comment in one of the above GitHub issues if you are able to reproduce this error. Error: x509: certificate signed by unknown authority \u00b6 Reported in GitHub issues ( 2602 ) When installing or upgrading cert-manager and using a namespace that is not cert-manager : Error: UPGRADE FAILED: release core-l7 failed, and has been rolled back due to atomic being set: failed to create resource: conversion webhook for cert-manager.io/v1alpha3, Kind=ClusterIssuer failed: Post https://cert-manager-webhook.core-l7.svc:443/convert?timeout=30s: x509: certificate signed by unknown authority A very similar error message may show when creating an Issuer or any other cert-manager custom resource: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: x509: certificate signed by unknown authority` With cmctl install and cmctl check api , you might see the following error message: 2022/06/06 15:36:30 Not ready: the cert-manager webhook CA bundle is not injected yet (Internal error occurred: conversion webhook for cert-manager.io/v1alpha2, Kind=Certificate failed: Post \"https://<company_name>-cert-manager-webhook.cert-manager.svc:443/convert?timeout=30s\": x509: certificate signed by unknown authority) If you are using cert-manager 0.14 and below with Helm, and that you are installing in a namespace different from cert-manager , the CRD manifest had the namespace name cert-manager hardcoded. You can see the hardcoded namespace in the following annotation: kubectl get crd issuers.cert-manager.io -oyaml | grep inject You will see the following: cert-manager.io/inject-ca-from-secret : cert-manager/cert-manager-webhook-ca # ^^^^^^^^^^^^ # hardcoded Note 1: this bug in the cert-manager Helm chart was was fixed in cert-manager 0.15. Note 2: since cert-manager 1.6, this annotation is no longer used on the cert-manager CRDs since conversion is no longer needed. The solution, if you are still using cert-manager 0.14 or below, is to render the manifest using helm template , then edit the annotation to use the correct namespace, and then use kubectl apply to install cert-manager. If you are using cert-manager 1.6 and below, the issue might be due to the cainjector being stuck trying to inject the self-signed certificate that the cert-manager webhook created and stored in the Secret resource cert-manager-webhook-ca into the spec.caBundle field of the cert-manager CRDs. The first step is to check whether the cainjector is running with no problem: $ kubectl -n cert-manager get pods -l app.kubernetes.io/name = cainjector NAME READY STATUS RESTARTS AGE cert-manager-cainjector-5c55bb7cb4-6z4cf 1/1 Running 11 (31h ago) 28d Looking at the logs, you will be able to tell if the leader election worked. It can take up to one minute for the leader election work to complete. I0608 start.go:126] \"starting\" version=\"v1.8.0\" revision=\"e466a521bc5455def8c224599c6edcd37e86410c\" I0608 leaderelection.go:248] attempting to acquire leader lease kube-system/cert-manager-cainjector-leader-election... I0608 leaderelection.go:258] successfully acquired lease kube-system/cert-manager-cainjector-leader-election I0608 controller.go:186] cert-manager/secret/customresourcedefinition/controller/controller-for-secret-customresourcedefinition \"msg\"=\"Starting Controller\" I0608 controller.go:186] cert-manager/certificate/customresourcedefinition/controller/controller-for-certificate-customresourcedefinition \"msg\"=\"Starting Controller\" I0608 controller.go:220] cert-manager/secret/customresourcedefinition/controller/controller-for-secret-customresourcedefinition \"msg\"=\"Starting workers\" \"worker count\"=1 I0608 controller.go:220] cert-manager/certificate/customresourcedefinition/controller/controller-for-certificate-customresourcedefinition \"msg\"=\"Starting workers\" \"worker count\"=1 The happy output contains lines like this: I0608 sources.go:184] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"Extracting CA from Secret resource\" \"resource_name\"=\"issuers.cert-manager.io\" \"secret\"=\"cert-manager/cert-manager-webhook-ca\" I0608 controller.go:178] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"updated object\" \"resource_name\"=\"issuers.cert-manager.io\" Now, look for any message that indicates that the Secret resource that the cert-manager webhook created can't be loaded. The two error messages that might show up are: E0608 sources.go:201] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"unable to fetch associated secret\" \"error\"=\"Secret \\\"cert-manager-webhook-caq\\\" not found\" The following message indicates that the given CRD has been skipped because the annotation is missing. You can ignore these messages: I0608 controller.go:156] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"failed to determine ca data source for injectable\" \"resource_name\"=\"challenges.acme.cert-manager.io\" If nothing seems wrong with the cainjector logs, you will want to check that the spec.caBundle field in the validation, mutation, and conversion configurations are correct. The Kubernetes API server uses the contents of that field to trust the cert-manager webhook. The caBundle contains the self-signed CA created by the cert-manager webhook when it started. $ kubectl get validatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig' { \"caBundle\": \"LS0tLS1...LS0tLS0K\", \"service\": { \"name\": \"cert-manager-webhook\", \"namespace\": \"cert-manager\", \"path\": \"/validate\", \"port\": 443 } } $ kubectl get mutatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig' { \"caBundle\": \"LS0tLS1...RFLS0tLS0K\", \"service\": { \"name\": \"cert-manager-webhook\", \"namespace\": \"cert-manager\", \"path\": \"/validate\", \"port\": 443 } } Let us see the contents of the caBundle : $ kubectl get mutatingwebhookconfigurations cert-manager-webhook -ojson \\ | jq '.webhooks[].clientConfig.caBundle' -r | base64 -d \\ | openssl x509 -noout -text -in - Certificate: Data: Version: 3 (0x2) Serial Number: ee:8f:4f:c8:55:7b:16:76:d8:6a:a2:e5:94:bc:7c:6b Signature Algorithm: ecdsa-with-SHA384 Issuer: CN = cert-manager-webhook-ca Validity Not Before: May 10 16:13:37 2022 GMT Not After : May 10 16:13:37 2023 GMT Subject: CN = cert-manager-webhook-ca Let us check that the contents of caBundle works for connecting to the webhook: $ kubectl -n cert-manager get secret cert-manager-webhook-ca -ojsonpath = '{.data.ca\\.crt}' \\ | base64 -d | openssl x509 -noout -text -in - Certificate: Data: Version: 3 (0x2) Serial Number: ee:8f:4f:c8:55:7b:16:76:d8:6a:a2:e5:94:bc:7c:6b Signature Algorithm: ecdsa-with-SHA384 Issuer: CN = cert-manager-webhook-ca Validity Not Before: May 10 16:13:37 2022 GMT Not After : May 10 16:13:37 2023 GMT Subject: CN = cert-manager-webhook-ca Our final test is to try to connect to the webhook using this trust bundle. Let us port-forward to the webhook pod: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 10250 In another shell session, send a /validate HTTP request with the following command: curl -vsS --resolve cert-manager-webhook.cert-manager.svc:10250:127.0.0.1 \\ --service-name cert-manager-webhook-ca \\ --cacert < ( kubectl get validatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig.caBundle' -r | base64 -d ) \\ https://cert-manager-webhook.cert-manager.svc:10250/validate 2 > & 1 -d@- <<'EOF' | sed '/^* /d; /bytes data]$/d; s/> //; s/< //' {\"kind\":\"AdmissionReview\",\"apiVersion\":\"admission.k8s.io/v1\",\"request\":{\"requestKind\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"kind\":\"Certificate\"},\"requestResource\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"resource\":\"certificates\"},\"name\":\"foo\",\"namespace\":\"default\",\"operation\":\"CREATE\",\"object\":{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"spec\":{\"dnsNames\":[\"foo\"],\"issuerRef\":{\"group\":\"cert-manager.io\",\"kind\":\"Issuer\",\"name\":\"letsencrypt\"},\"secretName\":\"foo\",\"usages\":[\"digital signature\"]}}}} EOF You should see a successful HTTP request and response: POST /validate HTTP / 1.1 Host : cert-manager-webhook.cert-manager.svc:10250 User-Agent : curl/7.83.0 Accept : */* Content-Length : 1299 Content-Type : application/x-www-form-urlencoded HTTP/1.1 200 OK Date: Wed, 08 Jun 2022 16:20:45 GMT Content-Length: 2029 Content-Type: text/plain; charset=utf-8 ... Error: cluster scoped resource \"mutatingwebhookconfigurations/\" is managed and access is denied \u00b6 This message was reported in GitHub issue 3717 . While installing cert-manager on GKE Autopilot, you will see the following message: Error: rendered manifests contain a resource that already exists. Unable to continue with install: could not get information about the resource: mutatingwebhookconfigurations.admissionregistration.k8s.io \"cert-manager-webhook\" is forbidden: User \"XXXX\" cannot get resource \"mutatingwebhookconfigurations\" in API group \"admissionregistration.k8s.io\" at the cluster scope: GKEAutopilot authz: cluster scoped resource \"mutatingwebhookconfigurations/\" is managed and access is denied This error message will appear when using Kubernetes 1.20 and below with GKE Autopilot. It is due to a restriction on mutating admission webhooks in GKE Autopilot . As of October 2021, the \"rapid\" Autopilot release channel has rolled out version 1.21 for Kubernetes masters. Installation via the Helm chart may end in an error message but cert-manager is reported to be working by some users. Feedback and PRs are welcome. Error: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied \u00b6 When installing cert-manager on GKE Autopilot with Helm, you will see the following error message: Not ready: the cert-manager webhook CA bundle is not injected yet After this failure, you should still see the three pods happily running: $ kubectl get pods -n cert-manager NAME READY STATUS RESTARTS AGE cert-manager-76578c9687-24kmr 1/1 Running 0 47m cert-manager-cainjector-b7d47f746-4799n 1/1 Running 0 47m cert-manager-webhook-7f788c5b6-mspnt 1/1 Running 0 47m But looking at either of the logs, you will see the following error message: E0425 leaderelection.go:334] error initially creating leader election record: leases.coordination.k8s.io is forbidden: User \"system:serviceaccount:cert-manager:cert-manager-webhook\" cannot create resource \"leases\" in API group \"coordination.k8s.io\" in the namespace \"kube-system\": GKEAutopilot authz: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied That is due to a limitation of GKE Autopilot. It is not possible to create resources in the kube-system namespace, and cert-manager uses the well-known kube-system to manage the leader election. To get around the limitation, you can tell Helm to use a different namespace for the leader election: helm install cert-manager jetstack/cert-manager --version 1 .8.0 \\ --namespace cert-manager --create-namespace \\ --set global.leaderElection.namespace = cert-manager","title":"The Definitive Debugging Guide for the cert-manager Webhook Pod"},{"location":"troubleshooting/webhook/#error-connect-connection-refused","text":"This issue was reported in 4 GitHub issues ( #2736 , #3133 , #3445 , #4425 ), was reported in 1 GitHub issue in an external project ( aws-load-balancer-controller#1563 ), on Stack Overflow ( serverfault#1076563 ), and was mentioned in 13 Slack messages that can be listed with the search in:#cert-manager in:#cert-manager-dev \":443: connect: connection refused\" . This error message can also be found in other projects that are building webhooks ( kubewarden-controller#110 ). Shortly after installing or upgrading cert-manager, you may hit this error when creating a Certificate, Issuer, or any other cert-manager custom resource. For example, creating an Issuer resource with the following command: kubectl apply -f- <<EOF apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: example spec: selfSigned: {} EOF shows the following error message: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.96.20.99:443: connect: connection refused When installing or upgrading cert-manager 1.5.0 and above with Helm, a very similar error message may appear when running helm install or helm upgrade : Error: INSTALLATION FAILED: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.96.20.99:443: connect: connection refused The message \"connection refused\" happens when the API server tries to establish a TCP connection with the cert-manager-webhook. In TCP terms, the API server sent the SYN packet to start the TCP handshake, and received an RST packet in return. If we were to use tcpdump inside the control plane node where the API server is running, we would see a packet returned to the API server: 192.168.1.43 (apiserver) -> 10.96.20.99 (webhook pod) TCP 59466 \u2192 443 [SYN] 10.96.20.99 (webhook pod) -> 192.168.1.43 (apiserver) TCP 443 \u2192 59466 [RST, ACK] The RST packet is sent by the Linux kernel when nothing is listening to the requested port. The RST packet can also be returned by one of the TCP hops, e.g., a firewall, as detailed in the Stack Overflow page What can be the reasons of connection refused errors? Note that firewalls usually don't return an RST packet; they usually drop the SYN packet entirely, and you end up with the error message i/o timeout or context deadline exceeded . If that is the case, continue your investigation with the section Error: i/o timeout (connectivity issue) and Error: context deadline exceeded respectively. Let's eliminate the possible causes from the closest to the source of the TCP connection (the API server) to its destination (the pod cert-manager-webhook ). Let's imagine that the name cert-manager-webhook.cert-manager.svc was resolved to 10.43.183.232. This is a cluster IP. The control plane node, in which the API server process runs, uses its iptables to rewrite the IP destination using the pod IP. That might be the first problem: sometimes, no pod IP is associated with a given cluster IP because the kubelet doesn't fill in the Endpoint resource with pod IPs as long as the readiness probe doesn't work. Let us first check whether it is a problem with the Endpoint resource: kubectl get endpoints -n cert-manager cert-manager-webhook A valid output would look like this: NAME ENDPOINTS AGE cert-manager-webhook 10.244.0.2:10250 27d \u2705 If you have this valid output and have the connect: connection refused , then the issue is deeper in the networking stack. We won't dig into this case, but you might want to use tcpdump and Wireshark to see whether traffic properly flows from the API server to the node's host namespace. The traffic from the host namespace to the pod's namespace already works fine since the kubelet was already able to reach the readiness endpoint. Common issues include firewall dropping traffic from the control plane to workers; for example, the API server on GKE is only allowed to talk to worker nodes (which is where the cert-manager webhook is running) over port 10250 . In EKS, your security groups might deny traffic from your control plane VPC towards your workers VPC over TCP 10250 . If you see <none> , it indicates that the cert-manager webhook is properly running but its readiness endpoint can't be reached: NAME ENDPOINTS AGE cert-manager-webhook <none> 236d \u274c To fix <none> , you will have to check whether the cert-manager-webhook deployment is healthy. The endpoints stays at <none> while the cert-manager-webhook isn't marked as healthy . kubectl get pod -n cert-manager -l app.kubernetes.io/name = webhook You should see that the pod is Running , and that the number of containers that are ready is 0/1 : NAME READY STATUS RESTARTS AGE cert-manager-76578c9687-24kmr 0/1 Running 7 (8h ago) 28d \u274c We won't be detailing the case where you get 1/1 and Running , since it would indicate an inconsistent state in Kubernetes. Continuing with 0/1 , that means the readiness endpoint isn't answering. When that happens, no endpoint is created. The next step is to figure out why the readiness endpoint isn't answering. Let us see which port the kubelet is using when hitting the readiness endpoint: kubectl -n cert-manager get deploy cert-manager-webhook -oyaml | grep -A5 readiness In our example, the port that the kubelet will try to hit is 6080: readinessProbe : failureThreshold : 3 httpGet : path : /healthz port : 6080 # \u2728 scheme : HTTP Now, let us port-forward to that port and see if /healthz works. In a shell session, run: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 6080 In another shell session, run: curl -sS --dump-header - 127 .0.0.1:6080/healthz The happy output is: HTTP / 1.1 200 OK \u2705 Date : Tue, 07 Jun 2022 17:16:56 GMT Content-Length : 0 If the readiness endpoint doesn't work, you will see: curl: (7) Failed to connect to 127.0.0.1 port 6080 after 0 ms: Connection refused \u274c At this point, verify that the readiness endpoint is configured on that same port. Let us see the logs to check that our webhook is listening on 6080 for its readiness endpoint: $ kubectl logs -n cert-manager -l app.kubernetes.io/name = webhook | head -10 I0607 webhook.go:129] \"msg\"=\"using dynamic certificate generating using CA stored in Secret resource\" I0607 server.go:133] \"msg\"=\"listening for insecure healthz connections\" \"address\"=\":6081\" \u274c I0607 server.go:197] \"msg\"=\"listening for secure connections\" \"address\"=\":10250\" I0607 dynamic_source.go:267] \"msg\"=\"Updated serving TLS certificate\" ... In the above example, the issue was a misconfiguration of the readiness port. In the webhook deployment, the argument --healthz-port=6081 was mismatched with the readiness configuration.","title":"Error: connect: connection refused"},{"location":"troubleshooting/webhook/#error-io-timeout-connectivity-issue","text":"This error message was reported 26 times on Slack. To list these messages, do a search with in:#cert-manager in:#cert-manager-dev \"443: i/o timeout\" . The error message was reported in 2 GitHub issues ( #2811 , #4073 ) Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": dial tcp 10.0.0.69:443: i/o timeout When the API server tries to talk to the cert-manager webhook, the SYN packet is never answered, and the connection times out. If we were to run tcpdump inside the webhook's net namespace, we would see: 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] 192.168.1.43 (apiserver) -> 10.0.0.69 (webhook pod) TCP [TCP Retransmission] 44772 \u2192 443 [SYN] This issue is caused by the SYN packet being dropped somewhere.","title":"Error: i/o timeout (connectivity issue)"},{"location":"troubleshooting/webhook/#cause-1-gke-private-cluster","text":"The default Helm configuration should work with GKE private clusters, but changing securePort might break it. For context, unlike public GKE clusters where the control plane can freely talk to pods over any TCP port, the control plane in private GKE clusters can only talk to the pods in worker nodes over TCP port 10250 and 443 . These two open ports refer to the containerPort inside the pod, not the port called port in the Service resource. For it to work, the containerPort inside the Deployment must match either 10250 or 443 ; containerPort is configured by the Helm value webhook.securePort . By default, webhook.securePort is set to 10250 . To see if something is off with the containerPort , let us start looking at the Service resource: kubectl get svc -n cert-manager cert-manager-webhook -oyaml Looking at the output, we see that the targetPort is set to \"https\" : apiVersion : v1 kind : Service metadata : name : cert-manager-webhook spec : ports : - name : https port : 443 # \u274c This port is not the cause. protocol : TCP targetPort : \"https\" # \ud83c\udf1f This port might be the cause. The reason the above port: 443 can't be the cause is because kube-proxy, which also runs on the control plane node, translates the webhook's cluster IP to a pod IP, and also translates the above port: 443 to the value in containerPort . To see how what is behind the target port \"https\" , we look at the Deployment resource: kubectl get deploy -n cert-manager cert-manager-webhook -oyaml | grep -A3 ports: The output shows that the containerPort is not set to 10250 , meaning that a new firewall rule will have to be added in Google Cloud. ports : - containerPort : 12345 # \ud83c\udf1f This port matches neither 10250 nor 443. name : https protocol : TCP To recap, if the above containerPort is something other than 443 or 10250 and you prefer not changing containerPort to 10250 , you will have to add a new firewall rule. You can read the section Adding a firewall rule in a GKE private cluster in the Google documentation. For context, the reason we did not default securePort to 443 is because binding to 443 requires one additional Linux capability ( NET_BIND_SERVICE ); on the other side, 10250 doesn't require any additional capability.","title":"Cause 1: GKE Private Cluster"},{"location":"troubleshooting/webhook/#cause-2-eks-on-a-custom-cni","text":"If you are on EKS and you are using a custom CNI such as Weave or Calico, the Kubernetes API server (which is in its own node) might not be able to reach the webhook pod. This happens because the control plane cannot be configured to run on a custom CNI on EKS, meaning that the CNIs cannot enable connectivity between the API server and the pods running in the worker nodes. Supposing that you are using Helm, the workaround is to add the following value in your values.yaml file: webhook : hostNetwork : true securePort : 10260 Or if you are using Helm from the command-line, use the following flag: --set webhook.hostNetwork = true --set webhook.securePort = 10260 By setting hostNetwork to true , the webhook pod will be run in the host's network namespace. By running in the host's network namespace, the webhook pod becomes accessible over the node's IP, which means you will work around the fact that kube-apiserver can't reach any pod IPs nor cluster IPs. By setting securePort to 10260 instead of relying on the default value (which is 10250 ), you will prevent a conflict between the webhook and the kubelet. The kubelet, which is an agent that runs on every Kubernetes worker node and runs directly on the host, uses the port 10250 to expose its internal API to kube-apiserver. To understand how hostnetwork and securePort interact, we have to look at how the TCP connection is established. When the kube-apiserver process tries to connect to the webhook pod, kube-proxy (which also runs on control plane nodes, even without a CNI) kicks in and translates the webhook's cluster IP to the webhook's host IP: https://cert-manager-webhook.cert-manager.svc:443/validate | |Step 1: resolve to the cluster IP v https://10.43.103.211:443/validate | |Step 2: send TCP packet v src: 172.28.0.1:43021 dst: 10.43.103.211:443 | |Step 3: kube-proxy rewrite (cluster IP to host IP) v src: 172.28.0.1:43021 dst: 172.28.0.2:10260 | | control-plane node | (host IP: 172.28.0.1) ------------|-------------------------------------------------- | (host IP: 172.28.0.2) v worker node +-------------------+ | webhook pod | | listens on | | 172.28.0.2:10260 | +-------------------+ The reason 10250 is used as the default securePort is because it works around another limitation with GKE Private Clusters, as detailed in the above section GKE Private Cluster .","title":"Cause 2: EKS on a custom CNI"},{"location":"troubleshooting/webhook/#cause-3-network-policies-calico","text":"Assuming that you are using the Helm chart and that you are using the default value of webhook.securePort (which is 10250 ), and that you are using a network policy controller such as Calico, check that there exists a policy allowing traffic from the API server to the webhook pod over TCP port 10250 .","title":"Cause 3: Network Policies, Calico"},{"location":"troubleshooting/webhook/#cause-4-eks-and-security-groups","text":"Assuming that you are using the Helm chart and that you are using the default value of webhook.securePort (which is 10250 ), you might want to check that your AWS Security Groups allow TCP traffic over 10250 from the control plane's VPC to the workers VPC.","title":"Cause 4: EKS and Security Groups"},{"location":"troubleshooting/webhook/#other-causes","text":"If none of the above causes apply, you will need to figure out why the webhook is unreachable. To debug reachability issues (i.e., packets being dropped), we advise to use tcpdump along with Wireshark at every TCP hop. You can follow the article Debugging Kubernetes Networking: my kube-dns is not working! to learn how to use tcpdump with Wireshark to debug networking issues.","title":"Other causes"},{"location":"troubleshooting/webhook/#error-x509-certificate-is-valid-for-xxxinternal-not-cert-manager-webhookcert-managersvc-eks-with-fargate-pods","text":"Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: x509: certificate is valid for ip-192-168-xxx-xxx.xxx.compute.internal, not cert-manager-webhook.cert-manager.svc This issue was first reported in #3237 . This is probably because you are running on EKS with Fargate enabled. Fargate creates a microVM per pod, and the VM's kernel is used to run the container in its own namespace. The problem is that each microVM gets its own kubelet. As for any Kubernetes node, the VM's port 10250 is listened to by a kubelet process. And 10250 is also the port that the cert-manager webhook listens on. But that's not a problem: the kubelet process and the cert-manager webhook process are running in two separate network namespaces, and ports don't clash. That's the case both in traditional Kubernetes nodes, as well as inside a Fargate microVM. The problem arises when the API server tries hitting the Fargate pod: the microVM's host net namespace is configured to port-forward every possible port for maximum compatibility with traditional pods, as demonstrated in the Stack Overflow page EKS Fargate connect to local kubelet . But the port 10250 is already used by the microVM's kubelet, so anything hitting this port won't be port-forwarded and will hit the kubelet instead. To sum up, the cert-manager webhook looks healthy and is able to listen to port 10250 as per its logs, but the microVM's host does not port-forward 10250 to the webhook's net namespace. That's the reason you see a message about an unexpected domain showing up when doing the TLS handshake: although the cert-manager webhook is properly running, the kubelet is the one responding to the API server. This is a limitation of Fargate's microVMs: the IP of the pod and the IP of the node are the same. It gives you the same experience as traditional pods, but it poses networking challenges. To fix the issue, the trick is to change the port the cert-manager webhook is listening on. Using Helm, we can use the parameter webhook.securePort : helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.8.0 \\ --set webhook.securePort = 10260","title":"Error: x509: certificate is valid for xxx.internal, not cert-manager-webhook.cert-manager.svc (EKS with Fargate pods)"},{"location":"troubleshooting/webhook/#error-service-cert-managercert-manager-webhook-not-found","text":"Error from server (InternalError): error when creating \"test-resources.yaml\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-managercert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": service \"cert-managercert-manager-webhook\" not found This error was reported in 2 GitHub issues ( #3195 , #4999 ). We do not know the cause of this error, please comment on one of the GitHub issues above if you happen to come across it.","title":"Error: service \"cert-managercert-manager-webhook\" not found"},{"location":"troubleshooting/webhook/#error-no-endpoints-available-for-service-cert-manager-webhook-ovhcloud","text":"Error: INSTALLATION FAILED: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: no endpoints available for service \"cert-manager-webhook\" This issue was first reported once in Slack ( 1 ). This error is rare and was only seen in OVHcloud managed Kubernetes clusters, where the etcd resource quota is quite low. etcd is the database where your Kubernetes resources (such as pods and deployments) are stored. OVHCloud limits the disk space used by your resources in etcd. When the limit is reached, the whole cluster starts behaving erratically and one symptom is that Endpoint resources aren't created by the kubelet. To verify that it is in fact a problem of quota, you should be able to see the following messages in your kube-apiserver logs: rpc error: code = Unknown desc = ETCD storage quota exceeded rpc error: code = Unknown desc = quota computation: etcdserver: not capable rpc error: code = Unknown desc = The OVHcloud storage quota has been reached The workaround is to remove some resources such as CertificateRequest resources to get under the limit, as explained in OVHCloud's ETCD Quotas error, troubleshooting page.","title":"Error: no endpoints available for service \"cert-manager-webhook\" (OVHCloud)"},{"location":"troubleshooting/webhook/#error-x509-certificate-has-expired-or-is-not-yet-valid","text":"This error message was reported once in Slack ( 1 ). When using kubectl apply : Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://kubernetes.default.svc:443/apis/webhook.cert-manager.io/v1beta1/mutations?timeout=30s: x509: certificate has expired or is not yet valid This error message was reported once in Slack ( 1 ). Please answer to the above Slack message since we are still unsure as to what may cause this issue; to get access to the Kubernetes Slack, visit https://slack.k8s.io/ .","title":"Error: x509: certificate has expired or is not yet valid"},{"location":"troubleshooting/webhook/#error-nethttp-request-canceled-while-waiting-for-connection","text":"Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) This error message was reported once in Slack ( 1 ).","title":"Error: net/http: request canceled while waiting for connection"},{"location":"troubleshooting/webhook/#error-context-deadline-exceeded","text":"This error message was reported in GitHub issues ( 2319 , 2706 5189 , 5004 ), and once on Stack Overflow . This error appears with cert-manager 0.12 and above when trying to apply an Issuer or any other cert-manager custom resource after having installed or upgraded cert-manager: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: context deadline exceeded \u2139\ufe0f In older releases of cert-manager (0.11 and below), the webhook relied on the APIService mechanism , and the message looked a bit different but the cause was the same: Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.certmanager.k8s.io\": Post https://kubernetes.default.svc:443/apis/webhook.certmanager.k8s.io/v1beta1/mutations?timeout=30s: context deadline exceeded \u2139\ufe0f The message context deadline exceeded also appears when using cmctl check api . The cause is identical, you can continue reading this section to debug it. Not ready: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": failed to call webhook: Post \"https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=10s\": context deadline exceeded The trouble with the message context deadline exceeded is that it obfuscates the part of the HTTP connection that timed out. When this message appears, we can't tell which part of the HTTP interaction timed out. It might be the DNS resolution, the TCP handshake, the TLS handshake, sending the HTTP request or receiving the HTTP response. \u2139\ufe0f For context, the query parameter ?timeout=30s that you can see in the above error messages is a timeout that the API server decides when calling the webhook. It is often set to 10 or 30 seconds. The following diagram shows what are the three errors that may be hidden behind the all-catching \"context deadline exceeded\" error message, represented by the outer box, that is usually thrown after 30 seconds: context deadline exceeded | 30 seconds | timeout v +-------------------------------------------------------------------------+ | | | i/o timeout | | | net/http: TLS handshake timeout | | 10 seconds | | | | timeout v | | |------------+ 30 seconds | net/http: request canceled | |TCP | timeout v while awaiting headers | |handshake +---------------------+ | | |------------| TLS | | | | | handshake +------------+ 10 seconds | | | +---------------------| sending | timeout v | | | request +------------+ | | +------------|receiving |------+ | | |resp. header| recv.| | | +------------+ resp.| | | | body +-----+ | +------|other| | |logic| | +-----+ +-------------------------------------------------------------------------+ <----------> <----------------------------------------------> connectivity webhook-side issue issue In the rest of the section, we will be trying to trigger one of the three \"more specific\" errors: i/o timeout is the TCP handshake timeout and comes from DialTimeout in the Kubernetes apiserver. The name resolution may be the cause, but usually, this message appears after the API server sent the SYN packet and waited for 10 seconds for the SYN-ACK packet to be received from the cert-manager webhook. net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) is the HTTP response timeout and comes from here and is configured to 30 seconds . The Kubernetes API server already sent the HTTP request is is waiting for the HTTP response headers (e.g., HTTP/1.1 200 OK ). net/http: TLS handshake timeout is when the TCP handshake is done, and the Kubernetes API server sent the initial TLS handshake packet ( ClientHello ) and waited for 10 seconds for the cert-manager webhook to answer with the ServerHello packet. We can sort these three messages in two categories: either it is a connectivity issue ( SYN is dropped), or it is a webhook issue (i.e., the TLS certificate is wrong, or the webhook is not returning any HTTP response): Timeout message Category i/o timeout connectivity issue net/http: TLS handshake timeout webhook-side issue net/http: request canceled while awaiting headers webhook-side issue The first step is to rule out a webhook-side issue. In your shell session, run the following: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 10250 In another shell session, check that you can reach the webhook: curl -vsS --resolve cert-manager-webhook.cert-manager.svc:10250:127.0.0.1 \\ --service-name cert-manager-webhook-ca \\ --cacert < ( kubectl -n cert-manager get secret cert-manager-webhook-ca -ojsonpath = '{.data.ca\\.crt}' | base64 -d ) \\ https://cert-manager-webhook.cert-manager.svc:10250/validate 2 > & 1 -d@- <<'EOF' | sed '/^* /d; /bytes data]$/d; s/> //; s/< //' {\"kind\":\"AdmissionReview\",\"apiVersion\":\"admission.k8s.io/v1\",\"request\":{\"requestKind\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"kind\":\"Certificate\"},\"requestResource\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"resource\":\"certificates\"},\"name\":\"foo\",\"namespace\":\"default\",\"operation\":\"CREATE\",\"object\":{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"spec\":{\"dnsNames\":[\"foo\"],\"issuerRef\":{\"group\":\"cert-manager.io\",\"kind\":\"Issuer\",\"name\":\"letsencrypt\"},\"secretName\":\"foo\",\"usages\":[\"digital signature\"]}}}} EOF The happy output looks like this: POST /validate HTTP / 1.1 Host : cert-manager-webhook.cert-manager.svc:10250 User-Agent : curl/7.83.0 Accept : */* Content-Length : 1299 Content-Type : application/x-www-form-urlencoded HTTP/1.1 200 OK Date: Wed, 08 Jun 2022 14:52:21 GMT Content-Length: 2029 Content-Type: text/plain; charset=utf-8 ... \"response\": { \"uid\": \"\", \"allowed\": true } If the response shows 200 OK , we can rule out a webhook-side issue. Since the initial error message was context deadline exceeded and not an apiserver-side issue such as x509: certificate signed by unknown authority or x509: certificate has expired or is not yet valid , we can conclude that the problem is a connectivity issue: the Kubernetes API server isn't able to establish a TCP connection to the cert-manager webhook. Please follow the instructions in the section Error: i/o timeout (connectivity issue) above to continue debugging.","title":"Error: context deadline exceeded"},{"location":"troubleshooting/webhook/#error-nethttp-tls-handshake-timeout","text":"This error message was reported in 1 GitHub issue ( #2602 ). Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: net/http: TLS handshake timeout Looking at the above diagram , this error message indicates that the Kubernetes API server successfully established a TCP connection to the pod IP associated with the cert-manager webhook. The TLS handshake timeout means that the cert-manager webhook process isn't the one ending the TCP connection: there is some HTTP proxy in between that is probably waiting for a plain HTTP request instead a ClientHello packet. We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error.","title":"Error: net/http: TLS handshake timeout"},{"location":"troubleshooting/webhook/#error-http-probe-failed-with-statuscode-500","text":"This error message was reported in 2 GitHub issue ( #3185 , #4557 ). The error message is visible as an event on the cert-manager webhook: Warning Unhealthy <invalid> (x13 over 15s) kubelet, node83 Readiness probe failed: HTTP probe failed with statuscode: 500 We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error.","title":"Error: HTTP probe failed with statuscode: 500"},{"location":"troubleshooting/webhook/#error-service-unavailable","text":"This error was reported in 1 GitHub issue ( #4281 ) Error from server (InternalError): error when creating \"STDIN\": Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post \"https://my-cert-manager-webhook.default.svc:443/mutate?timeout=10s\": Service Unavailable The above message appears in Kubernetes clusters using the Weave CNI. We do not know the cause of this error. Please comment on the above GitHub issue if you notice this error.","title":"Error: Service Unavailable"},{"location":"troubleshooting/webhook/#error-failed-calling-admission-webhook-the-server-is-currently-unable-to-handle-the-request","text":"This issue was reported in 4 GitHub issues ( 1369 , 1425 3542 , 4852 ) Error from server (InternalError): error when creating \"test-resources.yaml\": Internal error occurred: failed calling admission webhook \"issuers.admission.certmanager.k8s.io\": the server is currently unable to handle the request We do not know the cause of this error. Please comment in one of the above GitHub issues if you are able to reproduce this error.","title":"Error: failed calling admission webhook: the server is currently unable to handle the request"},{"location":"troubleshooting/webhook/#error-x509-certificate-signed-by-unknown-authority","text":"Reported in GitHub issues ( 2602 ) When installing or upgrading cert-manager and using a namespace that is not cert-manager : Error: UPGRADE FAILED: release core-l7 failed, and has been rolled back due to atomic being set: failed to create resource: conversion webhook for cert-manager.io/v1alpha3, Kind=ClusterIssuer failed: Post https://cert-manager-webhook.core-l7.svc:443/convert?timeout=30s: x509: certificate signed by unknown authority A very similar error message may show when creating an Issuer or any other cert-manager custom resource: Internal error occurred: failed calling webhook \"webhook.cert-manager.io\": Post https://cert-manager-webhook.cert-manager.svc:443/mutate?timeout=30s: x509: certificate signed by unknown authority` With cmctl install and cmctl check api , you might see the following error message: 2022/06/06 15:36:30 Not ready: the cert-manager webhook CA bundle is not injected yet (Internal error occurred: conversion webhook for cert-manager.io/v1alpha2, Kind=Certificate failed: Post \"https://<company_name>-cert-manager-webhook.cert-manager.svc:443/convert?timeout=30s\": x509: certificate signed by unknown authority) If you are using cert-manager 0.14 and below with Helm, and that you are installing in a namespace different from cert-manager , the CRD manifest had the namespace name cert-manager hardcoded. You can see the hardcoded namespace in the following annotation: kubectl get crd issuers.cert-manager.io -oyaml | grep inject You will see the following: cert-manager.io/inject-ca-from-secret : cert-manager/cert-manager-webhook-ca # ^^^^^^^^^^^^ # hardcoded Note 1: this bug in the cert-manager Helm chart was was fixed in cert-manager 0.15. Note 2: since cert-manager 1.6, this annotation is no longer used on the cert-manager CRDs since conversion is no longer needed. The solution, if you are still using cert-manager 0.14 or below, is to render the manifest using helm template , then edit the annotation to use the correct namespace, and then use kubectl apply to install cert-manager. If you are using cert-manager 1.6 and below, the issue might be due to the cainjector being stuck trying to inject the self-signed certificate that the cert-manager webhook created and stored in the Secret resource cert-manager-webhook-ca into the spec.caBundle field of the cert-manager CRDs. The first step is to check whether the cainjector is running with no problem: $ kubectl -n cert-manager get pods -l app.kubernetes.io/name = cainjector NAME READY STATUS RESTARTS AGE cert-manager-cainjector-5c55bb7cb4-6z4cf 1/1 Running 11 (31h ago) 28d Looking at the logs, you will be able to tell if the leader election worked. It can take up to one minute for the leader election work to complete. I0608 start.go:126] \"starting\" version=\"v1.8.0\" revision=\"e466a521bc5455def8c224599c6edcd37e86410c\" I0608 leaderelection.go:248] attempting to acquire leader lease kube-system/cert-manager-cainjector-leader-election... I0608 leaderelection.go:258] successfully acquired lease kube-system/cert-manager-cainjector-leader-election I0608 controller.go:186] cert-manager/secret/customresourcedefinition/controller/controller-for-secret-customresourcedefinition \"msg\"=\"Starting Controller\" I0608 controller.go:186] cert-manager/certificate/customresourcedefinition/controller/controller-for-certificate-customresourcedefinition \"msg\"=\"Starting Controller\" I0608 controller.go:220] cert-manager/secret/customresourcedefinition/controller/controller-for-secret-customresourcedefinition \"msg\"=\"Starting workers\" \"worker count\"=1 I0608 controller.go:220] cert-manager/certificate/customresourcedefinition/controller/controller-for-certificate-customresourcedefinition \"msg\"=\"Starting workers\" \"worker count\"=1 The happy output contains lines like this: I0608 sources.go:184] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"Extracting CA from Secret resource\" \"resource_name\"=\"issuers.cert-manager.io\" \"secret\"=\"cert-manager/cert-manager-webhook-ca\" I0608 controller.go:178] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"updated object\" \"resource_name\"=\"issuers.cert-manager.io\" Now, look for any message that indicates that the Secret resource that the cert-manager webhook created can't be loaded. The two error messages that might show up are: E0608 sources.go:201] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"unable to fetch associated secret\" \"error\"=\"Secret \\\"cert-manager-webhook-caq\\\" not found\" The following message indicates that the given CRD has been skipped because the annotation is missing. You can ignore these messages: I0608 controller.go:156] cert-manager/secret/customresourcedefinition/generic-inject-reconciler \"msg\"=\"failed to determine ca data source for injectable\" \"resource_name\"=\"challenges.acme.cert-manager.io\" If nothing seems wrong with the cainjector logs, you will want to check that the spec.caBundle field in the validation, mutation, and conversion configurations are correct. The Kubernetes API server uses the contents of that field to trust the cert-manager webhook. The caBundle contains the self-signed CA created by the cert-manager webhook when it started. $ kubectl get validatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig' { \"caBundle\": \"LS0tLS1...LS0tLS0K\", \"service\": { \"name\": \"cert-manager-webhook\", \"namespace\": \"cert-manager\", \"path\": \"/validate\", \"port\": 443 } } $ kubectl get mutatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig' { \"caBundle\": \"LS0tLS1...RFLS0tLS0K\", \"service\": { \"name\": \"cert-manager-webhook\", \"namespace\": \"cert-manager\", \"path\": \"/validate\", \"port\": 443 } } Let us see the contents of the caBundle : $ kubectl get mutatingwebhookconfigurations cert-manager-webhook -ojson \\ | jq '.webhooks[].clientConfig.caBundle' -r | base64 -d \\ | openssl x509 -noout -text -in - Certificate: Data: Version: 3 (0x2) Serial Number: ee:8f:4f:c8:55:7b:16:76:d8:6a:a2:e5:94:bc:7c:6b Signature Algorithm: ecdsa-with-SHA384 Issuer: CN = cert-manager-webhook-ca Validity Not Before: May 10 16:13:37 2022 GMT Not After : May 10 16:13:37 2023 GMT Subject: CN = cert-manager-webhook-ca Let us check that the contents of caBundle works for connecting to the webhook: $ kubectl -n cert-manager get secret cert-manager-webhook-ca -ojsonpath = '{.data.ca\\.crt}' \\ | base64 -d | openssl x509 -noout -text -in - Certificate: Data: Version: 3 (0x2) Serial Number: ee:8f:4f:c8:55:7b:16:76:d8:6a:a2:e5:94:bc:7c:6b Signature Algorithm: ecdsa-with-SHA384 Issuer: CN = cert-manager-webhook-ca Validity Not Before: May 10 16:13:37 2022 GMT Not After : May 10 16:13:37 2023 GMT Subject: CN = cert-manager-webhook-ca Our final test is to try to connect to the webhook using this trust bundle. Let us port-forward to the webhook pod: kubectl -n cert-manager port-forward deploy/cert-manager-webhook 10250 In another shell session, send a /validate HTTP request with the following command: curl -vsS --resolve cert-manager-webhook.cert-manager.svc:10250:127.0.0.1 \\ --service-name cert-manager-webhook-ca \\ --cacert < ( kubectl get validatingwebhookconfigurations cert-manager-webhook -ojson | jq '.webhooks[].clientConfig.caBundle' -r | base64 -d ) \\ https://cert-manager-webhook.cert-manager.svc:10250/validate 2 > & 1 -d@- <<'EOF' | sed '/^* /d; /bytes data]$/d; s/> //; s/< //' {\"kind\":\"AdmissionReview\",\"apiVersion\":\"admission.k8s.io/v1\",\"request\":{\"requestKind\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"kind\":\"Certificate\"},\"requestResource\":{\"group\":\"cert-manager.io\",\"version\":\"v1\",\"resource\":\"certificates\"},\"name\":\"foo\",\"namespace\":\"default\",\"operation\":\"CREATE\",\"object\":{\"apiVersion\":\"cert-manager.io/v1\",\"kind\":\"Certificate\",\"spec\":{\"dnsNames\":[\"foo\"],\"issuerRef\":{\"group\":\"cert-manager.io\",\"kind\":\"Issuer\",\"name\":\"letsencrypt\"},\"secretName\":\"foo\",\"usages\":[\"digital signature\"]}}}} EOF You should see a successful HTTP request and response: POST /validate HTTP / 1.1 Host : cert-manager-webhook.cert-manager.svc:10250 User-Agent : curl/7.83.0 Accept : */* Content-Length : 1299 Content-Type : application/x-www-form-urlencoded HTTP/1.1 200 OK Date: Wed, 08 Jun 2022 16:20:45 GMT Content-Length: 2029 Content-Type: text/plain; charset=utf-8 ...","title":"Error: x509: certificate signed by unknown authority"},{"location":"troubleshooting/webhook/#error-cluster-scoped-resource-mutatingwebhookconfigurations-is-managed-and-access-is-denied","text":"This message was reported in GitHub issue 3717 . While installing cert-manager on GKE Autopilot, you will see the following message: Error: rendered manifests contain a resource that already exists. Unable to continue with install: could not get information about the resource: mutatingwebhookconfigurations.admissionregistration.k8s.io \"cert-manager-webhook\" is forbidden: User \"XXXX\" cannot get resource \"mutatingwebhookconfigurations\" in API group \"admissionregistration.k8s.io\" at the cluster scope: GKEAutopilot authz: cluster scoped resource \"mutatingwebhookconfigurations/\" is managed and access is denied This error message will appear when using Kubernetes 1.20 and below with GKE Autopilot. It is due to a restriction on mutating admission webhooks in GKE Autopilot . As of October 2021, the \"rapid\" Autopilot release channel has rolled out version 1.21 for Kubernetes masters. Installation via the Helm chart may end in an error message but cert-manager is reported to be working by some users. Feedback and PRs are welcome.","title":"Error: cluster scoped resource \"mutatingwebhookconfigurations/\" is managed and access is denied"},{"location":"troubleshooting/webhook/#error-the-namespace-kube-system-is-managed-and-the-requests-verb-create-is-denied","text":"When installing cert-manager on GKE Autopilot with Helm, you will see the following error message: Not ready: the cert-manager webhook CA bundle is not injected yet After this failure, you should still see the three pods happily running: $ kubectl get pods -n cert-manager NAME READY STATUS RESTARTS AGE cert-manager-76578c9687-24kmr 1/1 Running 0 47m cert-manager-cainjector-b7d47f746-4799n 1/1 Running 0 47m cert-manager-webhook-7f788c5b6-mspnt 1/1 Running 0 47m But looking at either of the logs, you will see the following error message: E0425 leaderelection.go:334] error initially creating leader election record: leases.coordination.k8s.io is forbidden: User \"system:serviceaccount:cert-manager:cert-manager-webhook\" cannot create resource \"leases\" in API group \"coordination.k8s.io\" in the namespace \"kube-system\": GKEAutopilot authz: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied That is due to a limitation of GKE Autopilot. It is not possible to create resources in the kube-system namespace, and cert-manager uses the well-known kube-system to manage the leader election. To get around the limitation, you can tell Helm to use a different namespace for the leader election: helm install cert-manager jetstack/cert-manager --version 1 .8.0 \\ --namespace cert-manager --create-namespace \\ --set global.leaderElection.namespace = cert-manager","title":"Error: the namespace \"kube-system\" is managed and the request's verb \"create\" is denied"},{"location":"tutorials/","text":"Step-by-step tutorials are a great way to get started with cert-manager, and we provide a few for you to learn from. Take a look! Backup and Restore Resources : Backup the cert-manager resources in your cluster and then restore them. Pomerium Ingress : Tutorial on using the Pomerium Ingress Controller with cert-manager. Securing Ingresses with NGINX-Ingress and cert-manager : Tutorial for deploying NGINX into your cluster and securing incoming connections with a certificate from Let's Encrypt. Issuing an ACME Certificate using DNS Validation : Tutorial on how to resolve DNS ownership validation using DNS01 challenges. Issuing an ACME Certificate using HTTP Validation : Tutorial on how to resolve DNS ownership validation using HTTP01 challenges. Migrating from kube-lego : Tutorial on how to migrate from the now deprecated kube-lego project. Securing an EKS Cluster with Venafi : Tutorial for creating an EKS cluster and securing an NGINX deployment with a Venafi issued certificate. Securing an Istio service mesh with cert-manager : Tutorial for securing an Istio service mesh using a cert-manager issuer. Syncing Secrets Across Namespaces : Learn how to synchronize Kubernetes Secret resources across namespaces using extensions such as: reflector, kubed and kubernetes-replicator. Obtaining SSL certificates with the ZeroSSL : Tutorial describing usage of the ZeroSSL as external ACME server. External Tutorials \u00b6 A great AWS blog post on using cert-manager for end-to-end encryption in EKS. See Setting up end-to-end TLS encryption on Amazon EKS A full cert-manager installation demo on a GKE Cluster. See How-To: Automatic SSL Certificate Management for your Kubernetes Application Deployment cert-manager installation on GKE Cluster using Workload Identity. See Kubernetes, ingress-nginx, cert-manager & external-dns A video tutorial for beginners showing cert-manager in action. See Free SSL for Kubernetes with cert-manager","title":"\u4ecb\u7ecd"},{"location":"tutorials/#external-tutorials","text":"A great AWS blog post on using cert-manager for end-to-end encryption in EKS. See Setting up end-to-end TLS encryption on Amazon EKS A full cert-manager installation demo on a GKE Cluster. See How-To: Automatic SSL Certificate Management for your Kubernetes Application Deployment cert-manager installation on GKE Cluster using Workload Identity. See Kubernetes, ingress-nginx, cert-manager & external-dns A video tutorial for beginners showing cert-manager in action. See Free SSL for Kubernetes with cert-manager","title":"External Tutorials"},{"location":"tutorials/backup/","text":"If you need to uninstall cert-manager, or transfer your installation to a new cluster, you can backup all of cert-manager's configuration in order to later re-install. Backing up cert-manager resource configuration \u00b6 The following commands will back up the configuration of cert-manager resources. Doing that might be useful before upgrading cert-manager . As this backup does not include the Secrets containing the X.509 certificates, restoring to a cluster that does not already have those Secret objects will result in the certificates being reissued. Backup \u00b6 To backup all of your cert-manager configuration resources, run: kubectl get --all-namespaces -oyaml issuer,clusterissuer,cert > backup.yaml If you are transferring data to a new cluster, you may also need to copy across additional Secret resources that are referenced by your configured Issuers, such as: CA Issuers \u00b6 The root CA Secret referenced by issuer.spec.ca.secretName Vault Issuers \u00b6 The token authentication Secret referenced by issuer.spec.vault.auth.tokenSecretRef The AppRole configuration Secret referenced by issuer.spec.vault.auth.appRole.secretRef ACME Issuers \u00b6 The ACME account private key Secret referenced by issuer.acme.privateKeySecretRef Any Secret s referenced by DNS providers configured under the issuer.acme.dns01.providers and issuer.acme.solvers.dns01 fields. Restore \u00b6 In order to restore your configuration, you can kubectl apply the files created above after installing cert-manager, with the exception of the uid and resourceVersion fields that do not need to be restored: kubectl apply -f < ( awk '!/^ *(resourceVersion|uid): [^ ]+$/' backup.yaml ) Full cluster backup and restore \u00b6 This section refers to backing up and restoring 'all' Kubernetes resources in a cluster \u2014 including some cert-manager ones \u2014 for scenarios such as disaster recovery, cluster migration etc. Note : We have tested this process on simple Kubernetes test clusters with a limited set of Kubernetes releases. To avoid data loss, please test both the backup and the restore strategy on your own cluster before depending upon it in production. If you encounter any errors, please open a GitHub issue or a PR to document variations on this process for different Kubernetes environments. Avoiding unnecessary certificate reissuance \u00b6 Order of restore \u00b6 If cert-manager does not find a Kubernetes Secret with an X.509 certificate for a Certificate , reissuance will be triggered. To avoid unnecessary reissuance after a restore, ensure that Secret s are restored before Certificate s. Similarly, Secret s should be restored before Ingress es if you are using ingress-shim . Excluding some cert-manager resources from backup \u00b6 cert-manager has a number of custom resources that are designed to represent a point-in-time operation. An example would be a CertificateRequest that represents a one-time request for an X.509 certificate. The status of these resources can depend on other ephemeral resources (such as a temporary Secret holding a private key) so cert-manager might not be able to correctly recreate the state of these resources at a later point. In most cases backup and restore tools will not restore the statuses of custom resources, so including such one-time resources in a backup can result in an unnecessary reissuance after a restore as without the status fields cert-manager will not be able to tell that, for example, an Order has already been fulfilled. To avoid unnecessary reissuance, we recommend that Order s and Challenge s are excluded from the backup. We also don't recommend backing up CertificateRequest s, see Backing up CertificateRequests Restoring Ingress Certificates \u00b6 A Certificate created for an Ingress via ingress-shim will have an owner reference pointing to the Ingress resource. cert-manager uses the owner reference to verify that the Certificate 'belongs' to that Ingress and will not attempt to create/correct it for an existing Certificate . After a full cluster recreation, a restored owner reference would probably be incorrect ( Ingress UUID will have changed). The incorrect owner reference could lead to a situation where updates to the Ingress (i.e a new DNS name) are not applied to the Certificate . To avoid this issue, in most cases Certificate s created via ingress-shim can be excluded from the backup. Given that the restore happens in the correct order ( Secret with the X.509 certificate restored before the Ingress ) cert-manager will be able to create a new Certificate for the Ingress and determine that the existing Secret is for that Certificate . Velero \u00b6 We have briefly tested backup and restore with velero v1.5.3 and cert-manager versions v1.3.1 and v1.3.0 as well as velero v1.3.1 and cert-manager v1.1.0 . A few potential edge cases: Ensure that the backups include cert-manager CRDs. For example, we have seen that if --exclude-namespaces flag is passed to velero backup create , CRDs for which there are no actual resources to be included in the backup might also not be included in backup unless --include-cluster-resources=true flag is also passed to the backup command. Velero does not restore statuses of custom resources, so you should probably exclude Order s, Challenge s and CertificateRequest s from the backup, see Excluding some cert-manager resources from backup . Velero's default restore order ( Secrets before Ingress es, Custom Resources restored last), should ensure that there is no unnecessary certificate reissuance due to the order of restore operation, see Order of restore . When restoring the deployment of cert-manager itself, it may be necessary to restore cert-manager 's RBAC resources before the rest of the deployment. This is because cert-manager 's controller needs to be able to create Certificate 's for the cert-manager 's webhook before the webhook can become ready. In order to do this, the controller needs the right permissions. Since Velero by default restores pods before RBAC resources, the restore might get stuck waiting for the webhook pod to become ready. Velero does not restore owner references, so it may be necessary to exclude Certificate s created for Ingress es from the backup even when not re-creating the Ingress itself. See Restoring Ingress Certificates . Backing up CertificateRequests \u00b6 We no longer recommend including CertificateRequest resources in a backup for most scenarios. CertificateRequest s are designed to represent a one-time request for an X.509 certificate. Once the request has been fulfilled, CertificateRequest can usually be safely deleted 1 . In most cases (such as when a CertificateRequest has been created for a Certificate ) a new CertificateRequest will be created when needed (i.e at a time of a renewal of a Certificate ). In v1.3.0 , as part of our work towards policy implementation we introduced identity fields for CertificateRequest resources where, at a time of creation, cert-mananager 's webhook updates CertificateRequest 's spec with immutable identity fields, representing the identity of the creator of the CertificateRequest . This introduces some extra complexity for backing up and restoring CertificateRequest s as the identity of the restorer might differ from that of the original creator and in most cases a restored CertificateRequest would likely end up with incorrect state. there is an edge case where certain changes to Certificate spec may not trigger re-issuance if there is no CertificateRequest for that Certificate . See documentation on when do certificates get re-issued . \u21a9","title":"Backup and Restore Resources"},{"location":"tutorials/backup/#backing-up-cert-manager-resource-configuration","text":"The following commands will back up the configuration of cert-manager resources. Doing that might be useful before upgrading cert-manager . As this backup does not include the Secrets containing the X.509 certificates, restoring to a cluster that does not already have those Secret objects will result in the certificates being reissued.","title":"Backing up cert-manager resource configuration"},{"location":"tutorials/backup/#backup","text":"To backup all of your cert-manager configuration resources, run: kubectl get --all-namespaces -oyaml issuer,clusterissuer,cert > backup.yaml If you are transferring data to a new cluster, you may also need to copy across additional Secret resources that are referenced by your configured Issuers, such as:","title":"Backup"},{"location":"tutorials/backup/#ca-issuers","text":"The root CA Secret referenced by issuer.spec.ca.secretName","title":"CA Issuers"},{"location":"tutorials/backup/#vault-issuers","text":"The token authentication Secret referenced by issuer.spec.vault.auth.tokenSecretRef The AppRole configuration Secret referenced by issuer.spec.vault.auth.appRole.secretRef","title":"Vault Issuers"},{"location":"tutorials/backup/#acme-issuers","text":"The ACME account private key Secret referenced by issuer.acme.privateKeySecretRef Any Secret s referenced by DNS providers configured under the issuer.acme.dns01.providers and issuer.acme.solvers.dns01 fields.","title":"ACME Issuers"},{"location":"tutorials/backup/#restore","text":"In order to restore your configuration, you can kubectl apply the files created above after installing cert-manager, with the exception of the uid and resourceVersion fields that do not need to be restored: kubectl apply -f < ( awk '!/^ *(resourceVersion|uid): [^ ]+$/' backup.yaml )","title":"Restore"},{"location":"tutorials/backup/#full-cluster-backup-and-restore","text":"This section refers to backing up and restoring 'all' Kubernetes resources in a cluster \u2014 including some cert-manager ones \u2014 for scenarios such as disaster recovery, cluster migration etc. Note : We have tested this process on simple Kubernetes test clusters with a limited set of Kubernetes releases. To avoid data loss, please test both the backup and the restore strategy on your own cluster before depending upon it in production. If you encounter any errors, please open a GitHub issue or a PR to document variations on this process for different Kubernetes environments.","title":"Full cluster backup and restore"},{"location":"tutorials/backup/#avoiding-unnecessary-certificate-reissuance","text":"","title":"Avoiding unnecessary certificate reissuance"},{"location":"tutorials/backup/#order-of-restore","text":"If cert-manager does not find a Kubernetes Secret with an X.509 certificate for a Certificate , reissuance will be triggered. To avoid unnecessary reissuance after a restore, ensure that Secret s are restored before Certificate s. Similarly, Secret s should be restored before Ingress es if you are using ingress-shim .","title":"Order of restore"},{"location":"tutorials/backup/#excluding-some-cert-manager-resources-from-backup","text":"cert-manager has a number of custom resources that are designed to represent a point-in-time operation. An example would be a CertificateRequest that represents a one-time request for an X.509 certificate. The status of these resources can depend on other ephemeral resources (such as a temporary Secret holding a private key) so cert-manager might not be able to correctly recreate the state of these resources at a later point. In most cases backup and restore tools will not restore the statuses of custom resources, so including such one-time resources in a backup can result in an unnecessary reissuance after a restore as without the status fields cert-manager will not be able to tell that, for example, an Order has already been fulfilled. To avoid unnecessary reissuance, we recommend that Order s and Challenge s are excluded from the backup. We also don't recommend backing up CertificateRequest s, see Backing up CertificateRequests","title":"Excluding some cert-manager resources from backup"},{"location":"tutorials/backup/#restoring-ingress-certificates","text":"A Certificate created for an Ingress via ingress-shim will have an owner reference pointing to the Ingress resource. cert-manager uses the owner reference to verify that the Certificate 'belongs' to that Ingress and will not attempt to create/correct it for an existing Certificate . After a full cluster recreation, a restored owner reference would probably be incorrect ( Ingress UUID will have changed). The incorrect owner reference could lead to a situation where updates to the Ingress (i.e a new DNS name) are not applied to the Certificate . To avoid this issue, in most cases Certificate s created via ingress-shim can be excluded from the backup. Given that the restore happens in the correct order ( Secret with the X.509 certificate restored before the Ingress ) cert-manager will be able to create a new Certificate for the Ingress and determine that the existing Secret is for that Certificate .","title":"Restoring Ingress Certificates"},{"location":"tutorials/backup/#velero","text":"We have briefly tested backup and restore with velero v1.5.3 and cert-manager versions v1.3.1 and v1.3.0 as well as velero v1.3.1 and cert-manager v1.1.0 . A few potential edge cases: Ensure that the backups include cert-manager CRDs. For example, we have seen that if --exclude-namespaces flag is passed to velero backup create , CRDs for which there are no actual resources to be included in the backup might also not be included in backup unless --include-cluster-resources=true flag is also passed to the backup command. Velero does not restore statuses of custom resources, so you should probably exclude Order s, Challenge s and CertificateRequest s from the backup, see Excluding some cert-manager resources from backup . Velero's default restore order ( Secrets before Ingress es, Custom Resources restored last), should ensure that there is no unnecessary certificate reissuance due to the order of restore operation, see Order of restore . When restoring the deployment of cert-manager itself, it may be necessary to restore cert-manager 's RBAC resources before the rest of the deployment. This is because cert-manager 's controller needs to be able to create Certificate 's for the cert-manager 's webhook before the webhook can become ready. In order to do this, the controller needs the right permissions. Since Velero by default restores pods before RBAC resources, the restore might get stuck waiting for the webhook pod to become ready. Velero does not restore owner references, so it may be necessary to exclude Certificate s created for Ingress es from the backup even when not re-creating the Ingress itself. See Restoring Ingress Certificates .","title":"Velero"},{"location":"tutorials/backup/#backing-up-certificaterequests","text":"We no longer recommend including CertificateRequest resources in a backup for most scenarios. CertificateRequest s are designed to represent a one-time request for an X.509 certificate. Once the request has been fulfilled, CertificateRequest can usually be safely deleted 1 . In most cases (such as when a CertificateRequest has been created for a Certificate ) a new CertificateRequest will be created when needed (i.e at a time of a renewal of a Certificate ). In v1.3.0 , as part of our work towards policy implementation we introduced identity fields for CertificateRequest resources where, at a time of creation, cert-mananager 's webhook updates CertificateRequest 's spec with immutable identity fields, representing the identity of the creator of the CertificateRequest . This introduces some extra complexity for backing up and restoring CertificateRequest s as the identity of the restorer might differ from that of the original creator and in most cases a restored CertificateRequest would likely end up with incorrect state. there is an edge case where certain changes to Certificate spec may not trigger re-issuance if there is no CertificateRequest for that Certificate . See documentation on when do certificates get re-issued . \u21a9","title":"Backing up CertificateRequests"},{"location":"tutorials/syncing-secrets-across-namespaces/","text":"It may be required for multiple components across namespaces to consume the same Secret that has been created by a single Certificate . The recommended way to do this is to use extensions such as: - reflector with support for auto secret reflection - kubed with its secret syncing feature - kubernetes-replicator secret replication Serving a wildcard to ingress resources in different namespaces (default SSL certificate) \u00b6 Most ingress controllers, including ingress-nginx , Traefik , and Kong support specifying a single certificate to be used for ingress resources which request TLS but do not specify tls.[].secretName . This is often referred to as a \"default SSL certificate\". As long as this is correctly configured, ingress resources in any namespace will be able to use a single wildcard certificate. Wildcard certificates are not supported with HTTP01 validation and require DNS01. Sample ingress snippet: apiVersion: networking.k8s.io/v1 kind: Ingress #[...] spec: rules: - host: service.example.com #[...] tls: - hosts: - service.example.com #secretName omitted to use default wildcard certificate Syncing arbitrary secrets across namespaces using extensions \u00b6 In order for the target Secret to be synced, you can use the secretTemplate field for annotating the generated secret with the extension specific annotation (See CertificateSecretTemplate ). Using reflector \u00b6 The example below shows syncing a certificate's secret from the cert-manager namespace to multiple namespaces (i.e. dev , staging , prod ). Reflector will ensure that any namespace (existing or new) matching the allowed condition (with regex support) will get a copy of the certificate's secret and will keep it up to date. You can also sync other secrets (different name) using reflector (consult the extension's README ) --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : source namespace : cert-manager spec : secretName : source-tls commonName : source issuerRef : name : source-ca kind : Issuer group : cert-manager.io secretTemplate : annotations : reflector.v1.k8s.emberstack.com/reflection-allowed : \"true\" reflector.v1.k8s.emberstack.com/reflection-allowed-namespaces : \"dev,staging,prod\" # Control destination namespaces reflector.v1.k8s.emberstack.com/reflection-auto-enabled : \"true\" # Auto create reflection for matching namespaces reflector.v1.k8s.emberstack.com/reflection-auto-namespaces : \"dev,staging,prod\" # Control auto-reflection namespaces Using kubed \u00b6 The example below shows syncing a certificate belonging to the sandbox Certificate from the cert-manager namespace, into the sandbox namespace. apiVersion : v1 kind : Namespace metadata : name : sandbox labels : cert-manager-tls : sandbox # Define namespace label for kubed --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : sandbox namespace : cert-manager spec : secretName : sandbox-tls commonName : sandbox issuerRef : name : sandbox-ca kind : Issuer group : cert-manager.io secretTemplate : annotations : kubed.appscode.com/sync : \"cert-manager-tls=sandbox\" # Sync certificate to matching namespaces Using kubernetes-replicator \u00b6 Replicator supports both push- and pull-based replication. Push-based replication will \"push out\" the TLS secret into namespaces when new ones are created, or when the secret changes. Pull-based replication makes it possible to create an empty TLS secret in the destination namespace and select a \"source\" resource from which the data is replicated from. The following example shows the pull-based approach: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : source namespace : cert-manager spec : secretName : source-tls commonName : source issuerRef : name : source-ca kind : Issuer secretTemplate : annotations : replicator.v1.mittwald.de/replication-allowed : \"true\" # permit replication replicator.v1.mittwald.de/replication-allowed-namespaces : \"dev,test,prod-[0-9]*\" # comma separated list of namespaces or regular expressions --- apiVersion : v1 kind : Secret metadata : name : tls-secret-replica namespace : prod-1 annotations : replicator.v1.mittwald.de/replicate-from : cert-manager/source-tls type : kubernetes.io/tls # Normally, we'd create an empty destination secret, but secrets of type # 'kubernetes.io/tls' are treated in a special way and need to have properties # data[\"tls.crt\"] and data[\"tls.key\"] to begin with, though they may be empty. data : tls.key : \"\" tls.crt : \"\"","title":"Syncing Secrets Across Namespaces"},{"location":"tutorials/syncing-secrets-across-namespaces/#serving-a-wildcard-to-ingress-resources-in-different-namespaces-default-ssl-certificate","text":"Most ingress controllers, including ingress-nginx , Traefik , and Kong support specifying a single certificate to be used for ingress resources which request TLS but do not specify tls.[].secretName . This is often referred to as a \"default SSL certificate\". As long as this is correctly configured, ingress resources in any namespace will be able to use a single wildcard certificate. Wildcard certificates are not supported with HTTP01 validation and require DNS01. Sample ingress snippet: apiVersion: networking.k8s.io/v1 kind: Ingress #[...] spec: rules: - host: service.example.com #[...] tls: - hosts: - service.example.com #secretName omitted to use default wildcard certificate","title":"Serving a wildcard to ingress resources in different namespaces (default SSL certificate)"},{"location":"tutorials/syncing-secrets-across-namespaces/#syncing-arbitrary-secrets-across-namespaces-using-extensions","text":"In order for the target Secret to be synced, you can use the secretTemplate field for annotating the generated secret with the extension specific annotation (See CertificateSecretTemplate ).","title":"Syncing arbitrary secrets across namespaces using extensions"},{"location":"tutorials/syncing-secrets-across-namespaces/#using-reflector","text":"The example below shows syncing a certificate's secret from the cert-manager namespace to multiple namespaces (i.e. dev , staging , prod ). Reflector will ensure that any namespace (existing or new) matching the allowed condition (with regex support) will get a copy of the certificate's secret and will keep it up to date. You can also sync other secrets (different name) using reflector (consult the extension's README ) --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : source namespace : cert-manager spec : secretName : source-tls commonName : source issuerRef : name : source-ca kind : Issuer group : cert-manager.io secretTemplate : annotations : reflector.v1.k8s.emberstack.com/reflection-allowed : \"true\" reflector.v1.k8s.emberstack.com/reflection-allowed-namespaces : \"dev,staging,prod\" # Control destination namespaces reflector.v1.k8s.emberstack.com/reflection-auto-enabled : \"true\" # Auto create reflection for matching namespaces reflector.v1.k8s.emberstack.com/reflection-auto-namespaces : \"dev,staging,prod\" # Control auto-reflection namespaces","title":"Using reflector"},{"location":"tutorials/syncing-secrets-across-namespaces/#using-kubed","text":"The example below shows syncing a certificate belonging to the sandbox Certificate from the cert-manager namespace, into the sandbox namespace. apiVersion : v1 kind : Namespace metadata : name : sandbox labels : cert-manager-tls : sandbox # Define namespace label for kubed --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : sandbox namespace : cert-manager spec : secretName : sandbox-tls commonName : sandbox issuerRef : name : sandbox-ca kind : Issuer group : cert-manager.io secretTemplate : annotations : kubed.appscode.com/sync : \"cert-manager-tls=sandbox\" # Sync certificate to matching namespaces","title":"Using kubed"},{"location":"tutorials/syncing-secrets-across-namespaces/#using-kubernetes-replicator","text":"Replicator supports both push- and pull-based replication. Push-based replication will \"push out\" the TLS secret into namespaces when new ones are created, or when the secret changes. Pull-based replication makes it possible to create an empty TLS secret in the destination namespace and select a \"source\" resource from which the data is replicated from. The following example shows the pull-based approach: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : source namespace : cert-manager spec : secretName : source-tls commonName : source issuerRef : name : source-ca kind : Issuer secretTemplate : annotations : replicator.v1.mittwald.de/replication-allowed : \"true\" # permit replication replicator.v1.mittwald.de/replication-allowed-namespaces : \"dev,test,prod-[0-9]*\" # comma separated list of namespaces or regular expressions --- apiVersion : v1 kind : Secret metadata : name : tls-secret-replica namespace : prod-1 annotations : replicator.v1.mittwald.de/replicate-from : cert-manager/source-tls type : kubernetes.io/tls # Normally, we'd create an empty destination secret, but secrets of type # 'kubernetes.io/tls' are treated in a special way and need to have properties # data[\"tls.crt\"] and data[\"tls.key\"] to begin with, though they may be empty. data : tls.key : \"\" tls.crt : \"\"","title":"Using kubernetes-replicator"},{"location":"tutorials/acme/dns-validation/","text":"Issuing an ACME certificate using DNS validation \u00b6 cert-manager can be used to obtain certificates from a CA using the ACME protocol. The ACME protocol supports various challenge mechanisms which are used to prove ownership of a domain so that a valid certificate can be issued for that domain. One such challenge mechanism is DNS01. With a DNS01 challenge, you prove ownership of a domain by proving you control its DNS records. This is done by creating a TXT record with specific content that proves you have control of the domains DNS records. The following Issuer defines the necessary information to enable DNS validation. You can read more about the Issuer resource in the Issuer docs . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging namespace : default spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory email : user@example.com # Name of a secret used to store the ACME account private key privateKeySecretRef : name : letsencrypt-staging # ACME DNS-01 provider configurations solvers : # An empty 'selector' means that this solver matches all domains - selector : {} dns01 : cloudDNS : # The ID of the GCP project # reference: https://cert-manager.io/docs/tutorials/acme/dns-validation/ project : $PROJECT_ID # This is the secret used to access the service account serviceAccountSecretRef : name : clouddns-dns01-solver-svc-acct key : key.json # We only use cloudflare to solve challenges for example.org. # Alternative options such as 'matchLabels' and 'dnsZones' can be specified # as part of a solver's selector too. - selector : dnsNames : - example.org dns01 : cloudflare : email : my-cloudflare-acc@example.com # !! Remember to create a k8s secret before # kubectl create secret generic cloudflare-api-key-secret apiKeySecretRef : name : cloudflare-api-key-secret key : api-key We have specified the ACME server URL for Let's Encrypt's staging environment . The staging environment will not issue trusted certificates but is used to ensure that the verification process is working properly before moving to production. Let's Encrypt's production environment imposes much stricter rate limits , so to reduce the chance of you hitting those limits it is highly recommended to start by using the staging environment. To move to production, simply create a new Issuer with the URL set to https://acme-v02.api.letsencrypt.org/directory . The first stage of the ACME protocol is for the client to register with the ACME server. This phase includes generating an asymmetric key pair which is then associated with the email address specified in the Issuer. Make sure to change this email address to a valid one that you own. It is commonly used to send expiry notices when your certificates are coming up for renewal. The generated private key is stored in a Secret named letsencrypt-staging . The dns01 stanza contains a list of DNS01 providers that can be used to solve DNS challenges. Our Issuer defines two providers. This gives us a choice of which one to use when obtaining certificates. More information about the DNS provider configuration, including a list of supported providers, can be found in the DNS01 reference docs . Once we have created the above Issuer we can use it to obtain a certificate. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : name : letsencrypt-staging dnsNames : - '*.example.com' - example.com - example.org The Certificate resource describes our desired certificate and the possible methods that can be used to obtain it. You can obtain certificates for wildcard domains just like any other. Make sure to wrap wildcard domains with asterisks in your YAML resources, to avoid formatting issues. If you specify both example.com and *.example.com on the same Certificate, it will take slightly longer to perform validation as each domain will have to be validated one after the other. You can learn more about the Certificate resource in the docs . If the certificate is obtained successfully, the resulting key pair will be stored in a secret called example-com-tls in the same namespace as the Certificate. The certificate will have a common name of *.example.com and the Subject Alternative Names (SANs) will be *.example.com , example.com and example.org . In our Certificate we have referenced the letsencrypt-staging Issuer above. The Issuer must be in the same namespace as the Certificate. If you want to reference a ClusterIssuer , which is a cluster-scoped version of an Issuer, you must add kind: ClusterIssuer to the issuerRef stanza. For more information on ClusterIssuers , read the issuer concepts . The acme stanza defines the configuration for our ACME challenges. Here we have defined the configuration for our DNS challenges which will be used to verify domain ownership. For each domain mentioned in a dns01 stanza, cert-manager will use the provider's credentials from the referenced Issuer to create a TXT record called _acme-challenge . This record will then be verified by the ACME server in order to issue the certificate. Once domain ownership has been verified, any cert-manager affected records will be cleaned up. Note: It is your responsibility to ensure the selected provider is authoritative for your domain. After creating the above Certificate, we can check whether it has been obtained successfully using kubectl describe : $ kubectl describe certificate example-com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 57m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 55m cert-manager Domain \"*.example.com\" verified with \"dns-01\" validation Normal DomainVerified 55m cert-manager Domain \"example.com\" verified with \"dns-01\" validation Normal DomainVerified 55m cert-manager Domain \"example.org\" verified with \"dns-01\" validation Normal IssueCert 55m cert-manager Issuing certificate... Normal CertObtained 55m cert-manager Obtained certificate from ACME server Normal CertIssued 55m cert-manager Certificate issued successfully You can also check whether issuance was successful with kubectl get secret example-com-tls -o yaml . You should see a base64 encoded signed TLS key pair. Once our certificate has been obtained, cert-manager will periodically check its validity and attempt to renew it if it gets close to expiry. cert-manager considers certificates to be close to expiry when the 'Not After' field on the certificate is less than the current time plus 30 days.","title":"DNS Validation"},{"location":"tutorials/acme/dns-validation/#issuing-an-acme-certificate-using-dns-validation","text":"cert-manager can be used to obtain certificates from a CA using the ACME protocol. The ACME protocol supports various challenge mechanisms which are used to prove ownership of a domain so that a valid certificate can be issued for that domain. One such challenge mechanism is DNS01. With a DNS01 challenge, you prove ownership of a domain by proving you control its DNS records. This is done by creating a TXT record with specific content that proves you have control of the domains DNS records. The following Issuer defines the necessary information to enable DNS validation. You can read more about the Issuer resource in the Issuer docs . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging namespace : default spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory email : user@example.com # Name of a secret used to store the ACME account private key privateKeySecretRef : name : letsencrypt-staging # ACME DNS-01 provider configurations solvers : # An empty 'selector' means that this solver matches all domains - selector : {} dns01 : cloudDNS : # The ID of the GCP project # reference: https://cert-manager.io/docs/tutorials/acme/dns-validation/ project : $PROJECT_ID # This is the secret used to access the service account serviceAccountSecretRef : name : clouddns-dns01-solver-svc-acct key : key.json # We only use cloudflare to solve challenges for example.org. # Alternative options such as 'matchLabels' and 'dnsZones' can be specified # as part of a solver's selector too. - selector : dnsNames : - example.org dns01 : cloudflare : email : my-cloudflare-acc@example.com # !! Remember to create a k8s secret before # kubectl create secret generic cloudflare-api-key-secret apiKeySecretRef : name : cloudflare-api-key-secret key : api-key We have specified the ACME server URL for Let's Encrypt's staging environment . The staging environment will not issue trusted certificates but is used to ensure that the verification process is working properly before moving to production. Let's Encrypt's production environment imposes much stricter rate limits , so to reduce the chance of you hitting those limits it is highly recommended to start by using the staging environment. To move to production, simply create a new Issuer with the URL set to https://acme-v02.api.letsencrypt.org/directory . The first stage of the ACME protocol is for the client to register with the ACME server. This phase includes generating an asymmetric key pair which is then associated with the email address specified in the Issuer. Make sure to change this email address to a valid one that you own. It is commonly used to send expiry notices when your certificates are coming up for renewal. The generated private key is stored in a Secret named letsencrypt-staging . The dns01 stanza contains a list of DNS01 providers that can be used to solve DNS challenges. Our Issuer defines two providers. This gives us a choice of which one to use when obtaining certificates. More information about the DNS provider configuration, including a list of supported providers, can be found in the DNS01 reference docs . Once we have created the above Issuer we can use it to obtain a certificate. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : name : letsencrypt-staging dnsNames : - '*.example.com' - example.com - example.org The Certificate resource describes our desired certificate and the possible methods that can be used to obtain it. You can obtain certificates for wildcard domains just like any other. Make sure to wrap wildcard domains with asterisks in your YAML resources, to avoid formatting issues. If you specify both example.com and *.example.com on the same Certificate, it will take slightly longer to perform validation as each domain will have to be validated one after the other. You can learn more about the Certificate resource in the docs . If the certificate is obtained successfully, the resulting key pair will be stored in a secret called example-com-tls in the same namespace as the Certificate. The certificate will have a common name of *.example.com and the Subject Alternative Names (SANs) will be *.example.com , example.com and example.org . In our Certificate we have referenced the letsencrypt-staging Issuer above. The Issuer must be in the same namespace as the Certificate. If you want to reference a ClusterIssuer , which is a cluster-scoped version of an Issuer, you must add kind: ClusterIssuer to the issuerRef stanza. For more information on ClusterIssuers , read the issuer concepts . The acme stanza defines the configuration for our ACME challenges. Here we have defined the configuration for our DNS challenges which will be used to verify domain ownership. For each domain mentioned in a dns01 stanza, cert-manager will use the provider's credentials from the referenced Issuer to create a TXT record called _acme-challenge . This record will then be verified by the ACME server in order to issue the certificate. Once domain ownership has been verified, any cert-manager affected records will be cleaned up. Note: It is your responsibility to ensure the selected provider is authoritative for your domain. After creating the above Certificate, we can check whether it has been obtained successfully using kubectl describe : $ kubectl describe certificate example-com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 57m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 55m cert-manager Domain \"*.example.com\" verified with \"dns-01\" validation Normal DomainVerified 55m cert-manager Domain \"example.com\" verified with \"dns-01\" validation Normal DomainVerified 55m cert-manager Domain \"example.org\" verified with \"dns-01\" validation Normal IssueCert 55m cert-manager Issuing certificate... Normal CertObtained 55m cert-manager Obtained certificate from ACME server Normal CertIssued 55m cert-manager Certificate issued successfully You can also check whether issuance was successful with kubectl get secret example-com-tls -o yaml . You should see a base64 encoded signed TLS key pair. Once our certificate has been obtained, cert-manager will periodically check its validity and attempt to renew it if it gets close to expiry. cert-manager considers certificates to be close to expiry when the 'Not After' field on the certificate is less than the current time plus 30 days.","title":"Issuing an ACME certificate using DNS validation"},{"location":"tutorials/acme/http-validation/","text":"Issuing an ACME certificate using HTTP validation \u00b6 cert-manager can be used to obtain certificates from a CA using the ACME protocol. The ACME protocol supports various challenge mechanisms which are used to prove ownership of a domain so that a valid certificate can be issued for that domain. One such challenge mechanism is the HTTP01 challenge. With a HTTP01 challenge, you prove ownership of a domain by ensuring that a particular file is present at the domain. It is assumed that you control the domain if you are able to publish the given file under a given path. The following Issuer defines the necessary information to enable HTTP validation. You can read more about the Issuer resource in the Issuer docs . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging namespace : default spec : acme : # The ACME server URL server : https://acme-staging-v02.api.letsencrypt.org/directory # Email address used for ACME registration email : user@example.com # Name of a secret used to store the ACME account private key privateKeySecretRef : name : letsencrypt-staging # Enable the HTTP-01 challenge provider solvers : # An empty 'selector' means that this solver matches all domains - selector : {} http01 : ingress : class : nginx We have specified the ACME server URL for Let's Encrypt's staging environment . The staging environment will not issue trusted certificates but is used to ensure that the verification process is working properly before moving to production. Let's Encrypt's production environment imposes much stricter rate limits , so to reduce the chance of you hitting those limits it is highly recommended to start by using the staging environment. To move to production, simply create a new Issuer with the URL set to https://acme-v02.api.letsencrypt.org/directory . The first stage of the ACME protocol is for the client to register with the ACME server. This phase includes generating an asymmetric key pair which is then associated with the email address specified in the Issuer. Make sure to change this email address to a valid one that you own. It is commonly used to send expiry notices when your certificates are coming up for renewal. The generated private key is stored in a Secret named letsencrypt-staging . We must provide one or more Solvers for handling the ACME challenge. In this case we want to use HTTP validation so we specify an http01 Solver. We could optionally map different domains to use different Solver configurations. Once we have created the above Issuer we can use it to obtain a certificate. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : name : letsencrypt-staging commonName : example.com dnsNames : - www.example.com The Certificate resource describes our desired certificate and the possible methods that can be used to obtain it. You can learn more about the Certificate resource in the docs . If the certificate is obtained successfully, the resulting key pair will be stored in a secret called example-com-tls in the same namespace as the Certificate. The certificate will have a common name of example.com and the Subject Alternative Names (SANs) will be example.com and www.example.com . Note that only these SANs will be respected by TLS clients. In our Certificate we have referenced the letsencrypt-staging Issuer above. The Issuer must be in the same namespace as the Certificate. If you want to reference a ClusterIssuer , which is a cluster-scoped version of an Issuer, you must add kind: ClusterIssuer to the issuerRef stanza. For more information on ClusterIssuers , read the ClusterIssuer docs . The acme stanza defines the configuration for our ACME challenges. Here we have defined the configuration for our HTTP01 challenges which will be used to verify domain ownership. To verify ownership of each domain mentioned in an http01 stanza, cert-manager will create a Pod, Service and Ingress that exposes an HTTP endpoint that satisfies the HTTP01 challenge. The fields ingress and ingressClass in the http01 stanza can be used to control how cert-manager interacts with Ingress resources: If the ingress field is specified, then an Ingress resource with the same name in the same namespace as the Certificate must already exist and it will be modified only to add the appropriate rules to solve the challenge. This field is useful for the Google Cloud Loadbalancer ingress controller, as well as a number of others, that assign a single public IP address for each ingress resource. Without manual intervention, creating a new ingress resource would cause any challenges to fail. If the ingressClass field is specified, a new ingress resource with a randomly generated name will be created in order to solve the challenge. This new resource will have an annotation with key kubernetes.io/ingress.class and value set to the value of the ingressClass field. This works for the likes of the NGINX ingress controller. If neither are specified, new ingress resources will be created with a randomly generated name, but they will not have the ingress class annotation set. If both are specified, then the ingress field will take precedence. Once domain ownership has been verified, any cert-manager affected resources will be cleaned up or deleted. Note: It is your responsibility to point each domain name at the correct IP address for your ingress controller. After creating the above Certificate, we can check whether it has been obtained successfully using kubectl describe : $ kubectl describe certificate example-com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 57m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 55m cert-manager Domain \"example.com\" verified with \"http-01\" validation Normal DomainVerified 55m cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Normal IssueCert 55m cert-manager Issuing certificate... Normal CertObtained 55m cert-manager Obtained certificate from ACME server Normal CertIssued 55m cert-manager Certificate issued successfully You can also check whether issuance was successful with kubectl get secret example-com-tls -o yaml . You should see a base64 encoded signed TLS key pair. Once our certificate has been obtained, cert-manager will periodically check its validity and attempt to renew it if it gets close to expiry. cert-manager considers certificates to be close to expiry when the 'Not After' field on the certificate is less than the current time plus 30 days.","title":"HTTP Validation"},{"location":"tutorials/acme/http-validation/#issuing-an-acme-certificate-using-http-validation","text":"cert-manager can be used to obtain certificates from a CA using the ACME protocol. The ACME protocol supports various challenge mechanisms which are used to prove ownership of a domain so that a valid certificate can be issued for that domain. One such challenge mechanism is the HTTP01 challenge. With a HTTP01 challenge, you prove ownership of a domain by ensuring that a particular file is present at the domain. It is assumed that you control the domain if you are able to publish the given file under a given path. The following Issuer defines the necessary information to enable HTTP validation. You can read more about the Issuer resource in the Issuer docs . apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging namespace : default spec : acme : # The ACME server URL server : https://acme-staging-v02.api.letsencrypt.org/directory # Email address used for ACME registration email : user@example.com # Name of a secret used to store the ACME account private key privateKeySecretRef : name : letsencrypt-staging # Enable the HTTP-01 challenge provider solvers : # An empty 'selector' means that this solver matches all domains - selector : {} http01 : ingress : class : nginx We have specified the ACME server URL for Let's Encrypt's staging environment . The staging environment will not issue trusted certificates but is used to ensure that the verification process is working properly before moving to production. Let's Encrypt's production environment imposes much stricter rate limits , so to reduce the chance of you hitting those limits it is highly recommended to start by using the staging environment. To move to production, simply create a new Issuer with the URL set to https://acme-v02.api.letsencrypt.org/directory . The first stage of the ACME protocol is for the client to register with the ACME server. This phase includes generating an asymmetric key pair which is then associated with the email address specified in the Issuer. Make sure to change this email address to a valid one that you own. It is commonly used to send expiry notices when your certificates are coming up for renewal. The generated private key is stored in a Secret named letsencrypt-staging . We must provide one or more Solvers for handling the ACME challenge. In this case we want to use HTTP validation so we specify an http01 Solver. We could optionally map different domains to use different Solver configurations. Once we have created the above Issuer we can use it to obtain a certificate. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : default spec : secretName : example-com-tls issuerRef : name : letsencrypt-staging commonName : example.com dnsNames : - www.example.com The Certificate resource describes our desired certificate and the possible methods that can be used to obtain it. You can learn more about the Certificate resource in the docs . If the certificate is obtained successfully, the resulting key pair will be stored in a secret called example-com-tls in the same namespace as the Certificate. The certificate will have a common name of example.com and the Subject Alternative Names (SANs) will be example.com and www.example.com . Note that only these SANs will be respected by TLS clients. In our Certificate we have referenced the letsencrypt-staging Issuer above. The Issuer must be in the same namespace as the Certificate. If you want to reference a ClusterIssuer , which is a cluster-scoped version of an Issuer, you must add kind: ClusterIssuer to the issuerRef stanza. For more information on ClusterIssuers , read the ClusterIssuer docs . The acme stanza defines the configuration for our ACME challenges. Here we have defined the configuration for our HTTP01 challenges which will be used to verify domain ownership. To verify ownership of each domain mentioned in an http01 stanza, cert-manager will create a Pod, Service and Ingress that exposes an HTTP endpoint that satisfies the HTTP01 challenge. The fields ingress and ingressClass in the http01 stanza can be used to control how cert-manager interacts with Ingress resources: If the ingress field is specified, then an Ingress resource with the same name in the same namespace as the Certificate must already exist and it will be modified only to add the appropriate rules to solve the challenge. This field is useful for the Google Cloud Loadbalancer ingress controller, as well as a number of others, that assign a single public IP address for each ingress resource. Without manual intervention, creating a new ingress resource would cause any challenges to fail. If the ingressClass field is specified, a new ingress resource with a randomly generated name will be created in order to solve the challenge. This new resource will have an annotation with key kubernetes.io/ingress.class and value set to the value of the ingressClass field. This works for the likes of the NGINX ingress controller. If neither are specified, new ingress resources will be created with a randomly generated name, but they will not have the ingress class annotation set. If both are specified, then the ingress field will take precedence. Once domain ownership has been verified, any cert-manager affected resources will be cleaned up or deleted. Note: It is your responsibility to point each domain name at the correct IP address for your ingress controller. After creating the above Certificate, we can check whether it has been obtained successfully using kubectl describe : $ kubectl describe certificate example-com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 57m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 55m cert-manager Domain \"example.com\" verified with \"http-01\" validation Normal DomainVerified 55m cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Normal IssueCert 55m cert-manager Issuing certificate... Normal CertObtained 55m cert-manager Obtained certificate from ACME server Normal CertIssued 55m cert-manager Certificate issued successfully You can also check whether issuance was successful with kubectl get secret example-com-tls -o yaml . You should see a base64 encoded signed TLS key pair. Once our certificate has been obtained, cert-manager will periodically check its validity and attempt to renew it if it gets close to expiry. cert-manager considers certificates to be close to expiry when the 'Not After' field on the certificate is less than the current time plus 30 days.","title":"Issuing an ACME certificate using HTTP validation"},{"location":"tutorials/acme/migrating-from-kube-lego/","text":"kube-lego is an older Jetstack project for obtaining TLS certificates from Let's Encrypt (or another ACME server). Since cert-managers release, kube-lego has been gradually deprecated in favor of this project. There are a number of key differences between the two: Feature kube-lego cert-manager Configuration Annotations on Ingress resources CRDs CAs ACME ACME, signing key pair Kubernetes v1.2 - v1.8 v1.7+ Debugging Look at logs Kubernetes Events API Multi-tenancy Not supported Supported Distinct issuance sources per Certificate Not supported Supported Ingress controller support (ACME) GCE, NGINX All This guide will walk through how you can safely migrate your kube-lego installation to cert-manager, without service interruption. By the end of the guide, we should have: Scaled down and removed kube-lego Installed cert-manager Migrated ACME private key to cert-manager Created an ACME ClusterIssuer using this private key, to issue certificates throughout your cluster Configured cert-manager's ingress-shim to automatically provision Certificate resources for all Ingress resources with the kubernetes.io/tls-acme: \"true\" annotation, using the ClusterIssuer we have created Verified that the cert-manager installation is working 1. Scale down kube-lego \u00b6 Before we begin deploying cert-manager, it is best we scale our kube-lego deployment down to 0 replicas. This will prevent the two controllers potentially 'fighting' each other. If you deployed kube-lego using the official deployment YAMLs, a command like so should do: $ kubectl scale deployment kube-lego \\ --namespace kube-lego \\ --replicas = 0 You can then verify your kube-lego pod is no longer running with: $ kubectl get pods --namespace kube-lego 2. Deploy cert-manager \u00b6 cert-manager should be deployed using Helm, according to our official installation guide . No special steps are required here. We will return to this deployment at the end of this guide and perform an upgrade of some of the CLI flags we deploy cert-manager with however. Please take extra care to ensure you have configured RBAC correctly when deploying Helm and cert-manager - there are some nuances described in our deploying document! 3. Obtaining your ACME account private key \u00b6 In order to continue issuing and renewing certificates on your behalf, we need to migrate the user account private key that kube-lego has created for you over to cert-manager. Your ACME user account identity is a private key, stored in a secret resource. By default, kube-lego will store this key in a secret named kube-lego-account in the same namespace as your kube-lego Deployment. You may have overridden this value when you deploy kube-lego, in which case the secret name to use will be the value of the LEGO_SECRET_NAME environment variable. You should download a copy of this secret resource and save it in your local directory: $ kubectl get secret kube-lego-account -o yaml \\ --namespace kube-lego \\ --export > kube-lego-account.yaml Once saved, open up this file and change the metadata.name field to something more relevant to cert-manager. For the rest of this guide, we'll assume you chose letsencrypt-private-key . Once done, we need to create this new resource in the cert-manager namespace. By default, cert-manager stores supporting resources for ClusterIssuers in the namespace that it is running in, and we used cert-manager when deploying cert-manager above. You should change this if you have deployed cert-manager into a different namespace. $ kubectl create -f kube-lego-account.yaml \\ --namespace cert-manager 4. Creating an ACME ClusterIssuer using your old ACME account \u00b6 We need to create a ClusterIssuer which will hold information about the ACME account previously registered via kube-lego. In order to do so, we need two more pieces of information from our old kube-lego deployment: the server URL of the ACME server, and the email address used to register the account. Both of these bits of information are stored within the kube-lego ConfigMap . To retrieve them, you should be able to get the ConfigMap using kubectl : $ kubectl get configmap kube-lego -o yaml \\ --namespace kube-lego \\ --export Your email address should be shown under the .data.lego.email field, and the ACME server URL under .data.lego.url . For the purposes of this guide, we will assume the email is user@example.com and the URL https://acme-staging-v02.api.letsencrypt.org/directory . Now that we have migrated our private key to the new Secret resource, as well as obtaining our ACME email address and URL, we can create a ClusterIssuer resource! Create a file named cluster-issuer.yaml : apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : # Adjust the name here accordingly name : letsencrypt-staging spec : acme : # The ACME server URL server : https://acme-staging-v02.api.letsencrypt.org/directory # Email address used for ACME registration email : user@example.com # Name of a secret used to store the ACME account private key from step 3 privateKeySecretRef : name : letsencrypt-private-key # Enable the HTTP-01 challenge provider solvers : - http01 : ingress : class : nginx We then submit this file to our Kubernetes cluster: $ kubectl create -f cluster-issuer.yaml You should be able to verify the ACME account has been verified successfully: $ kubectl describe clusterissuer letsencrypt-staging ... Status: Acme: Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/7571319 Conditions: Last Transition Time: 2019 -01-30T14:52:03Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready 5. Configuring ingress-shim to use our new ClusterIssuer by default \u00b6 Now that our ClusterIssuer is ready to issue certificates, we have one last thing to do: we must reconfigure ingress-shim (deployed as part of cert-manager) to automatically create Certificate resources for all Ingress resources it finds with appropriate annotations. More information on the role of ingress-shim can be found in the docs , but for now we can just run a helm upgrade in order to add a few additional flags. Assuming you've named your ClusterIssuer letsencrypt-staging (as above), run: $ helm upgrade cert-manager \\ jetstack/cert-manager \\ --namespace cert-manager \\ --set ingressShim.defaultIssuerName = letsencrypt-staging \\ --set ingressShim.defaultIssuerKind = ClusterIssuer You should see the cert-manager pod be re-created, and once started it should automatically create Certificate resources for all of your ingresses that previously had kube-lego enabled. 6. Verify each ingress now has a corresponding Certificate \u00b6 Before we finish, we should make sure there is now a Certificate resource for each ingress resource you previously enabled kube-lego on. You should be able to check this by running: $ kubectl get certificates --all-namespaces There should be an entry for each ingress in your cluster with the kube-lego annotation. We can also verify that cert-manager has 'adopted' the old TLS certificates by viewing the logs for cert-manager: $ kubectl logs -n cert-manager -l app = cert-manager -c cert-manager ... I1025 21 :54:02.869269 1 sync.go:206 ] Certificate my-example-certificate scheduled for renewal in 292 hours Here we can see cert-manager has verified the existing TLS certificate and scheduled it to be renewed in 292 hours time.","title":"Migrating from Kube-LEGO"},{"location":"tutorials/acme/migrating-from-kube-lego/#1-scale-down-kube-lego","text":"Before we begin deploying cert-manager, it is best we scale our kube-lego deployment down to 0 replicas. This will prevent the two controllers potentially 'fighting' each other. If you deployed kube-lego using the official deployment YAMLs, a command like so should do: $ kubectl scale deployment kube-lego \\ --namespace kube-lego \\ --replicas = 0 You can then verify your kube-lego pod is no longer running with: $ kubectl get pods --namespace kube-lego","title":"1. Scale down kube-lego"},{"location":"tutorials/acme/migrating-from-kube-lego/#2-deploy-cert-manager","text":"cert-manager should be deployed using Helm, according to our official installation guide . No special steps are required here. We will return to this deployment at the end of this guide and perform an upgrade of some of the CLI flags we deploy cert-manager with however. Please take extra care to ensure you have configured RBAC correctly when deploying Helm and cert-manager - there are some nuances described in our deploying document!","title":"2. Deploy cert-manager"},{"location":"tutorials/acme/migrating-from-kube-lego/#3-obtaining-your-acme-account-private-key","text":"In order to continue issuing and renewing certificates on your behalf, we need to migrate the user account private key that kube-lego has created for you over to cert-manager. Your ACME user account identity is a private key, stored in a secret resource. By default, kube-lego will store this key in a secret named kube-lego-account in the same namespace as your kube-lego Deployment. You may have overridden this value when you deploy kube-lego, in which case the secret name to use will be the value of the LEGO_SECRET_NAME environment variable. You should download a copy of this secret resource and save it in your local directory: $ kubectl get secret kube-lego-account -o yaml \\ --namespace kube-lego \\ --export > kube-lego-account.yaml Once saved, open up this file and change the metadata.name field to something more relevant to cert-manager. For the rest of this guide, we'll assume you chose letsencrypt-private-key . Once done, we need to create this new resource in the cert-manager namespace. By default, cert-manager stores supporting resources for ClusterIssuers in the namespace that it is running in, and we used cert-manager when deploying cert-manager above. You should change this if you have deployed cert-manager into a different namespace. $ kubectl create -f kube-lego-account.yaml \\ --namespace cert-manager","title":"3. Obtaining your ACME account private key"},{"location":"tutorials/acme/migrating-from-kube-lego/#4-creating-an-acme-clusterissuer-using-your-old-acme-account","text":"We need to create a ClusterIssuer which will hold information about the ACME account previously registered via kube-lego. In order to do so, we need two more pieces of information from our old kube-lego deployment: the server URL of the ACME server, and the email address used to register the account. Both of these bits of information are stored within the kube-lego ConfigMap . To retrieve them, you should be able to get the ConfigMap using kubectl : $ kubectl get configmap kube-lego -o yaml \\ --namespace kube-lego \\ --export Your email address should be shown under the .data.lego.email field, and the ACME server URL under .data.lego.url . For the purposes of this guide, we will assume the email is user@example.com and the URL https://acme-staging-v02.api.letsencrypt.org/directory . Now that we have migrated our private key to the new Secret resource, as well as obtaining our ACME email address and URL, we can create a ClusterIssuer resource! Create a file named cluster-issuer.yaml : apiVersion : cert-manager.io/v1 kind : ClusterIssuer metadata : # Adjust the name here accordingly name : letsencrypt-staging spec : acme : # The ACME server URL server : https://acme-staging-v02.api.letsencrypt.org/directory # Email address used for ACME registration email : user@example.com # Name of a secret used to store the ACME account private key from step 3 privateKeySecretRef : name : letsencrypt-private-key # Enable the HTTP-01 challenge provider solvers : - http01 : ingress : class : nginx We then submit this file to our Kubernetes cluster: $ kubectl create -f cluster-issuer.yaml You should be able to verify the ACME account has been verified successfully: $ kubectl describe clusterissuer letsencrypt-staging ... Status: Acme: Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/7571319 Conditions: Last Transition Time: 2019 -01-30T14:52:03Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready","title":"4. Creating an ACME ClusterIssuer using your old ACME account"},{"location":"tutorials/acme/migrating-from-kube-lego/#5-configuring-ingress-shim-to-use-our-new-clusterissuer-by-default","text":"Now that our ClusterIssuer is ready to issue certificates, we have one last thing to do: we must reconfigure ingress-shim (deployed as part of cert-manager) to automatically create Certificate resources for all Ingress resources it finds with appropriate annotations. More information on the role of ingress-shim can be found in the docs , but for now we can just run a helm upgrade in order to add a few additional flags. Assuming you've named your ClusterIssuer letsencrypt-staging (as above), run: $ helm upgrade cert-manager \\ jetstack/cert-manager \\ --namespace cert-manager \\ --set ingressShim.defaultIssuerName = letsencrypt-staging \\ --set ingressShim.defaultIssuerKind = ClusterIssuer You should see the cert-manager pod be re-created, and once started it should automatically create Certificate resources for all of your ingresses that previously had kube-lego enabled.","title":"5. Configuring ingress-shim to use our new ClusterIssuer by default"},{"location":"tutorials/acme/migrating-from-kube-lego/#6-verify-each-ingress-now-has-a-corresponding-certificate","text":"Before we finish, we should make sure there is now a Certificate resource for each ingress resource you previously enabled kube-lego on. You should be able to check this by running: $ kubectl get certificates --all-namespaces There should be an entry for each ingress in your cluster with the kube-lego annotation. We can also verify that cert-manager has 'adopted' the old TLS certificates by viewing the logs for cert-manager: $ kubectl logs -n cert-manager -l app = cert-manager -c cert-manager ... I1025 21 :54:02.869269 1 sync.go:206 ] Certificate my-example-certificate scheduled for renewal in 292 hours Here we can see cert-manager has verified the existing TLS certificate and scheduled it to be renewed in 292 hours time.","title":"6. Verify each ingress now has a corresponding Certificate"},{"location":"tutorials/acme/nginx-ingress/","text":"This tutorial will detail how to install and secure ingress to your cluster using NGINX. Step 1 - Install Helm \u00b6 Skip this section if you have helm installed. The easiest way to install cert-manager is to use Helm , a templating and deployment tool for Kubernetes resources. First, ensure the Helm client is installed following the Helm installation instructions . For example, on MacOS: brew install kubernetes-helm Step 2 - Deploy the NGINX Ingress Controller \u00b6 A kubernetes ingress controller is designed to be the access point for HTTP and HTTPS traffic to the software running within your cluster. The ingress-nginx-controller does this by providing an HTTP proxy service supported by your cloud provider's load balancer. You can get more details about ingress-nginx and how it works from the documentation for ingress-nginx . Add the latest helm repository for the ingress-nginx helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx Update the helm repository with the latest charts: $ helm repo update Hang tight while we grab the latest from your chart repositories... ...Skip local chart repository ...Successfully got an update from the \"stable\" chart repository ...Successfully got an update from the \"ingress-nginx\" chart repository ...Successfully got an update from the \"coreos\" chart repository Update Complete. \u2388 Happy Helming!\u2388 Use helm to install an NGINX Ingress controller: $ helm install quickstart ingress-nginx/ingress-nginx NAME: quickstart ... lots of output ... It can take a minute or two for the cloud provider to provide and link a public IP address. When it is complete, you can see the external IP address using the kubectl command: $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE kubernetes ClusterIP 10 .0.0.1 <none> 443 /TCP 13m quickstart-ingress-nginx-controller LoadBalancer 10 .0.114.241 <pending> 80 :31635/TCP,443:30062/TCP 8m16s quickstart-ingress-nginx-controller-admission ClusterIP 10 .0.188.24 <none> 443 /TCP 8m16s This command shows you all the services in your cluster (in the default namespace), and any external IP addresses they have. When you first create the controller, your cloud provider won't have assigned and allocated an IP address through the LoadBalancer yet. Until it does, the external IP address for the service will be listed as <pending> . Your cloud provider may have options for reserving an IP address prior to creating the ingress controller and using that IP address rather than assigning an IP address from a pool. Read through the documentation from your cloud provider on how to arrange that. Step 3 - Assign a DNS name \u00b6 The external IP that is allocated to the ingress-controller is the IP to which all incoming traffic should be routed. To enable this, add it to a DNS zone you control, for example as www.example.com . This quick-start assumes you know how to assign a DNS entry to an IP address and will do so. Step 4 - Deploy an Example Service \u00b6 Your service may have its own chart, or you may be deploying it directly with manifests. This quick-start uses manifests to create and expose a sample service. The example service uses kuard , a demo application. The quick-start example uses three manifests for the sample. The first two are a sample deployment and an associated service: ```yaml file=./example/deployment.yaml ```yaml file=./example/service.yaml You can create download and reference these files locally, or you can reference them from the GitHub source repository for this documentation. To install the example service from the tutorial files straight from GitHub, do the following: kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/deployment.yaml # expected output: deployment.extensions \"kuard\" created kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/service.yaml # expected output: service \"kuard\" created An Ingress resource is what Kubernetes uses to expose this example service outside the cluster. You will need to download and modify the example manifest to reflect the domain that you own or control to complete this example. A sample ingress you can start with is: ```yaml file=./example/ingress.yaml You can download the sample manifest from GitHub , edit it, and submit the manifest to Kubernetes with the command below. Edit the file in your editor, and once it is saved: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress.yaml # expected output: ingress.extensions \"kuard\" created Note: The ingress example we show above has a host definition within it. The ingress-nginx-controller will route traffic when the hostname requested matches the definition in the ingress. You can deploy an ingress without a host definition in the rule, but that pattern isn't usable with a TLS certificate, which expects a fully qualified domain name. Once it is deployed, you can use the command kubectl get ingress to see the status of the ingress: NAME HOSTS ADDRESS PORTS AGE kuard * 80, 443 17s It may take a few minutes, depending on your service provider, for the ingress to be fully created. When it has been created and linked into place, the ingress will show an address as well: NAME HOSTS ADDRESS PORTS AGE kuard * 203.0.113.2 80 9m Note: The IP address on the ingress may not match the IP address that the ingress-nginx-controller has. This is fine, and is a quirk/implementation detail of the service provider hosting your Kubernetes cluster. Since we are using the ingress-nginx-controller instead of any cloud-provider specific ingress backend, use the IP address that was defined and allocated for the quickstart-ingress-nginx-controller LoadBalancer resource as the primary access point for your service. Make sure the service is reachable at the domain name you added above, for example http://www.example.com . The simplest way is to open a browser and enter the name that you set up in DNS, and for which we just added the ingress. You may also use a command line tool like curl to check the ingress. $ curl -kivL -H 'Host: www.example.com' 'http://203.0.113.2' The options on this curl command will provide verbose output, following any redirects, show the TLS headers in the output, and not error on insecure certificates. With ingress-nginx-controller , the service will be available with a TLS certificate, but it will be using a self-signed certificate provided as a default from the ingress-nginx-controller . Browsers will show a warning that this is an invalid certificate. This is expected and normal, as we have not yet used cert-manager to get a fully trusted certificate for our site. Warning : It is critical to make sure that your ingress is available and responding correctly on the internet. This quick-start example uses Let's Encrypt to provide the certificates, which expects and validates both that the service is available and that during the process of issuing a certificate uses that validation as proof that the request for the domain belongs to someone with sufficient control over the domain. Step 5 - Deploy cert-manager \u00b6 We need to install cert-manager to do the work with Kubernetes to request a certificate and respond to the challenge to validate it. We can use Helm or plain Kubernetes manifests to install cert-manager. Since we installed Helm earlier, we'll assume you want to use Helm; follow the Helm guide . For other methods, read the installation documentation for cert-manager. cert-manager mainly uses two different custom Kubernetes resources - known as CRDs - to configure and control how it operates, as well as to store state. These resources are Issuers and Certificates. Issuers \u00b6 An Issuer defines how cert-manager will request TLS certificates. Issuers are specific to a single namespace in Kubernetes, but there's also a ClusterIssuer which is meant to be a cluster-wide version. Take care to ensure that your Issuers are created in the same namespace as the certificates you want to create. You might need to add -n my-namespace to your kubectl create commands. Your other option is to replace your Issuers with ClusterIssuers ; ClusterIssuer resources apply across all Ingress resources in your cluster. If using a ClusterIssuer , remember to update the Ingress annotation cert-manager.io/issuer to cert-manager.io/cluster-issuer . If you see issues with issuers, follow the Troubleshooting Issuing ACME Certificates guide. More information on the differences between Issuers and ClusterIssuers - including when you might choose to use each can be found on Issuer concepts . Certificates \u00b6 Certificates resources allow you to specify the details of the certificate you want to request. They reference an issuer to define how they'll be issued. For more information, see Certificate concepts . Step 6 - Configure a Let's Encrypt Issuer \u00b6 We'll set up two issuers for Let's Encrypt in this example: staging and production. The Let's Encrypt production issuer has very strict rate limits . When you're experimenting and learning, it can be very easy to hit those limits. Because of that risk, we'll start with the Let's Encrypt staging issuer, and once we're happy that it's working we'll switch to the production issuer. Note that you'll see a warning about untrusted certificates from the staging issuer, but that's totally expected. Create this definition locally and update the email address to your own. This email is required by Let's Encrypt and used to notify you of certificate expiration and updates. ```yaml file=./example/staging-issuer.yaml Once edited, apply the custom resource: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/staging-issuer.yaml # expected output: issuer.cert-manager.io \"letsencrypt-staging\" created Also create a production issuer and deploy it. As with the staging issuer, you will need to update this example and add in your own email address. ```yaml file=./example/production-issuer.yaml ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/production-issuer.yaml # expected output: issuer.cert-manager.io \"letsencrypt-prod\" created Both of these issuers are configured to use the HTTP01 challenge provider. Check on the status of the issuer after you create it: $ kubectl describe issuer letsencrypt-staging Name: letsencrypt-staging Namespace: default Labels: <none> Annotations: kubectl.kubernetes.io/last-applied-configuration ={ \"apiVersion\" : \"cert-manager.io/v1\" , \"kind\" : \"Issuer\" , \"metadata\" : { \"annotations\" : {} , \"name\" : \"letsencrypt-staging\" , \"namespace\" : \"default\" } , ( ... )} API Version: cert-manager.io/v1 Kind: Issuer Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T18:03:54Z Generation: 0 Resource Version: 9092 Self Link: /apis/cert-manager.io/v1/namespaces/default/issuers/letsencrypt-staging UID: 25b7ae77-ea93-11e8-82f8-42010a8a00b5 Spec: Acme: Email: email@example.com Private Key Secret Ref: Key: Name: letsencrypt-staging Server: https://acme-staging-v02.api.letsencrypt.org/directory Solvers: Http 01 : Ingress: Class: nginx Status: Acme: Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/7374163 Conditions: Last Transition Time: 2018 -11-17T18:04:00Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready Events: <none> You should see the issuer listed with a registered account. Step 7 - Deploy a TLS Ingress Resource \u00b6 With all the prerequisite configuration in place, we can now do the pieces to request the TLS certificate. There are two primary ways to do this: using annotations on the ingress with ingress-shim or directly creating a certificate resource. In this example, we will add annotations to the ingress, and take advantage of ingress-shim to have it create the certificate resource on our behalf. After creating a certificate, the cert-manager will update or create a ingress resource and use that to validate the domain. Once verified and issued, cert-manager will create or update the secret defined in the certificate. Note: The secret that is used in the ingress should match the secret defined in the certificate. There isn't any explicit checking, so a typo will result in the ingress-nginx-controller falling back to its self-signed certificate. In our example, we are using annotations on the ingress (and ingress-shim) which will create the correct secrets on your behalf. Edit the ingress add the annotations that were commented out in our earlier example: ```yaml file=./example/ingress-tls.yaml and apply it: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress-tls.yaml # expected output: ingress.extensions \"kuard\" configured Cert-manager will read these annotations and use them to create a certificate, which you can request and see: $ kubectl get certificate NAME READY SECRET AGE quickstart-example-tls True quickstart-example-tls 16m cert-manager reflects the state of the process for every request in the certificate object. You can view this information using the kubectl describe command: $ kubectl describe certificate quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: <none> Annotations: <none> API Version: cert-manager.io/v1 Kind: Certificate Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T17:58:37Z Generation: 0 Owner References: API Version: networking.k8s.io/v1 Block Owner Deletion: true Controller: true Kind: Ingress Name: kuard UID: a3e9f935-ea87-11e8-82f8-42010a8a00b5 Resource Version: 9295 Self Link: /apis/cert-manager.io/v1/namespaces/default/certificates/quickstart-example-tls UID: 68d43400-ea92-11e8-82f8-42010a8a00b5 Spec: Dns Names: www.example.com Issuer Ref: Kind: Issuer Name: letsencrypt-staging Secret Name: quickstart-example-tls Status: Acme: Order: URL: https://acme-staging-v02.api.letsencrypt.org/acme/order/7374163/13665676 Conditions: Last Transition Time: 2018 -11-17T18:05:57Z Message: Certificate issued successfully Reason: CertIssued Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 9m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 8m cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Normal IssueCert 8m cert-manager Issuing certificate... Normal CertObtained 7m cert-manager Obtained certificate from ACME server Normal CertIssued 7m cert-manager Certificate issued Successfully The events associated with this resource and listed at the bottom of the describe results show the state of the request. In the above example the certificate was validated and issued within a couple of minutes. Once complete, cert-manager will have created a secret with the details of the certificate based on the secret used in the ingress resource. You can use the describe command as well to see some details: $ kubectl describe secret quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: cert-manager.io/certificate-name = quickstart-example-tls Annotations: cert-manager.io/alt-names = www.example.com cert-manager.io/common-name = www.example.com cert-manager.io/issuer-kind = Issuer cert-manager.io/issuer-name = letsencrypt-staging Type: kubernetes.io/tls Data ==== tls.crt: 3566 bytes tls.key: 1675 bytes Now that we have confidence that everything is configured correctly, you can update the annotations in the ingress to specify the production issuer: ```yaml file=./example/ingress-tls-final.yaml ```bash $ kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress-tls-final.yaml ingress.extensions \"kuard\" configured You will also need to delete the existing secret, which cert-manager is watching and will cause it to reprocess the request with the updated issuer. $ kubectl delete secret quickstart-example-tls secret \"quickstart-example-tls\" deleted This will start the process to get a new certificate, and using describe you can see the status. Once the production certificate has been updated, you should see the example KUARD running at your domain with a signed TLS certificate. $ kubectl describe certificate quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: <none> Annotations: <none> API Version: cert-manager.io/v1 Kind: Certificate Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T18:36:48Z Generation: 0 Owner References: API Version: networking.k8s.io/v1 Block Owner Deletion: true Controller: true Kind: Ingress Name: kuard UID: a3e9f935-ea87-11e8-82f8-42010a8a00b5 Resource Version: 283686 Self Link: /apis/cert-manager.io/v1/namespaces/default/certificates/quickstart-example-tls UID: bdd93b32-ea97-11e8-82f8-42010a8a00b5 Spec: Dns Names: www.example.com Issuer Ref: Kind: Issuer Name: letsencrypt-prod Secret Name: quickstart-example-tls Status: Conditions: Last Transition Time: 2019 -01-09T13:52:05Z Message: Certificate does not exist Reason: NotFound Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Generated 18s cert-manager Generated new private key Normal OrderCreated 18s cert-manager Created Order resource \"quickstart-example-tls-889745041\" You can see the current state of the ACME Order by running kubectl describe on the Order resource that cert-manager has created for your Certificate: $ kubectl describe order quickstart-example-tls-889745041 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 90s cert-manager Created Challenge resource \"quickstart-example-tls-889745041-0\" for domain \"www.example.com\" Here, we can see that cert-manager has created 1 'Challenge' resource to fulfill the Order. You can dig into the state of the current ACME challenge by running kubectl describe on the automatically created Challenge resource: $ kubectl describe challenge quickstart-example-tls-889745041-0 ... Status: Presented: true Processing: true Reason: Waiting for http-01 challenge propagation State: pending Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 15s cert-manager Challenge scheduled for processing Normal Presented 14s cert-manager Presented challenge using http-01 challenge mechanism From above, we can see that the challenge has been 'presented' and cert-manager is waiting for the challenge record to propagate to the ingress controller. You should keep an eye out for new events on the challenge resource, as a 'success' event should be printed after a minute or so (depending on how fast your ingress controller is at updating rules): $ kubectl describe challenge quickstart-example-tls-889745041-0 ... Status: Presented: false Processing: false Reason: Successfully authorized domain State: valid Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 71s cert-manager Challenge scheduled for processing Normal Presented 70s cert-manager Presented challenge using http-01 challenge mechanism Normal DomainVerified 2s cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Note: If your challenges are not becoming 'valid' and remain in the 'pending' state (or enter into a 'failed' state), it is likely there is some kind of configuration error. Read the Challenge resource reference docs for more information on debugging failing challenges. Once the challenge(s) have been completed, their corresponding challenge resources will be deleted , and the 'Order' will be updated to reflect the new state of the Order: $ kubectl describe order quickstart-example-tls-889745041 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 90s cert-manager Created Challenge resource \"quickstart-example-tls-889745041-0\" for domain \"www.example.com\" Normal OrderValid 16s cert-manager Order completed successfully Finally, the 'Certificate' resource will be updated to reflect the state of the issuance process. If all is well, you should be able to 'describe' the Certificate and see something like the below: $ kubectl describe certificate quickstart-example-tls Status: Conditions: Last Transition Time: 2019 -01-09T13:57:52Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -04-09T12:57:50Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Generated 11m cert-manager Generated new private key Normal OrderCreated 11m cert-manager Created Order resource \"quickstart-example-tls-889745041\" Normal OrderComplete 10m cert-manager Order \"quickstart-example-tls-889745041\" completed successfully","title":"Securing NGINX-ingress"},{"location":"tutorials/acme/nginx-ingress/#step-1-install-helm","text":"Skip this section if you have helm installed. The easiest way to install cert-manager is to use Helm , a templating and deployment tool for Kubernetes resources. First, ensure the Helm client is installed following the Helm installation instructions . For example, on MacOS: brew install kubernetes-helm","title":"Step 1 - Install Helm"},{"location":"tutorials/acme/nginx-ingress/#step-2-deploy-the-nginx-ingress-controller","text":"A kubernetes ingress controller is designed to be the access point for HTTP and HTTPS traffic to the software running within your cluster. The ingress-nginx-controller does this by providing an HTTP proxy service supported by your cloud provider's load balancer. You can get more details about ingress-nginx and how it works from the documentation for ingress-nginx . Add the latest helm repository for the ingress-nginx helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx Update the helm repository with the latest charts: $ helm repo update Hang tight while we grab the latest from your chart repositories... ...Skip local chart repository ...Successfully got an update from the \"stable\" chart repository ...Successfully got an update from the \"ingress-nginx\" chart repository ...Successfully got an update from the \"coreos\" chart repository Update Complete. \u2388 Happy Helming!\u2388 Use helm to install an NGINX Ingress controller: $ helm install quickstart ingress-nginx/ingress-nginx NAME: quickstart ... lots of output ... It can take a minute or two for the cloud provider to provide and link a public IP address. When it is complete, you can see the external IP address using the kubectl command: $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE kubernetes ClusterIP 10 .0.0.1 <none> 443 /TCP 13m quickstart-ingress-nginx-controller LoadBalancer 10 .0.114.241 <pending> 80 :31635/TCP,443:30062/TCP 8m16s quickstart-ingress-nginx-controller-admission ClusterIP 10 .0.188.24 <none> 443 /TCP 8m16s This command shows you all the services in your cluster (in the default namespace), and any external IP addresses they have. When you first create the controller, your cloud provider won't have assigned and allocated an IP address through the LoadBalancer yet. Until it does, the external IP address for the service will be listed as <pending> . Your cloud provider may have options for reserving an IP address prior to creating the ingress controller and using that IP address rather than assigning an IP address from a pool. Read through the documentation from your cloud provider on how to arrange that.","title":"Step 2 - Deploy the NGINX Ingress Controller"},{"location":"tutorials/acme/nginx-ingress/#step-3-assign-a-dns-name","text":"The external IP that is allocated to the ingress-controller is the IP to which all incoming traffic should be routed. To enable this, add it to a DNS zone you control, for example as www.example.com . This quick-start assumes you know how to assign a DNS entry to an IP address and will do so.","title":"Step 3 - Assign a DNS name"},{"location":"tutorials/acme/nginx-ingress/#step-4-deploy-an-example-service","text":"Your service may have its own chart, or you may be deploying it directly with manifests. This quick-start uses manifests to create and expose a sample service. The example service uses kuard , a demo application. The quick-start example uses three manifests for the sample. The first two are a sample deployment and an associated service: ```yaml file=./example/deployment.yaml ```yaml file=./example/service.yaml You can create download and reference these files locally, or you can reference them from the GitHub source repository for this documentation. To install the example service from the tutorial files straight from GitHub, do the following: kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/deployment.yaml # expected output: deployment.extensions \"kuard\" created kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/service.yaml # expected output: service \"kuard\" created An Ingress resource is what Kubernetes uses to expose this example service outside the cluster. You will need to download and modify the example manifest to reflect the domain that you own or control to complete this example. A sample ingress you can start with is: ```yaml file=./example/ingress.yaml You can download the sample manifest from GitHub , edit it, and submit the manifest to Kubernetes with the command below. Edit the file in your editor, and once it is saved: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress.yaml # expected output: ingress.extensions \"kuard\" created Note: The ingress example we show above has a host definition within it. The ingress-nginx-controller will route traffic when the hostname requested matches the definition in the ingress. You can deploy an ingress without a host definition in the rule, but that pattern isn't usable with a TLS certificate, which expects a fully qualified domain name. Once it is deployed, you can use the command kubectl get ingress to see the status of the ingress: NAME HOSTS ADDRESS PORTS AGE kuard * 80, 443 17s It may take a few minutes, depending on your service provider, for the ingress to be fully created. When it has been created and linked into place, the ingress will show an address as well: NAME HOSTS ADDRESS PORTS AGE kuard * 203.0.113.2 80 9m Note: The IP address on the ingress may not match the IP address that the ingress-nginx-controller has. This is fine, and is a quirk/implementation detail of the service provider hosting your Kubernetes cluster. Since we are using the ingress-nginx-controller instead of any cloud-provider specific ingress backend, use the IP address that was defined and allocated for the quickstart-ingress-nginx-controller LoadBalancer resource as the primary access point for your service. Make sure the service is reachable at the domain name you added above, for example http://www.example.com . The simplest way is to open a browser and enter the name that you set up in DNS, and for which we just added the ingress. You may also use a command line tool like curl to check the ingress. $ curl -kivL -H 'Host: www.example.com' 'http://203.0.113.2' The options on this curl command will provide verbose output, following any redirects, show the TLS headers in the output, and not error on insecure certificates. With ingress-nginx-controller , the service will be available with a TLS certificate, but it will be using a self-signed certificate provided as a default from the ingress-nginx-controller . Browsers will show a warning that this is an invalid certificate. This is expected and normal, as we have not yet used cert-manager to get a fully trusted certificate for our site. Warning : It is critical to make sure that your ingress is available and responding correctly on the internet. This quick-start example uses Let's Encrypt to provide the certificates, which expects and validates both that the service is available and that during the process of issuing a certificate uses that validation as proof that the request for the domain belongs to someone with sufficient control over the domain.","title":"Step 4 - Deploy an Example Service"},{"location":"tutorials/acme/nginx-ingress/#step-5-deploy-cert-manager","text":"We need to install cert-manager to do the work with Kubernetes to request a certificate and respond to the challenge to validate it. We can use Helm or plain Kubernetes manifests to install cert-manager. Since we installed Helm earlier, we'll assume you want to use Helm; follow the Helm guide . For other methods, read the installation documentation for cert-manager. cert-manager mainly uses two different custom Kubernetes resources - known as CRDs - to configure and control how it operates, as well as to store state. These resources are Issuers and Certificates.","title":"Step 5 - Deploy cert-manager"},{"location":"tutorials/acme/nginx-ingress/#issuers","text":"An Issuer defines how cert-manager will request TLS certificates. Issuers are specific to a single namespace in Kubernetes, but there's also a ClusterIssuer which is meant to be a cluster-wide version. Take care to ensure that your Issuers are created in the same namespace as the certificates you want to create. You might need to add -n my-namespace to your kubectl create commands. Your other option is to replace your Issuers with ClusterIssuers ; ClusterIssuer resources apply across all Ingress resources in your cluster. If using a ClusterIssuer , remember to update the Ingress annotation cert-manager.io/issuer to cert-manager.io/cluster-issuer . If you see issues with issuers, follow the Troubleshooting Issuing ACME Certificates guide. More information on the differences between Issuers and ClusterIssuers - including when you might choose to use each can be found on Issuer concepts .","title":"Issuers"},{"location":"tutorials/acme/nginx-ingress/#certificates","text":"Certificates resources allow you to specify the details of the certificate you want to request. They reference an issuer to define how they'll be issued. For more information, see Certificate concepts .","title":"Certificates"},{"location":"tutorials/acme/nginx-ingress/#step-6-configure-a-lets-encrypt-issuer","text":"We'll set up two issuers for Let's Encrypt in this example: staging and production. The Let's Encrypt production issuer has very strict rate limits . When you're experimenting and learning, it can be very easy to hit those limits. Because of that risk, we'll start with the Let's Encrypt staging issuer, and once we're happy that it's working we'll switch to the production issuer. Note that you'll see a warning about untrusted certificates from the staging issuer, but that's totally expected. Create this definition locally and update the email address to your own. This email is required by Let's Encrypt and used to notify you of certificate expiration and updates. ```yaml file=./example/staging-issuer.yaml Once edited, apply the custom resource: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/staging-issuer.yaml # expected output: issuer.cert-manager.io \"letsencrypt-staging\" created Also create a production issuer and deploy it. As with the staging issuer, you will need to update this example and add in your own email address. ```yaml file=./example/production-issuer.yaml ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/production-issuer.yaml # expected output: issuer.cert-manager.io \"letsencrypt-prod\" created Both of these issuers are configured to use the HTTP01 challenge provider. Check on the status of the issuer after you create it: $ kubectl describe issuer letsencrypt-staging Name: letsencrypt-staging Namespace: default Labels: <none> Annotations: kubectl.kubernetes.io/last-applied-configuration ={ \"apiVersion\" : \"cert-manager.io/v1\" , \"kind\" : \"Issuer\" , \"metadata\" : { \"annotations\" : {} , \"name\" : \"letsencrypt-staging\" , \"namespace\" : \"default\" } , ( ... )} API Version: cert-manager.io/v1 Kind: Issuer Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T18:03:54Z Generation: 0 Resource Version: 9092 Self Link: /apis/cert-manager.io/v1/namespaces/default/issuers/letsencrypt-staging UID: 25b7ae77-ea93-11e8-82f8-42010a8a00b5 Spec: Acme: Email: email@example.com Private Key Secret Ref: Key: Name: letsencrypt-staging Server: https://acme-staging-v02.api.letsencrypt.org/directory Solvers: Http 01 : Ingress: Class: nginx Status: Acme: Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/7374163 Conditions: Last Transition Time: 2018 -11-17T18:04:00Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready Events: <none> You should see the issuer listed with a registered account.","title":"Step 6 - Configure a Let's Encrypt Issuer"},{"location":"tutorials/acme/nginx-ingress/#step-7-deploy-a-tls-ingress-resource","text":"With all the prerequisite configuration in place, we can now do the pieces to request the TLS certificate. There are two primary ways to do this: using annotations on the ingress with ingress-shim or directly creating a certificate resource. In this example, we will add annotations to the ingress, and take advantage of ingress-shim to have it create the certificate resource on our behalf. After creating a certificate, the cert-manager will update or create a ingress resource and use that to validate the domain. Once verified and issued, cert-manager will create or update the secret defined in the certificate. Note: The secret that is used in the ingress should match the secret defined in the certificate. There isn't any explicit checking, so a typo will result in the ingress-nginx-controller falling back to its self-signed certificate. In our example, we are using annotations on the ingress (and ingress-shim) which will create the correct secrets on your behalf. Edit the ingress add the annotations that were commented out in our earlier example: ```yaml file=./example/ingress-tls.yaml and apply it: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress-tls.yaml # expected output: ingress.extensions \"kuard\" configured Cert-manager will read these annotations and use them to create a certificate, which you can request and see: $ kubectl get certificate NAME READY SECRET AGE quickstart-example-tls True quickstart-example-tls 16m cert-manager reflects the state of the process for every request in the certificate object. You can view this information using the kubectl describe command: $ kubectl describe certificate quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: <none> Annotations: <none> API Version: cert-manager.io/v1 Kind: Certificate Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T17:58:37Z Generation: 0 Owner References: API Version: networking.k8s.io/v1 Block Owner Deletion: true Controller: true Kind: Ingress Name: kuard UID: a3e9f935-ea87-11e8-82f8-42010a8a00b5 Resource Version: 9295 Self Link: /apis/cert-manager.io/v1/namespaces/default/certificates/quickstart-example-tls UID: 68d43400-ea92-11e8-82f8-42010a8a00b5 Spec: Dns Names: www.example.com Issuer Ref: Kind: Issuer Name: letsencrypt-staging Secret Name: quickstart-example-tls Status: Acme: Order: URL: https://acme-staging-v02.api.letsencrypt.org/acme/order/7374163/13665676 Conditions: Last Transition Time: 2018 -11-17T18:05:57Z Message: Certificate issued successfully Reason: CertIssued Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateOrder 9m cert-manager Created new ACME order, attempting validation... Normal DomainVerified 8m cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Normal IssueCert 8m cert-manager Issuing certificate... Normal CertObtained 7m cert-manager Obtained certificate from ACME server Normal CertIssued 7m cert-manager Certificate issued Successfully The events associated with this resource and listed at the bottom of the describe results show the state of the request. In the above example the certificate was validated and issued within a couple of minutes. Once complete, cert-manager will have created a secret with the details of the certificate based on the secret used in the ingress resource. You can use the describe command as well to see some details: $ kubectl describe secret quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: cert-manager.io/certificate-name = quickstart-example-tls Annotations: cert-manager.io/alt-names = www.example.com cert-manager.io/common-name = www.example.com cert-manager.io/issuer-kind = Issuer cert-manager.io/issuer-name = letsencrypt-staging Type: kubernetes.io/tls Data ==== tls.crt: 3566 bytes tls.key: 1675 bytes Now that we have confidence that everything is configured correctly, you can update the annotations in the ingress to specify the production issuer: ```yaml file=./example/ingress-tls-final.yaml ```bash $ kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/ingress-tls-final.yaml ingress.extensions \"kuard\" configured You will also need to delete the existing secret, which cert-manager is watching and will cause it to reprocess the request with the updated issuer. $ kubectl delete secret quickstart-example-tls secret \"quickstart-example-tls\" deleted This will start the process to get a new certificate, and using describe you can see the status. Once the production certificate has been updated, you should see the example KUARD running at your domain with a signed TLS certificate. $ kubectl describe certificate quickstart-example-tls Name: quickstart-example-tls Namespace: default Labels: <none> Annotations: <none> API Version: cert-manager.io/v1 Kind: Certificate Metadata: Cluster Name: Creation Timestamp: 2018 -11-17T18:36:48Z Generation: 0 Owner References: API Version: networking.k8s.io/v1 Block Owner Deletion: true Controller: true Kind: Ingress Name: kuard UID: a3e9f935-ea87-11e8-82f8-42010a8a00b5 Resource Version: 283686 Self Link: /apis/cert-manager.io/v1/namespaces/default/certificates/quickstart-example-tls UID: bdd93b32-ea97-11e8-82f8-42010a8a00b5 Spec: Dns Names: www.example.com Issuer Ref: Kind: Issuer Name: letsencrypt-prod Secret Name: quickstart-example-tls Status: Conditions: Last Transition Time: 2019 -01-09T13:52:05Z Message: Certificate does not exist Reason: NotFound Status: False Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Generated 18s cert-manager Generated new private key Normal OrderCreated 18s cert-manager Created Order resource \"quickstart-example-tls-889745041\" You can see the current state of the ACME Order by running kubectl describe on the Order resource that cert-manager has created for your Certificate: $ kubectl describe order quickstart-example-tls-889745041 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 90s cert-manager Created Challenge resource \"quickstart-example-tls-889745041-0\" for domain \"www.example.com\" Here, we can see that cert-manager has created 1 'Challenge' resource to fulfill the Order. You can dig into the state of the current ACME challenge by running kubectl describe on the automatically created Challenge resource: $ kubectl describe challenge quickstart-example-tls-889745041-0 ... Status: Presented: true Processing: true Reason: Waiting for http-01 challenge propagation State: pending Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 15s cert-manager Challenge scheduled for processing Normal Presented 14s cert-manager Presented challenge using http-01 challenge mechanism From above, we can see that the challenge has been 'presented' and cert-manager is waiting for the challenge record to propagate to the ingress controller. You should keep an eye out for new events on the challenge resource, as a 'success' event should be printed after a minute or so (depending on how fast your ingress controller is at updating rules): $ kubectl describe challenge quickstart-example-tls-889745041-0 ... Status: Presented: false Processing: false Reason: Successfully authorized domain State: valid Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Started 71s cert-manager Challenge scheduled for processing Normal Presented 70s cert-manager Presented challenge using http-01 challenge mechanism Normal DomainVerified 2s cert-manager Domain \"www.example.com\" verified with \"http-01\" validation Note: If your challenges are not becoming 'valid' and remain in the 'pending' state (or enter into a 'failed' state), it is likely there is some kind of configuration error. Read the Challenge resource reference docs for more information on debugging failing challenges. Once the challenge(s) have been completed, their corresponding challenge resources will be deleted , and the 'Order' will be updated to reflect the new state of the Order: $ kubectl describe order quickstart-example-tls-889745041 ... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Created 90s cert-manager Created Challenge resource \"quickstart-example-tls-889745041-0\" for domain \"www.example.com\" Normal OrderValid 16s cert-manager Order completed successfully Finally, the 'Certificate' resource will be updated to reflect the state of the issuance process. If all is well, you should be able to 'describe' the Certificate and see something like the below: $ kubectl describe certificate quickstart-example-tls Status: Conditions: Last Transition Time: 2019 -01-09T13:57:52Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -04-09T12:57:50Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Generated 11m cert-manager Generated new private key Normal OrderCreated 11m cert-manager Created Order resource \"quickstart-example-tls-889745041\" Normal OrderComplete 10m cert-manager Order \"quickstart-example-tls-889745041\" completed successfully","title":"Step 7 - Deploy a TLS Ingress Resource"},{"location":"tutorials/acme/pomerium-ingress/","text":"This tutorial covers installing the Pomerium Ingress Controller and securing it with cert-manager. Pomerium is an identity-aware proxy that can also provide a custom ingress controller for your Kubernetes services. Prerequisites \u00b6 Install Kubectl and set the context to the cluster you'll be working with. Pomerium connects to an identity provider ( IdP ) to authenticate users. See one of their guides to learn how to set up your IdP of choice to provide oauth2 validation. This tutorial assumes you have a domain space reserved for this cluster (such as *.example.com ). You will need access to DNS for this domain to assign A and CNAME records as needed. Install The Pomerium Ingress Controller \u00b6 Install Pomerium to your cluster: kubectl apply -f https://raw.githubusercontent.com/pomerium/ingress-controller/main/deployment.yaml Define a Secret with your IdP configuration. See Pomerium's Identity Providers pages for more information specific to your IdP: apiVersion : v1 kind : Secret metadata : name : idp namespace : pomerium type : Opaque stringData : client_id : ${IDP_PROVIDED_CLIENT_ID} client_secret : ${IDP_PROVIDED_CLIENT_SECRET} Add the secret to the cluster with kubectl apply -f . Define the global settings for Pomerium: apiVersion : ingress.pomerium.io/v1 kind : Pomerium metadata : name : global namespace : pomerium spec : secrets : pomerium/bootstrap authenticate : url : https://authenticate.example.com identityProvider : provider : ${YOUR_IdP} secret : pomerium/idp # certificates: # - pomerium/pomerium-proxy-tls Replace ${YOUR_IdP} with your identity provider. Apply with kubectl -f . Note that the last two lines are commented out. They reference a TLS certificate we will create further in the process. Install cert-manager \u00b6 Install cert-manager using any of the methods documented in the Installation section of the cert-manager docs. The simplest method is to download and apply the provided manifest: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml Configure Let's Encrypt Issuer \u00b6 For communication between the Ingresses and the internet, we'll want to use certificates signed by a trusted certificate authority like Let's Encrypt. This example creates two Let's Encrypt issuers, one for staging and one for production. The Let's Encrypt production issuer has strict rate limits . Before your configuration is finalized you may have to recreate services several times, hitting those limits. It's easy to confuse rate limiting with errors in configuration or operation while building your stack. Because of this, we will start with the Let's Encrypt staging issuer. Once your configuration is all but finalized, we will switch to a production issuer. Both of these issuers are configured to use the HTTP01 challenge provider. The following YAML defines a staging certificate issuer. You must update the email address to your own. The email field is required by Let's Encrypt and used to notify you of certificate expiration and updates. ```yaml file=./example/pomerium-staging-issuer.yaml You can download and edit the example and apply it with `kubectl apply -f`, or edit, and apply the custom resource in one command: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/pomerium-staging-issuer.yaml Create a production issuer and deploy it. As with the staging issuer, update this example with your own email address: ```yaml file=./example/pomerium-production-issuer.yaml ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/pomerium-production-issuer.yaml You can confirm on the status of the issuers after you create them: kubectl describe issuer -n pomerium letsencrypt-staging kubectl describe issuer -n pomerium letsencrypt-prod You should see the issuer listed with a registered account. Define a certificate for the Pomerium Proxy service. This should be the only certificate you need to manually define: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : pomerium-proxy-tls namespace : pomerium spec : dnsNames : - 'authenticate.example.com' issuerRef : kind : Issuer name : letsencrypt-staging secretName : pomerium-proxy-tls Adjust the dnsNames value to match your domain space. The subdomain ( authenticate in our example) must match the domain used for the callback URL in your IdP configuration. Add the certificate with kubectl -f . Uncomment the last two lines of the Pomerium global configuration that reference your newly created certificate, and re-apply to the cluster. Pomerium should now be installed and running in your cluster. You can verify by going to https://authenticate.example.com in your browser. Use kubectl describe pomerium to review the status of the Pomerium deployment and see recent events. Define a Test Service \u00b6 To test our new Ingress Controller, we will add the kuard app to our cluster and define an Ingress for it. Define the kuard deployment and associated service: ```yaml file=./example/deployment.yaml ```yaml file=./example/service.yaml You can download and reference these files locally, or you can reference them from the GitHub source repository for this documentation. To install the example service from the tutorial files straight from GitHub: kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/deployment.yaml kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/service.yaml Create a new Ingress manifest ( example-ingress.yaml ) for our test service: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : kuard annotations : cert-manager.io/issuer : letsencrypt-staging ingress.pomerium.io/policy : '[{\"allow\":{\"and\":[{\"domain\":{\"is\":\"example.com\"}}]}}]' spec : ingressClassName : pomerium rules : - host : kuard.example.com http : paths : - path : / pathType : Prefix backend : service : name : kuard port : number : 80 tls : - hosts : - kuard.example.com secretName : kuard.example.com-tls Again, change the references to example.com to match your domain space. Apply the Ingress manifest to the cluster: kubectl apply -f example-ingress.yaml The Pomerium Ingress Controller will use cert-manager to automatically provision a certificate from the letsencrypt-staging issuer for the route to kuard.example.com . Once you've configured all your application services correctly in the cluster, adjust the issuer for your Ingresses (including the Authenticate service) to use letsencrypt-prod .","title":"Pomerium Ingress"},{"location":"tutorials/acme/pomerium-ingress/#prerequisites","text":"Install Kubectl and set the context to the cluster you'll be working with. Pomerium connects to an identity provider ( IdP ) to authenticate users. See one of their guides to learn how to set up your IdP of choice to provide oauth2 validation. This tutorial assumes you have a domain space reserved for this cluster (such as *.example.com ). You will need access to DNS for this domain to assign A and CNAME records as needed.","title":"Prerequisites"},{"location":"tutorials/acme/pomerium-ingress/#install-the-pomerium-ingress-controller","text":"Install Pomerium to your cluster: kubectl apply -f https://raw.githubusercontent.com/pomerium/ingress-controller/main/deployment.yaml Define a Secret with your IdP configuration. See Pomerium's Identity Providers pages for more information specific to your IdP: apiVersion : v1 kind : Secret metadata : name : idp namespace : pomerium type : Opaque stringData : client_id : ${IDP_PROVIDED_CLIENT_ID} client_secret : ${IDP_PROVIDED_CLIENT_SECRET} Add the secret to the cluster with kubectl apply -f . Define the global settings for Pomerium: apiVersion : ingress.pomerium.io/v1 kind : Pomerium metadata : name : global namespace : pomerium spec : secrets : pomerium/bootstrap authenticate : url : https://authenticate.example.com identityProvider : provider : ${YOUR_IdP} secret : pomerium/idp # certificates: # - pomerium/pomerium-proxy-tls Replace ${YOUR_IdP} with your identity provider. Apply with kubectl -f . Note that the last two lines are commented out. They reference a TLS certificate we will create further in the process.","title":"Install The Pomerium Ingress Controller"},{"location":"tutorials/acme/pomerium-ingress/#install-cert-manager","text":"Install cert-manager using any of the methods documented in the Installation section of the cert-manager docs. The simplest method is to download and apply the provided manifest: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml","title":"Install cert-manager"},{"location":"tutorials/acme/pomerium-ingress/#configure-lets-encrypt-issuer","text":"For communication between the Ingresses and the internet, we'll want to use certificates signed by a trusted certificate authority like Let's Encrypt. This example creates two Let's Encrypt issuers, one for staging and one for production. The Let's Encrypt production issuer has strict rate limits . Before your configuration is finalized you may have to recreate services several times, hitting those limits. It's easy to confuse rate limiting with errors in configuration or operation while building your stack. Because of this, we will start with the Let's Encrypt staging issuer. Once your configuration is all but finalized, we will switch to a production issuer. Both of these issuers are configured to use the HTTP01 challenge provider. The following YAML defines a staging certificate issuer. You must update the email address to your own. The email field is required by Let's Encrypt and used to notify you of certificate expiration and updates. ```yaml file=./example/pomerium-staging-issuer.yaml You can download and edit the example and apply it with `kubectl apply -f`, or edit, and apply the custom resource in one command: ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/pomerium-staging-issuer.yaml Create a production issuer and deploy it. As with the staging issuer, update this example with your own email address: ```yaml file=./example/pomerium-production-issuer.yaml ```bash kubectl create --edit -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/pomerium-production-issuer.yaml You can confirm on the status of the issuers after you create them: kubectl describe issuer -n pomerium letsencrypt-staging kubectl describe issuer -n pomerium letsencrypt-prod You should see the issuer listed with a registered account. Define a certificate for the Pomerium Proxy service. This should be the only certificate you need to manually define: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : pomerium-proxy-tls namespace : pomerium spec : dnsNames : - 'authenticate.example.com' issuerRef : kind : Issuer name : letsencrypt-staging secretName : pomerium-proxy-tls Adjust the dnsNames value to match your domain space. The subdomain ( authenticate in our example) must match the domain used for the callback URL in your IdP configuration. Add the certificate with kubectl -f . Uncomment the last two lines of the Pomerium global configuration that reference your newly created certificate, and re-apply to the cluster. Pomerium should now be installed and running in your cluster. You can verify by going to https://authenticate.example.com in your browser. Use kubectl describe pomerium to review the status of the Pomerium deployment and see recent events.","title":"Configure Let's Encrypt Issuer"},{"location":"tutorials/acme/pomerium-ingress/#define-a-test-service","text":"To test our new Ingress Controller, we will add the kuard app to our cluster and define an Ingress for it. Define the kuard deployment and associated service: ```yaml file=./example/deployment.yaml ```yaml file=./example/service.yaml You can download and reference these files locally, or you can reference them from the GitHub source repository for this documentation. To install the example service from the tutorial files straight from GitHub: kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/deployment.yaml kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/acme/example/service.yaml Create a new Ingress manifest ( example-ingress.yaml ) for our test service: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : kuard annotations : cert-manager.io/issuer : letsencrypt-staging ingress.pomerium.io/policy : '[{\"allow\":{\"and\":[{\"domain\":{\"is\":\"example.com\"}}]}}]' spec : ingressClassName : pomerium rules : - host : kuard.example.com http : paths : - path : / pathType : Prefix backend : service : name : kuard port : number : 80 tls : - hosts : - kuard.example.com secretName : kuard.example.com-tls Again, change the references to example.com to match your domain space. Apply the Ingress manifest to the cluster: kubectl apply -f example-ingress.yaml The Pomerium Ingress Controller will use cert-manager to automatically provision a certificate from the letsencrypt-staging issuer for the route to kuard.example.com . Once you've configured all your application services correctly in the cluster, adjust the issuer for your Ingresses (including the Authenticate service) to use letsencrypt-prod .","title":"Define a Test Service"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/","text":"Last Verified: 15 July 2022 In this tutorial you will learn how to deploy and configure cert-manager on Google Kubernetes Engine (GKE). You will learn how to configure cert-manager to get a signed SSL certificate from Let's Encrypt, using an HTTP-01 challenge . Finally you will learn how the certificate can be used to serve an HTTPS website with a public domain name. Google Cloud : A suite of cloud computing services by Google. Kubernetes : Runs on your servers. Automates the deployment, scaling, and management of containerized applications. cert-manager : Runs in Kubernetes. Obtains TLS / SSL certificates and ensures the certificates are valid and up-to-date. Let\u2019s Encrypt : An Internet service. Allows you to generate free short-lived SSL certificates. First you will create a Kubernetes (GKE) cluster and deploy a sample web server. You will then create a public IP address and a public domain name for your website. You'll set up Ingress and Google Cloud load balancers so that Internet clients can connect to the web server using HTTP. Finally you will use cert-manager to get an SSL certificate from Let's Encrypt and configure the load balancer to use that certificate. By the end of this tutorial you will be able to connect to your website from the Internet using an https:// URL. Prerequisites \u00b6 \ud83d\udcbb Google Cloud account You will need a Google Cloud account. Registration requires a credit card or bank account details. Visit the Get started with Google Cloud page and follow the instructions. \ud83d\udcb5 If you have never used Google Cloud before, you may be eligible for the Google Cloud Free Program , which gives you a 90 day trial period that includes $300 in free Cloud Billing credits to explore and evaluate Google Cloud. \ud83d\udcbb Domain Name You will need a domain name and the ability to create DNS records in that domain. We will be getting a $12 domain name from Google Domains. Google Domains is one of the many possible \"domain name registrars\". NameCheap and GoDaddy are two other well-known registrars. \ud83d\udcb5 If you prefer not purchasing a domain name, it is also possible to adapt this tutorial to use the IP address to serve your website and for the SSL certificate. \ud83d\udcbb Software You will also need to install the following software on your laptop: gcloud : A set of tools to create and manage Google Cloud resources. kubectl : The Kubernetes command-line tool which allows you to configure Kubernetes clusters. curl : A command-line tool for connecting to a web server using HTTP and HTTPS. \u2139\ufe0f Try running gcloud components install kubectl to quickly install kubectl . 0. Configure gcloud with a Google Cloud project \u00b6 If you don't have a Google Cloud account, the command below will create one for you: gcloud init You will need to answer \"yes\" to the following question: Do you want to configure a default Compute Region and Zone? (Y/n)? Y After running the command, you will shown the project name, default region, and default zone. Example output: * Commands that require authentication will use firstname.lastname@example.com by default * Commands will reference project `your-project` by default * Compute Engine commands will use region `europe-west1` by default * Compute Engine commands will use zone `europe-west1-b` by default In this tutorial, we will refer to the name of the project that was selected while running gcloud init with the variable PROJECT . Where ever you see $PROJECT in a command, you need to either (1) replace the variable manually before you execute the command, or (2) export the variable in your shell session. This applies to all environment variables that you will encounter in the commands listed in this tutorial. We will go with option (2), so we need to export the environment variables before continuing using the information that was printed by gcloud init : export PROJECT = your-project # Your Google Cloud project ID. export REGION = europe-west1 # Your Google Cloud region. 1. Create a Kubernetes Cluster \u00b6 To get started, let's create a Kubernetes cluster in Google Cloud. You will need to pick a name for your cluster. Here, we will go with \"test-cluster-1\". Let us save it in an environment variable: export CLUSTER = test-cluster-1 Now, create the cluster using the following command: gcloud container clusters create $CLUSTER --preemptible --num-nodes = 1 Set up the Google Kubernetes Engine auth plugin for kubectl : gcloud components install gke-gcloud-auth-plugin export USE_GKE_GCLOUD_AUTH_PLUGIN = True gcloud container clusters get-credentials $CLUSTER Now check that you can connect to the cluster: kubectl get nodes -o wide \u23f2 It will take 4-5 minutes to create the cluster. \ud83d\udcb5 To minimize your cloud bill, this command creates a 1-node cluster using a preemptible virtual machine which is cheaper than a normal virtual machine. 2. Deploy a sample web server \u00b6 We will deploy a very simple web server which responds to HTTP requests with \"hello world!\". kubectl create deployment web --image = gcr.io/google-samples/hello-app:1.0 We also need to create a Kubernetes Service, so that connections can be routed to the web server Pods: kubectl expose deployment web --port = 8080 \u2139\ufe0f These kubectl imperative commands are used for readability and brevity. Feel free to use YAML manifests and kubectl apply -f instead. \u2139\ufe0f The Service created by kubectl expose will be of type ClusterIP (the default) and this is only reachable by components within the cluster. Later we will create an Ingress which is how we make the service available to clients outside the cluster. \ud83d\udd30 Read more about Using a Service to Expose Your App . 3. Create a static external IP address \u00b6 This tutorial is about creating a public facing HTTPS website with a Let's Encrypt SSL certificate using the HTTP01 challenge mechanism, so we need a public IP address so that both Let's Encrypt and other Internet clients can connect to your website. It is easy to create a public IP address in Google Cloud and later we will associate it with your website domain name and with a Google Cloud load balancer, which will accept HTTP(S) connections from Internet clients and proxy the requests to the web servers running in your cluster. Create a global static IP address as follows: gcloud compute addresses create web-ip --global You should see the new IP address listed: gcloud compute addresses list \u26a0\ufe0f You MUST create a global IP address because that is a prerequisite of the External HTTP(S) Load Balancer which we will be using in this tutorial. \ud83d\udcb5 Global static IP addresses are only available in the Premium network service tier and are more expensive than ephemeral and standard public IP addresses. \ud83d\udd30 Read more about Network service tiers in Google Cloud . \ud83d\udd30 Read more about Reserving a static external IP address in Google Cloud . Finally, we will save the IP address into an environment variable for later use. Display the IP address with the following command: gcloud compute addresses describe web-ip --format = 'value(address)' --global Then, copy the output and save it into an environment variable: export IP_ADDRESS = 198 .51.100.1 # Replace with your IP address 4. Create a domain name for your website \u00b6 You will need a domain name for your website and Let's Encrypt checks your domain before it signs your SSL certificate, so the domain name needs to be reachable from the Internet. We will purchase a cheap domain name using a credit card. Go to https://domains.google.com , and type something in the search box. For the example, we searched for hello-app.com because the example container that we will be deploying is called hello-app . Most importantly, we make sure to sort the domain names by price: We don't pick hello-app.com because it costs $2,800; instead, we go with the one at the top: heyapp.net . It looks good! We then click the cart button. On the next screen, you will want to disable the auto-renewal, since we don't want to pay for this domain every year: Now that you know your domain name, save it in an environment variable: export DOMAIN_NAME = heyapp.net Next, you will need to create a new A record pointing at the IP address that we created above. Head back to https://domains.google.com/registrar , open your domain (here, heyapp.net ) and click \"DNS\" on the left menu. You will see \"Custom records\". You want to add a new record of type A and put the IP address from the previous step into \"data\". You must leave \"Host name\" empty because we are configuring the top-level domain name: \ud83d\udd30 Learn more about What is a DNS A record? from the Cloudflare DNS tutorial . \u2139\ufe0f It is not strictly necessary to create a domain name for your website. You can connect to it using the IP address and later you can create an SSL certificate for the IP address instead of a domain name. If for some reason you can't create a domain name, then feel free to skip this section and adapt the instructions below to use an IP address instead. \u2139\ufe0f Every Google Cloud address has an automatically generated reverse DNS name like 51.159.120.34.bc.googleusercontent.com , but the parent domain googleusercontent.com has a CAA record which prevents Let's Encrypt from signing certificates for the sub-domains. See Certificate Authority Authorization (CAA) in the Let's Encrypt documentation. 5. Create an Ingress \u00b6 You won't be able to reach your website yet. Your web server is running inside your Kubernetes cluster but there is no route or proxy through which Internet clients can connect to it, yet! Now we will create a Kubernetes Ingress object and in Google Cloud this will trigger the creation of a various services which together allow Internet clients to reach your web server running inside your Kubernetes cluster. Initially we are going to create an HTTP (not an HTTPS) Ingress so that we can test the basic connectivity before adding the SSL layer. Copy the following YAML into a file called ingress.yaml and apply it: # ingress.yaml apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : web-ingress annotations : # This tells Google Cloud to create an External Load Balancer to realize this Ingress kubernetes.io/ingress.class : gce # This enables HTTP connections from Internet clients kubernetes.io/ingress.allow-http : \"true\" # This tells Google Cloud to associate the External Load Balancer with the static IP which we created earlier kubernetes.io/ingress.global-static-ip-name : web-ip spec : defaultBackend : service : name : web port : number : 8080 kubectl apply -f ingress.yaml This will trigger the creation of a Google HTTP(S) loadbalancer associated with the IP address that you created earlier. You can watch the progress and the resources that are being created: kubectl describe ingress web-ingress Within 4-5 minutes all the load balancer components should be ready and you should be able to connect to the DNS name and see the response from the hello-world web server that we deployed earlier: curl http://$DOMAIN_NAME Example output: Hello, world! Version: 1.0.0 Hostname: web-79d88c97d6-t8hj2 At this point we have a Google load balancer which is forwarding HTTP traffic to the hello-world web server running in a Pod in our cluster. \u23f2 It may take 4-5 minutes for the load balancer components to be created and configured and for Internet clients to be routed to your web server. Refer to the Troubleshooting section if it takes longer. \ud83d\udd30 Read about how to Use a static IP addresses for HTTP(S) load balancers via Ingress annotation . \ud83d\udd30 Read a Summary of external Ingress annotations for GKE . \ud83d\udd30 Read about Troubleshooting Ingress with External HTTP(S) Load Balancing on GKE . \u2139\ufe0f There are two Ingress classes available for GKE Ingress. The gce class deploys an external load balancer and the gce-internal class deploys an internal load balancer. Ingress resources without a class specified default to gce . \u26a0\ufe0f Contrary to the Kubernetes Ingress documentation, you MUST use the kubernetes.io/ingress.class annotation rather than the Ingress.Spec.IngressClassName field. See ingress-gce #1301 and ingress-gce #1337 . 6. Install cert-manager \u00b6 So finally we are ready to start creating an SSL certificate for our website. The first thing you need to do is install cert-manager, and we'll install it the easy using kubectl as follows: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.yaml This will create three Deployments, and a bunch of Services and Pods in a new namespace called cert-manager . It also installs various cluster scoped supporting resources such as RBAC roles and Custom Resource Definitions. You can view some of the resources that have been installed as follows: kubectl -n cert-manager get all And you can explore the Custom Resource Definitions (cert-manager's API) using kubectl explain , as follows: kubectl explain Certificate kubectl explain CertificateRequest kubectl explain Issuer \ud83d\udd30 Read about other ways to install cert-manager . \ud83d\udd30 Read more about Certificates and Issuers . 7. Create an Issuer for Let's Encrypt Staging \u00b6 An Issuer is a custom resource which tells cert-manager how to sign a Certificate. In this case the Issuer will be configured to connect to the Let's Encrypt staging server, which allows us to test everything without using up our Let's Encrypt certificate quota for the domain name. \u2139\ufe0f Let's Encrypt uses the Automatic Certificate Management Environment (ACME) protocol which is why the configuration below is under a key called acme . Save the following content to a file called issuer-lets-encrypt-staging.yaml , change the email field to use your email address and apply it: # issuer-lets-encrypt-staging.yaml apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory email : <email-address> # \u2757 Replace this with your email address privateKeySecretRef : name : letsencrypt-staging solvers : - http01 : ingress : name : web-ingress kubectl apply -f issuer-lets-encrypt-staging.yaml \u2139\ufe0f The email address is only used by Let's Encrypt to remind you to renew the certificate after 30 days before expiry. You will only receive this email if something goes wrong when renewing the certificate with cert-manager. You can check the status of the Issuer: kubectl describe issuers.cert-manager.io letsencrypt-staging Example output Status: Acme: Last Registered Email: firstname.lastname@example.com Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/60706744 Conditions: Last Transition Time: 2022-07-13T16:13:25Z Message: The ACME account was registered with the ACME server Observed Generation: 1 Reason: ACMEAccountRegistered Status: True Type: Ready \u2139\ufe0f The Let's Encrypt production issuer has very strict rate limits . When you're experimenting and learning, it can be very easy to hit those limits. Because of that risk, we'll start with the Let's Encrypt staging issuer, and once we're happy that it's working we'll switch to the production issuer. \u26a0\ufe0f In the next step you will see a warning about untrusted certificates because we start with the staging issuer, but that's totally expected. \ud83d\udd30 Read more about configuring the ACME Issuer . 8. Re-configure the Ingress for SSL \u00b6 Earlier we created an Ingress and saw that we could connect to our web server using HTTP. Now we will reconfigure that Ingress for HTTPS. First a quick hack, to work around a problem with the Google Cloud ingress controller. Create an empty Secret for your SSL certificate before reconfiguring the Ingress and apply it: # secret.yaml apiVersion : v1 kind : Secret metadata : name : web-ssl type : kubernetes.io/tls stringData : tls.key : \"\" tls.crt : \"\" kubectl apply -f secret.yaml \u2139\ufe0f This is a work around for a chicken-and-egg problem, where the ingress-gce controller won't update its forwarding rules unless it can first find the Secret that will eventually contain the SSL certificate. But Let's Encrypt won't sign the SSL certificate until it can get the special .../.well-known/acme-challenge/... URL which cert-manager adds to the Ingress and which must then be translated into Google Cloud forwarding rules, by the ingress-gce controller. \ud83d\udd30 Read more about Kubernetes Secrets and how to use them . Now make the following changes to the Ingress and apply them: --- a/ingress.yaml +++ b/ingress.yaml @@ -7,7 +7,12 @@ metadata: kubernetes.io/ingress.class: gce kubernetes.io/ingress.allow-http: \"true\" kubernetes.io/ingress.global-static-ip-name: web-ip + cert-manager.io/issuer: letsencrypt-staging spec: + tls: + - secretName: web-ssl + hosts: + - $DOMAIN_NAME defaultBackend: service: name: web kubectl apply -f ingress.yaml This triggers a complex set of operations which may take many minutes to eventually complete. Some of these steps take 2-3 minutes and some will initially fail. They should all eventually succeed because cert-manager and ingress-gce (the Google Cloud ingress controller) will periodically re-reconcile. Eventually, When all the pieces are in place, you should be able to use curl to check the HTTPS connection to your website: curl -v --insecure https:// $DOMAIN_NAME You should see that the HTTPS connection is established but that the SSL certificate is not trusted; that's why you use the --insecure flag at this stage Example output: * Server certificate: * subject: CN=www.example.com * start date: Jul 14 08:52:29 2022 GMT * expire date: Oct 12 08:52:28 2022 GMT * issuer: C=US; O=(STAGING) Let's Encrypt; CN=(STAGING) Artificial Apricot R3 * SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway. \u23f2 You will have to wait 5-10 minutes for the SSL certificate to be signed and then loaded by the Google Cloud load balancer. Refer to the Troubleshooting section if it takes longer. \u2139\ufe0f Adding the annotation cert-manager.io/issuer: letsencrypt-staging marks the Ingress for the attention of the cert-manager ingress-shim and causes it to create a new Certificate with a reference to the Issuer that we created earlier. \ud83d\udd30 Read Securing Ingress Resources to learn more. \ud83d\udd30 Read about how to Specify certificates for your Ingress in GKE . 9. Create a production ready SSL certificate \u00b6 Now that everything is working with the Let's Encrypt staging server, we can switch to the production server and get a trusted SSL certificate. Create a Let's Encrypt production Issuer and apply it: # issuer-lets-encrypt-production.yaml apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-production spec : acme : server : https://acme-v02.api.letsencrypt.org/directory email : <email-address> # \u2757 Replace this with your email address privateKeySecretRef : name : letsencrypt-production solvers : - http01 : ingress : name : web-ingress kubectl apply -f issuer-lets-encrypt-production.yaml Then update the Ingress annotation to use the production Issuer: kubectl annotate ingress web-ingress cert-manager.io/issuer = letsencrypt-production --overwrite This will trigger cert-manager to get a new SSL certificate signed by the Let's Encrypt production CA and store it to the web-ssl Secret. Within about 10 minutes, this new certificate will be synced to the Google Cloud load balancer and you will be able to connect to the website using secure HTTPS: curl -v https:// $DOMAIN_NAME Example output: ... * Server certificate: * subject: CN=www.example.com * start date: Jul 14 09:44:29 2022 GMT * expire date: Oct 12 09:44:28 2022 GMT * subjectAltName: host \"www.example.com\" matched cert's \"www.example.com\" * issuer: C=US; O=Let's Encrypt; CN=R3 * SSL certificate verify ok. ... Hello, world! Version: 1.0.0 Hostname: web-79d88c97d6-t8hj2 It should also be possible to visit https://$DOMAIN_NAME in your web browser, without any errors or warnings. That concludes the tutorial. You now understand how cert-manager integrates with Kubernetes Ingress and cloud Ingress controllers. You have learned how to use cert-manager to get free Let's Encrypt SSL certificates. And you have seen how the certificates can be used by a cloud based load balancer to terminate SSL connections from Internet clients and forward HTTPS requests to a web server running in your Kubernetes cluster. \ud83d\udcb5 Read the Clean up section to learn how to delete all the resources that you created in this tutorial and reduce your cloud bill. \ud83d\udd30 Read the Troubleshooting section if you encounter difficulties with the steps described in this tutorial. Clean up \u00b6 After completing the tutorial you can clean up by deleting the cluster and the domain name and the static IP as follows: # Delete the cluster and all the Google Cloud resources related to the Ingress that it contains gcloud container clusters delete $CLUSTER # Delete the domain name gcloud dns record-sets delete $DOMAIN_NAME --zone $ZONE --type A # Delete the static IP address gcloud compute addresses delete web-ip --global Troubleshooting \u00b6 When you create or update the Ingress object in this tutorial it triggers a complex set of operations which may take many minutes to eventually complete. Some of these steps take 2-3 minutes and some will initially fail but then subsequently succeed when either cert-manager or the Google ingress controller re-reconciles. In short, you should allow 5-10 minutes after you create or change the Ingress and you should expect to see some errors and warnings when you run kubectl describe ingress web-ingress . Here's a brief summary of the operations performed by cert-manager and ingress-gce (the Google Cloud Ingress controller): cert-manager connects to Let's Encrypt and sends an SSL certificate signing request. Let's Encrypt responds with a \"challenge\", which is a unique token that cert-manager must make available at a well-known location on the target web site. This proves that you are an administrator of that web site and domain name. cert-manager deploys a Pod containing a temporary web server that serves the Let's Encrypt challenge token. cert-manager reconfigures the Ingress, adding a rule to route requests for from Let's Encrypt to that temporary web server. Google Cloud ingress controller reconfigures the external HTTP load balancer with that new rule. Let's Encrypt now connects and receives the expected challenge token and the signs the SSL certificate and returns it to cert-manager. cert-manager stores the signed SSL certificate in the Kubernetes Secret called web-ssl . Google Cloud ingress controller uploads the signed certificate and associated private key to a Google Cloud certificate. Google Cloud ingress controller reconfigures the external load balancer to serve the uploaded SSL certificate. Check Ingress and associated events \u00b6 Use kubectl describe to view the Ingress configuration and all the associated Events. Check that the IP address is correct and that the TLS and Host entries match the domain name that you chose for your website. Notice that ingress-gce creates an Event for each of the Google Cloud components that it manages. And notice that it adds annotations with references to the ID of each of those components. cert-manager also creates Events when it reconciles the Ingress object, including details of the Certificate object that it creates for the Ingress. $ kubectl describe ingress web-ingress Name: web-ingress Labels: <none> Namespace: default Address: 34.120.159.51 Ingress Class: <none> Default backend: web:8080 (10.52.0.13:8080) TLS: web-ssl terminates www.example.com Rules: Host Path Backends ---- ---- -------- * * web:8080 (10.52.0.13:8080) Annotations: cert-manager.io/issuer: letsencrypt-staging ingress.kubernetes.io/backends: {\"k8s1-01784147-default-web-8080-1647ccd2\":\"HEALTHY\"} ingress.kubernetes.io/forwarding-rule: k8s2-fr-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/https-forwarding-rule: k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/https-target-proxy: k8s2-ts-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/ssl-cert: k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 ingress.kubernetes.io/target-proxy: k8s2-tp-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/url-map: k8s2-um-1lt9dzcy-default-web-ingress-yteotwe4 kubernetes.io/ingress.allow-http: true kubernetes.io/ingress.class: gce kubernetes.io/ingress.global-static-ip-name: web-ip Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateCertificate 28m cert-manager-ingress-shim Successfully created Certificate \"web-ssl\" Normal Sync 28m loadbalancer-controller UrlMap \"k8s2-um-1lt9dzcy-default-web-ingress-yteotwe4\" updated Warning Sync 24m (x16 over 28m) loadbalancer-controller Error syncing to GCP: error running load balancer syncing routine: loadbalancer 1lt9dzcy-default-web-ingress-yteotwe4 does not exist: googleapi: Error 404: The resource 'projects/your-project/global/sslCertificates/k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-e3b0c44298fc1c14' was not found, notFound Normal Sync 34s (x16 over 65m) loadbalancer-controller Scheduled for sync Use cmctl to show the state of a Certificate and its associated resources \u00b6 \u2139\ufe0f Install cmctl if you have not already done so. When you create a Certificate, cert-manager will create a collection of temporary resources which each contain information about the status of certificate signing process. You can read more about these in the Certificate Lifecycle section. Use the cmctl status command to view details of all these resources and all the associated Events and error messages. You may see some temporary errors, like: $ cmctl status certificate web-ssl Name: web-ssl Namespace: default Created at: 2022-07-14T17:30:06+01:00 Conditions: Ready: False, Reason: MissingData, Message: Issuing certificate as Secret does not contain a private key Issuing: True, Reason: MissingData, Message: Issuing certificate as Secret does not contain a private key DNS Names: - www.example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 4m37s cert-manager-certificates-trigger Issuing certificate as Secret does not contain a private key Normal Generated 4m37s cert-manager-certificates-key-manager Stored new private key in temporary Secret resource \"web-ssl-8gsqc\" Normal Requested 4m37s cert-manager-certificates-request-manager Created new CertificateRequest resource \"web-ssl-dblrj\" Issuer: Name: letsencrypt-staging Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server Events: <none> error: 'tls.crt' of Secret \"web-ssl\" is not set Not Before: <none> Not After: <none> Renewal Time: <none> CertificateRequest: Name: web-ssl-dblrj Namespace: default Conditions: Approved: True, Reason: cert-manager.io, Message: Certificate request has been approved by cert-manager.io Ready: False, Reason: Pending, Message: Waiting on certificate issuance from order default/web-ssl-dblrj-327645514: \"pending\" Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal cert-manager.io 4m37s cert-manager-certificaterequests-approver Certificate request has been approved by cert-manager.io Normal OrderCreated 4m37s cert-manager-certificaterequests-issuer-acme Created Order resource default/web-ssl-dblrj-327645514 Normal OrderPending 4m37s cert-manager-certificaterequests-issuer-acme Waiting on certificate issuance from order default/web-ssl-dblrj-327645514: \"\" Order: Name: web-ssl-dblrj-327645514 State: pending, Reason: Authorizations: URL: https://acme-staging-v02.api.letsencrypt.org/acme/authz-v3/3008789144, Identifier: www.example.com, Initial State: pending, Wildcard: false Challenges: - Name: web-ssl-dblrj-327645514-2671694319, Type: HTTP-01, Token: TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro, Key: TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro.f4bppCOm-jXasFGMKjpBE5aQlhiQBeTPIs0Lx822xao, State: pending, Reason: Waiting for HTTP-01 challenge propagation: did not get expected response when querying endpoint, expected \"TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro.f4bppCOm-jXasFGMKjpBE5aQlhiQBeTPIs0Lx822xao\" but got: Hello, world! Version: 1... (truncated), Processing: true, Presented: true This is because cert-manager is performing a preflight check to see if the temporary challenge web server is reachable at the expected URL. Initially it will not be reachable, because cert-manager takes some time to deploy the temporary web server and the Ingress controller takes time to set up the new HTTP routing rules. Eventually you will see that the Certificate is Ready and signed: $ cmctl status certificate web-ssl Name: web-ssl Namespace: default Created at: 2022-07-14T17:30:06+01:00 Conditions: Ready: True, Reason: Ready, Message: Certificate is up to date and has not expired DNS Names: - www.example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 31m cert-manager-certificates-trigger Issuing certificate as Secret does not contain a private key Normal Generated 31m cert-manager-certificates-key-manager Stored new private key in temporary Secret resource \"web-ssl-8gsqc\" Normal Requested 31m cert-manager-certificates-request-manager Created new CertificateRequest resource \"web-ssl-dblrj\" Normal Issuing 26m cert-manager-certificates-issuing The certificate has been successfully issued Issuer: Name: letsencrypt-staging Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server Events: <none> Secret: Name: web-ssl Issuer Country: US Issuer Organisation: (STAGING) Let's Encrypt Issuer Common Name: (STAGING) Artificial Apricot R3 Key Usage: Digital Signature, Key Encipherment Extended Key Usages: Server Authentication, Client Authentication Public Key Algorithm: RSA Signature Algorithm: SHA256-RSA Subject Key ID: a51e3621f5c1138947810f27dce425b33c88cb16 Authority Key ID: de727a48df31c3a650df9f8523df57374b5d2e65 Serial Number: fa8bb0b603ca2cdbfdfb2872d05ee52cda10 Events: <none> Not Before: 2022-07-14T16:34:52+01:00 Not After: 2022-10-12T16:34:51+01:00 Renewal Time: 2022-09-12T16:34:51+01:00 Check that the SSL certificate has been copied to Google Cloud \u00b6 After cert-manager receives the signed Certificate it stores in the web-ssl Secret, and this in turn triggers the Google Cloud ingress controller to copy that SSL certificate to Google Cloud. You can see the certificate using the gcloud command, as follows: $ gcloud compute ssl-certificates list NAME TYPE CREATION_TIMESTAMP EXPIRE_TIME MANAGED_STATUS k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 SELF_MANAGED 2022-07-14T09:37:06.920-07:00 2022-10-12T08:34:51.000-07:00 And you can view its contents and check its attributes as follows: $ gcloud compute ssl-certificates describe k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 --format = 'value(certificate)' \\ | openssl x509 -in - -noout -text ... Certificate: Data: Version: 3 (0x2) Serial Number: 04:9f:47:f1:cb:25:37:9b:86:a3:ef:bf:2e:77:3b:45:fc:1a Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Let's Encrypt, CN = R3 Validity Not Before: Jul 14 17:11:15 2022 GMT Not After : Oct 12 17:11:14 2022 GMT Subject: CN = www.example.com Check the Google Cloud forwarding-rules \u00b6 After you add the TLS stanza to the Ingress object, you should eventually see a forwarding-rule for the SSL connection: $ gcloud compute forwarding-rules describe k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 --global IPAddress: 34.120.159.51 IPProtocol: TCP creationTimestamp: '2022-07-14T09:37:12.362-07:00' description: '{\"kubernetes.io/ingress-name\": \"default/web-ingress\"}' fingerprint: oBTg7dRaIqI= id: '2303318464959215831' kind: compute#forwardingRule labelFingerprint: 42WmSpB8rSM= loadBalancingScheme: EXTERNAL name: k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 networkTier: PREMIUM portRange: 443-443 selfLink: https://www.googleapis.com/compute/v1/projects/your-project/global/forwardingRules/k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 target: https://www.googleapis.com/compute/v1/projects/your-project/global/targetHttpsProxies/k8s2-ts-1lt9dzcy-default-web-ingress-yteotwe4","title":"Deploy cert-manager on Google Kubernetes Engine (GKE) and create SSL certificates for Ingress using Let's Encrypt"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#prerequisites","text":"\ud83d\udcbb Google Cloud account You will need a Google Cloud account. Registration requires a credit card or bank account details. Visit the Get started with Google Cloud page and follow the instructions. \ud83d\udcb5 If you have never used Google Cloud before, you may be eligible for the Google Cloud Free Program , which gives you a 90 day trial period that includes $300 in free Cloud Billing credits to explore and evaluate Google Cloud. \ud83d\udcbb Domain Name You will need a domain name and the ability to create DNS records in that domain. We will be getting a $12 domain name from Google Domains. Google Domains is one of the many possible \"domain name registrars\". NameCheap and GoDaddy are two other well-known registrars. \ud83d\udcb5 If you prefer not purchasing a domain name, it is also possible to adapt this tutorial to use the IP address to serve your website and for the SSL certificate. \ud83d\udcbb Software You will also need to install the following software on your laptop: gcloud : A set of tools to create and manage Google Cloud resources. kubectl : The Kubernetes command-line tool which allows you to configure Kubernetes clusters. curl : A command-line tool for connecting to a web server using HTTP and HTTPS. \u2139\ufe0f Try running gcloud components install kubectl to quickly install kubectl .","title":"Prerequisites"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#0-configure-gcloud-with-a-google-cloud-project","text":"If you don't have a Google Cloud account, the command below will create one for you: gcloud init You will need to answer \"yes\" to the following question: Do you want to configure a default Compute Region and Zone? (Y/n)? Y After running the command, you will shown the project name, default region, and default zone. Example output: * Commands that require authentication will use firstname.lastname@example.com by default * Commands will reference project `your-project` by default * Compute Engine commands will use region `europe-west1` by default * Compute Engine commands will use zone `europe-west1-b` by default In this tutorial, we will refer to the name of the project that was selected while running gcloud init with the variable PROJECT . Where ever you see $PROJECT in a command, you need to either (1) replace the variable manually before you execute the command, or (2) export the variable in your shell session. This applies to all environment variables that you will encounter in the commands listed in this tutorial. We will go with option (2), so we need to export the environment variables before continuing using the information that was printed by gcloud init : export PROJECT = your-project # Your Google Cloud project ID. export REGION = europe-west1 # Your Google Cloud region.","title":"0. Configure gcloud with a Google Cloud project"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#1-create-a-kubernetes-cluster","text":"To get started, let's create a Kubernetes cluster in Google Cloud. You will need to pick a name for your cluster. Here, we will go with \"test-cluster-1\". Let us save it in an environment variable: export CLUSTER = test-cluster-1 Now, create the cluster using the following command: gcloud container clusters create $CLUSTER --preemptible --num-nodes = 1 Set up the Google Kubernetes Engine auth plugin for kubectl : gcloud components install gke-gcloud-auth-plugin export USE_GKE_GCLOUD_AUTH_PLUGIN = True gcloud container clusters get-credentials $CLUSTER Now check that you can connect to the cluster: kubectl get nodes -o wide \u23f2 It will take 4-5 minutes to create the cluster. \ud83d\udcb5 To minimize your cloud bill, this command creates a 1-node cluster using a preemptible virtual machine which is cheaper than a normal virtual machine.","title":"1. Create a Kubernetes Cluster"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#2-deploy-a-sample-web-server","text":"We will deploy a very simple web server which responds to HTTP requests with \"hello world!\". kubectl create deployment web --image = gcr.io/google-samples/hello-app:1.0 We also need to create a Kubernetes Service, so that connections can be routed to the web server Pods: kubectl expose deployment web --port = 8080 \u2139\ufe0f These kubectl imperative commands are used for readability and brevity. Feel free to use YAML manifests and kubectl apply -f instead. \u2139\ufe0f The Service created by kubectl expose will be of type ClusterIP (the default) and this is only reachable by components within the cluster. Later we will create an Ingress which is how we make the service available to clients outside the cluster. \ud83d\udd30 Read more about Using a Service to Expose Your App .","title":"2. Deploy a sample web server"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#3-create-a-static-external-ip-address","text":"This tutorial is about creating a public facing HTTPS website with a Let's Encrypt SSL certificate using the HTTP01 challenge mechanism, so we need a public IP address so that both Let's Encrypt and other Internet clients can connect to your website. It is easy to create a public IP address in Google Cloud and later we will associate it with your website domain name and with a Google Cloud load balancer, which will accept HTTP(S) connections from Internet clients and proxy the requests to the web servers running in your cluster. Create a global static IP address as follows: gcloud compute addresses create web-ip --global You should see the new IP address listed: gcloud compute addresses list \u26a0\ufe0f You MUST create a global IP address because that is a prerequisite of the External HTTP(S) Load Balancer which we will be using in this tutorial. \ud83d\udcb5 Global static IP addresses are only available in the Premium network service tier and are more expensive than ephemeral and standard public IP addresses. \ud83d\udd30 Read more about Network service tiers in Google Cloud . \ud83d\udd30 Read more about Reserving a static external IP address in Google Cloud . Finally, we will save the IP address into an environment variable for later use. Display the IP address with the following command: gcloud compute addresses describe web-ip --format = 'value(address)' --global Then, copy the output and save it into an environment variable: export IP_ADDRESS = 198 .51.100.1 # Replace with your IP address","title":"3. Create a static external IP address"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#4-create-a-domain-name-for-your-website","text":"You will need a domain name for your website and Let's Encrypt checks your domain before it signs your SSL certificate, so the domain name needs to be reachable from the Internet. We will purchase a cheap domain name using a credit card. Go to https://domains.google.com , and type something in the search box. For the example, we searched for hello-app.com because the example container that we will be deploying is called hello-app . Most importantly, we make sure to sort the domain names by price: We don't pick hello-app.com because it costs $2,800; instead, we go with the one at the top: heyapp.net . It looks good! We then click the cart button. On the next screen, you will want to disable the auto-renewal, since we don't want to pay for this domain every year: Now that you know your domain name, save it in an environment variable: export DOMAIN_NAME = heyapp.net Next, you will need to create a new A record pointing at the IP address that we created above. Head back to https://domains.google.com/registrar , open your domain (here, heyapp.net ) and click \"DNS\" on the left menu. You will see \"Custom records\". You want to add a new record of type A and put the IP address from the previous step into \"data\". You must leave \"Host name\" empty because we are configuring the top-level domain name: \ud83d\udd30 Learn more about What is a DNS A record? from the Cloudflare DNS tutorial . \u2139\ufe0f It is not strictly necessary to create a domain name for your website. You can connect to it using the IP address and later you can create an SSL certificate for the IP address instead of a domain name. If for some reason you can't create a domain name, then feel free to skip this section and adapt the instructions below to use an IP address instead. \u2139\ufe0f Every Google Cloud address has an automatically generated reverse DNS name like 51.159.120.34.bc.googleusercontent.com , but the parent domain googleusercontent.com has a CAA record which prevents Let's Encrypt from signing certificates for the sub-domains. See Certificate Authority Authorization (CAA) in the Let's Encrypt documentation.","title":"4. Create a domain name for your website"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#5-create-an-ingress","text":"You won't be able to reach your website yet. Your web server is running inside your Kubernetes cluster but there is no route or proxy through which Internet clients can connect to it, yet! Now we will create a Kubernetes Ingress object and in Google Cloud this will trigger the creation of a various services which together allow Internet clients to reach your web server running inside your Kubernetes cluster. Initially we are going to create an HTTP (not an HTTPS) Ingress so that we can test the basic connectivity before adding the SSL layer. Copy the following YAML into a file called ingress.yaml and apply it: # ingress.yaml apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : web-ingress annotations : # This tells Google Cloud to create an External Load Balancer to realize this Ingress kubernetes.io/ingress.class : gce # This enables HTTP connections from Internet clients kubernetes.io/ingress.allow-http : \"true\" # This tells Google Cloud to associate the External Load Balancer with the static IP which we created earlier kubernetes.io/ingress.global-static-ip-name : web-ip spec : defaultBackend : service : name : web port : number : 8080 kubectl apply -f ingress.yaml This will trigger the creation of a Google HTTP(S) loadbalancer associated with the IP address that you created earlier. You can watch the progress and the resources that are being created: kubectl describe ingress web-ingress Within 4-5 minutes all the load balancer components should be ready and you should be able to connect to the DNS name and see the response from the hello-world web server that we deployed earlier: curl http://$DOMAIN_NAME Example output: Hello, world! Version: 1.0.0 Hostname: web-79d88c97d6-t8hj2 At this point we have a Google load balancer which is forwarding HTTP traffic to the hello-world web server running in a Pod in our cluster. \u23f2 It may take 4-5 minutes for the load balancer components to be created and configured and for Internet clients to be routed to your web server. Refer to the Troubleshooting section if it takes longer. \ud83d\udd30 Read about how to Use a static IP addresses for HTTP(S) load balancers via Ingress annotation . \ud83d\udd30 Read a Summary of external Ingress annotations for GKE . \ud83d\udd30 Read about Troubleshooting Ingress with External HTTP(S) Load Balancing on GKE . \u2139\ufe0f There are two Ingress classes available for GKE Ingress. The gce class deploys an external load balancer and the gce-internal class deploys an internal load balancer. Ingress resources without a class specified default to gce . \u26a0\ufe0f Contrary to the Kubernetes Ingress documentation, you MUST use the kubernetes.io/ingress.class annotation rather than the Ingress.Spec.IngressClassName field. See ingress-gce #1301 and ingress-gce #1337 .","title":"5. Create an Ingress"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#6-install-cert-manager","text":"So finally we are ready to start creating an SSL certificate for our website. The first thing you need to do is install cert-manager, and we'll install it the easy using kubectl as follows: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.2/cert-manager.yaml This will create three Deployments, and a bunch of Services and Pods in a new namespace called cert-manager . It also installs various cluster scoped supporting resources such as RBAC roles and Custom Resource Definitions. You can view some of the resources that have been installed as follows: kubectl -n cert-manager get all And you can explore the Custom Resource Definitions (cert-manager's API) using kubectl explain , as follows: kubectl explain Certificate kubectl explain CertificateRequest kubectl explain Issuer \ud83d\udd30 Read about other ways to install cert-manager . \ud83d\udd30 Read more about Certificates and Issuers .","title":"6. Install cert-manager"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#7-create-an-issuer-for-lets-encrypt-staging","text":"An Issuer is a custom resource which tells cert-manager how to sign a Certificate. In this case the Issuer will be configured to connect to the Let's Encrypt staging server, which allows us to test everything without using up our Let's Encrypt certificate quota for the domain name. \u2139\ufe0f Let's Encrypt uses the Automatic Certificate Management Environment (ACME) protocol which is why the configuration below is under a key called acme . Save the following content to a file called issuer-lets-encrypt-staging.yaml , change the email field to use your email address and apply it: # issuer-lets-encrypt-staging.yaml apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-staging spec : acme : server : https://acme-staging-v02.api.letsencrypt.org/directory email : <email-address> # \u2757 Replace this with your email address privateKeySecretRef : name : letsencrypt-staging solvers : - http01 : ingress : name : web-ingress kubectl apply -f issuer-lets-encrypt-staging.yaml \u2139\ufe0f The email address is only used by Let's Encrypt to remind you to renew the certificate after 30 days before expiry. You will only receive this email if something goes wrong when renewing the certificate with cert-manager. You can check the status of the Issuer: kubectl describe issuers.cert-manager.io letsencrypt-staging Example output Status: Acme: Last Registered Email: firstname.lastname@example.com Uri: https://acme-staging-v02.api.letsencrypt.org/acme/acct/60706744 Conditions: Last Transition Time: 2022-07-13T16:13:25Z Message: The ACME account was registered with the ACME server Observed Generation: 1 Reason: ACMEAccountRegistered Status: True Type: Ready \u2139\ufe0f The Let's Encrypt production issuer has very strict rate limits . When you're experimenting and learning, it can be very easy to hit those limits. Because of that risk, we'll start with the Let's Encrypt staging issuer, and once we're happy that it's working we'll switch to the production issuer. \u26a0\ufe0f In the next step you will see a warning about untrusted certificates because we start with the staging issuer, but that's totally expected. \ud83d\udd30 Read more about configuring the ACME Issuer .","title":"7. Create an Issuer for Let's Encrypt Staging"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#8-re-configure-the-ingress-for-ssl","text":"Earlier we created an Ingress and saw that we could connect to our web server using HTTP. Now we will reconfigure that Ingress for HTTPS. First a quick hack, to work around a problem with the Google Cloud ingress controller. Create an empty Secret for your SSL certificate before reconfiguring the Ingress and apply it: # secret.yaml apiVersion : v1 kind : Secret metadata : name : web-ssl type : kubernetes.io/tls stringData : tls.key : \"\" tls.crt : \"\" kubectl apply -f secret.yaml \u2139\ufe0f This is a work around for a chicken-and-egg problem, where the ingress-gce controller won't update its forwarding rules unless it can first find the Secret that will eventually contain the SSL certificate. But Let's Encrypt won't sign the SSL certificate until it can get the special .../.well-known/acme-challenge/... URL which cert-manager adds to the Ingress and which must then be translated into Google Cloud forwarding rules, by the ingress-gce controller. \ud83d\udd30 Read more about Kubernetes Secrets and how to use them . Now make the following changes to the Ingress and apply them: --- a/ingress.yaml +++ b/ingress.yaml @@ -7,7 +7,12 @@ metadata: kubernetes.io/ingress.class: gce kubernetes.io/ingress.allow-http: \"true\" kubernetes.io/ingress.global-static-ip-name: web-ip + cert-manager.io/issuer: letsencrypt-staging spec: + tls: + - secretName: web-ssl + hosts: + - $DOMAIN_NAME defaultBackend: service: name: web kubectl apply -f ingress.yaml This triggers a complex set of operations which may take many minutes to eventually complete. Some of these steps take 2-3 minutes and some will initially fail. They should all eventually succeed because cert-manager and ingress-gce (the Google Cloud ingress controller) will periodically re-reconcile. Eventually, When all the pieces are in place, you should be able to use curl to check the HTTPS connection to your website: curl -v --insecure https:// $DOMAIN_NAME You should see that the HTTPS connection is established but that the SSL certificate is not trusted; that's why you use the --insecure flag at this stage Example output: * Server certificate: * subject: CN=www.example.com * start date: Jul 14 08:52:29 2022 GMT * expire date: Oct 12 08:52:28 2022 GMT * issuer: C=US; O=(STAGING) Let's Encrypt; CN=(STAGING) Artificial Apricot R3 * SSL certificate verify result: unable to get local issuer certificate (20), continuing anyway. \u23f2 You will have to wait 5-10 minutes for the SSL certificate to be signed and then loaded by the Google Cloud load balancer. Refer to the Troubleshooting section if it takes longer. \u2139\ufe0f Adding the annotation cert-manager.io/issuer: letsencrypt-staging marks the Ingress for the attention of the cert-manager ingress-shim and causes it to create a new Certificate with a reference to the Issuer that we created earlier. \ud83d\udd30 Read Securing Ingress Resources to learn more. \ud83d\udd30 Read about how to Specify certificates for your Ingress in GKE .","title":"8. Re-configure the Ingress for SSL"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#9-create-a-production-ready-ssl-certificate","text":"Now that everything is working with the Let's Encrypt staging server, we can switch to the production server and get a trusted SSL certificate. Create a Let's Encrypt production Issuer and apply it: # issuer-lets-encrypt-production.yaml apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : letsencrypt-production spec : acme : server : https://acme-v02.api.letsencrypt.org/directory email : <email-address> # \u2757 Replace this with your email address privateKeySecretRef : name : letsencrypt-production solvers : - http01 : ingress : name : web-ingress kubectl apply -f issuer-lets-encrypt-production.yaml Then update the Ingress annotation to use the production Issuer: kubectl annotate ingress web-ingress cert-manager.io/issuer = letsencrypt-production --overwrite This will trigger cert-manager to get a new SSL certificate signed by the Let's Encrypt production CA and store it to the web-ssl Secret. Within about 10 minutes, this new certificate will be synced to the Google Cloud load balancer and you will be able to connect to the website using secure HTTPS: curl -v https:// $DOMAIN_NAME Example output: ... * Server certificate: * subject: CN=www.example.com * start date: Jul 14 09:44:29 2022 GMT * expire date: Oct 12 09:44:28 2022 GMT * subjectAltName: host \"www.example.com\" matched cert's \"www.example.com\" * issuer: C=US; O=Let's Encrypt; CN=R3 * SSL certificate verify ok. ... Hello, world! Version: 1.0.0 Hostname: web-79d88c97d6-t8hj2 It should also be possible to visit https://$DOMAIN_NAME in your web browser, without any errors or warnings. That concludes the tutorial. You now understand how cert-manager integrates with Kubernetes Ingress and cloud Ingress controllers. You have learned how to use cert-manager to get free Let's Encrypt SSL certificates. And you have seen how the certificates can be used by a cloud based load balancer to terminate SSL connections from Internet clients and forward HTTPS requests to a web server running in your Kubernetes cluster. \ud83d\udcb5 Read the Clean up section to learn how to delete all the resources that you created in this tutorial and reduce your cloud bill. \ud83d\udd30 Read the Troubleshooting section if you encounter difficulties with the steps described in this tutorial.","title":"9. Create a production ready SSL certificate"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#clean-up","text":"After completing the tutorial you can clean up by deleting the cluster and the domain name and the static IP as follows: # Delete the cluster and all the Google Cloud resources related to the Ingress that it contains gcloud container clusters delete $CLUSTER # Delete the domain name gcloud dns record-sets delete $DOMAIN_NAME --zone $ZONE --type A # Delete the static IP address gcloud compute addresses delete web-ip --global","title":"Clean up"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#troubleshooting","text":"When you create or update the Ingress object in this tutorial it triggers a complex set of operations which may take many minutes to eventually complete. Some of these steps take 2-3 minutes and some will initially fail but then subsequently succeed when either cert-manager or the Google ingress controller re-reconciles. In short, you should allow 5-10 minutes after you create or change the Ingress and you should expect to see some errors and warnings when you run kubectl describe ingress web-ingress . Here's a brief summary of the operations performed by cert-manager and ingress-gce (the Google Cloud Ingress controller): cert-manager connects to Let's Encrypt and sends an SSL certificate signing request. Let's Encrypt responds with a \"challenge\", which is a unique token that cert-manager must make available at a well-known location on the target web site. This proves that you are an administrator of that web site and domain name. cert-manager deploys a Pod containing a temporary web server that serves the Let's Encrypt challenge token. cert-manager reconfigures the Ingress, adding a rule to route requests for from Let's Encrypt to that temporary web server. Google Cloud ingress controller reconfigures the external HTTP load balancer with that new rule. Let's Encrypt now connects and receives the expected challenge token and the signs the SSL certificate and returns it to cert-manager. cert-manager stores the signed SSL certificate in the Kubernetes Secret called web-ssl . Google Cloud ingress controller uploads the signed certificate and associated private key to a Google Cloud certificate. Google Cloud ingress controller reconfigures the external load balancer to serve the uploaded SSL certificate.","title":"Troubleshooting"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#check-ingress-and-associated-events","text":"Use kubectl describe to view the Ingress configuration and all the associated Events. Check that the IP address is correct and that the TLS and Host entries match the domain name that you chose for your website. Notice that ingress-gce creates an Event for each of the Google Cloud components that it manages. And notice that it adds annotations with references to the ID of each of those components. cert-manager also creates Events when it reconciles the Ingress object, including details of the Certificate object that it creates for the Ingress. $ kubectl describe ingress web-ingress Name: web-ingress Labels: <none> Namespace: default Address: 34.120.159.51 Ingress Class: <none> Default backend: web:8080 (10.52.0.13:8080) TLS: web-ssl terminates www.example.com Rules: Host Path Backends ---- ---- -------- * * web:8080 (10.52.0.13:8080) Annotations: cert-manager.io/issuer: letsencrypt-staging ingress.kubernetes.io/backends: {\"k8s1-01784147-default-web-8080-1647ccd2\":\"HEALTHY\"} ingress.kubernetes.io/forwarding-rule: k8s2-fr-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/https-forwarding-rule: k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/https-target-proxy: k8s2-ts-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/ssl-cert: k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 ingress.kubernetes.io/target-proxy: k8s2-tp-1lt9dzcy-default-web-ingress-yteotwe4 ingress.kubernetes.io/url-map: k8s2-um-1lt9dzcy-default-web-ingress-yteotwe4 kubernetes.io/ingress.allow-http: true kubernetes.io/ingress.class: gce kubernetes.io/ingress.global-static-ip-name: web-ip Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal CreateCertificate 28m cert-manager-ingress-shim Successfully created Certificate \"web-ssl\" Normal Sync 28m loadbalancer-controller UrlMap \"k8s2-um-1lt9dzcy-default-web-ingress-yteotwe4\" updated Warning Sync 24m (x16 over 28m) loadbalancer-controller Error syncing to GCP: error running load balancer syncing routine: loadbalancer 1lt9dzcy-default-web-ingress-yteotwe4 does not exist: googleapi: Error 404: The resource 'projects/your-project/global/sslCertificates/k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-e3b0c44298fc1c14' was not found, notFound Normal Sync 34s (x16 over 65m) loadbalancer-controller Scheduled for sync","title":"Check Ingress and associated events"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#use-cmctl-to-show-the-state-of-a-certificate-and-its-associated-resources","text":"\u2139\ufe0f Install cmctl if you have not already done so. When you create a Certificate, cert-manager will create a collection of temporary resources which each contain information about the status of certificate signing process. You can read more about these in the Certificate Lifecycle section. Use the cmctl status command to view details of all these resources and all the associated Events and error messages. You may see some temporary errors, like: $ cmctl status certificate web-ssl Name: web-ssl Namespace: default Created at: 2022-07-14T17:30:06+01:00 Conditions: Ready: False, Reason: MissingData, Message: Issuing certificate as Secret does not contain a private key Issuing: True, Reason: MissingData, Message: Issuing certificate as Secret does not contain a private key DNS Names: - www.example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 4m37s cert-manager-certificates-trigger Issuing certificate as Secret does not contain a private key Normal Generated 4m37s cert-manager-certificates-key-manager Stored new private key in temporary Secret resource \"web-ssl-8gsqc\" Normal Requested 4m37s cert-manager-certificates-request-manager Created new CertificateRequest resource \"web-ssl-dblrj\" Issuer: Name: letsencrypt-staging Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server Events: <none> error: 'tls.crt' of Secret \"web-ssl\" is not set Not Before: <none> Not After: <none> Renewal Time: <none> CertificateRequest: Name: web-ssl-dblrj Namespace: default Conditions: Approved: True, Reason: cert-manager.io, Message: Certificate request has been approved by cert-manager.io Ready: False, Reason: Pending, Message: Waiting on certificate issuance from order default/web-ssl-dblrj-327645514: \"pending\" Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal cert-manager.io 4m37s cert-manager-certificaterequests-approver Certificate request has been approved by cert-manager.io Normal OrderCreated 4m37s cert-manager-certificaterequests-issuer-acme Created Order resource default/web-ssl-dblrj-327645514 Normal OrderPending 4m37s cert-manager-certificaterequests-issuer-acme Waiting on certificate issuance from order default/web-ssl-dblrj-327645514: \"\" Order: Name: web-ssl-dblrj-327645514 State: pending, Reason: Authorizations: URL: https://acme-staging-v02.api.letsencrypt.org/acme/authz-v3/3008789144, Identifier: www.example.com, Initial State: pending, Wildcard: false Challenges: - Name: web-ssl-dblrj-327645514-2671694319, Type: HTTP-01, Token: TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro, Key: TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro.f4bppCOm-jXasFGMKjpBE5aQlhiQBeTPIs0Lx822xao, State: pending, Reason: Waiting for HTTP-01 challenge propagation: did not get expected response when querying endpoint, expected \"TKspp86xMjQzTvMVXWkezEA2sE2GSWjnld5Lt4X13ro.f4bppCOm-jXasFGMKjpBE5aQlhiQBeTPIs0Lx822xao\" but got: Hello, world! Version: 1... (truncated), Processing: true, Presented: true This is because cert-manager is performing a preflight check to see if the temporary challenge web server is reachable at the expected URL. Initially it will not be reachable, because cert-manager takes some time to deploy the temporary web server and the Ingress controller takes time to set up the new HTTP routing rules. Eventually you will see that the Certificate is Ready and signed: $ cmctl status certificate web-ssl Name: web-ssl Namespace: default Created at: 2022-07-14T17:30:06+01:00 Conditions: Ready: True, Reason: Ready, Message: Certificate is up to date and has not expired DNS Names: - www.example.com Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 31m cert-manager-certificates-trigger Issuing certificate as Secret does not contain a private key Normal Generated 31m cert-manager-certificates-key-manager Stored new private key in temporary Secret resource \"web-ssl-8gsqc\" Normal Requested 31m cert-manager-certificates-request-manager Created new CertificateRequest resource \"web-ssl-dblrj\" Normal Issuing 26m cert-manager-certificates-issuing The certificate has been successfully issued Issuer: Name: letsencrypt-staging Kind: Issuer Conditions: Ready: True, Reason: ACMEAccountRegistered, Message: The ACME account was registered with the ACME server Events: <none> Secret: Name: web-ssl Issuer Country: US Issuer Organisation: (STAGING) Let's Encrypt Issuer Common Name: (STAGING) Artificial Apricot R3 Key Usage: Digital Signature, Key Encipherment Extended Key Usages: Server Authentication, Client Authentication Public Key Algorithm: RSA Signature Algorithm: SHA256-RSA Subject Key ID: a51e3621f5c1138947810f27dce425b33c88cb16 Authority Key ID: de727a48df31c3a650df9f8523df57374b5d2e65 Serial Number: fa8bb0b603ca2cdbfdfb2872d05ee52cda10 Events: <none> Not Before: 2022-07-14T16:34:52+01:00 Not After: 2022-10-12T16:34:51+01:00 Renewal Time: 2022-09-12T16:34:51+01:00","title":"Use cmctl to show the state of a Certificate and its associated resources"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#check-that-the-ssl-certificate-has-been-copied-to-google-cloud","text":"After cert-manager receives the signed Certificate it stores in the web-ssl Secret, and this in turn triggers the Google Cloud ingress controller to copy that SSL certificate to Google Cloud. You can see the certificate using the gcloud command, as follows: $ gcloud compute ssl-certificates list NAME TYPE CREATION_TIMESTAMP EXPIRE_TIME MANAGED_STATUS k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 SELF_MANAGED 2022-07-14T09:37:06.920-07:00 2022-10-12T08:34:51.000-07:00 And you can view its contents and check its attributes as follows: $ gcloud compute ssl-certificates describe k8s2-cr-1lt9dzcy-4gjeakdb9n7k6ls7-a257650b5fefd174 --format = 'value(certificate)' \\ | openssl x509 -in - -noout -text ... Certificate: Data: Version: 3 (0x2) Serial Number: 04:9f:47:f1:cb:25:37:9b:86:a3:ef:bf:2e:77:3b:45:fc:1a Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Let's Encrypt, CN = R3 Validity Not Before: Jul 14 17:11:15 2022 GMT Not After : Oct 12 17:11:14 2022 GMT Subject: CN = www.example.com","title":"Check that the SSL certificate has been copied to Google Cloud"},{"location":"tutorials/getting-started-with-cert-manager-on-google-kubernetes-engine-using-lets-encrypt-for-ingress-ssl/#check-the-google-cloud-forwarding-rules","text":"After you add the TLS stanza to the Ingress object, you should eventually see a forwarding-rule for the SSL connection: $ gcloud compute forwarding-rules describe k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 --global IPAddress: 34.120.159.51 IPProtocol: TCP creationTimestamp: '2022-07-14T09:37:12.362-07:00' description: '{\"kubernetes.io/ingress-name\": \"default/web-ingress\"}' fingerprint: oBTg7dRaIqI= id: '2303318464959215831' kind: compute#forwardingRule labelFingerprint: 42WmSpB8rSM= loadBalancingScheme: EXTERNAL name: k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 networkTier: PREMIUM portRange: 443-443 selfLink: https://www.googleapis.com/compute/v1/projects/your-project/global/forwardingRules/k8s2-fs-1lt9dzcy-default-web-ingress-yteotwe4 target: https://www.googleapis.com/compute/v1/projects/your-project/global/targetHttpsProxies/k8s2-ts-1lt9dzcy-default-web-ingress-yteotwe4","title":"Check the Google Cloud forwarding-rules"},{"location":"tutorials/istio-csr/istio-csr/","text":"This guide will run through installing and using istio-csr from scratch. We'll use kind to create a new cluster locally in Docker, but this guide should work on any cluster as long as the relevant Istio Platform Setup has been performed. Note that if you're following the Platform Setup guide for OpenShift, do not run the istioctl install command listed in that guide; we'll run our own command later. Initial Setup \u00b6 You'll need the following tools installed on your machine: istioctl kind and docker (if you're using kind) helm kubectl jq In addition, Istio must not already be installed in your cluster. Installing istio-csr after Istio is not supported. Creating the Cluster and Installing cert-manager \u00b6 Kind will automatically set up kubectl to point to the newly created cluster. We install cert-manager using helm here, but if you've got a preferred method you can install in any way. kind create cluster --image=docker.io/kindest/node:v1.22.4 # Helm setup helm repo add jetstack https://charts.jetstack.io helm repo update # install cert-manager CRDs kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.crds.yaml # install cert-manager ; this might take a little time helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.8.0 # We need this namespace to exist since our cert will be placed there kubectl create namespace istio-system Create a cert-manager Issuer and Issuing Certificate \u00b6 An Issuer tells cert-manager how to issue certificates; we'll create a self-signed root CA in our cluster because it's really simple to configure. The approach of using a locally generated root certificate would work in a production deployment too, but there are also several other issuers in cert-manager which could be used. Note that the ACME issuer will not work , since it can't add the required fields to issued certificates. There are also some comments on the example-issuer providing a little more detail. Note also that this guide only uses Issuer s and not ClusterIssuer s - using a ClusterIssuer isn't a drop-in replacement, and in any case we recommend that production deployments use Issuers for easier access controls and scoping. kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/istio-csr/example/example-issuer.yaml Export the Root CA to a Local File \u00b6 While it's possible to configure Istio such that it can automatically \"discover\" the root CA, this can be dangerous in some specific scenarios involving other security holes, enabling signer hijacking attacks . As such, we'll export our Root CA and configure Istio later using that static cert. # Export our cert from the secret it ' s stored in , and base64 decode to get the PEM data. kubectl get -n istio-system secret istio-ca -ogo-template='{{index .data \"tls.crt\"}}' | base64 -d > ca.pem # Out of interest, we can check out what our CA looks like openssl x509 -in ca.pem -noout -text # Add our CA to a secret kubectl create secret generic -n cert-manager istio-root-ca --from-file=ca.pem=ca.pem Installing istio-csr \u00b6 istio-csr is best installed via Helm, and it should be simple and quick to install. There are a bunch of other configuration options for the helm chart, which you can check out here . helm repo add jetstack https://charts.jetstack.io helm repo update # We set a few helm template values so we can point at our static root CA helm install -n cert-manager cert-manager-istio-csr jetstack/cert-manager-istio-csr \\ --set \"app.tls.rootCAFile=/var/run/secrets/istio-csr/ca.pem\" \\ --set \"volumeMounts[0].name=root-ca\" \\ --set \"volumeMounts[0].mountPath=/var/run/secrets/istio-csr\" \\ --set \"volumes[0].name=root-ca\" \\ --set \"volumes[0].secret.secretName=istio-root-ca\" # Check to see that the istio-csr pod is running and ready kubectl get pods -n cert-manager NAME READY STATUS RESTARTS AGE cert-manager-aaaaaaaaaa-11111 1/1 Running 0 9m46s cert-manager-cainjector-aaaaaaaaaa-22222 1/1 Running 0 9m46s cert-manager-istio-csr-bbbbbbbbbb-00000 1/1 Running 0 63s cert-manager-webhook-aaaaaaaaa-33333 1/1 Running 0 9m46s Installing Istio \u00b6 If you're not running on kind, you may need to do some additional setup tasks before installing Istio. We use the istioctl CLI to install Istio, configured using a custom IstioOperator manifest. The custom manifest does the following: Disables the CA server in istiod, Ensures that Istio workloads request certificates from istio-csr, Ensures that the istiod certificates and keys are mounted from the Certificate created when installing istio-csr. First we download our demo manifest and then we apply it. curl -sSL https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/istio-csr/example/istio-config-getting-started.yaml > istio-install-config.yaml You may wish to inspect and tweak istio-install-config.yaml if you know what you're doing, but this manifest should work for example purposes as-is. If you set a custom app.tls.trustDomain when installing istio-csr via helm earlier, you'll need to ensure that value is repeated in istio-install-config.yaml . This final command will install Istio; the exact command you need might vary on different platforms, and will certainly vary on OpenShift. # This takes a little time to complete istioctl install -f istio-install-config.yaml # If you ' re on OpenShift, you need a different profile: # istioctl install --set profile = openshift -f istio-install-config.yaml You will be prompted for input to confirm your choice of Istio profile: This will install the Istio 1.14.1 demo profile with [\"Istio core\" \"Istiod\" \"Ingress gateways\" \"Egress gateways\"] components into the cluster. Proceed? (y/N) Confirm your selection by entering y into the console to proceed with installation. Validating Install \u00b6 The following steps are option but can be followed to validate everything is hooked correctly: Deploy a sample application & watch for certificaterequests.cert-manager.io resources Verify cert-manager logs for new certificaterequests and responses Verify the CA Endpoint being used in a istio-proxy sidecar container Using istioctl to fetch the certificate info for the istio-proxy container To see this all in action, lets deploy a very simple sample application from the Istio samples . First set some environment variables whose values could be changed if needed: # Set namespace for sample application export NAMESPACE = default # Set env var for the value of the app label in manifests export APP = httpbin # Grab the installed version of istio export ISTIO_VERSION = $( istioctl version -o json | jq -r '.meshVersion[0].Info.version' ) We use the default namespace for simplicity, so let's label the namespace for Istio injection: kubectl label namespace $NAMESPACE istio-injection = enabled --overwrite In a separate terminal you should now follow the logs for cert-manager : kubectl logs -n cert-manager $( kubectl get pods -n cert-manager -o jsonpath = '{.items..metadata.name}' --selector app = cert-manager ) --since 2m -f In another separate terminal, lets watch the istio-system namespace for certificaterequests : kubectl get certificaterequests.cert-manager.io -n istio-system -w Now deploy the sample application httpbin in the labeled namespace. Note the use of a variable to match the manifest version to your installed Istio version: kubectl apply -n $NAMESPACE -f https://raw.githubusercontent.com/istio/istio/ $ISTIO_VERSION /samples/httpbin/httpbin.yaml You should see something similar to the output here for certificaterequests : NAME APPROVED DENIED READY ISSUER REQUESTOR AGE istio-ca-74bnl True True selfsigned system:serviceaccount:cert-manager:cert-manager 2d2h istiod-w9zh6 True True istio-ca system:serviceaccount:cert-manager:cert-manager 27m istio-csr-8ddcs istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s The key request being istio-csr-8ddcs in our example output. You should then check your cert-manager log output for two log lines with this request being \"Approved\" and \"Ready\": I0113 16:51:59.186482 1 conditions.go:261] Setting lastTransitionTime for CertificateRequest \"istio-csr-8ddcs\" condition \"Approved\" to 2022-01-13 16:51:59.186455713 +0000 UTC m=+3507.098466775 I0113 16:51:59.258876 1 conditions.go:261] Setting lastTransitionTime for CertificateRequest \"istio-csr-8ddcs\" condition \"Ready\" to 2022-01-13 16:51:59.258837897 +0000 UTC m=+3507.170859959 You should now see the application is running with both the application container and the sidecar: ~ kubectl get pods -n $NAMESPACE NAME READY STATUS RESTARTS AGE httpbin-74fb669cc6-559cg 2 /2 Running 0 4m To validate that the istio-proxy sidecar container has requested the certificate from the correct service, check the container logs: kubectl logs $( kubectl get pod -n $NAMESPACE -o jsonpath = \"{.items...metadata.name}\" --selector app = $APP ) -c istio-proxy You should see some early logs similar to this example: Istio v1.12 and earlier versions: 2022-01-13T16:51:58.495493Z info CA Endpoint cert-manager-istio-csr.cert-manager.svc:443, provider Citadel 2022-01-13T16:51:58.495817Z info Using CA cert-manager-istio-csr.cert-manager.svc:443 cert with certs: var/run/secrets/istio/root-cert.pem 2022-01-13T16:51:58.495941Z info citadelclient Citadel client using custom root cert: cert-manager-istio-csr.cert-manager.svc:443 Istio v1.13+ 2022-01-13T16:51:58.495493Z info CA Endpoint cert-manager-istio-csr.cert-manager.svc:443, provider Citadel 2022-01-13T16:51:58.495817Z info Using CA cert-manager-istio-csr.cert-manager.svc:443 cert with certs: var/run/secrets/istio/root-cert.pem 2022-01-13T16:51:58.495941Z info citadelclient Citadel client using custom root cert: var/run/secrets/istio/root-cert.pem Finally we can inspect the certificate being used in memory by Envoy. This one liner should return you the certificate being used: istioctl proxy-config secret $( kubectl get pods -n $NAMESPACE -o jsonpath = '{.items..metadata.name}' --selector app = $APP ) -o json | jq -r '.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes' | base64 --decode | openssl x509 -text -noout In particular look for the following sections: Signature Algorithm: ecdsa-with-SHA256 Issuer: O=cert-manager, O=cluster.local, CN=istio-ca Validity Not Before: Jan 13 16:51:59 2022 GMT Not After : Jan 13 17:51:59 2022 GMT ... X509v3 Subject Alternative Name: URI:spiffe://cluster.local/ns/default/sa/httpbin You should see the relevant Trust Domain inside the Issuer. In the default case, it should be: cluster.local as above. Note that the SPIFFE URI may be different if you used a different namespace or application. Clean up \u00b6 Assuming your running inside kind, you can simply remove the cluster: ```shell kind delete cluster","title":"Securing the istio Service Mesh using cert-manager"},{"location":"tutorials/istio-csr/istio-csr/#initial-setup","text":"You'll need the following tools installed on your machine: istioctl kind and docker (if you're using kind) helm kubectl jq In addition, Istio must not already be installed in your cluster. Installing istio-csr after Istio is not supported.","title":"Initial Setup"},{"location":"tutorials/istio-csr/istio-csr/#creating-the-cluster-and-installing-cert-manager","text":"Kind will automatically set up kubectl to point to the newly created cluster. We install cert-manager using helm here, but if you've got a preferred method you can install in any way. kind create cluster --image=docker.io/kindest/node:v1.22.4 # Helm setup helm repo add jetstack https://charts.jetstack.io helm repo update # install cert-manager CRDs kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.crds.yaml # install cert-manager ; this might take a little time helm install cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --version v1.8.0 # We need this namespace to exist since our cert will be placed there kubectl create namespace istio-system","title":"Creating the Cluster and Installing cert-manager"},{"location":"tutorials/istio-csr/istio-csr/#create-a-cert-manager-issuer-and-issuing-certificate","text":"An Issuer tells cert-manager how to issue certificates; we'll create a self-signed root CA in our cluster because it's really simple to configure. The approach of using a locally generated root certificate would work in a production deployment too, but there are also several other issuers in cert-manager which could be used. Note that the ACME issuer will not work , since it can't add the required fields to issued certificates. There are also some comments on the example-issuer providing a little more detail. Note also that this guide only uses Issuer s and not ClusterIssuer s - using a ClusterIssuer isn't a drop-in replacement, and in any case we recommend that production deployments use Issuers for easier access controls and scoping. kubectl apply -f https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/istio-csr/example/example-issuer.yaml","title":"Create a cert-manager Issuer and Issuing Certificate"},{"location":"tutorials/istio-csr/istio-csr/#export-the-root-ca-to-a-local-file","text":"While it's possible to configure Istio such that it can automatically \"discover\" the root CA, this can be dangerous in some specific scenarios involving other security holes, enabling signer hijacking attacks . As such, we'll export our Root CA and configure Istio later using that static cert. # Export our cert from the secret it ' s stored in , and base64 decode to get the PEM data. kubectl get -n istio-system secret istio-ca -ogo-template='{{index .data \"tls.crt\"}}' | base64 -d > ca.pem # Out of interest, we can check out what our CA looks like openssl x509 -in ca.pem -noout -text # Add our CA to a secret kubectl create secret generic -n cert-manager istio-root-ca --from-file=ca.pem=ca.pem","title":"Export the Root CA to a Local File"},{"location":"tutorials/istio-csr/istio-csr/#installing-istio-csr","text":"istio-csr is best installed via Helm, and it should be simple and quick to install. There are a bunch of other configuration options for the helm chart, which you can check out here . helm repo add jetstack https://charts.jetstack.io helm repo update # We set a few helm template values so we can point at our static root CA helm install -n cert-manager cert-manager-istio-csr jetstack/cert-manager-istio-csr \\ --set \"app.tls.rootCAFile=/var/run/secrets/istio-csr/ca.pem\" \\ --set \"volumeMounts[0].name=root-ca\" \\ --set \"volumeMounts[0].mountPath=/var/run/secrets/istio-csr\" \\ --set \"volumes[0].name=root-ca\" \\ --set \"volumes[0].secret.secretName=istio-root-ca\" # Check to see that the istio-csr pod is running and ready kubectl get pods -n cert-manager NAME READY STATUS RESTARTS AGE cert-manager-aaaaaaaaaa-11111 1/1 Running 0 9m46s cert-manager-cainjector-aaaaaaaaaa-22222 1/1 Running 0 9m46s cert-manager-istio-csr-bbbbbbbbbb-00000 1/1 Running 0 63s cert-manager-webhook-aaaaaaaaa-33333 1/1 Running 0 9m46s","title":"Installing istio-csr"},{"location":"tutorials/istio-csr/istio-csr/#installing-istio","text":"If you're not running on kind, you may need to do some additional setup tasks before installing Istio. We use the istioctl CLI to install Istio, configured using a custom IstioOperator manifest. The custom manifest does the following: Disables the CA server in istiod, Ensures that Istio workloads request certificates from istio-csr, Ensures that the istiod certificates and keys are mounted from the Certificate created when installing istio-csr. First we download our demo manifest and then we apply it. curl -sSL https://raw.githubusercontent.com/cert-manager/website/master/content/docs/tutorials/istio-csr/example/istio-config-getting-started.yaml > istio-install-config.yaml You may wish to inspect and tweak istio-install-config.yaml if you know what you're doing, but this manifest should work for example purposes as-is. If you set a custom app.tls.trustDomain when installing istio-csr via helm earlier, you'll need to ensure that value is repeated in istio-install-config.yaml . This final command will install Istio; the exact command you need might vary on different platforms, and will certainly vary on OpenShift. # This takes a little time to complete istioctl install -f istio-install-config.yaml # If you ' re on OpenShift, you need a different profile: # istioctl install --set profile = openshift -f istio-install-config.yaml You will be prompted for input to confirm your choice of Istio profile: This will install the Istio 1.14.1 demo profile with [\"Istio core\" \"Istiod\" \"Ingress gateways\" \"Egress gateways\"] components into the cluster. Proceed? (y/N) Confirm your selection by entering y into the console to proceed with installation.","title":"Installing Istio"},{"location":"tutorials/istio-csr/istio-csr/#validating-install","text":"The following steps are option but can be followed to validate everything is hooked correctly: Deploy a sample application & watch for certificaterequests.cert-manager.io resources Verify cert-manager logs for new certificaterequests and responses Verify the CA Endpoint being used in a istio-proxy sidecar container Using istioctl to fetch the certificate info for the istio-proxy container To see this all in action, lets deploy a very simple sample application from the Istio samples . First set some environment variables whose values could be changed if needed: # Set namespace for sample application export NAMESPACE = default # Set env var for the value of the app label in manifests export APP = httpbin # Grab the installed version of istio export ISTIO_VERSION = $( istioctl version -o json | jq -r '.meshVersion[0].Info.version' ) We use the default namespace for simplicity, so let's label the namespace for Istio injection: kubectl label namespace $NAMESPACE istio-injection = enabled --overwrite In a separate terminal you should now follow the logs for cert-manager : kubectl logs -n cert-manager $( kubectl get pods -n cert-manager -o jsonpath = '{.items..metadata.name}' --selector app = cert-manager ) --since 2m -f In another separate terminal, lets watch the istio-system namespace for certificaterequests : kubectl get certificaterequests.cert-manager.io -n istio-system -w Now deploy the sample application httpbin in the labeled namespace. Note the use of a variable to match the manifest version to your installed Istio version: kubectl apply -n $NAMESPACE -f https://raw.githubusercontent.com/istio/istio/ $ISTIO_VERSION /samples/httpbin/httpbin.yaml You should see something similar to the output here for certificaterequests : NAME APPROVED DENIED READY ISSUER REQUESTOR AGE istio-ca-74bnl True True selfsigned system:serviceaccount:cert-manager:cert-manager 2d2h istiod-w9zh6 True True istio-ca system:serviceaccount:cert-manager:cert-manager 27m istio-csr-8ddcs istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s istio-csr-8ddcs True True istio-ca system:serviceaccount:cert-manager:cert-manager-istio-csr 0s The key request being istio-csr-8ddcs in our example output. You should then check your cert-manager log output for two log lines with this request being \"Approved\" and \"Ready\": I0113 16:51:59.186482 1 conditions.go:261] Setting lastTransitionTime for CertificateRequest \"istio-csr-8ddcs\" condition \"Approved\" to 2022-01-13 16:51:59.186455713 +0000 UTC m=+3507.098466775 I0113 16:51:59.258876 1 conditions.go:261] Setting lastTransitionTime for CertificateRequest \"istio-csr-8ddcs\" condition \"Ready\" to 2022-01-13 16:51:59.258837897 +0000 UTC m=+3507.170859959 You should now see the application is running with both the application container and the sidecar: ~ kubectl get pods -n $NAMESPACE NAME READY STATUS RESTARTS AGE httpbin-74fb669cc6-559cg 2 /2 Running 0 4m To validate that the istio-proxy sidecar container has requested the certificate from the correct service, check the container logs: kubectl logs $( kubectl get pod -n $NAMESPACE -o jsonpath = \"{.items...metadata.name}\" --selector app = $APP ) -c istio-proxy You should see some early logs similar to this example: Istio v1.12 and earlier versions: 2022-01-13T16:51:58.495493Z info CA Endpoint cert-manager-istio-csr.cert-manager.svc:443, provider Citadel 2022-01-13T16:51:58.495817Z info Using CA cert-manager-istio-csr.cert-manager.svc:443 cert with certs: var/run/secrets/istio/root-cert.pem 2022-01-13T16:51:58.495941Z info citadelclient Citadel client using custom root cert: cert-manager-istio-csr.cert-manager.svc:443 Istio v1.13+ 2022-01-13T16:51:58.495493Z info CA Endpoint cert-manager-istio-csr.cert-manager.svc:443, provider Citadel 2022-01-13T16:51:58.495817Z info Using CA cert-manager-istio-csr.cert-manager.svc:443 cert with certs: var/run/secrets/istio/root-cert.pem 2022-01-13T16:51:58.495941Z info citadelclient Citadel client using custom root cert: var/run/secrets/istio/root-cert.pem Finally we can inspect the certificate being used in memory by Envoy. This one liner should return you the certificate being used: istioctl proxy-config secret $( kubectl get pods -n $NAMESPACE -o jsonpath = '{.items..metadata.name}' --selector app = $APP ) -o json | jq -r '.dynamicActiveSecrets[0].secret.tlsCertificate.certificateChain.inlineBytes' | base64 --decode | openssl x509 -text -noout In particular look for the following sections: Signature Algorithm: ecdsa-with-SHA256 Issuer: O=cert-manager, O=cluster.local, CN=istio-ca Validity Not Before: Jan 13 16:51:59 2022 GMT Not After : Jan 13 17:51:59 2022 GMT ... X509v3 Subject Alternative Name: URI:spiffe://cluster.local/ns/default/sa/httpbin You should see the relevant Trust Domain inside the Issuer. In the default case, it should be: cluster.local as above. Note that the SPIFFE URI may be different if you used a different namespace or application.","title":"Validating Install"},{"location":"tutorials/istio-csr/istio-csr/#clean-up","text":"Assuming your running inside kind, you can simply remove the cluster: ```shell kind delete cluster","title":"Clean up"},{"location":"tutorials/venafi/venafi/","text":"This guide walks you through how to secure a Kubernetes Ingress resource using the Venafi Issuer type. Whilst stepping through, you will learn how to: Create an EKS cluster using eksctl Install cert-manager into the EKS cluster Deploy nginx-ingress to expose applications running in the cluster Configure a Venafi Cloud issuer Configure cert-manager to secure your application traffic While this guide focuses on EKS as a Kubernetes provisioner and Venafi as a Certificate issuer, the steps here should be generally re-usable for other Issuer types. Prerequisites \u00b6 An AWS account kubectl installed Access to a publicly registered DNS zone A Venafi Cloud account and API credentials Create an EKS cluster \u00b6 If you already have a running EKS cluster you can skip this step and move onto deploying cert-manager. eksctl is a tool that makes it easier to deploy and manage an EKS cluster. Installation instructions for various platforms can be found in the eksctl installation instructions . Once installed, you can create a basic cluster by running: $ eksctl create cluster This process may take up to 20 minutes to complete. Complete instructions on using eksctl can be found in the eksctl usage section . Once your cluster has been created, you should verify that your cluster is running correctly by running the following command: $ kubectl get pods --all-namespaces NAME READY STATUS RESTARTS AGE aws-node-8xpkp 1/1 Running 0 115s aws-node-tflxs 1/1 Running 0 118s coredns-694d9447b-66vlp 1/1 Running 0 23s coredns-694d9447b-w5bg8 1/1 Running 0 23s kube-proxy-4dvpj 1/1 Running 0 115s kube-proxy-tpvht 1/1 Running 0 118s You should see output similar to the above, with all pods in a Running state. Installing cert-manager \u00b6 There are no special requirements to note when installing cert-manager on EKS, so the regular running on Kubernetes guides can be used to install cert-manager. Please walk through the installation guide and return to this step once you have validated cert-manager is deployed correctly. Installing ingress-nginx \u00b6 A Kubernetes ingress controller is designed to be the access point for HTTP and HTTPS traffic to the software running within your cluster. The ingress-nginx controller does this by providing an HTTP proxy service supported by your cloud provider's load balancer (in this case, a Network Load Balancer (NLB) . You can get more details about ingress-nginx and how it works from the documentation for ingress-nginx . To deploy ingress-nginx using an ELB to expose the service, run the following: Deploy the AWS specific prerequisite manifest $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.4.0/deploy/static/provider/aws/deploy.yaml Deploy the 'generic' ingress-nginx manifest $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/aws/deploy.yaml You may have to wait up to 5 minutes for all the required components in your cluster and AWS account to become ready. You can run the following command to determine the address that Amazon has assigned to your NLB: $ kubectl get service -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE ingress-nginx LoadBalancer 10 .100.52.175 a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com 80 :31649/TCP,443:30567/TCP 4m10s The EXTERNAL-IP field may say <pending> for a while. This indicates the NLB is still being created. Retry the command until an EXTERNAL-IP has been provisioned. Once the EXTERNAL-IP is available, you should run the following command to verify that traffic is being correctly routed to ingress-nginx : $ curl http://a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com/ <html> <head><title>404 Not Found</title></head> <body> <center><h1>404 Not Found</h1></center> <hr><center>openresty/1.15.8.1</center> </body> </html> Whilst the above message would normally indicate an error (the page not being found), in this instance it indicates that traffic is being correctly routed to the ingress-nginx service. Note: Although the AWS Application Load Balancer (ALB) is a modern load balancer offered by AWS that can can be provisioned from within EKS, at the time of writing, the alb-ingress-controller is only capable of serving sites using certificates stored in AWS Certificate Manager (ACM). Version 1.15 of Kubernetes should address multiple bug fixes for this controller and allow for TLS termination support. Configure your DNS records \u00b6 Now that our NLB has been provisioned, we should point our application's DNS records at the NLBs address. Go into your DNS provider's console and set a CNAME record pointing to your NLB. For the purposes of demonstration, we will assume in this guide you have created the following DNS entry: example.com CNAME a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com As you progress through the rest of this tutorial, please replace example.com with your own registered domain. Deploying a demo application \u00b6 For the purposes of this demo, we provide an example deployment which is a simple \"hello world\" website. First, create a new namespace that will contain your application: $ kubectl create namespace demo namespace/demo created Save the following YAML into a file named demo-deployment.yaml : apiVersion : v1 kind : Service metadata : name : hello-kubernetes namespace : demo spec : type : ClusterIP ports : - port : 80 targetPort : 8080 selector : app : hello-kubernetes --- apiVersion : apps/v1 kind : Deployment metadata : name : hello-kubernetes namespace : demo spec : replicas : 2 selector : matchLabels : app : hello-kubernetes template : metadata : labels : app : hello-kubernetes spec : containers : - name : hello-kubernetes image : paulbouwer/hello-kubernetes:1.5 resources : requests : cpu : 100m memory : 100Mi ports : - containerPort : 8080 Then run: kubectl apply -n demo -f demo-deployment.yaml Note that the Service resource we deploy is of type ClusterIP and not LoadBalancer , as we will expose and secure traffic for this service using ingress-nginx that we deployed earlier. You should be able to see two Pods and one Service in the demo namespace: kubectl get po,svc -n demo NAME READY STATUS RESTARTS AGE hello-kubernetes-66d45d6dff-m2lnr 1 /1 Running 0 7s hello-kubernetes-66d45d6dff-qt2kb 1 /1 Running 0 7s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE service/hello-kubernetes ClusterIP 10 .100.164.58 <none> 80 /TCP 7s Note that we have not yet exposed this application to be accessible over the internet. We will expose the demo application to the internet in later steps. Creating a Venafi Issuer resource \u00b6 cert-manager supports both Venafi TPP and Venafi Cloud. Please only follow one of the below sections according to where you want to retrieve your Certificates from. Venafi TPP \u00b6 Assuming you already have a Venafi TPP server set up properly, you can create a Venafi Issuer resource that can be used to issue certificates. To do this, you need to make sure you have your TPP username and password . In order for cert-manager to be able to authenticate with your Venafi TPP server and set up an Issuer resource, you'll need to create a Kubernetes Secret containing your username and password: $ kubectl create secret generic \\ venafi-tpp-secret \\ --namespace = demo \\ --from-literal = username = 'YOUR_TPP_USERNAME_HERE' \\ --from-literal = password = 'YOUR_TPP_PASSWORD_HERE' We must then create a Venafi Issuer resource, which represents a certificate authority within Kubernetes. Save the following YAML into a file named venafi-issuer.yaml : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : venafi-issuer namespace : demo spec : venafi : zone : \"Default\" # Set this to the Venafi policy zone you want to use tpp : url : https://venafi-tpp.example.com/vedsdk # Change this to the URL of your TPP instance caBundle : <base64 encoded string of caBundle PEM file, or empty to use system root CAs> credentialsRef : name : venafi-tpp-secret Then run: $ kubectl apply -n demo -f venafi-issuer.yaml When you run the following command, you should see that the Status stanza of the output shows that the Issuer is Ready (i.e. has successfully validated itself with the Venafi TPP server). $ kubectl describe issuer -n demo venafi-issuer Status: Conditions: Last Transition Time: 2019 -07-17T15:46:00Z Message: Venafi issuer started Reason: Venafi issuer started Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 14s cert-manager Verified issuer with Venafi server Venafi Cloud \u00b6 You can sign up for a Venafi Cloud account by visiting the enrollment page . Once registered, you should fetch your API key by clicking your name in the top right of the control panel interface. In order for cert-manager to be able to authenticate with your Venafi Cloud account and set up an Issuer resource, you'll need to create a Kubernetes Secret containing your API key: $ kubectl create secret generic \\ venafi-cloud-secret \\ --namespace = demo \\ --from-literal = apikey = <API_KEY> We must then create a Venafi Issuer resource, which represents a certificate authority within Kubernetes. Save the following YAML into a file named venafi-issuer.yaml : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : venafi-issuer namespace : demo spec : venafi : zone : \"Default\" # Set this to the Venafi policy zone you want to use cloud : apiTokenSecretRef : name : venafi-cloud-secret key : apikey Then run: $ kubectl apply -n demo -f venafi-issuer.yaml When you run the following command, you should see that the Status stanza of the output shows that the Issuer is Ready (i.e. has successfully validated itself with the Venafi Cloud service). $ kubectl describe issuer -n demo venafi-issuer ... Status: Conditions: Last Transition Time: 2019 -07-17T15:46:00Z Message: Venafi issuer started Reason: Venafi issuer started Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 14s cert-manager Verified issuer with Venafi server Request a Certificate \u00b6 Now that the Issuer is configured and we have confirmed it has been set up correctly, we can begin requesting certificates which can be used by Kubernetes applications. Full information on how to specify and request Certificate resources can be found in the Issuing certificates guide. For now, we will create a basic X.509 Certificate that is valid for our domain, example.com : apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls namespace : demo spec : secretName : example-com-tls dnsNames : - example.com commonName : example.com issuerRef : name : venafi-issuer Save this YAML into a file named example-com-tls.yaml and run: $ kubectl apply -n demo -f example-com-tls.yaml As long as you've ensured that the zone of your Venafi Cloud account (in our example, we use the \"Default\" zone) has been configured with a CA or contains a custom certificate, cert-manager can now take steps to populate the example-com-tls Secret with a certificate. It does this by identifying itself with Venafi Cloud using the API key, then requesting a certificate to match the specifications of the Certificate resource that we've created. You can run kubectl describe to check the progress of your Certificate: $ kubectl describe certificate -n demo example-com-tls ... Status: Conditions: Last Transition Time: 2019 -07-17T17:43:01Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -10-15T12:00:00Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 33s cert-manager Requesting new certificate... Normal GenerateKey 33s cert-manager Generated new private key Normal Validate 33s cert-manager Validated certificate request against Venafi zone policy Normal Requesting 33s cert-manager Requesting certificate from Venafi server... Normal Retrieve 15s cert-manager Retrieved certificate from Venafi server Normal CertIssued 15s cert-manager Certificate issued successfully Once the Certificate has been issued, you should see events similar to above. You should then be able to see the certificate has been successfully stored in the Secret resource: $ kubectl get secret -n demo example-com-tls NAME TYPE DATA AGE example-com-tls kubernetes.io/tls 3 2m47s $ kubectl get secret example-com-tls -o 'go-template={{index .data \"tls.crt\"}}' | \\ base64 --decode | \\ openssl x509 -noout -text Certificate: Data: Version: 3 ( 0x2 ) Serial Number: 0d:ce:bf:89:04:d4:41:83:f4:4c:32:66:64:fb:60:14 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = DigiCert Inc, CN = DigiCert Test SHA2 Intermediate CA-1 Validity Not Before: Jul 17 00 :00:00 2019 GMT Not After : Oct 15 12 :00:00 2019 GMT Subject: C = US, ST = California, L = Palo Alto, O = Venafi Cloud, OU = SerialNumber, CN = example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: ( 2048 bit ) Modulus: 00 :ad:2e:66:02:20:c9:b1:6a:00:63:70:4e:22:3c: 45 :63:6e:e7:fd:4c:94:7d:75:50:22:a2:01:72:99: 9c:23:04:90:51:85:4d:47:32:e4:8b:ee:b1:ea:09: 1a:de:97:5d:31:05:a2:73:73:4f:06:a3:b2:59:ee: bc:30:f7:26:85:3d:b3:56:e4:c2:97:34:b6:ac:6d: 65 :7e:a2:4e:b4:ce:f2:0a:0a:4c:d7:32:d7:5a:18: e8:69:c6:34:28:26:36:ef:c5:bc:ae:ba:ca:d2:46: 3f:d4:61:39:66:8f:19:cc:d6:d6:10:77:af:51:93: 1b:4d:f8:d1:10:19:ab:ac:b3:7b:0b:98:58:29:e6: a9:ac:9f:7a:dc:63:0d:51:f5:bd:9f:f3:03:2e:b3: 2d:2f:00:87:f4:e1:cd:5a:32:c6:d8:fb:49:c4:e7: da:3f:0f:8f:bb:66:94:28:5d:99:fe:7c:f0:17:1b: fd:3e:ed:dd:36:bf:8e:62:60:0c:85:7f:76:74:4b: 37 :d9:c2:e8:74:49:04:bf:f1:83:81:cc:4f:9b:f3: 40 :97:d4:dc:b6:d3:2d:dc:73:18:93:48:a5:8f:6c: 57 :7f:ec:62:c0:bc:c2:b0:e9:0a:51:2d:c4:b6:87: 68 :96:87:f8:9a:86:3c:6a:f1:01:ca:57:c4:07:e7: b0:51 Exponent: 65537 ( 0x10001 ) X509v3 extensions: X509v3 Authority Key Identifier: keyid:D6:4D:F9:39:60:6C:73:C3:22:F5:AD:30:0C:2F:A0:D5:CA:75:4A:2A X509v3 Subject Key Identifier: A3:B3:47:2C:41:5E:9C:B2:27:97:57:14:A4:2E:BA:8C:93:E7:01:65 X509v3 Subject Alternative Name: DNS:example.com X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 CRL Distribution Points: Full Name: URI:http://crl3.digicert.com/DigiCertTestSHA2IntermediateCA1.crl Full Name: URI:http://crl4.digicert.com/DigiCertTestSHA2IntermediateCA1.crl X509v3 Certificate Policies: Policy: 2 .16.840.1.114412.1.1 CPS: https://www.digicert.com/CPS Authority Information Access: OCSP - URI:http://ocsp.digicert.com CA Issuers - URI:http://cacerts.test.digicert.com/DigiCertTestSHA2IntermediateCA1.crt X509v3 Basic Constraints: critical CA:FALSE Signature Algorithm: sha256WithRSAEncryption ae:d4:9c:8a:66:19:9e:7d:12:b7:05:c2:b6:33:b3:9c:a5:40: 47 :ab:34:8d:1b:0f:51:96:de:e9:46:5a:e4:16:10:43:56:bf: fa:f8:64:f4:cb:53:39:5b:45:ca:7f:15:d9:59:25:21:23:c4: 4d:dc:a7:f7:83:21:d2:3f:a8:0a:26:f4:ef:fa:1b:2b:7d:97: 7e:28:f3:ca:cd:b2:c4:92:f3:92:27:7f:e0:f1:ac:d6:db:4c: 10 :8a:f8:6f:09:bb:b3:4f:19:06:aa:bb:74:1c:e0:51:42:f6: 8c:7d:77:f7:80:a4:03:ab:a9:ae:ae:2b:89:17:af:2f:eb:f7: 3d:61:7c:dd:e1:5d:d2:5a:c5:6a:f6:c8:92:4c:0a:b5:75:d1: dd:39:f2:a7:a2:10:8c:6d:bf:ca:08:ad:b9:a9:df:e3:59:8f: 64 :16:3c:7e:8a:6e:27:fc:49:d7:06:f0:bd:94:15:f2:fd:0f: 94 :8a:b8:73:67:73:53:22:df:9d:36:e9:34:f9:2a:68:00:59: 78 :6d:2d:8f:a0:0f:13:af:bd:b3:aa:8c:37:c4:22:cf:23:fb: 56 :bc:4e:55:ae:3a:0a:e6:3e:b1:1a:22:71:7b:08:b8:00:41: 14 :26:f6:9b:9b:72:3f:eb:dc:dd:1b:db:a8:20:fd:54:75:ae: 25 :7f:80:e6 In the next step, we'll configure your application to actually use this new Certificate resource. Exposing and securing your application \u00b6 Now that we have issued a Certificate, we can expose our application using a Kubernetes Ingress resource. Create a file named application-ingress.yaml and save the following in it, replacing example.com with your own domain name: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : frontend-ingress namespace : demo annotations : kubernetes.io/ingress.class : \"nginx\" spec : tls : - hosts : - example.com secretName : example-com-tls rules : - host : example.com http : paths : - path : / pathType : Exact backend : service : name : kuard port : number : 80 You can then apply this resource with: $ kubectl apply -n demo -f application-ingress.yaml Once this has been created, you should be able to visit your application at the configured URL, here example.com ! Navigate to the address in your web browser and you should see the certificate obtained via Venafi being used to secure application traffic.","title":"Securing Ingresses with Venafi"},{"location":"tutorials/venafi/venafi/#prerequisites","text":"An AWS account kubectl installed Access to a publicly registered DNS zone A Venafi Cloud account and API credentials","title":"Prerequisites"},{"location":"tutorials/venafi/venafi/#create-an-eks-cluster","text":"If you already have a running EKS cluster you can skip this step and move onto deploying cert-manager. eksctl is a tool that makes it easier to deploy and manage an EKS cluster. Installation instructions for various platforms can be found in the eksctl installation instructions . Once installed, you can create a basic cluster by running: $ eksctl create cluster This process may take up to 20 minutes to complete. Complete instructions on using eksctl can be found in the eksctl usage section . Once your cluster has been created, you should verify that your cluster is running correctly by running the following command: $ kubectl get pods --all-namespaces NAME READY STATUS RESTARTS AGE aws-node-8xpkp 1/1 Running 0 115s aws-node-tflxs 1/1 Running 0 118s coredns-694d9447b-66vlp 1/1 Running 0 23s coredns-694d9447b-w5bg8 1/1 Running 0 23s kube-proxy-4dvpj 1/1 Running 0 115s kube-proxy-tpvht 1/1 Running 0 118s You should see output similar to the above, with all pods in a Running state.","title":"Create an EKS cluster"},{"location":"tutorials/venafi/venafi/#installing-cert-manager","text":"There are no special requirements to note when installing cert-manager on EKS, so the regular running on Kubernetes guides can be used to install cert-manager. Please walk through the installation guide and return to this step once you have validated cert-manager is deployed correctly.","title":"Installing cert-manager"},{"location":"tutorials/venafi/venafi/#installing-ingress-nginx","text":"A Kubernetes ingress controller is designed to be the access point for HTTP and HTTPS traffic to the software running within your cluster. The ingress-nginx controller does this by providing an HTTP proxy service supported by your cloud provider's load balancer (in this case, a Network Load Balancer (NLB) . You can get more details about ingress-nginx and how it works from the documentation for ingress-nginx . To deploy ingress-nginx using an ELB to expose the service, run the following: Deploy the AWS specific prerequisite manifest $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.4.0/deploy/static/provider/aws/deploy.yaml Deploy the 'generic' ingress-nginx manifest $ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/aws/deploy.yaml You may have to wait up to 5 minutes for all the required components in your cluster and AWS account to become ready. You can run the following command to determine the address that Amazon has assigned to your NLB: $ kubectl get service -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE ingress-nginx LoadBalancer 10 .100.52.175 a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com 80 :31649/TCP,443:30567/TCP 4m10s The EXTERNAL-IP field may say <pending> for a while. This indicates the NLB is still being created. Retry the command until an EXTERNAL-IP has been provisioned. Once the EXTERNAL-IP is available, you should run the following command to verify that traffic is being correctly routed to ingress-nginx : $ curl http://a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com/ <html> <head><title>404 Not Found</title></head> <body> <center><h1>404 Not Found</h1></center> <hr><center>openresty/1.15.8.1</center> </body> </html> Whilst the above message would normally indicate an error (the page not being found), in this instance it indicates that traffic is being correctly routed to the ingress-nginx service. Note: Although the AWS Application Load Balancer (ALB) is a modern load balancer offered by AWS that can can be provisioned from within EKS, at the time of writing, the alb-ingress-controller is only capable of serving sites using certificates stored in AWS Certificate Manager (ACM). Version 1.15 of Kubernetes should address multiple bug fixes for this controller and allow for TLS termination support.","title":"Installing ingress-nginx"},{"location":"tutorials/venafi/venafi/#configure-your-dns-records","text":"Now that our NLB has been provisioned, we should point our application's DNS records at the NLBs address. Go into your DNS provider's console and set a CNAME record pointing to your NLB. For the purposes of demonstration, we will assume in this guide you have created the following DNS entry: example.com CNAME a8c2870a5a8a311e9a9a10a2e7af57d7-6c2ec8ede48726ab.elb.eu-west-1.amazonaws.com As you progress through the rest of this tutorial, please replace example.com with your own registered domain.","title":"Configure your DNS records"},{"location":"tutorials/venafi/venafi/#deploying-a-demo-application","text":"For the purposes of this demo, we provide an example deployment which is a simple \"hello world\" website. First, create a new namespace that will contain your application: $ kubectl create namespace demo namespace/demo created Save the following YAML into a file named demo-deployment.yaml : apiVersion : v1 kind : Service metadata : name : hello-kubernetes namespace : demo spec : type : ClusterIP ports : - port : 80 targetPort : 8080 selector : app : hello-kubernetes --- apiVersion : apps/v1 kind : Deployment metadata : name : hello-kubernetes namespace : demo spec : replicas : 2 selector : matchLabels : app : hello-kubernetes template : metadata : labels : app : hello-kubernetes spec : containers : - name : hello-kubernetes image : paulbouwer/hello-kubernetes:1.5 resources : requests : cpu : 100m memory : 100Mi ports : - containerPort : 8080 Then run: kubectl apply -n demo -f demo-deployment.yaml Note that the Service resource we deploy is of type ClusterIP and not LoadBalancer , as we will expose and secure traffic for this service using ingress-nginx that we deployed earlier. You should be able to see two Pods and one Service in the demo namespace: kubectl get po,svc -n demo NAME READY STATUS RESTARTS AGE hello-kubernetes-66d45d6dff-m2lnr 1 /1 Running 0 7s hello-kubernetes-66d45d6dff-qt2kb 1 /1 Running 0 7s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE service/hello-kubernetes ClusterIP 10 .100.164.58 <none> 80 /TCP 7s Note that we have not yet exposed this application to be accessible over the internet. We will expose the demo application to the internet in later steps.","title":"Deploying a demo application"},{"location":"tutorials/venafi/venafi/#creating-a-venafi-issuer-resource","text":"cert-manager supports both Venafi TPP and Venafi Cloud. Please only follow one of the below sections according to where you want to retrieve your Certificates from.","title":"Creating a Venafi Issuer resource"},{"location":"tutorials/venafi/venafi/#venafi-tpp","text":"Assuming you already have a Venafi TPP server set up properly, you can create a Venafi Issuer resource that can be used to issue certificates. To do this, you need to make sure you have your TPP username and password . In order for cert-manager to be able to authenticate with your Venafi TPP server and set up an Issuer resource, you'll need to create a Kubernetes Secret containing your username and password: $ kubectl create secret generic \\ venafi-tpp-secret \\ --namespace = demo \\ --from-literal = username = 'YOUR_TPP_USERNAME_HERE' \\ --from-literal = password = 'YOUR_TPP_PASSWORD_HERE' We must then create a Venafi Issuer resource, which represents a certificate authority within Kubernetes. Save the following YAML into a file named venafi-issuer.yaml : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : venafi-issuer namespace : demo spec : venafi : zone : \"Default\" # Set this to the Venafi policy zone you want to use tpp : url : https://venafi-tpp.example.com/vedsdk # Change this to the URL of your TPP instance caBundle : <base64 encoded string of caBundle PEM file, or empty to use system root CAs> credentialsRef : name : venafi-tpp-secret Then run: $ kubectl apply -n demo -f venafi-issuer.yaml When you run the following command, you should see that the Status stanza of the output shows that the Issuer is Ready (i.e. has successfully validated itself with the Venafi TPP server). $ kubectl describe issuer -n demo venafi-issuer Status: Conditions: Last Transition Time: 2019 -07-17T15:46:00Z Message: Venafi issuer started Reason: Venafi issuer started Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 14s cert-manager Verified issuer with Venafi server","title":"Venafi TPP"},{"location":"tutorials/venafi/venafi/#venafi-cloud","text":"You can sign up for a Venafi Cloud account by visiting the enrollment page . Once registered, you should fetch your API key by clicking your name in the top right of the control panel interface. In order for cert-manager to be able to authenticate with your Venafi Cloud account and set up an Issuer resource, you'll need to create a Kubernetes Secret containing your API key: $ kubectl create secret generic \\ venafi-cloud-secret \\ --namespace = demo \\ --from-literal = apikey = <API_KEY> We must then create a Venafi Issuer resource, which represents a certificate authority within Kubernetes. Save the following YAML into a file named venafi-issuer.yaml : apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : venafi-issuer namespace : demo spec : venafi : zone : \"Default\" # Set this to the Venafi policy zone you want to use cloud : apiTokenSecretRef : name : venafi-cloud-secret key : apikey Then run: $ kubectl apply -n demo -f venafi-issuer.yaml When you run the following command, you should see that the Status stanza of the output shows that the Issuer is Ready (i.e. has successfully validated itself with the Venafi Cloud service). $ kubectl describe issuer -n demo venafi-issuer ... Status: Conditions: Last Transition Time: 2019 -07-17T15:46:00Z Message: Venafi issuer started Reason: Venafi issuer started Status: True Type: Ready Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Ready 14s cert-manager Verified issuer with Venafi server","title":"Venafi Cloud"},{"location":"tutorials/venafi/venafi/#request-a-certificate","text":"Now that the Issuer is configured and we have confirmed it has been set up correctly, we can begin requesting certificates which can be used by Kubernetes applications. Full information on how to specify and request Certificate resources can be found in the Issuing certificates guide. For now, we will create a basic X.509 Certificate that is valid for our domain, example.com : apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls namespace : demo spec : secretName : example-com-tls dnsNames : - example.com commonName : example.com issuerRef : name : venafi-issuer Save this YAML into a file named example-com-tls.yaml and run: $ kubectl apply -n demo -f example-com-tls.yaml As long as you've ensured that the zone of your Venafi Cloud account (in our example, we use the \"Default\" zone) has been configured with a CA or contains a custom certificate, cert-manager can now take steps to populate the example-com-tls Secret with a certificate. It does this by identifying itself with Venafi Cloud using the API key, then requesting a certificate to match the specifications of the Certificate resource that we've created. You can run kubectl describe to check the progress of your Certificate: $ kubectl describe certificate -n demo example-com-tls ... Status: Conditions: Last Transition Time: 2019 -07-17T17:43:01Z Message: Certificate is up to date and has not expired Reason: Ready Status: True Type: Ready Not After: 2019 -10-15T12:00:00Z Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Issuing 33s cert-manager Requesting new certificate... Normal GenerateKey 33s cert-manager Generated new private key Normal Validate 33s cert-manager Validated certificate request against Venafi zone policy Normal Requesting 33s cert-manager Requesting certificate from Venafi server... Normal Retrieve 15s cert-manager Retrieved certificate from Venafi server Normal CertIssued 15s cert-manager Certificate issued successfully Once the Certificate has been issued, you should see events similar to above. You should then be able to see the certificate has been successfully stored in the Secret resource: $ kubectl get secret -n demo example-com-tls NAME TYPE DATA AGE example-com-tls kubernetes.io/tls 3 2m47s $ kubectl get secret example-com-tls -o 'go-template={{index .data \"tls.crt\"}}' | \\ base64 --decode | \\ openssl x509 -noout -text Certificate: Data: Version: 3 ( 0x2 ) Serial Number: 0d:ce:bf:89:04:d4:41:83:f4:4c:32:66:64:fb:60:14 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = DigiCert Inc, CN = DigiCert Test SHA2 Intermediate CA-1 Validity Not Before: Jul 17 00 :00:00 2019 GMT Not After : Oct 15 12 :00:00 2019 GMT Subject: C = US, ST = California, L = Palo Alto, O = Venafi Cloud, OU = SerialNumber, CN = example.com Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: ( 2048 bit ) Modulus: 00 :ad:2e:66:02:20:c9:b1:6a:00:63:70:4e:22:3c: 45 :63:6e:e7:fd:4c:94:7d:75:50:22:a2:01:72:99: 9c:23:04:90:51:85:4d:47:32:e4:8b:ee:b1:ea:09: 1a:de:97:5d:31:05:a2:73:73:4f:06:a3:b2:59:ee: bc:30:f7:26:85:3d:b3:56:e4:c2:97:34:b6:ac:6d: 65 :7e:a2:4e:b4:ce:f2:0a:0a:4c:d7:32:d7:5a:18: e8:69:c6:34:28:26:36:ef:c5:bc:ae:ba:ca:d2:46: 3f:d4:61:39:66:8f:19:cc:d6:d6:10:77:af:51:93: 1b:4d:f8:d1:10:19:ab:ac:b3:7b:0b:98:58:29:e6: a9:ac:9f:7a:dc:63:0d:51:f5:bd:9f:f3:03:2e:b3: 2d:2f:00:87:f4:e1:cd:5a:32:c6:d8:fb:49:c4:e7: da:3f:0f:8f:bb:66:94:28:5d:99:fe:7c:f0:17:1b: fd:3e:ed:dd:36:bf:8e:62:60:0c:85:7f:76:74:4b: 37 :d9:c2:e8:74:49:04:bf:f1:83:81:cc:4f:9b:f3: 40 :97:d4:dc:b6:d3:2d:dc:73:18:93:48:a5:8f:6c: 57 :7f:ec:62:c0:bc:c2:b0:e9:0a:51:2d:c4:b6:87: 68 :96:87:f8:9a:86:3c:6a:f1:01:ca:57:c4:07:e7: b0:51 Exponent: 65537 ( 0x10001 ) X509v3 extensions: X509v3 Authority Key Identifier: keyid:D6:4D:F9:39:60:6C:73:C3:22:F5:AD:30:0C:2F:A0:D5:CA:75:4A:2A X509v3 Subject Key Identifier: A3:B3:47:2C:41:5E:9C:B2:27:97:57:14:A4:2E:BA:8C:93:E7:01:65 X509v3 Subject Alternative Name: DNS:example.com X509v3 Key Usage: critical Digital Signature, Key Encipherment X509v3 Extended Key Usage: TLS Web Server Authentication, TLS Web Client Authentication X509v3 CRL Distribution Points: Full Name: URI:http://crl3.digicert.com/DigiCertTestSHA2IntermediateCA1.crl Full Name: URI:http://crl4.digicert.com/DigiCertTestSHA2IntermediateCA1.crl X509v3 Certificate Policies: Policy: 2 .16.840.1.114412.1.1 CPS: https://www.digicert.com/CPS Authority Information Access: OCSP - URI:http://ocsp.digicert.com CA Issuers - URI:http://cacerts.test.digicert.com/DigiCertTestSHA2IntermediateCA1.crt X509v3 Basic Constraints: critical CA:FALSE Signature Algorithm: sha256WithRSAEncryption ae:d4:9c:8a:66:19:9e:7d:12:b7:05:c2:b6:33:b3:9c:a5:40: 47 :ab:34:8d:1b:0f:51:96:de:e9:46:5a:e4:16:10:43:56:bf: fa:f8:64:f4:cb:53:39:5b:45:ca:7f:15:d9:59:25:21:23:c4: 4d:dc:a7:f7:83:21:d2:3f:a8:0a:26:f4:ef:fa:1b:2b:7d:97: 7e:28:f3:ca:cd:b2:c4:92:f3:92:27:7f:e0:f1:ac:d6:db:4c: 10 :8a:f8:6f:09:bb:b3:4f:19:06:aa:bb:74:1c:e0:51:42:f6: 8c:7d:77:f7:80:a4:03:ab:a9:ae:ae:2b:89:17:af:2f:eb:f7: 3d:61:7c:dd:e1:5d:d2:5a:c5:6a:f6:c8:92:4c:0a:b5:75:d1: dd:39:f2:a7:a2:10:8c:6d:bf:ca:08:ad:b9:a9:df:e3:59:8f: 64 :16:3c:7e:8a:6e:27:fc:49:d7:06:f0:bd:94:15:f2:fd:0f: 94 :8a:b8:73:67:73:53:22:df:9d:36:e9:34:f9:2a:68:00:59: 78 :6d:2d:8f:a0:0f:13:af:bd:b3:aa:8c:37:c4:22:cf:23:fb: 56 :bc:4e:55:ae:3a:0a:e6:3e:b1:1a:22:71:7b:08:b8:00:41: 14 :26:f6:9b:9b:72:3f:eb:dc:dd:1b:db:a8:20:fd:54:75:ae: 25 :7f:80:e6 In the next step, we'll configure your application to actually use this new Certificate resource.","title":"Request a Certificate"},{"location":"tutorials/venafi/venafi/#exposing-and-securing-your-application","text":"Now that we have issued a Certificate, we can expose our application using a Kubernetes Ingress resource. Create a file named application-ingress.yaml and save the following in it, replacing example.com with your own domain name: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : frontend-ingress namespace : demo annotations : kubernetes.io/ingress.class : \"nginx\" spec : tls : - hosts : - example.com secretName : example-com-tls rules : - host : example.com http : paths : - path : / pathType : Exact backend : service : name : kuard port : number : 80 You can then apply this resource with: $ kubectl apply -n demo -f application-ingress.yaml Once this has been created, you should be able to visit your application at the configured URL, here example.com ! Navigate to the address in your web browser and you should see the certificate obtained via Venafi being used to secure application traffic.","title":"Exposing and securing your application"},{"location":"tutorials/zerossl/zerossl/","text":"The ZeroSSL \u00b6 This guide walks you through how to secure a Kubernetes Ingress resource using the ZeroSSL Issuer type. The ZeroSSL just like Let's Encrypt and its competitors allows to create free 90 days certificates. All is need is to create account at https://zerossl.com/ . After that go to developer section and generate EAB Credentials for ACME Clients . You will need it later. Please note! \\ EAB credentials are not stored in your account, please make sure to note them somewhere. Each click on \"Generate\" will create a new set of credentials. Even if you create multiple credentials, all of them will remain functional. Please note! \\ EAB credentials are one-use only. Create additional pair for different environments. Prerequisites \u00b6 An AWS account kubectl installed Access to a publicly registered DNS zone Kubernetes cluster, you can use AWS EKS ingress-nginx deployed and working inside cluster Tutorial scenario: \u00b6 Installing cert-manager \u00b6 Make sure you use cert-manager 1.8.2+ / 1.7.3+ . See link for more details. Please walk through the installation guide and return to this step once you have validated cert-manager is deployed correctly. Follow steps under running on Kubernetes to install in k8s. In order to automatically switch to the ZeroSSL we recommend setting default shim by adding the following configuration to values file. ingressShim : defaultIssuerName : \"zerossl-production\" defaultIssuerKind : \"ClusterIssuer\" installCRDs : true Install it using helm: helm upgrade --install --namespace cert-manager --version v1.8.2 cert-manager jetstack/cert-manager -f values.yaml Configure your DNS records \u00b6 The best way to manage DNS using AWS is by using Route53. Create AWS account with permissions to modify Route53 rules. EAB secret \u00b6 Once you will get your credentials first step is to create seed with secrets. They are responsible for authenticating with your ZeroSSL account. $ kubectl create secret generic \\ zero-ssl-eabsecret \\ --namespace = cert-manager \\ --from-literal = secret = 'YOUR_ZEROSSL_EAB_SECRET' Another way of creating secret. \u00b6 Encode it in base64 first. echo -n \"YOUR_ZEROSSL_EAB_SECRET\" | base64 -w 0 apiVersion : v1 kind : Secret metadata : name : zero-ssl-eabsecret data : secret : YOUR_ENCODED_ZEROSSL_EAB_SECRET kubectl apply -f zero-ssl-eabsecret.yaml -n cert-manager Cluster issuer \u00b6 Then we must create the ZeroSSL ClusterIssuer , let's call it zerossl-production . In our case we are using AWS. See pre-conditions to provision all required elements. apiVersion : cert-manager.io/v1alpha2 kind : ClusterIssuer metadata : name : zerossl-production spec : acme : # ZeroSSL ACME server server : https://acme.zerossl.com/v2/DV90 email : dummy-email@yopmail.com # name of a secret used to store the ACME account private key privateKeySecretRef : name : zerossl-prod # for each cert-manager new EAB credencials are required externalAccountBinding : keyID : ZEROSSL_KEY_ID keySecretRef : name : zero-ssl-eabsecret key : secret keyAlgorithm : HS256 # ACME DNS-01 provider configurations to verify domain solvers : - selector : {} dns01 : route53 : region : us-west-2 # optional if ambient credentials are available; see ambient credentials documentation # see Route53 for >0 issue \"letsencrypt.org\" and change to >0 issue \"sectigo.com\" accessKeyID : ACCESS_KEY_ID secretAccessKeySecretRef : name : route53-credentials-secret key : secret-access-key Then run: \u00b6 $ kubectl apply -n cert-manager -f zerossl-production.yaml $ kubectl describe Clusterissuer zerossl-prod Status: Acme: Last Registered Email: dummy-email@yopmail.com Uri: https://acme.zerossl.com/v2/DV90/account/tXXX_NwSv15rlS_XXXX Conditions: Last Transition Time: 2021 -09-09T17:03:26Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready Please note! \u00b6 If this step failed and the ACME account is not registered please check if secrets in zero-ssl-eabsecret are correct. Request a ingress certificate \u00b6 apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : test-ingress namespace : default spec : rules : - host : test.example.com tls : - secretName : secret-tls Apply test-ingress: kubectl apply -f ingress.yaml You are set! Check your ingress. kubectl describe ingress test-ingress -n default # check if tls is terminated using secret-tls openssl s_client -showcerts -connect test.example.com:443 # verify server certificate and its chain","title":"Securing Ingresses with ZeroSSL"},{"location":"tutorials/zerossl/zerossl/#the-zerossl","text":"This guide walks you through how to secure a Kubernetes Ingress resource using the ZeroSSL Issuer type. The ZeroSSL just like Let's Encrypt and its competitors allows to create free 90 days certificates. All is need is to create account at https://zerossl.com/ . After that go to developer section and generate EAB Credentials for ACME Clients . You will need it later. Please note! \\ EAB credentials are not stored in your account, please make sure to note them somewhere. Each click on \"Generate\" will create a new set of credentials. Even if you create multiple credentials, all of them will remain functional. Please note! \\ EAB credentials are one-use only. Create additional pair for different environments.","title":"The ZeroSSL"},{"location":"tutorials/zerossl/zerossl/#prerequisites","text":"An AWS account kubectl installed Access to a publicly registered DNS zone Kubernetes cluster, you can use AWS EKS ingress-nginx deployed and working inside cluster","title":"Prerequisites"},{"location":"tutorials/zerossl/zerossl/#tutorial-scenario","text":"","title":"Tutorial scenario:"},{"location":"tutorials/zerossl/zerossl/#installing-cert-manager","text":"Make sure you use cert-manager 1.8.2+ / 1.7.3+ . See link for more details. Please walk through the installation guide and return to this step once you have validated cert-manager is deployed correctly. Follow steps under running on Kubernetes to install in k8s. In order to automatically switch to the ZeroSSL we recommend setting default shim by adding the following configuration to values file. ingressShim : defaultIssuerName : \"zerossl-production\" defaultIssuerKind : \"ClusterIssuer\" installCRDs : true Install it using helm: helm upgrade --install --namespace cert-manager --version v1.8.2 cert-manager jetstack/cert-manager -f values.yaml","title":"Installing cert-manager"},{"location":"tutorials/zerossl/zerossl/#configure-your-dns-records","text":"The best way to manage DNS using AWS is by using Route53. Create AWS account with permissions to modify Route53 rules.","title":"Configure your DNS records"},{"location":"tutorials/zerossl/zerossl/#eab-secret","text":"Once you will get your credentials first step is to create seed with secrets. They are responsible for authenticating with your ZeroSSL account. $ kubectl create secret generic \\ zero-ssl-eabsecret \\ --namespace = cert-manager \\ --from-literal = secret = 'YOUR_ZEROSSL_EAB_SECRET'","title":"EAB secret"},{"location":"tutorials/zerossl/zerossl/#another-way-of-creating-secret","text":"Encode it in base64 first. echo -n \"YOUR_ZEROSSL_EAB_SECRET\" | base64 -w 0 apiVersion : v1 kind : Secret metadata : name : zero-ssl-eabsecret data : secret : YOUR_ENCODED_ZEROSSL_EAB_SECRET kubectl apply -f zero-ssl-eabsecret.yaml -n cert-manager","title":"Another way of creating secret."},{"location":"tutorials/zerossl/zerossl/#cluster-issuer","text":"Then we must create the ZeroSSL ClusterIssuer , let's call it zerossl-production . In our case we are using AWS. See pre-conditions to provision all required elements. apiVersion : cert-manager.io/v1alpha2 kind : ClusterIssuer metadata : name : zerossl-production spec : acme : # ZeroSSL ACME server server : https://acme.zerossl.com/v2/DV90 email : dummy-email@yopmail.com # name of a secret used to store the ACME account private key privateKeySecretRef : name : zerossl-prod # for each cert-manager new EAB credencials are required externalAccountBinding : keyID : ZEROSSL_KEY_ID keySecretRef : name : zero-ssl-eabsecret key : secret keyAlgorithm : HS256 # ACME DNS-01 provider configurations to verify domain solvers : - selector : {} dns01 : route53 : region : us-west-2 # optional if ambient credentials are available; see ambient credentials documentation # see Route53 for >0 issue \"letsencrypt.org\" and change to >0 issue \"sectigo.com\" accessKeyID : ACCESS_KEY_ID secretAccessKeySecretRef : name : route53-credentials-secret key : secret-access-key","title":"Cluster issuer"},{"location":"tutorials/zerossl/zerossl/#then-run","text":"$ kubectl apply -n cert-manager -f zerossl-production.yaml $ kubectl describe Clusterissuer zerossl-prod Status: Acme: Last Registered Email: dummy-email@yopmail.com Uri: https://acme.zerossl.com/v2/DV90/account/tXXX_NwSv15rlS_XXXX Conditions: Last Transition Time: 2021 -09-09T17:03:26Z Message: The ACME account was registered with the ACME server Reason: ACMEAccountRegistered Status: True Type: Ready","title":"Then run:"},{"location":"tutorials/zerossl/zerossl/#please-note","text":"If this step failed and the ACME account is not registered please check if secrets in zero-ssl-eabsecret are correct.","title":"Please note!"},{"location":"tutorials/zerossl/zerossl/#request-a-ingress-certificate","text":"apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : test-ingress namespace : default spec : rules : - host : test.example.com tls : - secretName : secret-tls Apply test-ingress: kubectl apply -f ingress.yaml You are set! Check your ingress. kubectl describe ingress test-ingress -n default # check if tls is terminated using secret-tls openssl s_client -showcerts -connect test.example.com:443 # verify server certificate and its chain","title":"Request a ingress certificate"},{"location":"usage/","text":"Once an Issuer has been configured, you're ready to issue your first certificate! There are several use cases and methods for requesting certificates through cert-manager: Certificate Resources : The simplest and most common method for requesting signed certificates. Securing Ingress Resources : A method to secure ingress resources in your cluster. Securing OpenFaaS functions : Secure your OpenFaaS services using cert-manager. Integration with Garden : Garden is a developer tool for developing Kubernetes applications which has first class support for integrating cert-manager. Securing Knative : Secure your Knative services with trusted HTTPS certificates. Enable mTLS on Pods with CSI : Using the cert-manager CSI driver to provide unique keys and certificates that share the lifecycle of pods. Securing Istio Gateway : Secure your Istio Gateway in Kubernetes using cert-manager. Securing Istio Service Mesh : Using the cert-manager Istio integration, secure the mTLS PKI for each pod through cert-manager managed certificates. Policy for cert-manager certificates : Manage what cert-manager certificates are able to be signed or rejected through custom resource defined policy.","title":"\u4ecb\u7ecd"},{"location":"usage/approver-policy/","text":"cert-manager CertificateRequests can be rejected from being signed by using the approval API . approver-policy is a cert-manager project that enables you to write policy to automatically manage this approval mechanism. Please read the project page for more information on how to install and use approver-policy.","title":"Policy for cert-manager certificates"},{"location":"usage/certificate/","text":"In cert-manager, the Certificate resource represents a human readable definition of a certificate request that is to be honored by an issuer which is to be kept up-to-date. This is the usual way that you will interact with cert-manager to request signed certificates. In order to issue any certificates, you'll need to configure an Issuer or ClusterIssuer resource first. Creating Certificate Resources \u00b6 A Certificate resource specifies fields that are used to generate certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field. A Certificate resource, for the example.com and www.example.com DNS names, spiffe://cluster.local/ns/sandbox/sa/example URI Subject Alternative Name, that is valid for 90 days and renews 15 days before expiry is below. It contains an exhaustive list of all options a Certificate resource may have however only a subset of fields are required as labelled. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : sandbox spec : # Secret names are always required. secretName : example-com-tls # secretTemplate is optional. If set, these annotations and labels will be # copied to the Secret named example-com-tls. These labels and annotations will # be re-reconciled if the Certificate's secretTemplate changes. secretTemplate # is also enforced, so relevant label and annotation changes on the Secret by a # third party will be overwriten by cert-manager to match the secretTemplate. secretTemplate : annotations : my-secret-annotation-1 : \"foo\" my-secret-annotation-2 : \"bar\" labels : my-secret-label : foo duration : 2160h # 90d renewBefore : 360h # 15d subject : organizations : - jetstack # The use of the common name field has been deprecated since 2000 and is # discouraged from being used. commonName : example.com isCA : false privateKey : algorithm : RSA encoding : PKCS1 size : 2048 usages : - server auth - client auth # At least one of a DNS Name, URI, or IP address is required. dnsNames : - example.com - www.example.com uris : - spiffe://cluster.local/ns/sandbox/sa/example ipAddresses : - 192.168.0.5 # Issuer references are always required. issuerRef : name : ca-issuer # We can reference ClusterIssuers by changing the kind here. # The default value is Issuer (i.e. a locally namespaced Issuer) kind : Issuer # This is optional since cert-manager will default to this value however # if you are using an external issuer, change this to that issuer group. group : cert-manager.io The signed certificate will be stored in a Secret resource named example-com-tls in the same namespace as the Certificate once the issuer has successfully issued the requested certificate. If secretTemplate is present, annotations and labels set in this property will be copied over to example-com-tls secret. Both properties are optional. The Certificate will be issued using the issuer named ca-issuer in the sandbox namespace (the same namespace as the Certificate resource). Note: If you want to create an Issuer that can be referenced by Certificate resources in all namespaces, you should create a ClusterIssuer resource and set the certificate.spec.issuerRef.kind field to ClusterIssuer . Note: The renewBefore and duration fields must be specified using a Go time.Duration string format, which does not allow the d (days) suffix. You must specify these values using s , m , and h suffixes instead. Failing to do so without installing the webhook component can prevent cert-manager from functioning correctly #1269 . Note: Take care when setting the renewBefore field to be very close to the duration as this can lead to a renewal loop, where the Certificate is always in the renewal period. Some Issuers set the notBefore field on their issued X.509 certificates before the issue time to fix clock-skew issues, leading to the working duration of a certificate to be less than the full duration of the certificate. For example, Let's Encrypt sets it to be one hour before issue time, so the actual working duration of the certificate is 89 days, 23 hours (the full duration remains 90 days). A full list of the fields supported on the Certificate resource can be found in the API reference documentation . X.509 key usages and extended key usages cert-manager supports requesting certificates that have a number of custom key usages and extended key usages . Although cert-manager will attempt to honor this request, some issuers will remove, add defaults, or otherwise completely ignore the request. The CA and SelfSigned Issuer will always return certificates matching the usages you have requested. Unless any number of usages has been set, cert-manager will set the default requested usages of digital signature , key encipherment , and server auth . cert-manager will not attempt to request a new certificate if the current certificate does not match the current key usage set. An exhaustive list of supported key usages can be found in the API reference documentation . Temporary Certificates while Issuing On old GKE versions ( 1.10.7-gke.1 and below), when requesting certificates using the ingress-shim alongside the ingress-gce ingress controller, ingress-gce required a temporary certificate must be present while waiting for the issuance of a signed certificate. Note that this issue was solved in 1.10.7-gke.2 . # Required for GKE 1.10.7-gke.1 and below. cert-manager.io/issue-temporary-certificate\" : \"true\" That made sure that a temporary self-signed certificate was present in the Secret . The self-signed certificate was replaced with the signed certificate later on. Rotation of the private key By default, the private key won't be rotated automatically. Using the setting rotationPolicy: Always , the private key Secret associated with a Certificate object can be configured to be rotated as soon as an action triggers the reissuance of the Certificate object (see Actions that will trigger a rotation of the private key below). With rotationPolicy: Always , cert-manager waits until the Certificate object is correctly signed before overwriting the tls.key file in the Secret. With this setting, you can expect no downtime if your application can detect changes to the mounted tls.crt and tls.key and reload them gracefully or automatically restart. If your application only loads the private key and signed certificate once at start up, the new certificate won't immediately be served by your application, and you will want to either manually restart your pod with kubectl rollout restart , or automate the action by running wave . Wave is a Secret controller that makes sure deployments get restarted whenever a mounted Secret changes. Re-use of private keys Some issuers, like the built-in [Venafi issuer](../configuration/venafi.md), may disallow re-using private keys. If this is the case, you must explicitly configure the `rotationPolicy: Always` setting for each of your Certificate objects accordingly. In the following example, the certificate has been set with rotationPolicy: Always : apiVersion : cert-manager.io/v1 kind : Certificate spec : secretName : my-cert-tls privateKey : rotationPolicy : Always # \ud83d\udd30 Here. Actions that will trigger a rotation of the private key Setting the rotationPolicy: Always won't rotate the private key immediately. In order to rotate the private key, the certificate objects must be reissued. A certificate object is reissued under the following circumstances: when the X.509 certificate is nearing expiry, which is when the Certificate's status.renewalTime is reached; when a change is made to one of the following fields on the Certificate's spec: commonName , dnsNames , ipAddresses , uris , emailAddresses , subject , isCA , usages , duration or issuerRef ; when a reissuance is manually triggered with the following: cmctl renew cert-1 Note that the above command requires cmctl . **\u274c** Deleting the Secret resource associated with a Certificate resource is **not a recommended solution** for manually rotating the private key. The recommended way to manually rotate the private key is to trigger the reissuance of the Certificate resource with the following command (requires [`cmctl`](./cmctl.md#renew)): cmctl renew cert-1 The rotationPolicy setting \u00b6 The possible values for rotationPolicy are: Value Description Never (default) cert-manager reuses the existing private key on each issuance Always (recommended) cert-manager regenerates a new private key on each issuance With rotationPolicy: Never , a private key is only generated if one does not already exist in the target Secret resource (using the tls.key key). All further issuances will re-use this private key. This is the default in order to maintain compatibility with previous releases. With rotationPolicy: Always , a new private key will be generated each time an action triggers the reissuance of the certificate object (see Actions that will trigger a rotation of the private key above). Note that if the private key secret already exists when creating the certificate object, the existing private key will not be used, since the rotation mechanism also includes the initial issuance. \ud83d\udc49 We recommend that you configure `rotationPolicy: Always` on your Certificate resources. Rotating both the certificate and the private key simultaneously prevents the risk of issuing a certificate with an exposed private key. Another benefit to renewing the private key regularly is to let you be confident that the private key rotation can be done in case of emergency. More generally, it is a good practice to be rotating the keys as often as possible, reducing the risk associated with compromised keys. Cleaning up Secrets when Certificates are deleted \u00b6 By default, cert-manager does not delete the Secret resource containing the signed certificate when the corresponding Certificate resource is deleted. This means that deleting a Certificate won't take down any services that are currently relying on that certificate, but the certificate will no longer be renewed. The Secret needs to be manually deleted if it is no longer needed. If you would prefer the Secret to be deleted automatically when the Certificate is deleted, you need to configure your installation to pass the --enable-certificate-owner-ref flag to the controller. Renewal \u00b6 cert-manager will automatically renew Certificate s. It will calculate when to renew a Certificate based on the issued X.509 certificate's duration and a 'renewBefore' value which specifies how long before expiry a certificate should be renewed. spec.duration and spec.renewBefore fields on a Certificate can be used to specify an X.509 certificate's duration and a 'renewBefore' value. Default value for spec.duration is 90 days. Some issuers might be configured to only issue certificates with a set duration, so the actual duration may be different. Minimum value for spec.duration is 1 hour and minimum value for spec.renewBefore is 5 minutes. It is also required that spec.duration > spec.renewBefore . Once an X.509 certificate has been issued, cert-manager will calculate the renewal time for the Certificate . By default this will be \u2154 through the X.509 certificate's duration. If spec.renewBefore has been set, it will be spec.renewBefore amount of time before expiry. cert-manager will set Certificate 's status.RenewalTime to the time when the renewal will be attempted. Additional Certificate Output Formats \u00b6 \u26d4\ufe0f The additional certificate output formats feature is currently in an _experimental_ alpha state, and is subject to breaking changes or complete removal in future releases. This feature is only enabled by adding it to the `--feature-gates` flag on the cert-manager controller and webhook components: --feature-gates = AdditionalCertificateOutputFormats = true additionalOutputFormats is a field on the Certificate spec that allows specifying additional supplementary formats of issued certificates and their private key. There are currently two supported additional output formats: CombinedPEM and DER . Both output formats can be specified on the same Certificate. apiVersion : cert-manager.io/v1 kind : Certificate spec : ... secretName : my-cert-tls additionalOutputFormats : - type : CombinedPEM - type : DER # Results in: apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : ca.crt : <PEM CA certificate> tls.key : <PEM private key> tls.crt : <PEM signed certificate chain> tls-combined.pem : <PEM private key + \"\\n\" + PEM signed certificate chain> key.der : <DER binary format of private key> CombinedPEM \u00b6 The CombinedPEM type will create a new key entry in the resulting Certificate's Secret tls-combined.pem . This entry will contain the PEM encoded private key, followed by at least one new line character, followed by the PEM encoded signed certificate chain- <private key> + \"\\n\" + <signed certificate chain> apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : tls-combined.pem : <PEM private key + \"\\n\" + PEM signed certificate chain> ... DER \u00b6 The DER type will create a new key entry in the resulting Certificate's Secret key.der . This entry will contain the DER binary format of the private key. apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : key.der : <DER binary format of private key> ...","title":"Certificate Resources"},{"location":"usage/certificate/#creating-certificate-resources","text":"A Certificate resource specifies fields that are used to generate certificate signing requests which are then fulfilled by the issuer type you have referenced. Certificates specify which issuer they want to obtain the certificate from by specifying the certificate.spec.issuerRef field. A Certificate resource, for the example.com and www.example.com DNS names, spiffe://cluster.local/ns/sandbox/sa/example URI Subject Alternative Name, that is valid for 90 days and renews 15 days before expiry is below. It contains an exhaustive list of all options a Certificate resource may have however only a subset of fields are required as labelled. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com namespace : sandbox spec : # Secret names are always required. secretName : example-com-tls # secretTemplate is optional. If set, these annotations and labels will be # copied to the Secret named example-com-tls. These labels and annotations will # be re-reconciled if the Certificate's secretTemplate changes. secretTemplate # is also enforced, so relevant label and annotation changes on the Secret by a # third party will be overwriten by cert-manager to match the secretTemplate. secretTemplate : annotations : my-secret-annotation-1 : \"foo\" my-secret-annotation-2 : \"bar\" labels : my-secret-label : foo duration : 2160h # 90d renewBefore : 360h # 15d subject : organizations : - jetstack # The use of the common name field has been deprecated since 2000 and is # discouraged from being used. commonName : example.com isCA : false privateKey : algorithm : RSA encoding : PKCS1 size : 2048 usages : - server auth - client auth # At least one of a DNS Name, URI, or IP address is required. dnsNames : - example.com - www.example.com uris : - spiffe://cluster.local/ns/sandbox/sa/example ipAddresses : - 192.168.0.5 # Issuer references are always required. issuerRef : name : ca-issuer # We can reference ClusterIssuers by changing the kind here. # The default value is Issuer (i.e. a locally namespaced Issuer) kind : Issuer # This is optional since cert-manager will default to this value however # if you are using an external issuer, change this to that issuer group. group : cert-manager.io The signed certificate will be stored in a Secret resource named example-com-tls in the same namespace as the Certificate once the issuer has successfully issued the requested certificate. If secretTemplate is present, annotations and labels set in this property will be copied over to example-com-tls secret. Both properties are optional. The Certificate will be issued using the issuer named ca-issuer in the sandbox namespace (the same namespace as the Certificate resource). Note: If you want to create an Issuer that can be referenced by Certificate resources in all namespaces, you should create a ClusterIssuer resource and set the certificate.spec.issuerRef.kind field to ClusterIssuer . Note: The renewBefore and duration fields must be specified using a Go time.Duration string format, which does not allow the d (days) suffix. You must specify these values using s , m , and h suffixes instead. Failing to do so without installing the webhook component can prevent cert-manager from functioning correctly #1269 . Note: Take care when setting the renewBefore field to be very close to the duration as this can lead to a renewal loop, where the Certificate is always in the renewal period. Some Issuers set the notBefore field on their issued X.509 certificates before the issue time to fix clock-skew issues, leading to the working duration of a certificate to be less than the full duration of the certificate. For example, Let's Encrypt sets it to be one hour before issue time, so the actual working duration of the certificate is 89 days, 23 hours (the full duration remains 90 days). A full list of the fields supported on the Certificate resource can be found in the API reference documentation .","title":"Creating Certificate Resources"},{"location":"usage/certificate/#the-rotationpolicy-setting","text":"The possible values for rotationPolicy are: Value Description Never (default) cert-manager reuses the existing private key on each issuance Always (recommended) cert-manager regenerates a new private key on each issuance With rotationPolicy: Never , a private key is only generated if one does not already exist in the target Secret resource (using the tls.key key). All further issuances will re-use this private key. This is the default in order to maintain compatibility with previous releases. With rotationPolicy: Always , a new private key will be generated each time an action triggers the reissuance of the certificate object (see Actions that will trigger a rotation of the private key above). Note that if the private key secret already exists when creating the certificate object, the existing private key will not be used, since the rotation mechanism also includes the initial issuance. \ud83d\udc49 We recommend that you configure `rotationPolicy: Always` on your Certificate resources. Rotating both the certificate and the private key simultaneously prevents the risk of issuing a certificate with an exposed private key. Another benefit to renewing the private key regularly is to let you be confident that the private key rotation can be done in case of emergency. More generally, it is a good practice to be rotating the keys as often as possible, reducing the risk associated with compromised keys.","title":"The rotationPolicy setting"},{"location":"usage/certificate/#cleaning-up-secrets-when-certificates-are-deleted","text":"By default, cert-manager does not delete the Secret resource containing the signed certificate when the corresponding Certificate resource is deleted. This means that deleting a Certificate won't take down any services that are currently relying on that certificate, but the certificate will no longer be renewed. The Secret needs to be manually deleted if it is no longer needed. If you would prefer the Secret to be deleted automatically when the Certificate is deleted, you need to configure your installation to pass the --enable-certificate-owner-ref flag to the controller.","title":"Cleaning up Secrets when Certificates are deleted"},{"location":"usage/certificate/#renewal","text":"cert-manager will automatically renew Certificate s. It will calculate when to renew a Certificate based on the issued X.509 certificate's duration and a 'renewBefore' value which specifies how long before expiry a certificate should be renewed. spec.duration and spec.renewBefore fields on a Certificate can be used to specify an X.509 certificate's duration and a 'renewBefore' value. Default value for spec.duration is 90 days. Some issuers might be configured to only issue certificates with a set duration, so the actual duration may be different. Minimum value for spec.duration is 1 hour and minimum value for spec.renewBefore is 5 minutes. It is also required that spec.duration > spec.renewBefore . Once an X.509 certificate has been issued, cert-manager will calculate the renewal time for the Certificate . By default this will be \u2154 through the X.509 certificate's duration. If spec.renewBefore has been set, it will be spec.renewBefore amount of time before expiry. cert-manager will set Certificate 's status.RenewalTime to the time when the renewal will be attempted.","title":"Renewal"},{"location":"usage/certificate/#additional-certificate-output-formats","text":"\u26d4\ufe0f The additional certificate output formats feature is currently in an _experimental_ alpha state, and is subject to breaking changes or complete removal in future releases. This feature is only enabled by adding it to the `--feature-gates` flag on the cert-manager controller and webhook components: --feature-gates = AdditionalCertificateOutputFormats = true additionalOutputFormats is a field on the Certificate spec that allows specifying additional supplementary formats of issued certificates and their private key. There are currently two supported additional output formats: CombinedPEM and DER . Both output formats can be specified on the same Certificate. apiVersion : cert-manager.io/v1 kind : Certificate spec : ... secretName : my-cert-tls additionalOutputFormats : - type : CombinedPEM - type : DER # Results in: apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : ca.crt : <PEM CA certificate> tls.key : <PEM private key> tls.crt : <PEM signed certificate chain> tls-combined.pem : <PEM private key + \"\\n\" + PEM signed certificate chain> key.der : <DER binary format of private key>","title":"Additional Certificate Output Formats"},{"location":"usage/certificate/#combinedpem","text":"The CombinedPEM type will create a new key entry in the resulting Certificate's Secret tls-combined.pem . This entry will contain the PEM encoded private key, followed by at least one new line character, followed by the PEM encoded signed certificate chain- <private key> + \"\\n\" + <signed certificate chain> apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : tls-combined.pem : <PEM private key + \"\\n\" + PEM signed certificate chain> ...","title":"CombinedPEM"},{"location":"usage/certificate/#der","text":"The DER type will create a new key entry in the resulting Certificate's Secret key.der . This entry will contain the DER binary format of the private key. apiVersion : v1 kind : Secret metadata : name : my-cert-tls type : kubernetes.io/tls data : key.der : <DER binary format of private key> ...","title":"DER"},{"location":"usage/csi/","text":"Enabling mTLS of Pods using the cert-manager CSI Driver \u00b6 A Container Storage Interface (CSI) driver has been created to facilitate mTLS of Pods running inside your cluster through use of cert-manager. Using this driver will ensure that the private key and corresponding signed certificate will be unique to each Pod and will be stored on disk to the node that the Pod is scheduled to. The life cycle of the certificate key pair matches that of the Pod meaning that they will be created at Pod creation, and destroyed during termination. This driver also handles renewal on live certificates on the fly. A CSI driver is a storage plugin that is deployed into your Kubernetes cluster that can honor volume requests specified on Pods, just like those enabled by default such as the Secret , ConfigMap , or hostPath volume drivers. In the case of the cert-manager CSI driver, it makes use of the ephemeral volume type, made beta as of v1.16 and as such will only work from the Kubernetes version v1.16 . An ephemeral volumes means that the volume is created and destroyed as the Pod is created and terminated, as well as specifying the volume attributes, without the need of a PersistentVolume . This gives the feature of not only having unique certificates and keys per Pod, where the private key never leaves the hosts node, but that the desired certificate for that Pod template can be defined in line with the deployment spec. Warning : Use of the CSI driver is mostly intended for supporting a PKI of your cluster and facilitating mTLS, and as such, a private Certificate Authority issuer should be used - CA, Vault, and perhaps Venafi, or other external issuers. It is not recommended to use public Certificate Authorities, for example Let's Encrypt, which hold strict rate limits on the number of certificates that can be issued for a single domain. Like Pods, these certificate key pairs are designed to be non-immutable and can be created and destroyed at any time during normal operation. How Does it Work? \u00b6 The CSI specification is a protocol and standard for building storage drivers for container orchestration platforms with the intention that a single driver may be ported across multiple platforms and outlines a consistent specification to how drivers should behave from an infrastructure perspective. Since cert-manager is designed to only be run with a Kubernetes cluster, so too does the cert-manager CSI driver. The driver should be deployed as a DaemonSet which means a single instance of the driver may be run on each node. The driver will not work when running multiple instances on a single node. The set of nodes that the driver runs on can be restricted using the nodeSelector in its Pod template. When a Pod is scheduled to a node with a cert-manager CSI volume specified, the Kubelet running on that node will send a NodePublishVolume call to the driver on that node, containing that Pods information as well as the attributes detailed from the in-line volume attributes. From this, the driver will generate a private key as well as a certificate request based upon that key using information built from the volume attributes. The driver will create a CertificateRequest resource in the same namespace in the Pod that, if valid, cert-manager will return a signed certificate. The resulting signed certificate and generated key will be written to that node's file system to be mounted to the Pods file system. Since the driver needs access to the nodes file system it must be made privileged. Once mounted, the Pod will begin execution with the unique private key and certificate available in its file system, as defined by its mount path. By default, the driver will keep track of certificates created in order to monitor when they should be marked for renewal. When this happens, the driver will request for a new signed certificate, and when successful, will simply overwrite the existing certificate in path. When the Pod is marked for termination, the NodeUnpublishVolume call is made to the node's driver which in turn destroys the certificate and key from the nodes file system. The CSI driver is able to recover its full state in the event the its Pod being terminated.","title":"CSI Driver"},{"location":"usage/csi/#enabling-mtls-of-pods-using-the-cert-manager-csi-driver","text":"A Container Storage Interface (CSI) driver has been created to facilitate mTLS of Pods running inside your cluster through use of cert-manager. Using this driver will ensure that the private key and corresponding signed certificate will be unique to each Pod and will be stored on disk to the node that the Pod is scheduled to. The life cycle of the certificate key pair matches that of the Pod meaning that they will be created at Pod creation, and destroyed during termination. This driver also handles renewal on live certificates on the fly. A CSI driver is a storage plugin that is deployed into your Kubernetes cluster that can honor volume requests specified on Pods, just like those enabled by default such as the Secret , ConfigMap , or hostPath volume drivers. In the case of the cert-manager CSI driver, it makes use of the ephemeral volume type, made beta as of v1.16 and as such will only work from the Kubernetes version v1.16 . An ephemeral volumes means that the volume is created and destroyed as the Pod is created and terminated, as well as specifying the volume attributes, without the need of a PersistentVolume . This gives the feature of not only having unique certificates and keys per Pod, where the private key never leaves the hosts node, but that the desired certificate for that Pod template can be defined in line with the deployment spec. Warning : Use of the CSI driver is mostly intended for supporting a PKI of your cluster and facilitating mTLS, and as such, a private Certificate Authority issuer should be used - CA, Vault, and perhaps Venafi, or other external issuers. It is not recommended to use public Certificate Authorities, for example Let's Encrypt, which hold strict rate limits on the number of certificates that can be issued for a single domain. Like Pods, these certificate key pairs are designed to be non-immutable and can be created and destroyed at any time during normal operation.","title":"Enabling mTLS of Pods using the cert-manager CSI Driver"},{"location":"usage/csi/#how-does-it-work","text":"The CSI specification is a protocol and standard for building storage drivers for container orchestration platforms with the intention that a single driver may be ported across multiple platforms and outlines a consistent specification to how drivers should behave from an infrastructure perspective. Since cert-manager is designed to only be run with a Kubernetes cluster, so too does the cert-manager CSI driver. The driver should be deployed as a DaemonSet which means a single instance of the driver may be run on each node. The driver will not work when running multiple instances on a single node. The set of nodes that the driver runs on can be restricted using the nodeSelector in its Pod template. When a Pod is scheduled to a node with a cert-manager CSI volume specified, the Kubelet running on that node will send a NodePublishVolume call to the driver on that node, containing that Pods information as well as the attributes detailed from the in-line volume attributes. From this, the driver will generate a private key as well as a certificate request based upon that key using information built from the volume attributes. The driver will create a CertificateRequest resource in the same namespace in the Pod that, if valid, cert-manager will return a signed certificate. The resulting signed certificate and generated key will be written to that node's file system to be mounted to the Pods file system. Since the driver needs access to the nodes file system it must be made privileged. Once mounted, the Pod will begin execution with the unique private key and certificate available in its file system, as defined by its mount path. By default, the driver will keep track of certificates created in order to monitor when they should be marked for renewal. When this happens, the driver will request for a new signed certificate, and when successful, will simply overwrite the existing certificate in path. When the Pod is marked for termination, the NodeUnpublishVolume call is made to the node's driver which in turn destroys the certificate and key from the nodes file system. The CSI driver is able to recover its full state in the event the its Pod being terminated.","title":"How Does it Work?"},{"location":"usage/gateway/","text":"FEATURE STATE : cert-manager 1.5 [alpha] \ud83d\udccc This page focuses on automatically creating Certificate resources by annotating Kubernetes Gateway resource. If you are looking for using an ACME Issuer along with HTTP-01 challenges using the Kubernetes Gateway API, see [ACME HTTP-01](../configuration/acme/http01/README.md). \ud83d\udea7 cert-manager 1.8+ is tested with v1alpha2 Kubernetes Gateway API. It should also work with v1beta1 because of resource conversion, but has not been tested with it. cert-manager can generate TLS certificates for Gateway resources. This is configured by adding annotations to a Gateway and is similar to the process for Securing Ingress Resources . The Gateway resource is part of the Gateway API , a set of CRDs that you install on your Kubernetes cluster and which provide various improvements over the Ingress API. The Gateway resource holds the TLS configuration, as illustrated in the following diagram (source: https://gateway-api.sigs.k8s.io ): \ud83d\udccc This feature requires the installation of the [Gateway API bundle](https://gateway-api.sigs.k8s.io/guides/#installing-a-gateway-controller) and passing a feature flag to the cert-manager controller. To install v1.5.1 Gateway API bundle (Gateway CRDs and webhook), run the following command: kubectl apply -f \"https://github.com/kubernetes-sigs/gateway-api/releases/download/v0.5.1/standard-install.yaml\" To enable the feature in cert-manager, turn on the `GatewayAPI` feature gate: - If you are using Helm: helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager \\ --set \"extraArgs={--feature-gates=ExperimentalGatewayAPISupport=true}\" - If you are using the raw cert-manager manifests, add the following flag to the cert-manager controller Deployment: args : - --feature-gates=ExperimentalGatewayAPISupport=true The Gateway API CRDs should either be installed before cert-manager starts or the cert-manager Deployment should be restarted after installing the Gateway API CRDs. This is important because some of the cert-manager components only perform the Gateway API check on startup. You can restart cert-manager with the following command: kubectl rollout restart deployment cert-manager -n cert-manager The annotations cert-manager.io/issuer or cert-manager.io/cluster-issuer tell cert-manager to create a Certificate for a Gateway. For example, the following Gateway will trigger the creation of a Certificate with the name example-com-tls : apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : example annotations : cert-manager.io/issuer : foo spec : gatewayClassName : foo listeners : - name : http hostname : example.com port : 443 protocol : HTTPS allowedRoutes : namespaces : from : All tls : mode : Terminate certificateRefs : - name : example-com-tls A few moments later, cert-manager will create a Certificate. The Certificate is named after the Secret name example-com-tls . The dnsNames field is set with the hostname field from the Gateway spec. apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - example.com # \u2705 Copied from the `hostname` field. secretName : example-com-tls \ud83d\udea7 this mechanism can only be used to create Secrets in the same namespace as the `Gateway`, see [`cert-manager#5610`](https://github.com/cert-manager/cert-manager/issues/5610) Use cases \u00b6 Generate TLS certs for selected TLS blocks \u00b6 cert-manager skips any listener block that cannot be used for generating a Certificate. For a listener block to be used for creating a Certificate, it must meet the following requirements: Field Requirement tls.hostname Must not be empty. tls.mode Must be set to Terminate . Passthrough is not supported. tls.certificateRef.name Cannot be left empty. tls.certificateRef.kind If specified, must be set to Secret . tls.certificateRef.group If specified, must be set to core . tls.certificateRef.namespace If specified, must be the same as the Gateway . In the following example, the first four listener blocks will not be used to generate Certificate resources: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : my-gateway namespace : default annotations : cert-manager.io/issuer : my-issuer spec : listeners : # \u274c Missing \"tls\" block, the following listener is skipped. - hostname : example.com # \u274c Missing \"hostname\", the following listener is skipped. - tls : certificateRefs : - name : example-com-tls kind : Secret\" group : core # \u274c \"mode: Passthrough\" is not supported, the following listener is skipped. - hostname : example.com tls : mode : Passthrough certificateRefs : - name : example-com-tls kind : Secret group : core # \u274c Cross-namespace secret references are not supported, the following listener is skipped. - hostname : foo.example.com port : 443 protocol : HTTPS allowedRoutes : namespaces : from : All tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core namespace : other-namespace # \u2705 The following listener is valid. - hostname : foo.example.com # \u2705 Required. port : 443 protocol : HTTPS allowedRoutes : namespaces : from : All tls : mode : Terminate # \u2705 Required. \"Terminate\" is the only supported mode. certificateRefs : - name : example-com-tls # \u2705 Required. kind : Secret # \u2705 Required. \"Secret\" is the only valid value. group : core # \u2705 Required. \"core\" is the only valid value. cert-manager has skipped over the first four listener blocks and has created a single Certificate named example-com-tls for the last listener block: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - foo.example.com secretName : example-com-tls Two listeners with the same Secret name \u00b6 The same Secret name can be re-used in multiple TLS blocks, regardless of the hostname. Let us imagine that you have these two listeners: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : example annotations : cert-manager.io/issuer : my-issuer spec : gatewayClassName : foo listeners : # Listener 1. - hostname : example.com port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 2: Same Secret name as Listener 1, with a different hostname. - hostname : * .example.com port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 3: also same Secret name, except the hostname is also the same. - hostname : * .example.com port : 8443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 4: different Secret name. - hostname : site.org port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : site-org-tls kind : Secret group : core cert-manager will create two Certificates since two Secret names are used: example-com-tls and site-org-tls . Note the Certificate's dnsNames contains a single occurrence of *.example.com for both listener 2 and 3 (the hostname values are de-duplicated). The two Certificates look like this: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - example.com # From listener 1. - * .example.com # From listener 2 and 3. secretName : example-com-tls --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : site-org-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - site.org # From listener 4. secretName : site-org-tls Supported Annotations \u00b6 If you are migrating to Gateway resources from Ingress resources, be aware that there are some differences between the annotations for Ingress resources versus the annotations for Gateway resources. The Gateway resource supports the following annotations for generating Certificate resources: cert-manager.io/issuer : the name of an Issuer to acquire the certificate required for this Gateway. The Issuer must be in the same namespace as the Gateway resource. cert-manager.io/cluster-issuer : the name of a ClusterIssuer to acquire the Certificate required for this Gateway. It does not matter which namespace your Gateway resides, as ClusterIssuers are non-namespaced resources. cert-manager.io/issuer-kind : the kind of the external issuer resource, for example AWSPCACIssuer . This is only necessary for out-of-tree issuers. cert-manager.io/issuer-group : the API group of the external issuer controller, for example awspca.cert-manager.io . This is only necessary for out-of-tree issuers. cert-manager.io/common-name : (optional) this annotation allows you to configure spec.commonName for the Certificate to be generated. cert-manager.io/duration : (optional) this annotation allows you to configure spec.duration field for the Certificate to be generated. cert-manager.io/renew-before : (optional) this annotation allows you to configure spec.renewBefore field for the Certificate to be generated. cert-manager.io/usages : (optional) this annotation allows you to configure spec.usages field for the Certificate to be generated. Pass a string with comma-separated values i.e \"key agreement,digital signature, server auth\" cert-manager.io/revision-history-limit : (optional) this annotation allows you to configure spec.revisionHistoryLimit field to limit the number of CertificateRequests to be kept for a Certificate. Minimum value is 1. If unset all CertificateRequests will be kept. cert-manager.io/private-key-algorithm : (optional) this annotation allows you to configure spec.privateKey.algorithm field to set the algorithm for private key generation for a Certificate. Valid values are RSA , ECDSA and Ed25519 . If unset an algorithm RSA will be used. cert-manager.io/private-key-encoding : (optional) this annotation allows you to configure spec.privateKey.encoding field to set the encoding for private key generation for a Certificate. Valid values are PKCS1 and PKCS8 . If unset an algorithm PKCS1 will be used. cert-manager.io/private-key-size : (optional) this annotation allows you to configure spec.privateKey.size field to set the size of the private key for a Certificate. If algorithm is set to RSA , valid values are 2048 , 4096 or 8192 , and will default to 2048 if not specified. If algorithm is set to ECDSA , valid values are 256 , 384 or 521 , and will default to 256 if not specified. If algorithm is set to Ed25519 , size is ignored. cert-manager.io/private-key-rotation-policy : (optional) this annotation allows you to configure spec.privateKey.rotationPolicy field to set the rotation policy of the private key for a Certificate. Valid values are Never and Always . If unset a rotation policy Never will be used.","title":"Securing gateway.networking.k8s.io Gateway Resources"},{"location":"usage/gateway/#use-cases","text":"","title":"Use cases"},{"location":"usage/gateway/#generate-tls-certs-for-selected-tls-blocks","text":"cert-manager skips any listener block that cannot be used for generating a Certificate. For a listener block to be used for creating a Certificate, it must meet the following requirements: Field Requirement tls.hostname Must not be empty. tls.mode Must be set to Terminate . Passthrough is not supported. tls.certificateRef.name Cannot be left empty. tls.certificateRef.kind If specified, must be set to Secret . tls.certificateRef.group If specified, must be set to core . tls.certificateRef.namespace If specified, must be the same as the Gateway . In the following example, the first four listener blocks will not be used to generate Certificate resources: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : my-gateway namespace : default annotations : cert-manager.io/issuer : my-issuer spec : listeners : # \u274c Missing \"tls\" block, the following listener is skipped. - hostname : example.com # \u274c Missing \"hostname\", the following listener is skipped. - tls : certificateRefs : - name : example-com-tls kind : Secret\" group : core # \u274c \"mode: Passthrough\" is not supported, the following listener is skipped. - hostname : example.com tls : mode : Passthrough certificateRefs : - name : example-com-tls kind : Secret group : core # \u274c Cross-namespace secret references are not supported, the following listener is skipped. - hostname : foo.example.com port : 443 protocol : HTTPS allowedRoutes : namespaces : from : All tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core namespace : other-namespace # \u2705 The following listener is valid. - hostname : foo.example.com # \u2705 Required. port : 443 protocol : HTTPS allowedRoutes : namespaces : from : All tls : mode : Terminate # \u2705 Required. \"Terminate\" is the only supported mode. certificateRefs : - name : example-com-tls # \u2705 Required. kind : Secret # \u2705 Required. \"Secret\" is the only valid value. group : core # \u2705 Required. \"core\" is the only valid value. cert-manager has skipped over the first four listener blocks and has created a single Certificate named example-com-tls for the last listener block: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - foo.example.com secretName : example-com-tls","title":"Generate TLS certs for selected TLS blocks"},{"location":"usage/gateway/#two-listeners-with-the-same-secret-name","text":"The same Secret name can be re-used in multiple TLS blocks, regardless of the hostname. Let us imagine that you have these two listeners: apiVersion : gateway.networking.k8s.io/v1alpha2 kind : Gateway metadata : name : example annotations : cert-manager.io/issuer : my-issuer spec : gatewayClassName : foo listeners : # Listener 1. - hostname : example.com port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 2: Same Secret name as Listener 1, with a different hostname. - hostname : * .example.com port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 3: also same Secret name, except the hostname is also the same. - hostname : * .example.com port : 8443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : example-com-tls kind : Secret group : core # Listener 4: different Secret name. - hostname : site.org port : 443 protocol : HTTPS routes : kind : HTTPRoute parentRefs : - name : example kind : Gateway tls : mode : Terminate certificateRefs : - name : site-org-tls kind : Secret group : core cert-manager will create two Certificates since two Secret names are used: example-com-tls and site-org-tls . Note the Certificate's dnsNames contains a single occurrence of *.example.com for both listener 2 and 3 (the hostname values are de-duplicated). The two Certificates look like this: apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : example-com-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - example.com # From listener 1. - * .example.com # From listener 2 and 3. secretName : example-com-tls --- apiVersion : cert-manager.io/v1 kind : Certificate metadata : name : site-org-tls spec : issuerRef : name : my-issuer kind : Issuer group : cert-manager.io dnsNames : - site.org # From listener 4. secretName : site-org-tls","title":"Two listeners with the same Secret name"},{"location":"usage/gateway/#supported-annotations","text":"If you are migrating to Gateway resources from Ingress resources, be aware that there are some differences between the annotations for Ingress resources versus the annotations for Gateway resources. The Gateway resource supports the following annotations for generating Certificate resources: cert-manager.io/issuer : the name of an Issuer to acquire the certificate required for this Gateway. The Issuer must be in the same namespace as the Gateway resource. cert-manager.io/cluster-issuer : the name of a ClusterIssuer to acquire the Certificate required for this Gateway. It does not matter which namespace your Gateway resides, as ClusterIssuers are non-namespaced resources. cert-manager.io/issuer-kind : the kind of the external issuer resource, for example AWSPCACIssuer . This is only necessary for out-of-tree issuers. cert-manager.io/issuer-group : the API group of the external issuer controller, for example awspca.cert-manager.io . This is only necessary for out-of-tree issuers. cert-manager.io/common-name : (optional) this annotation allows you to configure spec.commonName for the Certificate to be generated. cert-manager.io/duration : (optional) this annotation allows you to configure spec.duration field for the Certificate to be generated. cert-manager.io/renew-before : (optional) this annotation allows you to configure spec.renewBefore field for the Certificate to be generated. cert-manager.io/usages : (optional) this annotation allows you to configure spec.usages field for the Certificate to be generated. Pass a string with comma-separated values i.e \"key agreement,digital signature, server auth\" cert-manager.io/revision-history-limit : (optional) this annotation allows you to configure spec.revisionHistoryLimit field to limit the number of CertificateRequests to be kept for a Certificate. Minimum value is 1. If unset all CertificateRequests will be kept. cert-manager.io/private-key-algorithm : (optional) this annotation allows you to configure spec.privateKey.algorithm field to set the algorithm for private key generation for a Certificate. Valid values are RSA , ECDSA and Ed25519 . If unset an algorithm RSA will be used. cert-manager.io/private-key-encoding : (optional) this annotation allows you to configure spec.privateKey.encoding field to set the encoding for private key generation for a Certificate. Valid values are PKCS1 and PKCS8 . If unset an algorithm PKCS1 will be used. cert-manager.io/private-key-size : (optional) this annotation allows you to configure spec.privateKey.size field to set the size of the private key for a Certificate. If algorithm is set to RSA , valid values are 2048 , 4096 or 8192 , and will default to 2048 if not specified. If algorithm is set to ECDSA , valid values are 256 , 384 or 521 , and will default to 256 if not specified. If algorithm is set to Ed25519 , size is ignored. cert-manager.io/private-key-rotation-policy : (optional) this annotation allows you to configure spec.privateKey.rotationPolicy field to set the rotation policy of the private key for a Certificate. Valid values are Never and Always . If unset a rotation policy Never will be used.","title":"Supported Annotations"},{"location":"usage/ingress/","text":"A common use-case for cert-manager is requesting TLS signed certificates to secure your ingress resources. This can be done by simply adding annotations to your Ingress resources and cert-manager will facilitate creating the Certificate resource for you. A small sub-component of cert-manager, ingress-shim, is responsible for this. How It Works \u00b6 The sub-component ingress-shim watches Ingress resources across your cluster. If it observes an Ingress with annotations described in the Supported Annotations section, it will ensure a Certificate resource with the name provided in the tls.secretName field and configured as described on the Ingress exists in the Ingress 's namespace. For example: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : # add an annotation indicating the issuer to use. cert-manager.io/cluster-issuer : nameOfClusterIssuer name : myIngress namespace : myIngress spec : rules : - host : example.com http : paths : - pathType : Prefix path : / backend : service : name : myservice port : number : 80 tls : # < placing a host in the TLS config will determine what ends up in the cert's subjectAltNames - hosts : - example.com secretName : myingress-cert # < cert-manager will store the created certificate in this secret. Supported Annotations \u00b6 You can specify the following annotations on Ingress resources in order to trigger Certificate resources to be automatically created: cert-manager.io/issuer : the name of an Issuer to acquire the certificate required for this Ingress. The Issuer must be in the same namespace as the Ingress resource. cert-manager.io/cluster-issuer : the name of a ClusterIssuer to acquire the certificate required for this Ingress. It does not matter which namespace your Ingress resides, as ClusterIssuers are non-namespaced resources. cert-manager.io/issuer-kind : the kind of the external issuer resource, for example AWSPCAIssuer . This is only necessary for out-of-tree issuers. cert-manager.io/issuer-group : the API group of the external issuer controller, for example awspca.cert-manager.io . This is only necessary for out-of-tree issuers. kubernetes.io/tls-acme: \"true\" : this annotation requires additional configuration of the ingress-shim see below . Namely, a default Issuer must be specified as arguments to the ingress-shim container. acme.cert-manager.io/http01-ingress-class : this annotation allows you to configure the ingress class that will be used to solve challenges for this ingress. Customizing this is useful when you are trying to secure internal services, and need to solve challenges using a different ingress class to that of the ingress. If not specified and the acme-http01-edit-in-place annotation is not set, this defaults to the ingress class defined in the Issuer resource. acme.cert-manager.io/http01-edit-in-place: \"true\" : this controls whether the ingress is modified 'in-place', or a new one is created specifically for the HTTP01 challenge. If present, and set to \"true\", the existing ingress will be modified. Any other value, or the absence of the annotation assumes \"false\". This annotation will also add the annotation \"cert-manager.io/issue-temporary-certificate\": \"true\" onto created certificates which will cause a temporary certificate to be set on the resulting Secret until the final signed certificate has been returned. This is useful for keeping compatibility with the ingress-gce component. cert-manager.io/common-name : (optional) this annotation allows you to configure spec.commonName for the Certificate to be generated. cert-manager.io/duration : (optional) this annotation allows you to configure spec.duration field for the Certificate to be generated. cert-manager.io/renew-before : (optional) this annotation allows you to configure spec.renewBefore field for the Certificate to be generated. cert-manager.io/usages : (optional) this annotation allows you to configure spec.usages field for the Certificate to be generated. Pass a string with comma-separated values i.e \"key agreement,digital signature, server auth\" cert-manager.io/revision-history-limit : (optional) this annotation allows you to configure spec.revisionHistoryLimit field to limit the number of CertificateRequests to be kept for a Certificate. Minimum value is 1. If unset all CertificateRequests will be kept. cert-manager.io/private-key-algorithm : (optional) this annotation allows you to configure spec.privateKey.algorithm field to set the algorithm for private key generation for a Certificate. Valid values are RSA , ECDSA and Ed25519 . If unset an algorithm RSA will be used. cert-manager.io/private-key-encoding : (optional) this annotation allows you to configure spec.privateKey.encoding field to set the encoding for private key generation for a Certificate. Valid values are PKCS1 and PKCS8 . If unset an algorithm PKCS1 will be used. cert-manager.io/private-key-size : (optional) this annotation allows you to configure spec.privateKey.size field to set the size of the private key for a Certificate. If algorithm is set to RSA , valid values are 2048 , 4096 or 8192 , and will default to 2048 if not specified. If algorithm is set to ECDSA , valid values are 256 , 384 or 521 , and will default to 256 if not specified. If algorithm is set to Ed25519 , size is ignored. cert-manager.io/private-key-rotation-policy : (optional) this annotation allows you to configure spec.privateKey.rotationPolicy field to set the rotation policy of the private key for a Certificate. Valid values are Never and Always . If unset a rotation policy Never will be used. Optional Configuration \u00b6 The ingress-shim sub-component is deployed automatically as part of installation. If you would like to use the old kube-lego kubernetes.io/tls-acme: \"true\" annotation for fully automated TLS, you will need to configure a default Issuer when deploying cert-manager. This can be done by adding the following --set when deploying using Helm: --set ingressShim.defaultIssuerName = letsencrypt-prod \\ --set ingressShim.defaultIssuerKind = ClusterIssuer \\ --set ingressShim.defaultIssuerGroup = cert-manager.io Or by adding the following arguments to the cert-manager deployment podTemplate container arguments. - --default-issuer-name=letsencrypt-prod - --default-issuer-kind=ClusterIssuer - --default-issuer-group=cert-manager.io In the above example, cert-manager will create Certificate resources that reference the ClusterIssuer letsencrypt-prod for all Ingresses that have a kubernetes.io/tls-acme: \"true\" annotation. Issuers configured via annotations have a preference over the default issuer. If a default issuer is configured via CLI flags and a cert-manager.io/cluster-issuer or cert-manager.io/issuer annotation also has been added to an Ingress, the created Certificate will refer to the issuer configured via annotation. For more information on deploying cert-manager, read the installation guide . Troubleshooting \u00b6 If you do not see a Certificate resource being created after applying the ingress-shim annotations check that at least cert-manager.io/issuer or cert-manager.io/cluster-issuer is set. If you want to use kubernetes.io/tls-acme: \"true\" make sure to have checked all steps above and you might want to look for errors in the cert-manager pod logs if not resolved.","title":"Securing Ingress Resources"},{"location":"usage/ingress/#how-it-works","text":"The sub-component ingress-shim watches Ingress resources across your cluster. If it observes an Ingress with annotations described in the Supported Annotations section, it will ensure a Certificate resource with the name provided in the tls.secretName field and configured as described on the Ingress exists in the Ingress 's namespace. For example: apiVersion : networking.k8s.io/v1 kind : Ingress metadata : annotations : # add an annotation indicating the issuer to use. cert-manager.io/cluster-issuer : nameOfClusterIssuer name : myIngress namespace : myIngress spec : rules : - host : example.com http : paths : - pathType : Prefix path : / backend : service : name : myservice port : number : 80 tls : # < placing a host in the TLS config will determine what ends up in the cert's subjectAltNames - hosts : - example.com secretName : myingress-cert # < cert-manager will store the created certificate in this secret.","title":"How It Works"},{"location":"usage/ingress/#supported-annotations","text":"You can specify the following annotations on Ingress resources in order to trigger Certificate resources to be automatically created: cert-manager.io/issuer : the name of an Issuer to acquire the certificate required for this Ingress. The Issuer must be in the same namespace as the Ingress resource. cert-manager.io/cluster-issuer : the name of a ClusterIssuer to acquire the certificate required for this Ingress. It does not matter which namespace your Ingress resides, as ClusterIssuers are non-namespaced resources. cert-manager.io/issuer-kind : the kind of the external issuer resource, for example AWSPCAIssuer . This is only necessary for out-of-tree issuers. cert-manager.io/issuer-group : the API group of the external issuer controller, for example awspca.cert-manager.io . This is only necessary for out-of-tree issuers. kubernetes.io/tls-acme: \"true\" : this annotation requires additional configuration of the ingress-shim see below . Namely, a default Issuer must be specified as arguments to the ingress-shim container. acme.cert-manager.io/http01-ingress-class : this annotation allows you to configure the ingress class that will be used to solve challenges for this ingress. Customizing this is useful when you are trying to secure internal services, and need to solve challenges using a different ingress class to that of the ingress. If not specified and the acme-http01-edit-in-place annotation is not set, this defaults to the ingress class defined in the Issuer resource. acme.cert-manager.io/http01-edit-in-place: \"true\" : this controls whether the ingress is modified 'in-place', or a new one is created specifically for the HTTP01 challenge. If present, and set to \"true\", the existing ingress will be modified. Any other value, or the absence of the annotation assumes \"false\". This annotation will also add the annotation \"cert-manager.io/issue-temporary-certificate\": \"true\" onto created certificates which will cause a temporary certificate to be set on the resulting Secret until the final signed certificate has been returned. This is useful for keeping compatibility with the ingress-gce component. cert-manager.io/common-name : (optional) this annotation allows you to configure spec.commonName for the Certificate to be generated. cert-manager.io/duration : (optional) this annotation allows you to configure spec.duration field for the Certificate to be generated. cert-manager.io/renew-before : (optional) this annotation allows you to configure spec.renewBefore field for the Certificate to be generated. cert-manager.io/usages : (optional) this annotation allows you to configure spec.usages field for the Certificate to be generated. Pass a string with comma-separated values i.e \"key agreement,digital signature, server auth\" cert-manager.io/revision-history-limit : (optional) this annotation allows you to configure spec.revisionHistoryLimit field to limit the number of CertificateRequests to be kept for a Certificate. Minimum value is 1. If unset all CertificateRequests will be kept. cert-manager.io/private-key-algorithm : (optional) this annotation allows you to configure spec.privateKey.algorithm field to set the algorithm for private key generation for a Certificate. Valid values are RSA , ECDSA and Ed25519 . If unset an algorithm RSA will be used. cert-manager.io/private-key-encoding : (optional) this annotation allows you to configure spec.privateKey.encoding field to set the encoding for private key generation for a Certificate. Valid values are PKCS1 and PKCS8 . If unset an algorithm PKCS1 will be used. cert-manager.io/private-key-size : (optional) this annotation allows you to configure spec.privateKey.size field to set the size of the private key for a Certificate. If algorithm is set to RSA , valid values are 2048 , 4096 or 8192 , and will default to 2048 if not specified. If algorithm is set to ECDSA , valid values are 256 , 384 or 521 , and will default to 256 if not specified. If algorithm is set to Ed25519 , size is ignored. cert-manager.io/private-key-rotation-policy : (optional) this annotation allows you to configure spec.privateKey.rotationPolicy field to set the rotation policy of the private key for a Certificate. Valid values are Never and Always . If unset a rotation policy Never will be used.","title":"Supported Annotations"},{"location":"usage/ingress/#optional-configuration","text":"The ingress-shim sub-component is deployed automatically as part of installation. If you would like to use the old kube-lego kubernetes.io/tls-acme: \"true\" annotation for fully automated TLS, you will need to configure a default Issuer when deploying cert-manager. This can be done by adding the following --set when deploying using Helm: --set ingressShim.defaultIssuerName = letsencrypt-prod \\ --set ingressShim.defaultIssuerKind = ClusterIssuer \\ --set ingressShim.defaultIssuerGroup = cert-manager.io Or by adding the following arguments to the cert-manager deployment podTemplate container arguments. - --default-issuer-name=letsencrypt-prod - --default-issuer-kind=ClusterIssuer - --default-issuer-group=cert-manager.io In the above example, cert-manager will create Certificate resources that reference the ClusterIssuer letsencrypt-prod for all Ingresses that have a kubernetes.io/tls-acme: \"true\" annotation. Issuers configured via annotations have a preference over the default issuer. If a default issuer is configured via CLI flags and a cert-manager.io/cluster-issuer or cert-manager.io/issuer annotation also has been added to an Ingress, the created Certificate will refer to the issuer configured via annotation. For more information on deploying cert-manager, read the installation guide .","title":"Optional Configuration"},{"location":"usage/ingress/#troubleshooting","text":"If you do not see a Certificate resource being created after applying the ingress-shim annotations check that at least cert-manager.io/issuer or cert-manager.io/cluster-issuer is set. If you want to use kubernetes.io/tls-acme: \"true\" make sure to have checked all steps above and you might want to look for errors in the cert-manager pod logs if not resolved.","title":"Troubleshooting"},{"location":"usage/istio/","text":"cert-manager can be integrated with Istio using the project istio-csr . istio-csr will deploy an agent that is responsible for receiving certificate signing requests for all members of the Istio mesh, and signing them through cert-manager. istio-csr will sign all control plane and workload certificates via your chosen cert-manager Issuer. Please follow the instructions for installing and using istio-csr on the project page .","title":"Securing Istio Service Mesh"},{"location":"usage/kube-csr/","text":"Kubernetes has an in-built CertificateSigningRequest resource. This resource is similar to the cert-manager CertificateRequest in that it is used to request an X.509 signed certificate from a referenced Certificate Authority (CA). Using this resource may be useful for users who are using an application that supports this resource, but not the cert-manager CertificateRequest resource, and they still wish for certificates to be signed through cert-manager. CertificateSigningRequests reference a SignerName or signer as the entity it wishes to sign its request from. For cert-manager, a signer can be mapped to either an Issuer or ClusterIssuer . Feature State \u00b6 This feature is currently in an experimental state, and its behavior is subject to change in further releases. \u26d4\ufe0f This feature is only enabled by adding it to the `--feature-gates` flag on the cert-manager controller: --feature-gates = ExperimentalCertificateSigningRequestControllers = true Which can be added using Helm: $ helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --set featureGates = \"ExperimentalCertificateSigningRequestControllers=true\" \\ # --set installCRDs=true > Note: cert-manager supports signing CertificateSigningRequests > using all [internal Issuers](../configuration/README.md). > Note: cert-manager _does not_ automatically approve CertificateSigningRequests > that reference a cert-manager [Issuer](../configuration/README.md). Please refer to > the [Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process) > for the request process of CertificateSigningRequests. Signer Name \u00b6 CertificateSigningRequests contain a spec.signerName field to reference a CA to sign the request. cert-manager Issuers or ClusterIssuers are referenced in the following form: <resource type>.cert-manager.io/<signer namespace (if namespaced)>.<signer name> For example, a namespaced Issuer in the namespace sandbox with the name my-issuer would be referenced via: signerName : issuers.cert-manager.io/sandbox.my-issuer A ClusterIssuer with the name my-cluster-issuer would be referenced via: signerName : clusterissuers.cert-manager.io/my-cluster-issuer Referencing Namespaced Issuers \u00b6 Unlike CertificateRequests, CertificateSigningRequests are cluster scoped resources. To prevent users from requesting certificates from a namespaced Issuer in a namespace that they otherwise would not have access to, cert-manager performs a SubjectAccessReview . This review ensures that the requesting user has the permission to reference the signers resource in the given namespace. The name should be either the name of the Issuer, or \"*\" to reference all Issuers in that namespace. An example Role to give permissions to reference Issuers in the sandbox namespace would look like the following: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : cert-manager-referencer:my-issuer namespace : sandbox rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"reference\" ] resourceNames : - \"my-issuer\" # To give permission to _only_ reference Issuers with the name 'my-issuer' - \"*\" # To give permission to reference Issuers with any name in this namespace Annotations \u00b6 To keep feature parity with CertificateRequests, annotations are used to store values that do not exist as spec or status fields on the CertificateSigningRequest resource. These fields are either set by the requester or by the signer as labelled below. Requester annotations: experimental.cert-manager.io/request-duration : Set by the requester . Accepts a Go time duration string specifying the requested certificate duration. Defaults to 90 days. Some signers such as Venafi or ACME typically do not allow requesting a duration. experimental.cert-manager.io/request-is-ca : Set by the requester . If set to \"true\" , will request for a CA certificate. experimental.cert-manager.io/private-key-secret-name : Set by the requester . Required only for the SelfSigned signer. Used to reference a Secret which contains the PEM encoded private key of the requester's X.509 certificate signing request at key tls.key . Used to sign the requester's request. venafi.experimental.cert-manager.io/custom-fields : Set by the requester . Optional for only the Venafi signer. Used for adding custom fields to the Venafi request. This will only work with Venafi TPP v19.3 and higher. The value is a JSON array with objects containing the name and value keys, for example: venafi.experimental.cert-manager.io/custom-fields: |- [ {\"name\": \"field-name\", \"value\": \"field value\"}, {\"name\": \"field-name-2\", \"value\": \"field value 2\"} ] Signer annotations: venafi.experimental.cert-manager.io/pickup-id : Set by the signer . Only used for the Venafi signer. Used to record the Venafi Pickup ID of a certificate signing request that has been submitted to the Venafi API for collection during issuance. Usage \u00b6 CertificateSigningRequests can be manually created using cmctl . This command takes a manifest file containing a Certificate resource as input. This generates a private key and creates a CertificateSigningRequest. CertificateSigningRequests are not approved by default, so you will likely need to approve it manually: $ kubectl certificate approve <name>","title":"Kubernetes CertificateSigningRequests"},{"location":"usage/kube-csr/#feature-state","text":"This feature is currently in an experimental state, and its behavior is subject to change in further releases. \u26d4\ufe0f This feature is only enabled by adding it to the `--feature-gates` flag on the cert-manager controller: --feature-gates = ExperimentalCertificateSigningRequestControllers = true Which can be added using Helm: $ helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --create-namespace \\ --set featureGates = \"ExperimentalCertificateSigningRequestControllers=true\" \\ # --set installCRDs=true > Note: cert-manager supports signing CertificateSigningRequests > using all [internal Issuers](../configuration/README.md). > Note: cert-manager _does not_ automatically approve CertificateSigningRequests > that reference a cert-manager [Issuer](../configuration/README.md). Please refer to > the [Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process) > for the request process of CertificateSigningRequests.","title":"Feature State"},{"location":"usage/kube-csr/#signer-name","text":"CertificateSigningRequests contain a spec.signerName field to reference a CA to sign the request. cert-manager Issuers or ClusterIssuers are referenced in the following form: <resource type>.cert-manager.io/<signer namespace (if namespaced)>.<signer name> For example, a namespaced Issuer in the namespace sandbox with the name my-issuer would be referenced via: signerName : issuers.cert-manager.io/sandbox.my-issuer A ClusterIssuer with the name my-cluster-issuer would be referenced via: signerName : clusterissuers.cert-manager.io/my-cluster-issuer","title":"Signer Name"},{"location":"usage/kube-csr/#referencing-namespaced-issuers","text":"Unlike CertificateRequests, CertificateSigningRequests are cluster scoped resources. To prevent users from requesting certificates from a namespaced Issuer in a namespace that they otherwise would not have access to, cert-manager performs a SubjectAccessReview . This review ensures that the requesting user has the permission to reference the signers resource in the given namespace. The name should be either the name of the Issuer, or \"*\" to reference all Issuers in that namespace. An example Role to give permissions to reference Issuers in the sandbox namespace would look like the following: apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : cert-manager-referencer:my-issuer namespace : sandbox rules : - apiGroups : [ \"cert-manager.io\" ] resources : [ \"signers\" ] verbs : [ \"reference\" ] resourceNames : - \"my-issuer\" # To give permission to _only_ reference Issuers with the name 'my-issuer' - \"*\" # To give permission to reference Issuers with any name in this namespace","title":"Referencing Namespaced Issuers"},{"location":"usage/kube-csr/#annotations","text":"To keep feature parity with CertificateRequests, annotations are used to store values that do not exist as spec or status fields on the CertificateSigningRequest resource. These fields are either set by the requester or by the signer as labelled below. Requester annotations: experimental.cert-manager.io/request-duration : Set by the requester . Accepts a Go time duration string specifying the requested certificate duration. Defaults to 90 days. Some signers such as Venafi or ACME typically do not allow requesting a duration. experimental.cert-manager.io/request-is-ca : Set by the requester . If set to \"true\" , will request for a CA certificate. experimental.cert-manager.io/private-key-secret-name : Set by the requester . Required only for the SelfSigned signer. Used to reference a Secret which contains the PEM encoded private key of the requester's X.509 certificate signing request at key tls.key . Used to sign the requester's request. venafi.experimental.cert-manager.io/custom-fields : Set by the requester . Optional for only the Venafi signer. Used for adding custom fields to the Venafi request. This will only work with Venafi TPP v19.3 and higher. The value is a JSON array with objects containing the name and value keys, for example: venafi.experimental.cert-manager.io/custom-fields: |- [ {\"name\": \"field-name\", \"value\": \"field value\"}, {\"name\": \"field-name-2\", \"value\": \"field value 2\"} ] Signer annotations: venafi.experimental.cert-manager.io/pickup-id : Set by the signer . Only used for the Venafi signer. Used to record the Venafi Pickup ID of a certificate signing request that has been submitted to the Venafi API for collection during issuance.","title":"Annotations"},{"location":"usage/kube-csr/#usage","text":"CertificateSigningRequests can be manually created using cmctl . This command takes a manifest file containing a Certificate resource as input. This generates a private key and creates a CertificateSigningRequest. CertificateSigningRequests are not approved by default, so you will likely need to approve it manually: $ kubectl certificate approve <name>","title":"Usage"},{"location":"usage/prometheus-metrics/","text":"To help with operations and insights into cert-manager activities, cert-manager exposes metrics in the Prometheus format from the controller component. These are available at the standard /metrics path of the controller component's configured HTTP port. Scraping Metrics \u00b6 How metrics are scraped will depend how you're operating your Prometheus server(s). These examples presume the Prometheus Operator is being used to run Prometheus, and configure Pod or Service Monitor CRDs. Helm \u00b6 If you're deploying cert-manager with helm, a ServiceMonitor resource can be configured. This configuration should enable metric scraping, and the configuration can be further tweaked as described in the Helm configuration documentation . prometheus : enabled : true servicemonitor : enabled : true Regular Manifests \u00b6 If you're not using helm to deploy cert-manager and instead using the provided regular YAML manifests, this example PodMonitor and deployment patch should be all you need to start ingesting cert-manager metrics. Apply the following patch to your cert-manager deployment spec : template : spec : containers : - name : cert-manager-controller ports : - containerPort : 9402 name : http protocol : TCP Create the following PodMonitor apiVersion : monitoring.coreos.com/v1 kind : PodMonitor metadata : name : cert-manager namespace : cert-manager labels : app : cert-manager app.kubernetes.io/name : cert-manager app.kubernetes.io/instance : cert-manager app.kubernetes.io/component : \"controller\" spec : jobLabel : app.kubernetes.io/name selector : matchLabels : app : cert-manager app.kubernetes.io/name : cert-manager app.kubernetes.io/instance : cert-manager app.kubernetes.io/component : \"controller\" podMetricsEndpoints : - port : http honorLabels : true Monitoring Mixin \u00b6 Monitoring mixins are a way to bundle common alerts, rules, and dashboards for an application in a configurable and extensible way, using the Jsonnet data templating language. A cert-manager monitoring mixin can be found here https://gitlab.com/uneeq-oss/cert-manager-mixin . Documentation on usage can be found with the cert-manager-mixin project.","title":"Prometheus Metrics"},{"location":"usage/prometheus-metrics/#scraping-metrics","text":"How metrics are scraped will depend how you're operating your Prometheus server(s). These examples presume the Prometheus Operator is being used to run Prometheus, and configure Pod or Service Monitor CRDs.","title":"Scraping Metrics"},{"location":"usage/prometheus-metrics/#helm","text":"If you're deploying cert-manager with helm, a ServiceMonitor resource can be configured. This configuration should enable metric scraping, and the configuration can be further tweaked as described in the Helm configuration documentation . prometheus : enabled : true servicemonitor : enabled : true","title":"Helm"},{"location":"usage/prometheus-metrics/#regular-manifests","text":"If you're not using helm to deploy cert-manager and instead using the provided regular YAML manifests, this example PodMonitor and deployment patch should be all you need to start ingesting cert-manager metrics. Apply the following patch to your cert-manager deployment spec : template : spec : containers : - name : cert-manager-controller ports : - containerPort : 9402 name : http protocol : TCP Create the following PodMonitor apiVersion : monitoring.coreos.com/v1 kind : PodMonitor metadata : name : cert-manager namespace : cert-manager labels : app : cert-manager app.kubernetes.io/name : cert-manager app.kubernetes.io/instance : cert-manager app.kubernetes.io/component : \"controller\" spec : jobLabel : app.kubernetes.io/name selector : matchLabels : app : cert-manager app.kubernetes.io/name : cert-manager app.kubernetes.io/instance : cert-manager app.kubernetes.io/component : \"controller\" podMetricsEndpoints : - port : http honorLabels : true","title":"Regular Manifests"},{"location":"usage/prometheus-metrics/#monitoring-mixin","text":"Monitoring mixins are a way to bundle common alerts, rules, and dashboards for an application in a configurable and extensible way, using the Jsonnet data templating language. A cert-manager monitoring mixin can be found here https://gitlab.com/uneeq-oss/cert-manager-mixin . Documentation on usage can be found with the cert-manager-mixin project.","title":"Monitoring Mixin"}]}